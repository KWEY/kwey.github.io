<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>雪人 - 笔记</title><meta name="keywords" content="sql  python node  video web html css javascript"><meta name="author" content="雪人"><meta name="copyright" content="雪人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="雪人的笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="雪人">
<meta property="og:url" content="https://www.webq.top/page/2/index.html">
<meta property="og:site_name" content="雪人">
<meta property="og:description" content="雪人的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.webq.top/img/face.jpg">
<meta property="article:author" content="雪人">
<meta property="article:tag" content="sql  python node  video web html css javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.webq.top/img/face.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.webq.top/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/favicon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/favicon.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/favicon.png"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isSidebar: false,
  postUpdate: '2021-10-27 10:41:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/face.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/cli/"><i class="fa-fw fas fa-retweet"></i><span> CLI</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 工具集</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/follow/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></li><li><a class="site-page" href="/audio/"><i class="fa-fw fas fa-music"></i><span> audio_context</span></a></li><li><a class="site-page" href="/piano/"><i class="fa-fw fas fa-music"></i><span> 在线Piano</span></a></li><li><a class="site-page" href="/hy/"><i class="fa-fw fas fa-video"></i><span> Canvas绘图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文档库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/11/19/doc/ci/"><span> CI</span></a></li><li><a class="site-page" href="/2020/11/19/doc/h264/"><span> h264</span></a></li><li><a class="site-page" href="/2020/11/19/doc/f4v/"><span> f4v</span></a></li><li><a class="site-page" href="/2020/11/19/doc/mask/"><span> mask</span></a></li><li><a class="site-page" href="/2020/11/19/doc/dj/"><span> Django</span></a></li><li><a class="site-page" href="/2020/11/19/doc/mse/"><span> MSE</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雪人</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/cli/"><i class="fa-fw fas fa-retweet"></i><span> CLI</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 工具集</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/follow/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></li><li><a class="site-page" href="/audio/"><i class="fa-fw fas fa-music"></i><span> audio_context</span></a></li><li><a class="site-page" href="/piano/"><i class="fa-fw fas fa-music"></i><span> 在线Piano</span></a></li><li><a class="site-page" href="/hy/"><i class="fa-fw fas fa-video"></i><span> Canvas绘图</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文档库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/11/19/doc/ci/"><span> CI</span></a></li><li><a class="site-page" href="/2020/11/19/doc/h264/"><span> h264</span></a></li><li><a class="site-page" href="/2020/11/19/doc/f4v/"><span> f4v</span></a></li><li><a class="site-page" href="/2020/11/19/doc/mask/"><span> mask</span></a></li><li><a class="site-page" href="/2020/11/19/doc/dj/"><span> Django</span></a></li><li><a class="site-page" href="/2020/11/19/doc/mse/"><span> MSE</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav></header><main class="layout_page" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/http-histroy/" title="HTTP的神秘面纱">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP的神秘面纱"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-histroy/" title="HTTP的神秘面纱">HTTP的神秘面纱</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.256Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。


各层的作用
1.物理层：
主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 
　　2.数据链路层：
定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 　
　
3.网络层：
在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
　　4.传输层：
定义了一些传输数据的协议和端口号（WWW端口80等），如： 
TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）UDP（us ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/network/http-get-post/" title="HTTP 请求方法：GET 和 POST">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP 请求方法：GET 和 POST"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-get-post/" title="HTTP 请求方法：GET 和 POST">HTTP 请求方法：GET 和 POST</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.256Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据。

GET 方法请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：
/test/demo_form.php?name1=value1&amp;name2=value2有关 GET 请求的其他一些注释：GET 请求可被缓存GET 请求保留在浏览器历史记录中GET 请求可被收藏为书签GET 请求不应在处理敏感数据时使用GET 请求有长度限制GET 请求只应当用于取回数据
POST 方法请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：

POST /test/demo_form.php HTTP/1.1
Host: w3cschool.cn
name1=value1&amp;amp;name2=value2
有关 POST 请求的其他一些注释：
    POST 请求不会被缓存    POST 请求不会保留在浏览器历史记录中    POST 不能被收藏为书签    POST 请求对数据长度没有要求

比较 GET 与 POST下面的表格比较了两种 HTTP ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/http-https/" title="HTTP 与 HTTPS">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP 与 HTTPS"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-https/" title="HTTP 与 HTTPS">HTTP 与 HTTPS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.256Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。
HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。
HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：
1、TCP 三次同步握手2、客户端验证 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/network/http-info/" title="HTTP 简介">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP 简介"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-info/" title="HTTP 简介">HTTP 简介</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.256Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。

W3CHTTP 工作原理HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP默认端口号为80，但是你也可以改为8080或者其他端口。
HTTP三点注意事项：
HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。


HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。


HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/dns/" title="HTTP 状态消息">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP 状态消息"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/dns/" title="HTTP 状态消息">HTTP 状态消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.255Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">以Chrome 浏览器为例：（访问： www.google.com
1、 Chrome 浏览器 会首先搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存），看自身的缓存中是否有 www.google.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。

注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看

2、如果浏览器自身的缓存里面没有找到对应的条目，那么 Chrome 会搜索操作系统自身的 DNS 缓存,如果找到且没有过期则停止搜索解析到此结束.

注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看

3、如果在 Windows 系统的 DNS 缓存也没有找到，那么尝试读取 hosts 文件（位于 C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的 IP 地址，如果有则解析成功。
4、如果在 hosts 文件中也没有找到对应的条 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/network/http-code/" title="HTTP 状态消息">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP 状态消息"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-code/" title="HTTP 状态消息">HTTP 状态消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.255Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">1xx: 信息该状态码属于临时响应类型，代表请求已被接受，需要继续处理。
该类状态码只包含状态行和某些可选的响应头信息，并以空行结束。
消息：描述：100 Continue服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101 Switching Protocols服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。103 Checkpoint用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。

2xx: 成功该类型的状态码，表示请求已成功被服务器接收、理解、并接受。
消息：描述：200 OK请求成功（这是对HTTP请求成功的标准应答。）201 Created请求被创建完成，同时新的资源被创建。202 Accepted供处理的请求已被接受，但是处理未完成。203 Non-Authoritative Information请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。204 No Content请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/http-206/" title="Http 206 文件断点续传下载原理">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Http 206 文件断点续传下载原理"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-206/" title="Http 206 文件断点续传下载原理">Http 206 文件断点续传下载原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.255Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
断点续传下载需要重视2对头信息Accept-Ranges/Range与If-Range/tag

断点续传检测服务器端是否支持范围请求假如在响应中存在 Accept-Ranges 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。例如，你可以使用 cURL 发送一个 HEAD 请求来进行检测。
curl -I http://i.imgur.com/z4d4kWk.jpgHTTP/1.1 200 OK...Accept-Ranges: bytesContent-Length: 146515

在上面的响应中， Accept-Ranges: bytes 表示界定范围的单位是 bytes 。这里  Content-Length 也是有效信息，因为它提供了要检索的图片的完整大小。
如果站点未发送 Accept-Ranges 首部，那么它们有可能不支持范围请求。一些站点会明确将其值设置为 “none”，以此来表明不支持。在这种情况下，某些应用的下载管理器会将暂停按钮禁用。
curl -I https://www.youtube.com/watch?v=EwTZ2xpQwpAH ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/network/http-cors/" title="跨域资源共享 CORS 详解">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="跨域资源共享 CORS 详解"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-cors/" title="跨域资源共享 CORS 详解">跨域资源共享 CORS 详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.255Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。  它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-Lang ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/http-differ/" title="HTTP1.0、HTTP1.1 和 HTTP2.0 的区别">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP1.0、HTTP1.1 和 HTTP2.0 的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/http-differ/" title="HTTP1.0、HTTP1.1 和 HTTP2.0 的区别">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.255Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">一、HTTP的基本优化
影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。

带宽：忽略。
延迟：
浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。


DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。


建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。


二、HTTP1.0和HTTP1.1的一些区别缓存处理：HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/proxy-reproxy/" title="正向代理与反向代理的区别">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="正向代理与反向代理的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/proxy-reproxy/" title="正向代理与反向代理的区别">正向代理与反向代理的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.254Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
正向代理代理的对象是客户端，反向代理代理的对象是服务端

1. 概念正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。
  反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。

2. 区别  正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。
正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/vi/" title="Linux vi/vim">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux vi/vim"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/vi/" title="Linux vi/vim">Linux vi/vim</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.254Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

原文地址
vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：
命令模式：用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令：

i&nbsp;切换到输入模式，以输入字符。
x&nbsp;删除当前光标所在处的字符。
:&nbsp;切换到底线命令模式，以在最底一行输入命令。

若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。
输入模式在命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键：

字符按键以及Shift组合，输入字符
ENTER，回车键，换行
BACK SPACE，退格键，删除光标前一个字符
DEL， ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/yum/" title="linux下安装软件--yum命令">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux下安装软件--yum命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/yum/" title="linux下安装软件--yum命令">linux下安装软件--yum命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.254Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
在安装yum的时候，yum会建立它的软件仓库，可以通过yum repolist来查看有哪些，yum库的定义目录为/etc/yum.repos.d,一般情况下，这些预装的库能满足我们的需要,如果自己添加repository需要相应URL和密钥。

1.准备：centos7 修改yum源为阿里源,某下网络下速度比较快 首先是到yum源设置文件夹里
cd /etc/yum.repos.d
接着备份旧的配置文件   sudo mv CentOS-Base.repo CentOS-Base.repo.bak下载阿里源的文件,也可以是其他的源如（修改CentOS默认yum源为国内yum镜像源）
sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
清理缓存
yum clean all
重新生成缓存
yum makecache 

2.列出已经安装的软件包yum list installed 列出所有已经安装的软件包yum list packageName 在线查看软件包yum list install ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/network/cookie-session/" title="cookie 和 session">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cookie 和 session"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/cookie-session/" title="cookie 和 session">cookie 和 session</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.254Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/network/">network</a></span></div><div class="content">
HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据

cookie首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：1、服务器向客户端发送 cookie。通常使用 HTTP 协议规定的 set-cookie 头操作。规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。2、浏览器将 cookie 保存。3、每次请求浏览器都会将 cookie 发向服务器。其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间(单位：s)。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/network/cookie-parser/" title="cookie-parser 和 express-session">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cookie-parser 和 express-session"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/network/cookie-parser/" title="cookie-parser 和 express-session">cookie-parser 和 express-session</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.254Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/brower/">brower</a></span></div><div class="content">
cookie-parser 在用 express 生成器构建项目时自动安装的，它的作用就是设置，获取和删除 cookie。express-session 依赖于它。

cookie-parser1. 引入var cookieParser = require(&#x27;cookie-parser&#x27;);    #引入模块app.use(cookieParser());        #挂载中间件，可以理解为实例化

这两行代码默认在app.js中写好了，表示现在可以直接使用 cookie 了。
2. 创建cookieres.cookie(name, value [, options]);

name 是 cookie 名，value 是 cookie 值，可以是 json 对象或字符串。options 是选项，详细请阅这里，常用选项有：
&#123;    &#39;maxAge&#39;: 90000,    # 有效时长，即90000毫秒后过期，String    &#39;signed&#39;: false     # 默认为false，表示是否签名，Boolean& ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/nginx-n/" title="前端开发者必备的Nginx知识">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端开发者必备的Nginx知识"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/nginx-n/" title="前端开发者必备的Nginx知识">前端开发者必备的Nginx知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.253Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写

nginx在应用程序中的作用解决跨域请求过滤配置gzip负载均衡静态资源服务器…
nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。
下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。
为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？正反向代理看这
基本配置配置结构下面是一个nginx配置文件的基本结构：
events &#123; &#125;http &#123;    server &#123;         location path        &#123;            ...        &#125;        location path        &#123;            ...        &#125;    &#12 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/nginx-root-alias/" title="详解root和alias指令">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="详解root和alias指令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/nginx-root-alias/" title="详解root和alias指令">详解root和alias指令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.253Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
配置nginx的静态文件有两个指令，一个 root 和一个 alias

静态文件Nginx以其高性能著称，常用与做前端反向代理服务器。同时nginx也是一个高性能的静态文件服务器。通常都会把应用的静态文件使用nginx处理。
对于这两个指令，是否需要在路径的后面加上斜杠，经常容易让人犯晕，本文通过尝试不同的匹配规则，归纳了一个比较通用的配置方式。
基本配置与简明 Nginx Location Url 配置笔记一文关于location url配置的实验一样，本文也使用vagrant虚拟机里的nginx。其基本配置如下：
# /etc/nginx/sites-enabled/pro.confserver &#123;   listen 80 default_server;   server_name localhost;   access_log /var/log/nginx/pro/access.log;   error_log /var/log/nginx/pro/error.log;   error_page 404 /404.html;   root /vagrant/pro; ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/nginx-proxy/" title="Nginx 反向代理与负载均衡">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 反向代理与负载均衡"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/nginx-proxy/" title="Nginx 反向代理与负载均衡">Nginx 反向代理与负载均衡</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.253Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">nginx负载均衡的5种策略Nginx入门Nginx 配置反向代理服务器
用户访问网站的时候首先会访问nginx服务器，然后nginx服务器再从服务器集群中选择压力较小的服务器，将该访问请求引向该服务器
nginx配置下面修改配置方面我就从mac系统下来进行简单的演示，如何安装的话也暂以mac为主了，windows系统直接去Nginx官网下载安装即可
安装nginx    1-进到homebrew官网，然后复制命令，预安装需要的东西    2-brew install nginx    安装nginx    3-nginx -v  显示版本号进入nginx    cd /usr/local/etc/nginx
nginx常用命令
一、启动nginx
nginx
    访问localhost:8080(默认)即可

二、关闭nginx
如果出现下图情况，不要惊慌，是因为之前nginx被启动过了
只需nginx -s stop，停止nginx服务
然后再次启动nginx即可
三、重启nginx
nginx -s reload
每次修改完.conf文件就需要重启nginx
四、检查配置
检 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/nginx-ws/" title="基本的 WebSocket 的 Nginx 配置">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基本的 WebSocket 的 Nginx 配置"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/nginx-ws/" title="基本的 WebSocket 的 Nginx 配置">基本的 WebSocket 的 Nginx 配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.253Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">nginx and WebSockets
先用 ws 模块写一个简单的 WebSocket 服务器:
Server = require(&#x27;ws&#x27;).Serverwss = new Server port: 3000wss.on (&#x27;connection&#x27;, (ws) =&gt;&#123;    console.log &#x27;a connection&#x27;    ws.send &#x27;started&#x27;&#125;)console.log &#x27;server started&#x27;

然后修改 Hosts, 添加, 比如 ws.repo, 指向 127.0.0.1然后是 Nginx 配置:
server &#123;    listen 80;    server_name ws.repo;    location / &#123;        proxy_pass http://127.0.0.1:3000/;        proxy_redirect off;        proxy_http_ver ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/nginx-wss/" title="Nginx代理ssl转发https和wss请求">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx代理ssl转发https和wss请求"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/nginx-wss/" title="Nginx代理ssl转发https和wss请求">Nginx代理ssl转发https和wss请求</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.253Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">使用场景什么情况下需要这种操作？
比如，后台多台服务器做反向代理；
比如，微信小程序，建立微信小程序的websocket连接，必须要使用wss，但是目前不支持自定义端口，在调用的时候会使用默认端口，这个时候就需要做个代理。
实现Nginx配置
server &#123;    listen 443; #https和wss协议默认端口    # ssl的相关配置    ssl on;    ssl_certificate /usr/local/a.pem; // ssl pem文件    ssl_certificate_key /usr/local/a.key; // ssl key文件    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;    ssl_prefer_server_ciphers on;    ssl_buffer_size 1400;   ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/java/" title="CentOS7下yum安装Java">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CentOS7下yum安装Java"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/java/" title="CentOS7下yum安装Java">CentOS7下yum安装Java</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">一：查看yum包含的jdk版本yum search java 或者 yum list java*


版本jrejdk1.8java-1.8.0-openjdk.x86_64java-1.8.0-openjdk-devel.x86_641.7java-1.7.0-openjdk.x86_64java-1.7.0-openjdk-devel.x86_641.6java-1.6.0-openjdk.x86_64java-1.6.0-openjdk-devel.x86_64

二、安装jdk此次选择java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment
yum install java-1.8.0-openjdk-devel.x86_64

注：也可以安装1.8.0的所有文件yum install java-1.8.0-openjdk* -y

三： 使用命令检查是否安装成功java -version</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/jdk/" title="Linux安装jdk的三种方法">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装jdk的三种方法"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/jdk/" title="Linux安装jdk的三种方法">Linux安装jdk的三种方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">环境：
Linux版本：CentOS 6.5
JDK版本：JDK 1.7
方法：方法一：手动解压JDK的压缩包，然后设置环境变量方法二：用yum安装JDK方法三：用rpm安装JDK
方法一：手动解压JDK的压缩包，然后设置环境变量
`1.在/usr/目录下创建java目录 
[root@localhost ~]# mkdir/usr/java[root@localhost ~]# cd /usr/java
2.下载，然后解压 ``` bash[root@localhost java]# curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz[root@localhost java]# tar -zxvf jdk-7u79-linux-x64.tar.gz
&#96;3.设置环境变量&#96;&#96;&#96; bash[root@localhost java]# vi &#x2F;etc&#x2F;profile
添加如下内容：
#set java environme ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/jenkins/" title="CentOS7下yum安装Jenkins">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CentOS7下yum安装Jenkins"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/jenkins/" title="CentOS7下yum安装Jenkins">CentOS7下yum安装Jenkins</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">准备条件：安装Java（CentOS下安装Java1.8）1、Yum安装yum源导入
#添加Yum源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo#导入密钥sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key

安装
sudo yum install -y jenkins
2、开放端口Jenkins站点的默认监听端口是8080(防火墙安装看这)
sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload

3、安装完成后启动Jenkins：
检查Jenkins服务状态sudo systemctl status jenkins
设置为开机自启动sudo systemctl enable jenkins
启动Jenkins服务sudo systemctl start jenkin ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/kcptun/" title="使用kcptun加速shadowsocks">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用kcptun加速shadowsocks"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/kcptun/" title="使用kcptun加速shadowsocks">使用kcptun加速shadowsocks</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.252Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费100%-200%的带宽的代价（理想状态下），换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。

网络诊断地址
工作原理：
服务端安装 KCPTunwget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh &amp;&amp; chmod +x ./kcptun.sh &amp;&amp; ./kcptun.sh

接下来会依次提醒设置以下参数（这里是最终的结果

1、端口：默认29900，即为KCPTUN与其客户端连接使用的端口，默认即可。
2、要加速的地址：默认127.0.0.1。
3、要加速的端口：设置为你的SS/SSR使用的端口。
4、密码：自己设置，用于KCPTUN客户端连接使用，不要使用默认密码。
5、加密方式选择：较强的加密方式会影响网速，建议默认a ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/crontab-mongo/" title="Linux定时任务 + mongodb自动备份">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux定时任务 + mongodb自动备份"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab-mongo/" title="Linux定时任务 + mongodb自动备份">Linux定时任务 + mongodb自动备份</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
mongodump -d k-blog -c articles -o ./

原文地址
Linux 自动定时备份 MongoDB
mongodb自动整库备份脚本#!/bin/shDB_HOST=&quot;127.0.0.1&quot;DB_NAME=&quot;node_user&quot;OUT_DIR=&quot;/data/backup/mongod_bak/mongod_bak_now&quot; #临时备份目录TAR_DIR=&quot;/data/backup/mongod_bak/mongod_bak_list&quot; #备份存放路径DATE=$(date +%Y_%m_%d) #获取当前系统时间echo &quot;-----当前时间为$DATE-----&quot;DAYS=7 #DAYS=7代表删除7天前的备份，即只保留最近7天的备份TAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot; #最终保存的数据库备份文件名cd $OUT_DIRecho &quot;-----删除原有备份文件-----&quot;find $OUT_ ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/crontab/" title="crontab 定时任务">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="crontab 定时任务"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab/" title="crontab 定时任务">crontab 定时任务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合

crontab 定时任务每天一个linux命令（50）：crontab命令
Linux 下执行定时任务 crontab 命令详解
linux命令
Centos7:利用crontab定时执行任务
19、crontab 定时任务19.1. 命令格式crontab [-u user] file crontab [-u user] [ -e | -l | -r ]
19.2. 命令参数
-u user：用来设定某个用户的crontab服务；
file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/google-bbr/" title="SSR开启Google的BBR内核脚本加速TCP">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSR开启Google的BBR内核脚本加速TCP"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/google-bbr/" title="SSR开启Google的BBR内核脚本加速TCP">SSR开启Google的BBR内核脚本加速TCP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。

BBR 这个特性其实是在 Linux 内核 4.9 才计划加入的。所以，要开启BBR，需要内核版本在Linux kernel 4.9以上，根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。下面纪录一下如何升级Linux内核，并且开启BBR：
下载bbr 安装脚本：
wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh

安装成功后重启服务器
shutdown -r now

查看内核版本，如果返回值含有4.13或以上版本, 就表示安装成功了。
uname -r

sysctl net.ipv4.tcp_ava ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/firewalld/" title="centos7安装防火墙firewalld">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7安装防火墙firewalld"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/firewalld/" title="centos7安装防火墙firewalld">centos7安装防火墙firewalld</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.251Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">默认情况下CentOS 7可能已经安装了firewalld服务，若确实没有安装直接使用yum命令安装即可：
先来安装# yum install -y firewalld
常用命令安装完成后firewalld并没有运行，有必要先来熟悉下基本的命令：
#查看运行状态firewall-cmd --state#启动firewallsystemctl start firewalld#设置开机自启systemctl enable firewalld#删除开机自启systemctl disable firewalld#停止firewallsystemctl stop firewalld

注：elasticsearch需要开放9200,9300两个端口
# firewall-cmd --add-port=9200/tcp --permanent  #永久开放9200端口# firewall-cmd --add-port=9300/tcp --permanent  #永久开放9300端口# firewall-cmd --reload  #重新加载# firewall-cmd --list-all #查 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/centos-cmd/" title="centos7 常用命令【systemctl替换service】">     <img class="post_bg" src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7 常用命令【systemctl替换service】"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/centos-cmd/" title="centos7 常用命令【systemctl替换service】">centos7 常用命令【systemctl替换service】</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">centos7 上面启动服务以及关闭服务已经不是以前的service stop/start xxxx了
而是systemctl命令，不过用service他会有一个提醒你用systemctl”,

“content”: ‘ ‘ 看所有网卡IP地址——ip addr
启动防火墙——systemctl start firewalld.service
停止防火墙——systemctl stop firewalld.service
查看firewalld防火墙状态——firewall-cmd –state
禁止防火墙开机启动——systemctl disable firewalld.service
列出正在运行的服务状态——systemctl
启动一个服务—— systemctl start postfix.service
关闭一个服务—— systemctl stop postfix.servic
重启一个服务：—— systemctl restart postfix.service
显示一个服务的状态—— systemctl status postfix.service
在开机时启用一个服务 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/linux/centos-node/" title="Centos7 安装nvm、node">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Centos7 安装nvm、node"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/centos-node/" title="Centos7 安装nvm、node">Centos7 安装nvm、node</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">首先：安装nvm
下载命令curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash
或者
wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash

下载完成后加入系统环境source   ~/.bashrc

查看 NVM 版本list
nvm list-romote



4、安装需要的node版本
nvm install  v11.9.0
查看当前机器已安装版本号
nvm list
切换node版本
nvm use v11.9.0
7、设置默认的node版本
nvm alias default v11.9.0

n是Node的一个模块，作者是TJ Holowaychuk（Express框架作者）
n与nvm的区别

n是 npm 的一个全局模块，安装n之前需要先安装node。nvm是一个独立软件包。

在安装的时候，n会先将指定版本的 node 存储下来，然后将 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/linux/crontab-1/" title="centos7 常用命令【systemctl替换service】">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="centos7 常用命令【systemctl替换service】"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/linux/crontab-1/" title="centos7 常用命令【systemctl替换service】">centos7 常用命令【systemctl替换service】</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="content">
service crond status

1、先手动执行定时任务以此来判断脚本是否有问题。
2、确认服务器是否开启定时任务计划服务
命令：
service crond statusservice crond start

3、查看crontab执行记录
如果出现了crontab定时任务不执行的情况，首先需要定位问题，那么就需要通过日志来确定问题所在。
crontab的日志位置一般位于/var/log/cron，利用下面的语句即可查看日志。
tail -f /var/log/cron
上面的/var/log/cron只会记录是否执行了某些计划的脚本，但是具体执行是否正确以及脚本执行过程中的一些信息linux
会通过邮件形式发送到给该用户。对于root用户该邮件记录位于/var/spool/mail/root，通过以下命令可以查看最近的crontab执行情况。
tail -f /var/spool/mail/root
mail邮件一般只会记录脚本执行成功与否，如果执行失败，无法给出进一步的错误信息，这时需要我们将语句执行的错误信息
重定向至文件中，这样可以很方便的查看错误信息
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/xss-csrf/" title="XSS和CSRF">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XSS和CSRF"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/xss-csrf/" title="XSS和CSRF">XSS和CSRF</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.250Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
跨站脚本攻击(Cross Site Scripting)、跨站请求伪造(Cross Site Request Forgery)

XSS，(cross site scripting),跨站脚本注入，指攻击者利用一些技巧向页面注入脚本代码并让其执行，从而达成攻击效果。
XSS原理攻击者利用页面输入和输出的功能，在输入时使用闭标签再加脚本代码等技巧，当服务器输出这些输入信息到页面时，就会插入并执行脚本代码。解决方法是可以在服务端对客户端的输入进行过滤或转义。注意：这里不一定只用script标签，还可以用img等其他标签，或者用onclick等事件方法达到执行脚本代码。简单例子如下：
//Web 请求如下所示：GET http://www.somesite.com/page.asppageid=10&amp;lang=en&amp;title=Section%20Title//在发出请求后，服务器返回的 HTML 内容包括：// Section Title// 攻击者可以通过摆脱 //  标记来注入代码：// http://www.somesite.com/page.asp?pageid= ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/video-demuxing-muxing/" title="new 命令">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="new 命令"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/video-demuxing-muxing/" title="new 命令">new 命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
Mux 是 Multiplex 的缩写，意为“多路传输”，其实就是“混流”、“封装”的意思，与“合成”的意思相似就是指把视频素材和音频素材封装到一个单独的文件中。

muxing 是在mux 后面加了 -ing 构成的动名词形式。Demux是在 mux 前面加了个表示否定的 De- 前缀，意思是进行与 muxing 相反的“分解复用”操作，也就是我们平时说的“分离”一个文件中的视频部分或是音频部分。同样，也可以在 demux 后面加 -ing 构成动名词 demuxing。意义：通过 muxing（混流），可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，作为一个信号进行传输，等传输完毕，就可以通过 demuxing（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。要点：在 muxing 与 demuxing 的整个过程，都不对原来的视频、音频或字幕重新编码。混流（封装、打包）后的文件，可以通过分离（分解、解包）操作，获得与原始素材一模一样的独立的视频、音频和字幕文件。
视频的分离与合成，编码和解码
对媒体流的处理分为两种：“编码（encoding）”和“解码（de ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/web-worker/" title="Web Worker">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Worker"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/web-worker/" title="Web Worker">Web Worker</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给Worker 线程

Web Worker 有以下几个使用注意点。

同源限制
  分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

DOM 限制
  Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

通信联系
  Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

脚本限制
  Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

文件限制
  Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。


主线程主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worke ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/web-err/" title="前端异常监控解决方案">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端异常监控解决方案"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/web-err/" title="前端异常监控解决方案">前端异常监控解决方案</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.249Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">
前端监控包括行为监控、异常监控、性能监控等,一个用户在操作应用过程中如果出现异常，有可能是前端引起，也有可能是后端引起，需要有一个机制，将前后端串联起来，使监控本身统一于监控系统。

原文地址
一个监控系统，大致可以分为四个阶段:
采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。
存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。
分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。
报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。
一、前端异常1.1 前端异常分类a. 出错界面呈现的内容与用户预期的内容不符，例如点击进入非目标界面，数据不准确，出现的错误提示不可理解，界面错位，提交后跳转到错误界面等情况。这类异常出现时，虽然产品本身功能还能正常使用，但用户无法达成自己目标。 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/sort/" title="各种排序实现">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="各种排序实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/sort/" title="各种排序实现">各种排序实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
十大经典排序算法总结

 详细图文解析 看这
一、冒泡demo:// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，//就好像气泡往上冒一样function bubbleSort(arr) &#123;    let len = arr.length;    for (let i = 0; i &lt; len; i++) &#123;        for (let j = 0; j &lt; len - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比                [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];            &#125;        &#125;    &#125;    return arr;&#125;// 1) 首先，在数组中选择一个中间项作为主元// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/stack/" title="JavaScipt中栈的实现">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScipt中栈的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/stack/" title="JavaScipt中栈的实现">JavaScipt中栈的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。

栈需要有如下的方法:

push(element(s)): 添加几个元素到栈顶
pop(): 移除并返回栈顶元素
peek(): 返回栈顶元素
isAmpty: 检查栈是否为空，为空则返回true
clear: 移除栈中所有元素
size: 返回栈中元素个数。
print: 以字符串显示栈中所有内容

/*** 栈的构造函数*/function Stack() &#123;    /**    * 用数组来模拟栈    * @type &#123;Array&#125;    */    var items = [];    /**    * 将元素送入栈，放置于数组的最后一位    * @param  &#123;Any&#125; element 接受的元素，不限制类型    */    this.push = function(element) &#123;        items.push(element);    &#125;;    /**    * 弹出 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/textContent/" title="Node.textContent">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.textContent"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/textContent/" title="Node.textContent">Node.textContent</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
Node.textContent 属性表示一个节点及其后代的文本内容。

1、如果 element 是 Document，DocumentType 或者 Notation 类型节点，则 textContent 返回 null。如果你要获取整个文档的文本以及CDATA数据，可以使用document.documentElement.textContent。2、如果节点是个CDATA片段，注释，ProcessingInstruction节点或一个文本节点，textContent 返回节点内部的文本内容（即 nodeValue）。3、对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释、ProcessingInstruction节点。如果该节点没有子节点的话，返回一个空字符串。4、在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。

与innerText的区别IE引入了node.innerText。意图类似，但有以下区别：
1、textContent 会获取所有元素的内容，包括script ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/tostring/" title="toString方法和valueOf方法以及Symbol.toPrimitive">     <img class="post_bg" src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="toString方法和valueOf方法以及Symbol.toPrimitive"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/tostring/" title="toString方法和valueOf方法以及Symbol.toPrimitive">toString方法和valueOf方法以及Symbol.toPrimitive</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
每个对象都有一个toString()方法和valueOf方法，其中toString()方法返回一个表示该对象的字符串，valueOf方法返回该对象的原始值。

对于值类型数据(又叫基本类型)场景下，toString及valueOf方法的使用toString方法对于值类型数据使用而言，其效果相当于类型转换，将原类型转为字符串。
valueOf方法对于值类型数据使用而言，其效果将相当于返回原数据。 
复合对象类型数据使用toString及valueOf方法var test = &#123;     i: 10,     toString: function() &#123;         console.log(&#x27;toString&#x27;);         return this.i;     &#125;,     valueOf: function() &#123;         console.log(&#x27;valueOf&#x27;);         return this.i;     &#125; &#125; alert(test);// 10  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/11/14/js/ts-3.7/" title="TypeScript 3.7、TypeScript 3.8 Beta">     <img class="post_bg" src="/img/js.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript 3.7、TypeScript 3.8 Beta"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/ts-3.7/" title="TypeScript 3.7、TypeScript 3.8 Beta">TypeScript 3.7、TypeScript 3.8 Beta</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Javascript/">Javascript</a></span></div><div class="content">原文链接： TypeScript 3.7
翻译地址
TypeScript 3.8 Beta
1、可选链## 2、空值联合&lt;a href=&quot;https://www.webq.top/article/926&quot; target=&quot;_blank&quot; style=&quot;font-size: 14px;&quot;&gt;参照上文：es2020&lt;/a&gt;
3、断言函数      它们是一些特殊函数的集合。当一些非预期的事情发生的时候它们将抛出 error。它们被称为断言函数
function isString(val: any): val is string &#123;    return typeof val === &quot;string&quot;;&#125;function yell(str: any) &#123;    if (isString(str)) &#123;        return str.toUppercase();    &#125;    throw &quot;Oops!&quot;;&#125;
 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/11/14/js/ts-dts/" title="TS声明文件">     <img class="post_bg" src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS声明文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/11/14/js/ts-dts/" title="TS声明文件">TS声明文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-14T08:10:34.248Z" title="发表于 2020-11-14 16:10:34">2020-11-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/web/">web</a></span></div><div class="content">
当使用外部JavaScript库或新的宿主API时，需要一个自定义声明文件（.d.ts）

原文地址
流程最好从程序库的文档而不是代码开始写.d.ts文件。 这样保证不会被具体实现所干扰，而且相比于JS代码更易读。 下面的例子会假设你正在参照文档写声明文件。
命名空间当定义接口（例如：“options”对象），你会选择是否将这些类型放进命名空间里。 这主要是靠主观判断 – 如果使用的人主要是用这些类型来声明变量和参数，并且类型命名不会引起命名冲突，则放在全局命名空间里更好。 如果类型不是被直接使用，或者没法起一个唯一的名字的话，就使用命名空间来避免与其它类型发生冲突。
回调函数许多JavaScript库接收一个函数做为参数，之后传入已知的参数来调用它。 当用这些类型为函数签名的时候，不要把这些参数标记成可选参数。 正确的思考方式是“(调用者)会提供什么样的参数？”，不是“(函数)会使用到什么样的参数？”。
 TypeScript 0.9.7+不会强制这种可选参数的使用，参数可选的双向协变可以被外部的linter强制执行。
扩展与声明合并写声明文件的时候，要记住TypeScript扩展 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/face.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">雪人</div><div class="author-info__description">雪人的笔记</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kwey"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="sticky_layout"><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/dm-render/render/" title="浏览器渲染原理"><img src="/img/default2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器渲染原理"/></a><div class="content"><a class="title" href="/2021/07/11/dm-render/render/" title="浏览器渲染原理">浏览器渲染原理</a><time datetime="2021-07-11T01:38:14.322Z" title="发表于 2021-07-11 09:38:14">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/08/brower/fps/" title="WebRender如何摆脱jank"><img src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRender如何摆脱jank"/></a><div class="content"><a class="title" href="/2021/05/08/brower/fps/" title="WebRender如何摆脱jank">WebRender如何摆脱jank</a><time datetime="2021-05-08T02:58:41.114Z" title="发表于 2021-05-08 10:58:41">2021-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/07/brower/gpu-acc/" title="GPU硬件加速"><img src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GPU硬件加速"/></a><div class="content"><a class="title" href="/2021/05/07/brower/gpu-acc/" title="GPU硬件加速">GPU硬件加速</a><time datetime="2021-05-07T07:06:14.068Z" title="发表于 2021-05-07 15:06:14">2021-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/01/brower/lifecycle/" title="浏览器周期"><img src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器周期"/></a><div class="content"><a class="title" href="/2021/02/01/brower/lifecycle/" title="浏览器周期">浏览器周期</a><time datetime="2021-02-01T06:04:52.359Z" title="发表于 2021-02-01 14:04:52">2021-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/19/doc/mask/" title="CSS Masking Module Level 1"><img src="/img/hy.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS Masking Module Level 1"/></a><div class="content"><a class="title" href="/2020/11/19/doc/mask/" title="CSS Masking Module Level 1">CSS Masking Module Level 1</a><time datetime="2020-11-19T06:06:47.980Z" title="发表于 2020-11-19 14:06:47">2020-11-19</time></div></div></div></div></div><div class="card-widget" id="card-newest-comments"><div class="card-content"><div class="item-headline"><i class="fas fa-bolt"></i><span>最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="card-widget card-categories"><div class="card-content"><div class="item-headline"><i class="fas fa-folder-open"></i><span>分类</span></div><ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Databse/"><span class="card-category-list-name">Databse</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Javascript/"><span class="card-category-list-name">Javascript</span><span class="card-category-list-count">20</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">19</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Node/"><span class="card-category-list-name">Node</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/brower/"><span class="card-category-list-name">brower</span><span class="card-category-list-count">23</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/frame/"><span class="card-category-list-name">frame</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/gpu/"><span class="card-category-list-name">gpu</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/network/"><span class="card-category-list-name">network</span><span class="card-category-list-count">1</span></a></li>
            <li class="card-category-list-item more is-center"><a class="card-category-list-link-more" href="/categories/">
                <span>查看更多</span><i class="fas fa-angle-right"></i></a></li>
            </ul></div></div><div class="card-widget card-tags"><div class="card-content"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/CMD/" style="font-size: 1.1em; color: #999">CMD</a> <a href="/tags/CSS/" style="font-size: 1.1em; color: #999">CSS</a> <a href="/tags/Javascript/" style="font-size: 1.5em; color: #99a9bf">Javascript</a> <a href="/tags/Mongodb/" style="font-size: 1.19em; color: #999da1">Mongodb</a> <a href="/tags/brower/" style="font-size: 1.41em; color: #99a5b7">brower</a> <a href="/tags/centos/" style="font-size: 1.28em; color: #99a0aa">centos</a> <a href="/tags/cmd/" style="font-size: 1.32em; color: #99a2ae">cmd</a> <a href="/tags/cors/" style="font-size: 1.1em; color: #999">cors</a> <a href="/tags/css/" style="font-size: 1.28em; color: #99a0aa">css</a> <a href="/tags/django/" style="font-size: 1.19em; color: #999da1">django</a> <a href="/tags/err/" style="font-size: 1.1em; color: #999">err</a> <a href="/tags/es6/" style="font-size: 1.46em; color: #99a7bb">es6</a> <a href="/tags/git/" style="font-size: 1.1em; color: #999">git</a> <a href="/tags/github/" style="font-size: 1.14em; color: #999b9d">github</a> <a href="/tags/html/" style="font-size: 1.37em; color: #99a4b2">html</a> <a href="/tags/http/" style="font-size: 1.37em; color: #99a4b2">http</a> <a href="/tags/hy/" style="font-size: 1.1em; color: #999">hy</a> <a href="/tags/java/" style="font-size: 1.14em; color: #999b9d">java</a> <a href="/tags/javascript/" style="font-size: 1.1em; color: #999">javascript</a> <a href="/tags/jdk/" style="font-size: 1.1em; color: #999">jdk</a> <a href="/tags/jwt/" style="font-size: 1.1em; color: #999">jwt</a> <a href="/tags/lifecycle/" style="font-size: 1.1em; color: #999">lifecycle</a> <a href="/tags/mobile/" style="font-size: 1.1em; color: #999">mobile</a> <a href="/tags/model/" style="font-size: 1.23em; color: #999ea6">model</a> <a href="/tags/mse/" style="font-size: 1.1em; color: #999">mse</a> <a href="/tags/mysql/" style="font-size: 1.23em; color: #999ea6">mysql</a> <a href="/tags/network/" style="font-size: 1.1em; color: #999">network</a> <a href="/tags/nginx/" style="font-size: 1.28em; color: #99a0aa">nginx</a> <a href="/tags/node/" style="font-size: 1.1em; color: #999">node</a> <a href="/tags/npm/" style="font-size: 1.14em; color: #999b9d">npm</a> <a href="/tags/nuxt/" style="font-size: 1.1em; color: #999">nuxt</a> <a href="/tags/proxy/" style="font-size: 1.1em; color: #999">proxy</a> <a href="/tags/schedule/" style="font-size: 1.1em; color: #999">schedule</a> <a href="/tags/tcp/" style="font-size: 1.1em; color: #999">tcp</a> <a href="/tags/typescript/" style="font-size: 1.14em; color: #999b9d">typescript</a> <a href="/tags/video/" style="font-size: 1.19em; color: #999da1">video</a> <a href="/tags/vue/" style="font-size: 1.14em; color: #999b9d">vue</a> <a href="/tags/webpack/" style="font-size: 1.28em; color: #99a0aa">webpack</a> <a href="/tags/ws/" style="font-size: 1.14em; color: #999b9d">ws</a> <a href="/tags/xhr/" style="font-size: 1.1em; color: #999">xhr</a></div></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/02/"><span class="card-archive-list-date">二月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/11/"><span class="card-archive-list-date">十一月 2020</span><span class="card-archive-list-count">149</span></a></li></ul></div></div><div class="card-widget card-webinfo"><div class="card-content"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">153</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">345.2k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-10-27T02:41:44.431Z"></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 雪人</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div></div></body></html>