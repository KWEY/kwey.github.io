<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>全新Chrome Devtools Performance使用指南</title>
    <url>/2020/11/14/brower/chrome-performance/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000011516068?utm_source=tag-newest" target="_blank">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器的缓存机制</title>
    <url>/2020/11/14/brower/cache/</url>
    <content><![CDATA[<blockquote>
<p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的</p>
</blockquote>
<h2 id="一：缓存规则解析"><a href="#一：缓存规则解析" class="headerlink" title="一：缓存规则解析"></a>一：缓存规则解析</h2><p> <img src="/img/cache1.png"><br> <img src="/img/cache2.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>1、强制缓存<br>主要有三种(暂不分析协商缓存过程)，如下：</p>
<ul>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）</li>
</ul>
<ul>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)</li>
</ul>
<ul>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果<br>那么强制缓存的缓存规则是什么？</li>
</ul>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，<br>控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p>
<p>到了HTTP/1.1，Expire已经被Cache-Control替代<br>原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>Cache-Control的优先级比expires</p>
<p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul><li>
<span style="font-weight: bold; background-color: rgb(238, 236, 224); color: rgb(249, 150, 59);">public： 客户端和代理服务器都可缓存</li><li>

</li><li>
private：只有客户端可以缓存，默认取值</li><li>

</li><li>
no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>

</li><li>
no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>

</li><li>
max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul>


<p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p>
<p>1、from memory cache     代表使用内存中的缓存，<br>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>
<p>2、from disk cache    代表使用的是硬盘中的缓存，</p>
<p>浏览器读取缓存的顺序为memory –&gt; disk。</p>
<p>浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；</p>
<p>而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>
<h2 id="二、对比缓存（协商缓存"><a href="#二、对比缓存（协商缓存" class="headerlink" title="二、对比缓存（协商缓存"></a>二、对比缓存（协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况</p>
<p> <img src="/img/cache4.png"><br>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：</p>
<p>Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。## </p>
<h2 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h2><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。<br><img src="/img/cache5.png"></p>
<p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。<br>服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。</p>
<p> <img src="/img/cache6.png"></p>
<h2 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h2><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p>
<p> <img src="/img/cache7.png"></p>
<p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。<br>服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p>
<p> <img src="/img/cache8.png"></p>
<p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p>
<p> <img src="/img/cache9.png"></p>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
<h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。</p>
<p>这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
<p>1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>
<p>2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
<p>参考文档：<br><a id="cb_post_title_url" href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器的缓存机制</title>
    <url>/2020/11/14/brower/cache2/</url>
    <content><![CDATA[<p>浏览器缓存最主要的作用是减少网络传输的损耗以及降低服务器压力。</p>
<p>接下来我将通过以下几个部分来探讨浏览器缓存机制：</p>
<ul>
<li>缓存位置</li>
<li>缓存策略</li>
</ul>

<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>浏览器缓存位置分为四种，其优先级顺序如下：</p>
<ol>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ol>

<p>当上述四个缓存位置中的缓存都没有命中时，则会向服务器发起请求。</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 是一个注册在指定源和路径下的事件驱动 worker。它采用 JavaScript 控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。</p>
<p>我们可以通过谷歌开发者工具中的 Application -&gt; Service Workers 查看当前缓存的资源。</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache 即内存中的缓存，其特点是容量小、读取高效、持续性短，会随着进程的释放而释放。</p>
<p>所以，在内存使用率低、缓存小尺寸资源时，会以 Memory Cache 为优先，否则使用 Disk Cache。</p>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 即磁盘中的缓存，其特点是容量大、读取缓慢、持续性长，任何资源都能存储到磁盘中。</p>
<p>所以，在内存使用率高、缓存大尺寸资源时，会以 Disk Cache 为优先。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache 是 HTTP 2.0 中的内容，其缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</p>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>浏览器每次在向服务器发起 HTTP 请求获得资源后，可能会根据不同情况（可能是代码控制如 Service Worker、Push Cache，也可能是根据 HTTP Header 的缓存标识字段）将资源缓存起来。</p>
<p>浏览器缓存策略分为强制缓存和协商缓存，其是通过设置 HTTP Header 来实现的。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>当浏览器发起 HTTP 请求时，会依次查找上述缓存位置中是否存在缓存资源并通过缓存标识字段 Expires 或 Cache-Control 来验证缓存资源是否过期。</p>
<p>Expires 是服务器端在响应请求时用来规定资源的失效时间。</p>
<p>Cache-Control 是服务器端在响应请求时用来规定资源是否需要被浏览器缓存以及缓存的有效时间等。</p>
<figure></figure>



<p><a href="https://juejin.im/post/5c749f6851882562934ca96e" target="_blank">浏览器缓存机制</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect" target="_blank">浏览器缓存机制剖析</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=207907457&amp;idx=1&amp;sn=cf0b3d1e630c977a839fdc8ee7c99904&amp;scene=21#wechat_redirect" target="_blank">构建高性能WEB之HTTP首部优化</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect" target="_blank">浏览器的缓存机制小结</a></p>
]]></content>
  </entry>
  <entry>
    <title>Cache-Control</title>
    <url>/2020/11/14/brower/Cache-Control/</url>
    <content><![CDATA[<blockquote>
<p>浏览器缓存里, Cache-Control是金字塔顶尖的规则, 它藐视一切其他设置, 只要其他设置与其抵触, 一律覆盖之.</p>
</blockquote>
<p>语法为: “Cache-Control : cache-directive”.<br>Cache-directive共有如下12种(其中请求中指令7种, 响应中指令 9 种):</p>
<table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><th> cache-directive</th><th>描述 </th><th>存储策略 </th><th>过期策略 </th><th>请求 </th><th>响应 </th></tr><tr><td> Public</td><td>  资源将被客户端和代理服务器缓存</td><td>yes </td><td> </td><td> </td><td>yes </td></tr><tr><td> Private</td><td> 资源将被客户端缓存、代理服务器不缓存</td><td>yes </td><td> </td><td> </td><td> yes</td></tr><tr><td> no-sore</td><td> 请求和相应都不缓存</td><td> yes</td><td> </td><td> yes</td><td> yes</td></tr><tr><td> no-cache</td><td> 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</td><td> yes</td><td> yes</td><td> yes</td><td> yes</td></tr><tr><td> max-age</td><td> 客户端可以接收生存期不大于指定时间（以秒为单位）的响应
</td><td> yes</td><td> yes</td><td> yes</td><td> yes</td></tr><tr><td> s-maxage</td><td> 覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。</td><td> yes</td><td> yes</td><td></td><td> yes</td></tr><tr><td> max-stale</td><td> 指示客户端可以接收超出超时期间的响应消息</td><td> </td><td> yes</td><td> yes</td><td> yes</td></tr><tr><td> min-fresh</td><td> 指示客户端可以接收响应时间小于当前时间加上指定时间的响应。</td><td> </td><td> yes</td><td> yes</td><td> </td></tr><tr><td> must-revalidate</td><td> 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</td><td> </td><td> yes</td><td></td><td> yes</td></tr><tr><td> proxy-revalidate</td><td> 与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</td><td> </td><td> yes</td><td> </td><td> yes</td></tr><tr><td> only-if-cached</td><td> 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝</td><td> </td><td> </td><td> yes</td><td> </td></tr><tr><td> no-transform</td><td> 不得对资源进行转换或转变</td><td> </td><td> </td><td> yes</td><td> yes</td></tr></tbody></table>

<p>假设所请求资源于4月5日缓存, 且在4月12日过期.</p>
<p>当max-age 与 max-stale 和 min-fresh 同时使用时, 它们的设置相互之间独立生效, 最为保守的缓存策略总是有效. 这意味着, 如果max-age=10 days, max-stale=2 days, min-fresh=3 days, 那么:</p>
<p>根据max-age的设置, 覆盖原缓存周期, 缓存资源将在4月15日失效(5+10=15);</p>
<p>根据max-stale的设置, 缓存过期后两天依然有效, 此时响应将返回110(Response is stale)状态码, 缓存资源将在4月14日失效(12+2=14);</p>
<p>根据min-fresh的设置, 至少要留有3天的新鲜期, 缓存资源将在4月9日失效(12-3=9);</p>
<p>由于客户端总是采用最保守的缓存策略, 因此, 4月9日后, 对于该资源的请求将重新向服务器发起验证.<br>注： 单一计算不会叠加</p>
<h2 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" class="headerlink" title="用户行为对缓存的影响"></a>用户行为对缓存的影响</h2><table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><th>操作 </th><th>Expires/ Cache-Control</th><th>Etag / If-None-Match </th></tr><tr><td> 地址栏回车</td><td> yes</td><td> yes</td></tr><tr><td> 页面链接跳转</td><td> yes</td><td> yes</td></tr><tr><td> 新打开窗口</td><td> yes</td><td> yes</td></tr><tr><td> 前进后退</td><td> yes</td><td> yes</td></tr><tr><td> F5</td><td> 无效</td><td> yes</td></tr><tr><td> Ctrl+F5</td><td> 无效</td><td> 无效</td></tr></tbody></table>]]></content>
  </entry>
  <entry>
    <title>浏览器的回流与重绘 (Reflow &amp; Repaint)</title>
    <url>/2020/11/14/brower/repaint-reflow/</url>
    <content><![CDATA[<h2 id="客户端渲染页面的过程"><a href="#客户端渲染页面的过程" class="headerlink" title="客户端渲染页面的过程"></a>客户端渲染页面的过程</b></h2><ul>
<li>1、处理 HTML 标记并构建 DOM 树。</li>
<li>2、处理 CSS 标记并构建 CSSOM 树。</li>
<li>3、将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>4、根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>5、将各个节点绘制到屏幕上。</li>
</ul>
<p>这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>
<h2 id="阻塞渲染：CSS-与-JavaScript"><a href="#阻塞渲染：CSS-与-JavaScript" class="headerlink" title="阻塞渲染：CSS 与 JavaScript"></a>阻塞渲染：CSS 与 JavaScript</h2><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。<br>同时，由于下面两点：</p>
<ul>
<li>1、默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li>
<li>2、JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</li>
<li>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</li>
</ul>
<ul>
<li><p>1、当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</p>
</li>
<li><p>2、JavaScript 可以查询和修改 DOM 与 CSSOM。</p>
</li>
<li><p>3、CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</p>
</li>
<li><p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
</li>
<li><p>1、CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</p>
</li>
<li><p>2、JavaScript 应尽量少影响 DOM 的构建。</p>
</li>
</ul>
<p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<p>浏览器的发展日益加快，具体的渲染策略会不断进化，但了解这些原理后，就能想通它进化的逻辑。下面来看看 CSS 与 JavaScript 具体会怎样阻塞资源。</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;app1.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;app2.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;app3.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>
<p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;ad.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;statistics.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。<br>从上一段也能推出，多个 async-script 的执行顺序是不确定的。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true</p>
<h2 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h2><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。<br>会导致回流的操作</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<br>一些常用且会导致回流的属性和方法</li>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollIntoViewIfNeeded()</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
<li>scrollTo()<h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</li>
</ul>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>回流比重绘的代价要更高。<br>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。<br>现代浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()<br>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</li>
</ul>
<h2 id="如何避免CSS"><a href="#如何避免CSS" class="headerlink" title="如何避免CSS"></a>如何避免CSS</h2><ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。JavaScript</li>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>WebRender如何摆脱jank</title>
    <url>/2021/05/08/brower/fps/</url>
    <content><![CDATA[<p><img src="/hide/fps.png"></p>
<p>丢弃的帧是指系统没有在帧预算内完成其工作。在浏览器完成填充之前，显示器会尝试从帧缓冲区中获取新帧。在这种情况下，显示屏将再次显示旧版本的帧。</p>
<p>一个掉下来的相框就像你从翻页书上撕下一页。这会使动画看起来结巴或跳跃，因为你错过了上一页和下一页之间的过渡。<br><img src="/hide/fps1.png"></p>
<p>因此，我们要确保在显示器再次检查之前，将所有这些像素放入帧缓冲区。让我们看看浏览器历史上是如何做到这一点的，以及这一点是如何随着时间的推移而改变的。然后我们就可以看看怎样才能更快。</p>
]]></content>
  </entry>
  <entry>
    <title>CentOS 7上安装和配置MongoDB</title>
    <url>/2020/11/14/database/centos-mongo/</url>
    <content><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/learn/Server-side/Express_Nodejs/mongoose">数据库以及 Node/Express 应用的数据库集成(Mongoose)</a></p>
<blockquote>
<p>MongoDB是提供高性能，高可用性和自动缩放的NoSQL数据库。 NoSQL数据库意味着，与MySQL或PostgreSQL不同，它不支持SQL（结构化查询语言）来检索或操纵存储的数据。 MongoDB不会将数据存储在表中，而是将数据存储在类似于JSON的“文档”结构中（在MongoDB中称为BSON）</p>
</blockquote>
<h2 id="在CentOS中添加MongoDB资源库"><a href="#在CentOS中添加MongoDB资源库" class="headerlink" title="在CentOS中添加MongoDB资源库"></a>在CentOS中添加MongoDB资源库</h2><p>使用ssh root帐户连接到CentOS 7服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@107.182.28.215 -p 29420</span><br></pre></td></tr></table></figure>

<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line">vi mongodb-org-4.0.repo </span><br></pre></td></tr></table></figure>
<p>填入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<p>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.0.asc">https://www.mongodb.org/static/pgp/server-4.0.asc</a></p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">默认数据位置： /var/lib/mongo </span><br><span class="line"></span><br><span class="line">默认日志位置： /var/<span class="built_in">log</span>/mongodb</span><br><span class="line"></span><br><span class="line">配置文件位置：/etc/mongod.conf</span><br></pre></td></tr></table></figure>
<h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开启：systemctl start mongod</span><br><span class="line"></span><br><span class="line">关闭：systemctl stop mongod</span><br><span class="line"></span><br><span class="line">重启：systemctl restart mongod</span><br><span class="line"></span><br><span class="line">开机自启：systemctl ennable mongod</span><br></pre></td></tr></table></figure>
<p>（2）在用的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建目录：/data/db</span><br><span class="line">        /data/logs</span><br><span class="line">        </span><br><span class="line">创建配置文件：/data/mongo.cfg</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/f179ce608391" target="_blank">配置文件mongod.conf</a>、<a href="https://mib168.iteye.com/blog/1843186" target="_blank">csdn详解</a><br>并填入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line"><span class="comment"># 日志为文件</span></span><br><span class="line">  destination: file</span><br><span class="line"><span class="comment"># 文件位置</span></span><br><span class="line">  path: /home/data/logs/k-blog.log</span><br><span class="line"><span class="comment"># 是否追加</span></span><br><span class="line">  logAppend: <span class="literal">true</span></span><br><span class="line"><span class="comment">#进程</span></span><br><span class="line">processManagement:</span><br><span class="line"><span class="comment"># 守护进程方式</span></span><br><span class="line">  fork: <span class="literal">true</span></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /home/data/db</span><br><span class="line">net:</span><br><span class="line"><span class="comment"># 绑定IP，默认127.0.0.1，只能本机访问</span></span><br><span class="line">  bindIp: 127.0.0.1</span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">  port: 27017</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开启：mongod -f mongod.cfg </span><br><span class="line">关闭：mongo进入shell控制台，输入use admin，然后输入db.shutdownServer()关闭服务。</span><br></pre></td></tr></table></figure>

<h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum erase $(rpm -qa | grep mongodb-org)</span><br></pre></td></tr></table></figure>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove packageName</span><br><span class="line">yum erase packageName</span><br></pre></td></tr></table></figure>
<p>其中remove是只卸载软件，保留配置文件和数据文件，erase是卸载软件并删除其相关的文件。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL 版本发布历史总结</title>
    <url>/2020/11/14/database/mysql/</url>
    <content><![CDATA[<ul>
<li><p>在2000 年的时候，MySQL 公布了自己的源代码，并采用GPL（GNU General Public License）许可协议，正式进入开源世界。</p>
</li>
<li><p>2000年4月，MySQL对旧的存储引擎进行了整理，命名为MyISAM。</p>
</li>
<li><p>2001年，Heikiki Tuuri向MySQL提出建议，希望能集成他们的存储引擎InnoDB，这个引擎同样支持事务处理，还支持行级锁。所以在2001年发布的3.23 版本的时候，该版本已经支持大多数的基本的SQL 操作，而且还集成了MyISAM和InnoDB 存储引擎。MySQL与InnoDB的正式结合版本是4.0。</p>
</li>
<li><p>2003年12月，MySQL 5.0版本发布，提供了视图、存储过程等功能</p>
</li>
<li><p>2008年11月，MySQL 5.1发布，它提供了分区、事件管理，以及基于行的复制和基于磁盘的NDB集群系统，同时修复了大量的Bug。</p>
</li>
<li><p>2010年04月22 发布MySQL 5.5, MySQLcluster 7.1，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎。</p>
</li>
<li><p>2015年5月29日,发布了MySQL 5.6分支的最新的开发里程碑版本MySQL 5.6.25</p>
</li>
<li><p>2015年10月21日，MySQL 5.7.9 正式发布</p>
</li>
<li><p>2018年04月19日，  MySQL 8.0.11 </p>
<h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="版本3-23（2001）"><a href="#版本3-23（2001）" class="headerlink" title="版本3.23（2001）"></a>版本3.23（2001）</h3><p>一般认为这个版本的发布是Mysql真正“诞生”的时刻，其开始获得广泛使用。在这个版本，Mysql依然只是一个在平面文件（Flat File） 上实现了 SQL 查询的系统。但一个重要的改进是引入 MyISAM 代替了老旧而且有诸多限制的 ISAM 引擎。InnoDB 引擎也已经可以使用，但没有包含在默认的二进制发行版中，因为它太新了。所以如果要使用 InnoDB，必须手工编译。版本 3.23 还引入了全文索引和复制。复制是 Mysql 成为互联网应用的数据库系统的关键特性。</p>
<h3 id="版本4-0（2003）"><a href="#版本4-0（2003）" class="headerlink" title="版本4.0（2003）"></a>版本4.0（2003）</h3></li>
<li><p>支持新的语法，比如 UNION 和多表 DELETE 语法。</p>
</li>
<li><p>重写了复制，在备库使用了两个现成来实现复制，避免了之前一个线程所有复制工作的模式下任务切换导致的问题。</p>
</li>
<li><p>InnoDB 成为标准配备，包括了全部的特性：行级锁、外键等。</p>
</li>
<li><p>引入了查询缓存（自那以后这部门改动不大），同时还支持通过 SSL 进行连接。</p>
<h3 id="版本4-1（2005）"><a href="#版本4-1（2005）" class="headerlink" title="版本4.1（2005）"></a>版本4.1（2005）</h3></li>
<li><p>引入了更多新的语法，比如子查询和 INSERT ON DUPLICATE KEY UPDATE。</p>
</li>
<li><p>开始支持 UTF-8 字符集。</p>
</li>
<li><p>支持新的二进制协议和 prepared 语句。</p>
<h3 id="版本5-0（2006）"><a href="#版本5-0（2006）" class="headerlink" title="版本5.0（2006）"></a>版本5.0（2006）</h3></li>
<li><p>这个版本出现了一些“企业级”特性：视图、触发器、存储过程和存储函数。</p>
</li>
<li><p>老的 ISAM 引擎的代码被彻底移除，同时引入了新的 Federated 等引擎。</p>
<h3 id="版本5-1（2008）"><a href="#版本5-1（2008）" class="headerlink" title="版本5.1（2008）"></a>版本5.1（2008）</h3></li>
<li><p>这是 Sun 收购 MySQL AB 以后发布的首个版本，研发时间长达五年。</p>
</li>
<li><p>引入了分区、基于行的复制，以及 plugin API（包括可插拔存储引擎的 API）。</p>
</li>
</ul>
<ul>
<li><p>移除了 BerkeyDB 引擎，这是 MySQL 最早的事务存储引擎。</p>
</li>
<li><p>其他如 Federated 引擎也被放弃。</p>
</li>
<li><p>同时 Oracle 收购的 InnoDB Oy发布了 InnoDB plugin。</p>
<h3 id="版本5-5（2010）"><a href="#版本5-5（2010）" class="headerlink" title="版本5.5（2010）"></a>版本5.5（2010）</h3><p>性能提升</p>
</li>
<li><p>默认InnoDB plugin引擎。具有提交、回滚和crash恢复功能、ACID兼容。</p>
</li>
<li><p>行级锁(一致性的非锁定读 MVCC)。</p>
</li>
<li><p>表与索引存储在表空间、表大小无限制。</p>
</li>
<li><p>支持dynamic(primary key缓存内存 避免主键查询引起的IO )与compressed(支持数据及索引压缩)行格式。</p>
</li>
<li><p>InnoDB plugin文件格式Barracuda、支持表压缩、节约存储、提供内存命中率、truncate table速度更快。</p>
</li>
<li><p>原InnoDB只有一个UndoSegment，最多支持1023的并发；现在有128个Segments，支持128K个并发（同样，解决高并发带来的事务回滚）。</p>
</li>
<li><p>Innodb_thread_concurrency默认为0，线程并发数无限制，可根据具体应用设置最佳值。</p>
</li>
<li><p>Innodb_io_capacity可以动态调整刷新脏页的数量，改善大批量更新时刷新脏页跟不上导致的性能下降问题。Default：200，跟硬盘的IOPS有关。</p>
</li>
<li><p>充分利用CPU多核处理能力innodb_read_io_threads阈值：1-64innodb_write_io_threads 阈值：1-64根据数据库的读写比灵活设置，充分发挥多CPU、高性能存储设备的性能，不支持动态加载 。</p>
</li>
<li><p>自适应刷新脏页</p>
</li>
<li><p>热数据存活更久</p>
</li>
<li><p>buffer pool多实例 ：innodb_buffer_pool_instances 参数增加innodb_buffer_pool实例个数，大大降低buffer pool的mutex争抢过热情况。</p>
</li>
<li><p>Linux上实现异步IO</p>
</li>
<li><p>重新支持组提交</p>
</li>
<li><p>稳定性提升</p>
</li>
<li><p>支持半同步Replication。</p>
</li>
<li><p>增加Relay Log 自我修复功能。</p>
</li>
<li><p>Crash recovery。</p>
</li>
<li><p>引入红-黑树做插入排序的中间数据结构，时间复杂度大大降低，减少恢复时间。</p>
</li>
<li><p>Thread Pool 分组排队 限流</p>
<h3 id="版本5-6（2012）"><a href="#版本5-6（2012）" class="headerlink" title="版本5.6（2012）"></a>版本5.6（2012）</h3></li>
<li><p>默认参数的改变</p>
</li>
<li><p>Back_log  排队队列</p>
</li>
<li><p>支持全文索引</p>
</li>
<li><p>支持online DDL create,alter,drop</p>
</li>
<li><p>可以在建表时指定表空间位置</p>
<pre><code>create table external (x int unsigned not null primary key)data directory = &#39;/volumes/external1/data&#39;;</code></pre>
</li>
<li><p>新增参数innodb_page_size可以设置page大小</p>
</li>
<li><p>整合了memcached API，可以使用API来直接访问innodb表，并非SQL（减少SQL解析、查询优化代价）</p>
</li>
<li><p>innodb只读事务，不需要设置TRX_ID字段，</p>
</li>
<li><p>减少内部数据结构开销，减少read view</p>
</li>
<li><p>仅仅非只读事务依然需要TRX_ID</p>
</li>
<li><p>innodb改进点</p>
</li>
<li><p>innodb表空间在线迁移(TransportableTablespaces)</p>
</li>
<li><p>undo log可独立出系统表空间</p>
</li>
<li><p>redo log最大可增长到512G</p>
</li>
<li><p>innodb后台线程独立出来</p>
</li>
<li><p>优化器改进</p>
</li>
<li><p>ICP</p>
<pre><code>  可以在引擎层直接过滤数据，避免二次回表
  节省BP空间，提高查询性能</code></pre>
</li>
<li><p>BKA</p>
<pre><code>  全称Batch Key Access：
  SQL通过辅助索引要访问表数据时候，将大量的随机访问放入缓存，交给MRR接口合并为顺序访问。</code></pre>
</li>
<li><p>MRR</p>
<pre><code>  全称Multi Range Read：
  在BKA算法应用之后，通过MRR接口合并随机访问为顺序访问，再去检索表数据。
  变大量随机为顺序访问。在通过辅助索引检索大量数据时，性能提升明显
  磁头无需来回寻道，page只需读取一次，且较好利用了innodb线性预读功能（每次预读64个连续page）。</code></pre>
</li>
<li><p>统计信息持久化，mysqld重启后不丢失</p>
</li>
<li><p>explain语句支持insert，update，delete，replace语句，并且支持JSON格式</p>
</li>
<li><p>子查询优化提升。</p>
<h3 id="版本5-7（2015年）"><a href="#版本5-7（2015年）" class="headerlink" title="版本5.7（2015年）"></a>版本5.7（2015年）</h3><p>安全性</p>
</li>
<li><p>用户表 mysql.user 的 plugin字段不允许为空， 默认值是 mysql_native_password，而不是 mysql_old_password，不再支持旧密码格式；</p>
</li>
<li><p>增加密码过期机制，过期后需要修改密码，否则可能会被禁用，或者进入沙箱模式；</p>
</li>
<li><p>增加密码过期机制，过期后需要修改密码，否则可能会被禁用，或者进入沙箱模式；</p>
</li>
<li><p>提供了更为简单SSL安全访问配置，并且默认连接就采用SSL的加密方式。<br>灵活性</p>
</li>
<li><p>MySQL数据库从5.7.8版本开始，也提供了对JSON的支持。</p>
</li>
<li><p>可以混合存储结构化数据和非结构化数据，同时拥有关系型数据库和非关系型数据库的优点</p>
</li>
<li><p>能够提供完整的事务支持</p>
</li>
<li><p>generated column是MySQL 5.7引入的新特性，所谓generated column，就是数据库中这一列由其他列计算而得<br>易用性</p>
</li>
<li><p>在MySQL 5.7 之前，如果用户输入了错误的SQL语句，按下 ctrl+c ，虽然能够”结束”SQL语句的运行，但是，也会退出当前会话，MySQL 5.7对这一违反直觉的地方进行了改进，不再退出会话。</p>
</li>
<li><p>MySQL 5.7可以explain一个正在运行的SQL，这对于DBA分析运行时间较长的语句将会非常有用。</p>
</li>
<li><p>sys schema是MySQL 5.7.7中引入的一个系统库，包含了一系列视图、函数和存储过程， 该项目专注于MySQL的易用性。<br>例如：如何查看数据库中的冗余索引；如何获取未使用的索引；如何查看使用全表扫描的SQL语句。<br>可用性</p>
</li>
<li><p>在线设置 复制的过滤规则 不再需要重启MySQL，只需要停止SQLthread，修改完成以后，启动SQLthread。</p>
</li>
<li><p>在线修改buffer pool的大小。</p>
</li>
<li><p>Online DDL MySQL 5.7支持重命名索引和修改varchar的大小，这两项操作在之前的版本中，都需要重建索引或表。</p>
</li>
<li><p>在线开启GTID ，在之前的版本中，由于不支持在线开启GTID，用户如果希望将低版本的数据库升级到支持GTID的数据库版本，需要先关闭数据库，再以GTID模式启动，所以导致升级起来特别麻烦。<br>性能</p>
</li>
<li><p>临时表的性能改进。</p>
<p>  临时表只在当前会话中可见<br>  临时表的生命周期是当前连接（MySQL宕机或重启，则当前连接结束）</p>
</li>
<li><p>只读事务性能改进。</p>
<p>  MySQL 5.7通过 避免为只读事务分配事务ID ，不为只读事务分配回滚段，减少锁竞争等多种方式，优化了只读事务的开销，提高了数据库的整体性能。</p>
</li>
<li><p>加速连接处理。</p>
<p>  在MySQL 5.7之前，变量的初始化操作（THD、VIO）都是在连接接收线程里面完成的，现在将这些工作下发给工作线程，以减少连接接收线程的工作量，提高连接的处理速度。这个优化对那些频繁建立短连接的应用，将会非常有用。</p>
</li>
<li><p>复制性能的改进 （支持多线程复制（Multi-Threaded Slaves, 简称MTS）</p>
<p>  MySQL的默认配置是库级别的并行复制，为了充分发挥MySQL 5.7的并行复制的功能，我们需要将slave-parallel-type配置成LOGICAL_CLOCK。</p>
</li>
<li><p>支持多源复制（Multi-source replication）</p>
</li>
<li><p>严格性改变</p>
</li>
<li><p>默认启用 STRICT_TRANS_TABLES 模式。</p>
</li>
<li><p>对 ONLY_FULL_GROUP_BY 模式实现了更复杂的特性支持，并且也被默认启用。</p>
</li>
<li><p>其他被默认启用的sql mode还有 NO_ENGINE_SUBSTITUTION。</p>
</li>
<li><p>默认参数的改变</p>
</li>
<li><p>默认binlog格式调整为ROW格式</p>
</li>
<li><p>默认binlog错误后的操作调整为ABORT_SERVER</p>
<p>  在先前的选项下（binlog_error_action=IGNORE_ERROR），如果一个错误发生，导致无法写入binlog，mysql-server会在错误日志中记录错误并强制关闭binlog功能。这会使mysql-server在不记录binlog的模式下继续运行，导致从库无法继续获取到主库的binlog。</p>
</li>
<li><p>默认开启mysql崩溃时的binlog安全。</p>
</li>
<li><p>默认调低slave_net_timeout。</p>
</li>
<li><p>安装不同</p>
</li>
<li><p>mysql_install_db已经不再推荐使用了，建议改成mysqld –initialize 完成实例初始化。如果 datadir 指向的目标目录下已经有数据文件，则会有[ERROR] Aborting；</p>
</li>
</ul>
<p>在初始化时如果加上 –initial-insecure，则会创建空密码的 root@localhost 账号，否则会创建带密码的 root@localhost 账号，密码直接写在 log-error 日志文件中；新用户登入后需要立刻修改密码，否则无法继续后续的工作。</p>
<h3 id="版本8-0（2018"><a href="#版本8-0（2018" class="headerlink" title="版本8.0（2018"></a>版本8.0（2018</h3><p>作为版本号突飞猛进的一个版本，在MySQL 8.0中新增了如下的特性：<br><a href="https://learnku.com/laravel/t/10243/mysql-8-new-features-required-by-10-developers" target="_blank">10 个开发者必知的 MySQL 8.0 新功能</a></p>
<ul>
<li>用户角色</li>
</ul>
<p>8.0中将会增强账号管理的功能，提供角色这一概念，即能组合权限，批量授权给某一用户。</p>
<ul>
<li><p>增强的InnoDB<br>自增id会写入到redo log中，这一改动使得数据库重启之后的自增值能恢复到重启前的状态<br>增加了死锁检测开关innodb_deadlock_detect，可以在高并发系统中动态调整这一特性，提升性能</p>
</li>
<li><p>增强的JSON操作<br>增加了-&gt;&gt;操作符，使用这一操作符等同于对JSON_EXTRACT的结果进行JSON_UNQUOTE操作，简化了SQL语句<br>增加了按JSON数据组织返回数据操作的两个方法：JSON_ARRAYAGG与JSON_OBJECTAGG。JSON_ARRAYAGG将某列的值按照一个JSON数据返回，而JSON_OBJECTAGG将列A作为键，列B作为值，返回一个JSON对象格式的数据</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MariaDB 与MySQL</title>
    <url>/2020/11/14/database/mariadb-mysql/</url>
    <content><![CDATA[<blockquote>
<p>MariaDB是MySQL关系数据库管理系统的一个复刻，由社区开发，有商业支持，旨在继续保持在GNU GPL下开源。MariaDB的开发是由MySQL的一些原始开发者领导的，他们担心甲骨文公司收购MySQL后会有一些隐患。</p>
</blockquote>
<p>MariaDB打算保持与MySQL的高度兼容性，确保具有库二进制奇偶校验的直接替换功能，以及与MySQL <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3" title="应用程序接口">API</a>和命令的精确匹配。 MariaDB自带了一个新的&lt;a href=”<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&amp;action=edit&amp;redlink=1&quot;">https://zh.wikipedia.org/w/index.php?title=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&amp;action=edit&amp;redlink=1&quot;</a> original-title&quot;存储引擎（页面不存在）”&gt;存储引擎</a><a href="https://zh.wikipedia.org/w/index.php?title=Aria_(storage_engine)&amp;action=edit&amp;redlink=1" title="Aria (storage engine)（页面不存在）">Aria</a>，它可以替代<a href="https://zh.wikipedia.org/wiki/MyISAM" title="MyISAM">MyISAM</a>，成为默认的事务和非事务引擎。<sup id="cite_ref-7"><a href="https://zh.wikipedia.org/wiki/MariaDB#cite_note-7">[7]</a></sup> 它最初使用<a href="https://zh.wikipedia.org/w/index.php?title=XtraDB&amp;action=edit&amp;redlink=1" original-title="XtraDB（页面不存在）">XtraDB</a>作为默认存储引擎， 并从10.2版本切换回<a href="https://zh.wikipedia.org/wiki/InnoDB" title="InnoDB">InnoDB</a>。</p>
<p>MariaDB直到5.5版本，均依照MySQL的版本。因此，使用MariaDB5.5的人会从MySQL 5.5中了解到MariaDB的所有功能。<br>从2012年11月12日起发布的10.0.0版开始，不再依照MySQL的版号。10.0.x版以5.5版为基础，加上移植自MySQL 5.6版的功能和自行开发的新功能。<table><tbody><tr><th>版本</th><th>原始发布日期</th><th>最新版本</th><th>发布日期</th><th>状态</th></tr><tr><td title="旧版本，不再支持"><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.1</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2009年10月29日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.1.67</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2013年1月30日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">Stable (GA)</span></td></tr><tr><td title="旧版本，不再支持"><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.2</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2010年4月10日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.2.14</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2013年1月30日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">Stable (GA)</span></td></tr><tr><td title="旧版本，不再支持"><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.3</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2011年7月26日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">5.3.12</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">2013年1月30日</span></td><td><span style="background-color: rgb(255, 255, 255); color: rgb(249, 150, 59);">Stable (GA)</span></td></tr><tr><td title="旧版本，仍被支持">5.5</td><td>2012年2月25日</td><td>5.5.65</td><td>2019年7月31日</td><td>Stable (GA)</td></tr><tr><td title="旧版本，仍被支持">10.0</td><td>2012年11月12日</td><td>10.0.38</td><td>2019年1月31日</td><td>Stable (GA)</td></tr><tr><td title="旧版本，仍被支持">10.1</td><td>2014年6月30日</td><td>10.1.41</td><td>2019年7月31日</td><td>Stable (GA)</td></tr><tr><td title="旧版本，仍被支持">10.2</td><td>2016年4月18日</td><td>10.2.27</td><td>2019年9月11日</td><td>Stable (GA)</td></tr><tr><td title="旧版本，仍被支持">10.3</td><td>2017年4月16日</td><td>10.3.18</td><td>2019年9月11日</td><td>Stable (GA)</td></tr><tr><td title="当前版本"><b style="color: rgb(139, 170, 74);">10.4</b></td><td><span style="color: rgb(139, 170, 74);">2018年11月9日</span></td><td><span style="color: rgb(139, 170, 74);">10.4.8</span></td><td><span style="color: rgb(139, 170, 74);">2019年9月11日</span></td><td><span style="color: rgb(139, 170, 74);">Stable (GA)</span></td></tr><tr><td colspan="5"><small><div><b>格式：</b><span style="color: rgb(249, 150, 59); font-size: 14px;">旧版本</span></div><div><span title="旧版本，仍被支持">旧版本，仍被支持</span></div><div><span title="当前版本"><b>当前版本：</b></span><span style="color: rgb(139, 170, 74); font-size: 14px;">最新的预览版</span></div><div></div></small></td></tr></tbody></table></p>
<p>MariaDB都是MySQL的代码级量身定制的替代者，相应的版本可以直接替换（如MySQL 5.1 -&gt; <a href="https://mariadb.com/kb/en/what-is-mariadb-51/">MariaDB 5.1</a>， <a href="https://mariadb.com/kb/en/what-is-mariadb-52/">MariaDB 5.2</a> &amp; <a href="https://mariadb.com/kb/en/what-is-mariadb-53/">MariaDB 5.3</a>也是兼容的。MySQL 5.5将与兼容），具体是：<ul start="1"><li>数据及表的定义文件（.frm）在代码级兼容；</li><li>所有客户端的API、协议和结构都是相同的；</li><li>所有文件件名、二进制文件、路径、端口、套接字等……全都是一样的；</li><li>所有的MySQL与其他语言（PHP、Perl、Python、Java、.NET、MyODBC、Rub、MySQL C……）的连接文件无需任何改动，在MariaDB就可工作；<ul start="1"><li>但有些<a href="https://mariadb.com/kb/en/installation-issues-with-php5/">PHP5安装要点</a>你要知道（旧的PHP5客户端库兼容性检查程序存在bug）；</li></ul></li><li>mysql-client程序也可在MariaDB服务器上工作。</li></ul><br>　　意思也就是，在大多数情况下，你只要卸载MySQL后，<a href="https://mariadb.com/kb/en/getting-installing-and-upgrading-mariadb/">安装MariaDB</a>后就可工作（在使用相同的主版本（如5.1版）的情况下，不需任何数据文件的转换）</p>
]]></content>
  </entry>
  <entry>
    <title>数据库的备份、还原、导入及导出</title>
    <url>/2020/11/14/database/mongo-restore/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000006236494">mongodb 备份、还原、导入、导出简单操作</a></p>
<p>一般来说，进行整库导出导入时使用mongodump和mongorestore，这一对组合操作的数据是BSON格式，进行大量dump和restore时效率较高</p>
<p>进行单个集合导出导入时使用</p>
<ul>
<li><p><a href="https://docs.mongodb.com/manual/reference/program/mongoexport">mongoexport</a>（备份)</p>
</li>
<li><p><a href="https://docs.mongodb.com/manual/reference/program/mongoimport">mongoimport</a>（还原）</p>
</li>
</ul>
<p>这一对组合操作的数据是JSON格式，可读性较高。</p>
<h2 id="mongodump（备份"><a href="#mongodump（备份" class="headerlink" title="mongodump（备份)"></a>mongodump（备份)</h2><p>说明：</p>
<blockquote>
<p>mongodump是一个用于导出二进制数据库内容的实用工具，它导出的bson文档中只会包含着集合文档等信息，不包括索引信息（索引信息会单独导出），所以还原后，索引必须重建（这个不用担心，使用mongorestore会自动重建mongodump生成的索引信息）。3.4版本中添加了对只读视图的支持。</p>
</blockquote>
<p>参数：<br>| 命令      |全称         |    默认值        |参考释义   |<br>|  —-    |  —–      | ——-         | —–   |<br>|  —-    |  –help      | ——-         | 查看mongodump命令的使用帮助   |<br>|  —-    |  –version      | ——-         | 返回mongodump的版本号   |<br>|  -h    |  –host <hostname>&lt;:port&gt;      | localhost:27017         | 指定mongod要连接的主机名及端口号   |<br>|  —-    |  –port <port>      | 27017         | 指定MongoDB实例监听客户连接的TCP端口号   |<br>|  -u    |  –username      | ——-         | 指定用于向使用认证的MongoDB数据库认证的用户名，与–password和<br>–authenticationDatabase结合使用   |<br>|  -p    |  –password      | ——-         | 指定用于向使用认证的MongoDB数据库认证的密码。与–username和 –<br>authenticationDatabase选项结合使用。   |<br>|  -d    |  –db      | ——-         | 指定要备份的数据库。如果不指定，mongodump会将此实例中的所有数据库备份。   |<br>|  -c    |  –collection      | ——-         | 指定要备份的集合。如果不指定，则会将指定数据库或实例中的所有集合备份。|<br>|      |  –gzip     | ——-         | 3.2版本+，压缩输出，如果mongodump指定导出到目录，则该选项会将每个文件都压缩，并添加.gz后缀；如果mongodump指定导出到文档或标准输出流，则该选项会压缩到文档或输出流中|<br>|  -o    |  –out (path)      | ——-         | 指定导出数据的目录路径，如不指定，则mongodump默认将文件输出到dump所在的工作目录中。该选项不能和–archive一起使用   |</p>
<p>例子：<br>随便进一目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongodump -d mytest -c user -o  ./</span><br></pre></td></tr></table></figure>
<p>会在当前目录生成mytest文件夹，里面有两个文件：</p>
<ul>
<li>user.bson</li>
<li>user.metadata,json</li>
</ul>
<blockquote>
<p>整库备份：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongodump -d k-blog -o ./</span><br></pre></td></tr></table></figure>
<p>在备份完成后，系统自动在当前目录下建立一个k-blog目</p>
<h2 id="mongorestore（还原）"><a href="#mongorestore（还原）" class="headerlink" title="mongorestore（还原）"></a>mongorestore（还原）</h2><p>说明： </p>
<blockquote>
<p>mongorestore用来导入数据到MongoDB实例中，3.0.0版本以上支持通过标准输入流来导入数据。</p>
</blockquote>
<p>参数：<br>| 命令      |全称         |    默认值        |参考释义   |<br>|  —-    |  —–      | ——-         | —–   |<br>|  -d    |  –db (database)      | ——-         | 指定要还原的数据库。如果不指定，restore将会还原dump记录的所有数据库，并会覆盖现有数据库数据|<br>|  -c    |  –collection      | ——-         | 指定要还原的集合。如果不指定，mongorestore会从文件名中读取识别集合名称（如果有扩展名则会省略扩展名）   |<br>|  —-    |  –drop          | ——-         | 还原集合之前会先从目标数据库中删除集合，不会删除不在备份中的集合。   |<br>|  —-    |  –gzip      | ——-         | 3.2版本+，从压缩文件中还原  |<br>|  —-    |  (path)      | ——-         | 要还原的数据文件路径，该参数必须是mongorestore命令的最后一个参数   |<br>例子：</p>
<p>通过user.bson文件还原mytest数据库中的user集合，并在还原之前进行删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongorestore --drop -d k-blog -c user ./user.bson</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整库恢复：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongorestore  -d k-blog  ./</span><br></pre></td></tr></table></figure>
<h2 id="mongoexport（导出）及mongoimport（导入）"><a href="#mongoexport（导出）及mongoimport（导入）" class="headerlink" title="mongoexport（导出）及mongoimport（导入）"></a>mongoexport（导出）及mongoimport（导入）</h2><h2 id="mongoexport（导出）"><a href="#mongoexport（导出）" class="headerlink" title="mongoexport（导出）"></a>mongoexport（导出）</h2><p>参数<br>| 命令      |全称         |    默认值        |参考释义   |<br>|  —-    |  —–      | ——-         | —–   |<br>|  —-    |  –help      | ——-         | 查看mongoexport的使用帮助   |<br>|  —-    |  –version      | ——-         | 查看mongoexport的版本号   |<br>|  —-    |  –db &lt;database&gt;      | ——-         | 指定要在哪个数据库上运行该命令   |<br>|  —-    |  –collection &lt;collection&gt;      | ——-         | 指定要导出的集合   |<br>|  —-    |  –fields &lt;field1[,field2]&gt;      | ——-         | 指定导出时只导出一个或多个字段，导出多个时，需要使用逗号分隔;当字段中有空格时，需要用英文引号括起来。   |<br>|  —-    |  –query &lt;JSON&gt;      | ——-         | 提供查询文档作为导出数据源   |<br>|  —-    |  –type&lt;string&gt;      | ——-         | 指定要导出的文件类型，可选值：json，csv   |<br>|  -o    |  –out &lt;file&gt;      | ——-         | 指定要导出的文件路径（含文件名），如果不指定，则会导出为标准输出（例如stdout）   |<br>例子：<br>导出mytest数据库中的user集合到user.json文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongoexport -d mytest -c user -o ./user.json</span><br></pre></td></tr></table></figure>
<p>会在当前目录中生成json文件<div></p>
<h2 id="mongoimport（导入）"><a href="#mongoimport（导入）" class="headerlink" title="mongoimport（导入）"></a>mongoimport（导入）</h2><p>参数：<br>| 命令      |全称         |    默认值        |参考释义   |<br>|  —-    |  —–      | ——-         | —–   |<br>|  —-    |  –ignoreBlanks      | ——-         | 忽略要导入文件中的空字段，如果不指定该参数，则默认会读取空字段并创建   |<br>|  —-    |  –type &lt;json csv tsv&gt;  | json，csv，tsv   | 要导入的文件类型，另外支持tsv  |<br>|  —-    |  –headerline      | ——-         | 使用第一行作为字段名称   |<br>|  —-    |  –mode &lt;insert upsert merge&gt;      | insert（插入），upsert（替换数据库中的文档），merge（合并         | 指定导入过程中，如何应对数据库文档与导入文件中的文档匹配（默认会使用_id字段对比）的情况   |</p>
<p>例子：<br>从user.json文件导入到mytest数据库中的user集合，并在之前进行删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongoimport --drop -d mytest -c user --file ./user.json</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Mongoose Populate 基本使用</title>
    <url>/2020/11/14/database/mongoose-populate/</url>
    <content><![CDATA[<blockquote>
<p>在使用 mongoose 时，通过一个外键与另一张表建立关联</p>
</blockquote>
<p><a href="https://mongoosejs.com/docs/index.html" target="_blank">mongoose官网地址</a></p>
<h2 id="Mongoose-之-Population-使用"><a href="#Mongoose-之-Population-使用" class="headerlink" title="Mongoose 之 Population 使用"></a><a href="https://blog.csdn.net/Elliott_Yoho/article/details/53537147" target="_blank">Mongoose 之 Population 使用</a></h2><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Query.populate(path, [select], [model], [match], [options])</span><br></pre></td></tr></table></figure>
<ul>
<li><p>path  ： String或Object。</p>
<ul>
<li>String类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。</li>
<li>Object类型的时，就是把 populate 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。</li>
</ul>
</li>
<li><p>select：Object或String，可选，指定填充 document 中的哪些字段。</p>
<ul>
<li>Object类型的时，格式如: {name: 1, _id: 0}，为0表示不填充，为1时表示填充。</li>
<li>String类型的时，格式如: “name -_id”，用空格分隔字段，在字段名前加上-表示不填充。详细语法介绍 query-select</li>
</ul>
</li>
</ul>
<p>尝试中发现 select 默认会填充 _id。</p>
<ul>
<li><p>model: Model，可选，指定关联字段的 model，如果没有指定就会使用Schema的ref。</p>
</li>
<li><p>match: Object，可选，指定附加的查询条件。</p>
</li>
<li><p>options：Object，可选，指定附加的其他查询选项，如排序以及条数限制等等。</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>数据模型<br>创建三个Schema和Model。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line">mongoose.Promise = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/population&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span>,</span><br><span class="line">    posts: [&#123;</span><br><span class="line">        type: Schema.Types.ObjectId, </span><br><span class="line">        ref: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    comments: [&#123;</span><br><span class="line">        type: Schema.Types.ObjectId, </span><br><span class="line">        ref: <span class="string">&#x27;comment&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&#x27;user&#x27;</span>, userSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">    author: &#123;</span><br><span class="line">        type: Schema.Types.ObjectId, </span><br><span class="line">        ref: <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    comments: [&#123;</span><br><span class="line">        type: Schema.Types.ObjectId, </span><br><span class="line">        ref: <span class="string">&#x27;comment&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Post = mongoose.model(<span class="string">&#x27;post&#x27;</span>, postSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">        content: <span class="built_in">String</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            type: Schema.Types.ObjectId, </span><br><span class="line">            ref: <span class="string">&#x27;user&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> Comment = mongoose.model(<span class="string">&#x27;comment&#x27;</span>, commentSchema);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.User = User;</span><br><span class="line"><span class="built_in">exports</span>.Post = Post;</span><br><span class="line"><span class="built_in">exports</span>.Comment = Comment;</span><br></pre></td></tr></table></figure>
<p>在上述的例子中，创建了三个 Models:User，Post，Comment。</p>
<p>User 的属性 posts，对应是一个 ObjectId 的数组。ref表示关联Post(注意: 被关联的model的 type 必须是 ObjectId, Number, String, 和 Buffer 才有效)。</p>
<p>Post的属性 poster 和 comments 分别关联User和Comment。</p>
<p>Comment的属性 post 和 commenter 分别关联Post和User。</p>
<p>三个 Models 的关系:一个 user–has many–&gt;post。一个 post–has one–&gt;user，has many–&gt;comment。一个 comment–has one–&gt;post 和 user。</p>
<blockquote>
<p>注: ref 对应是在connection中注册过的model。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&#x27;user&#x27;</span>, userSchema);</span><br><span class="line">...</span><br><span class="line">author: &#123;<span class="attr">type</span>: Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">&#x27;user&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 这里的 ref: &#x27;user&#x27; 是第一行的 mongoose.model(&#x27;user&#x27;, userSchema) 第一个参数。</span></span><br></pre></td></tr></table></figure>


<p>填充User的posts字段:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//填充所有 users 的 posts</span></span><br><span class="line">User.find()</span><br><span class="line">    .populate(<span class="string">&#x27;posts&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="literal">null</span>, &#123;<span class="attr">sort</span>: &#123; <span class="attr">title</span>: -<span class="number">1</span> &#125;&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">            onsole.log(docs[<span class="number">0</span>].posts[<span class="number">0</span>].title); <span class="comment">// post-by-aikin</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充 user &#x27;luajin&#x27;的 posts</span></span><br><span class="line">User.findOne(&#123;<span class="attr">name</span>: <span class="string">&#x27;luajin&#x27;</span>&#125;)</span><br><span class="line">    .populate(&#123;<span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>, <span class="attr">select</span>: &#123; <span class="attr">title</span>: <span class="number">1</span> &#125;, <span class="attr">options</span>: &#123;<span class="attr">sort</span>: &#123; <span class="attr">title</span>: -<span class="number">1</span> &#125;&#125;&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(doc.posts[<span class="number">0</span>].title);  <span class="comment">// post-by-luajin</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充所有 users 的 posts</span></span><br><span class="line">User.find()</span><br><span class="line">    .populate(<span class="string">&#x27;posts&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="literal">null</span>, &#123;<span class="attr">sort</span>: &#123; <span class="attr">title</span>: -<span class="number">1</span> &#125;&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs[<span class="number">0</span>].posts[<span class="number">0</span>].title); <span class="comment">// post-by-aikin</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充 user &#x27;luajin&#x27;的 posts</span></span><br><span class="line">User.findOne(&#123;<span class="attr">name</span>: <span class="string">&#x27;luajin&#x27;</span>&#125;)</span><br><span class="line">    .populate(&#123;<span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>, <span class="attr">select</span>: &#123; <span class="attr">title</span>: <span class="number">1</span> &#125;, <span class="attr">options</span>: &#123;<span class="attr">sort</span>: &#123; <span class="attr">title</span>: -<span class="number">1</span> &#125;&#125;&#125;)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(doc.posts[<span class="number">0</span>].title);  <span class="comment">// post-by-luajin</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="填充多个字段"><a href="#填充多个字段" class="headerlink" title="填充多个字段"></a>填充多个字段</h2><p>假如，我们要填充 Post 中的 author 和 comments，且填充 author 的 name 和 age，还有 comments 的 content； 不填充 author 和 comments 的 _id。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若是用字符串填写，select 同时作用于两个字段，即 author 和 comments 都会填充 name age content，若该字段没有这些数据，则不填充。</span></span><br><span class="line"></span><br><span class="line">Post.findOne(&#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;).populate(<span class="string">&#x27;author comments&#x27;</span>, <span class="string">&#x27;name age content -_id&#x27;</span>).exec()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组形式可以单独对某一字段用 select 选择要填充的数据。</span></span><br><span class="line">Post.findOne(&#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;).populate([</span><br><span class="line">    &#123;</span><br><span class="line">    path: <span class="string">&#x27;author&#x27;</span>, <span class="attr">select</span>: <span class="string">&#x27;name age -_id&#x27;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">    path: <span class="string">&#x27;comments&#x27;</span>, <span class="attr">select</span>: <span class="string">&#x27;content -_id&#x27;</span></span><br><span class="line">&#125;]).exec()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(post);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">&#123; </span><br><span class="line">    _id: <span class="number">584</span>a030733604a156a4f6600,</span><br><span class="line">    author: &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;,</span><br><span class="line">    title: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    content: <span class="string">&#x27;wakaka&#x27;</span>,</span><br><span class="line">    __v: <span class="number">1</span>,</span><br><span class="line">    comments: [ &#123; <span class="attr">content</span>: <span class="string">&#x27;walala&#x27;</span> &#125; ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CSS中的BFC</title>
    <url>/2020/11/14/css/bfc/</url>
    <content><![CDATA[<blockquote>
<p>BFC（Block Formatting Context）直译为“块级格式化范围 </p>
</blockquote>
<p>文档流其实分为定位流、浮动流和普通流三种。而<code>普通流其实就是指BFC中的FC</code>。<br><code>FC``是页面中的一块渲染区域</code>，有一套渲染规则，决定了其<code>子元素如何布局，以及和其他元素之间的关系和作用。</code>常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文</p>
<h2 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h2><p>满足下列条件之一就可触发BFC</p>
<ul>
<li>根元素，即HTML元素</li>
<li>float的值不为none</li>
<li>overflow的值不为visible</li>
<li>display的值为inline-block、table-cell、table-caption</li>
<li>position的值为absolute或fixed 　</li>
</ul>
<h2 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h2><p>1.内部的Box会在垂直方向，一个接一个地放置。<br>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>4.BFC的区域不会与float box重叠。<br>5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>6.计算BFC的高度时，浮动元素也参与计算</p>
<h2 id="BFC有哪些作用："><a href="#BFC有哪些作用：" class="headerlink" title="BFC有哪些作用："></a>BFC有哪些作用：</h2><ul>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
<li>可以包含浮动元素——清除内部浮动</li>
<li>分属于不同的BFC时可以阻止margin重叠</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CSS盒模型以及外边距合并</title>
    <url>/2020/11/14/css/css-box/</url>
    <content><![CDATA[<p>盒模型的四要素是border、margin、padding、content</p>
<p>盒模型基本概念<br>所有HTML元素，在页面的呈现过程中，都遵循CSS制定的盒模型。盒模型的几个要素是 border 、 margin 、 padding 、 content ，如下图，</p>
<p><img src="/img/css-box.jpg" alt="alt &#39;css box&#39;"></p>
<p>盒模型</p>
<ul>
<li>content：真正包含元素内容的区域</li>
<li>padding(内边距)：内容和边框之间的一段间距，属于标签内部</li>
<li>border(边框)：包含边框的区域，扩展了内边距区域。它位于边框边界内部。大小为border-box宽和border-box高</li>
<li>margin(外边距)：该标签和其他标签之间的间距，设置此内容，不会影响标签的大小</li>
</ul>
<p>当一个元素既有margin,又有padding,还有边框时，在普通流中所占的空间就是这些值的总和。</p>
<p>即横向空间为：marginLeft + borderLeftWidth + paddingLeft + width + paddingRight + borderRightWidth + marginRight，纵向的同理。</p>
<p>盒模型的分类及不同盒模型之间的区别<br>盒模型分为*<strong>IE盒模型**<em>和</em></strong>W3C标准***的盒模型。</p>
<blockquote>
<p>它们之间的区别在于IE盒模型和W3C标准盒模型计算高度和宽度的方式不同。具体不同表现在以下方面：</p>
</blockquote>
<p>W3C标准盒模型（高度的计算类似）：</p>
<p>一个元素的宽度= content </p>
<p>盒子的总宽度= margin-left + border-left + padding-left + width + padding-right + border-right + margin-right </p>
<p><img src="/img/css-box-standard.jpg" alt="alt &#39;W3C标准模型&#39;"></p>
<p>IE怪异盒模型（高度的计算类似）：</p>
<p>一个元素的宽度= content + padding + border<br>盒子的总宽度= margin-left + width + margin-right </p>
<p><img src="/img/css-box-ie.jpg" alt="alt &#39;IE盒子模型&#39;"></p>
<p>如何通过CSS设置IE盒模型和W3C标准盒模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//W3C标准盒模型（浏览器默认）</span><br><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:content-box</span>;</span><br><span class="line"></span><br><span class="line">//IE怪异盒模型</span><br><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:border-box</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>


<p> box-sizing 是CSS3的新属性，为了避免在不同的浏览器中表现不同的情况产生，我们可以这样使用<br> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Element</span> &#123;</span><br><span class="line">    <span class="attribute">-moz-box-sizing</span>: border-box;  </span><br><span class="line">    <span class="attribute">-webkit-box-sizing</span>: border-box; </span><br><span class="line">    <span class="attribute">-o-box-sizing</span>: border-box; </span><br><span class="line">    <span class="attribute">-ms-box-sizing</span>: border-box; </span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br>用盒模型解释边距重叠<br>边距重叠也称为外边距合并，指的是块的顶部外边距和底部外边距有时被组合（折叠）为单个外边距，其大小时组合到其中的最大的外边距。<br>发生边距重叠的基本情况有三种：</p>
<ul>
<li>1、相邻的兄弟姐妹元素</li>
<li>2、块级元素与其第一个或最后一个子元素</li>
<li>3、空块元素</li>
</ul>
<h2 id="阻止合并方法"><a href="#阻止合并方法" class="headerlink" title="阻止合并方法"></a>阻止合并方法</h2><p>这部分将讲解不会发生外边距合并的情况</p>
<blockquote>
<p>1.通用方法</p>
</blockquote>
<ul>
<li>处于静态流元素会发生合并，所以 float 和 position:absolute 都不会发生合并<br>设置为 inline-block ，也不会发生合并</li>
</ul>
<blockquote>
<p>2.针对于父元素和子元素情况不合并方法<br>以下都不会发生合并</p>
</blockquote>
<ul>
<li>设置了清除浮动属性<br>因为 margin 需要直接接触才能合并，所以父元素或子元素中有 border 或 padding ，或者二者之间有元素</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>opacity、visibility、display</title>
    <url>/2020/11/14/css/hide/</url>
    <content><![CDATA[<p><a href="http://www.w3school.com.cn/cssref/pr_opacity.asp" rel="nofollow noreferrer" target="_blank">opacity </a>用来设置透明度 </p>
<p><a href="http://www.w3school.com.cn/css/pr_class_display.asp" rel="nofollow noreferrer" target="_blank">display</a> 定义建立布局时元素生成的显示框类型 </p>
<p><a href="http://www.w3school.com.cn/cssref/pr_class_visibility.asp" rel="nofollow noreferrer" target="_blank">visibility</a> 用来设置元素是否可见。 </p>
<p>opacity、visibility、display 这三个属性分别取值 0、hidden、none 都能使元素在页面上看不见，但是他们在方方面面都还是有区别的。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><blockquote>
<p>使用 opacity 和 display 属性时，父元素对子元素的影响很明显，子元素设置的 opacity 和 display 属性是不起作用的，显示的效果和父元素一样，而使用 visibility 属性时，子元素如果设置为 visibility:visible; 并没有受父元素的影响，可以继续显示出来。</p>
</blockquote>
<blockquote>
<p><code>回流</code>当页面中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(也有人会把回流叫做是重布局或者重排)。</p>
</blockquote>
<p>每个页面至少需要一次回流，就是在页面第一次加载的时候。dispaly 属性会产生回流，而 opacity 和 visibility 属性不会产生回流。</p>
<blockquote>
<p><code>重绘</code>当页面中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的时候，比如background-color。则称为重绘。</p>
</blockquote>
<p>dispaly 和 visibility 属性会产生重绘，而 opacity 属性不一定会产生重绘。</p>
<p><a href="https://segmentfault.com/q/1010000008983727" style="">元素提升为合成层后，transform 和 opacity 不会触发 repaint，如果不是合成层，则其依然会触发 repaint。</a> </p>
<p><a href="https://segmentfault.com/q/1010000008983727" target="_blank" style="">在 Blink 和 WebKit 内核的浏览器中，对于应用了 transition 或者 animation 的 opacity 元素，浏览器会将渲染层提升为合成层。</p>
<p></a><a href="https://segmentfault.com/q/1010000008983727" style="">也可以使用 translateZ(0) 或者 translate3d(0,0,0) 来人为地强制性地创建一个合成层。</a></p>
<table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><th> </th><th> opacity: 0</th><th>visibility: hidden </th><th>display: none </th></tr><tr><td> 是否占据页面空间</td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes</td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes</td><td>no </td></tr><tr><td> 对子元素是否有影响   </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td>no </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td></tr><tr><td> 自身绑定的事件是否继续触发</td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td>no </td><td>no </td></tr><tr><td> 是否影响被遮挡的元素触发事件</td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td>no </td><td>no </td></tr><tr><td> 属性值改变是否产生回流</td><td>no </td><td>no </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td></tr><tr><td> 属性值改变是否产生重绘</td><td><span style="color: rgb(194, 79, 74); font-size: large;">不一定 </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td></tr><tr><td> 是否支持transition</td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td><span style="color: rgb(249, 150, 59); font-size: large;">yes </td><td>no </td></tr></tbody></table>


]]></content>
  </entry>
  <entry>
    <title>Flex 布局教程</title>
    <url>/2020/11/14/css/flex/</url>
    <content><![CDATA[<h2 id="6个属性设置在容器上"><a href="#6个属性设置在容器上" class="headerlink" title="6个属性设置在容器上:"></a>6个属性设置在容器上:</h2><ul>
<li>flex-direction: row （默认 row |row-reverse |column |column-reverse;</li>
<li>flex-wrap nowrap （默认 nowrap | wrap | wrap-reverse; </li>
<li>flex-flow: <code>前两个只和，默认row nowrap`` &lt;flex-direction&gt; || &lt;flex-wrap&gt;</code></li>
<li>justify-content flex-start （默认 flex-start | flex-end |center\nspace-between | space-around; </li>
<li>align-items stretch （默认 flex-start |flex-end |center\nbaseline | stretch; </li>
<li>align-content stretch （默认 flex-start |flex-end |center\nspace-between |space-around |stretch; </li>
</ul>
<h2 id="6个属性设置在项目上。"><a href="#6个属性设置在项目上。" class="headerlink" title="6个属性设置在项目上。"></a>6个属性设置在项目上。</h2><ul>
<li>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>flex-grow: <code>&lt;number&gt;</code>/* default 0 */ </li>
<li>flex-shrink: <code>&lt;number&gt;</code>/* default 1 */ </li>
<li>flex-base: <code>&lt;length&gt;</code> | auto; /* default auto */ </li>
<li>flex: <code>[&lt;&#39;flex-grow&#39;&gt;&lt;&#39;flex-shrink&#39;&gt;?||&lt;&#39;flex-basis&#39;&gt;] </code><br>性有两个快捷值： auto  ( 1 1 auto ) 和 none ( 0 0 auto )。</li>
<li>align-self: flex-to | flex-start | flex-end |center | baseline | stretch; </li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank">图文教程请点击这</a></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2021/11/27/dm-render/render/</url>
    <content><![CDATA[<p>一：</p>
<!-- ## [性能指标制定](http://bi.bilibili.co/page/overview)

![](/hide/bi.png) -->


<h2 id="计算机的核心-CPU和GPU"><a href="#计算机的核心-CPU和GPU" class="headerlink" title="计算机的核心 - CPU和GPU"></a><a href="https://www.bilibili.com/video/BV13y4y1z7HP">计算机的核心 - CPU和GPU</a></h2><p><img src="/hide/cpu.png"><br><img src="/hide/gpu.png"></p>
<blockquote>
<p>绿色的是计算单元，橙红色的是存储单元，橙黄色的是控制单元。</p>
</blockquote>
<blockquote>
<p>CPU是通用计算，而GPU是专用计算</p>
</blockquote>
<h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><blockquote>
<p>由GPU、显存、电路板，还有BIOS固件组成<br>1: 独立显卡主要由GPU、显存和接口电路构成<br>2: 集成显卡没有独立显存而是使用主板上的内存</p>
</blockquote>
<blockquote>
<p>DRAM 存储器（cpu/gpu 与存储器是两个不同的芯片）<br>1：主存储器————内存<br>2：辅助存储器</p>
</blockquote>
<blockquote>
<p>速度来讲，就是：Register &gt; Cache &gt; 内存 &gt; 硬盘。越上层，速度就越快、价格越高、容量越低。</p>
</blockquote>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><blockquote>
<p>中央处理器（Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。它的功能主要是解释计算机指令以及处理计算机软件中的数据</p>
</blockquote>
<p>串行地一件接着一件处理交给它的任务<br>在CPU上快速在多个任务间切换，对于使用者来说，就像并发（Concurrent）地执行了多个任务一样</p>
<p><img src="/hide/cpu0.jpeg"><br><img src="/hide/cpu1.jpeg"></p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>NVIDIA公司在1999年发布 Geforce256图形处理芯片时首先提出GPU的概念。从此 NVIDIA显卡的芯就用GPU来称呼。GPU使显卡减少了对CPU的依赖，并进行部分原本CPU的工作，尤其是在3D图形处理时。</p>
<blockquote>
<p>GPU（Graphics Processing Unit）是图形处理器又称显示核心、视觉处理器、显示芯片，是一种 专门在个人电脑、工作站、游戏机和一些移动设备上运行图像运算工作的微处理器。</p>
</blockquote>
<p>GPGPU（General-Purpose computing on Graphics Processing Units）即图形处理单元上的通 用计算，利用处理图形任务的图形处理器来计算原本由中央处理器（CPU）处理的通用计算任务。</p>
<h3 id="英伟达Turing-GPU架构"><a href="#英伟达Turing-GPU架构" class="headerlink" title="英伟达Turing GPU架构"></a>英伟达Turing GPU架构</h3><p>TU102 GPU包含6个图像处理集群（GPC）、36个纹理处理集群（TPC）和72个流式多元处理器（SM）。</p>
<p>每个GPC均包含一个专用的光栅化引擎和6个TPC，且每个TPC均包含两个SM。</p>
<p>每个SM包含64个CUDA核心、8个Tensor核心、1个256KB寄存器堆、4个纹理单元以及96KB的L1或共享内存，且我们可根据计算或图形工作负载将这些内存设置为不同容量。每个SM中的全新RT核心处理引擎负责执行光线追踪加速。<br><img src="/hide/tur.webp"><br><img src="/hide/gpu0.png"></p>
<h3 id="GPU-图形渲染流水线"><a href="#GPU-图形渲染流水线" class="headerlink" title="GPU 图形渲染流水线"></a>GPU 图形渲染流水线</h3><p><img src="/hide/gpu1.png"></p>
<blockquote>
<p>1: 顶点着色器（Vertex Shader）<br>该阶段的输入是 顶点数据（Vertex Data） 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。</p>
</blockquote>
<blockquote>
<p>2: 形状装配（Shape Assembly），又称 图元装配<br>该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。图元（Primitive） 用于表示如何渲染顶点数据，如：点、线、三角形。</p>
</blockquote>
<blockquote>
<p>3: 几何着色器（Geometry Shader）<br>该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
</blockquote>
<blockquote>
<p>4: 光栅化（Rasterization）<br>该阶段会把图元映射为最终屏幕上相应的像素，生成片段。片段（Fragment） 是渲染一个像素所需要的所有数据。</p>
</blockquote>
<blockquote>
<p>5: 片段着色器（Fragment Shader）<br>该阶段首先会对输入的片段进行 裁切（Clipping）。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p>
</blockquote>
<blockquote>
<p>6: 测试与混合（Tests and Blending）<br>该阶段会检测片段的对应的深度值（z 坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查 alpha 值（ alpha 值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
</blockquote>
<blockquote>
<p>GPU 采用如下公式进行计算，并得出最后的颜色。</p>
</blockquote>
<p>最终的颜色值就是 S（上面像素） 的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素） 颜色的透明度）。</p>
<p>R = S + D * (1 - Sa)</p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><blockquote>
<p>进程（Process）<br>系统进行资源分配和调度的基本单位，是操作系统结构的继承</p>
</blockquote>
<blockquote>
<p>线程（Thread）<br>进程中的实际运作单位，是程序执行的最小单位</p>
</blockquote>
<h3 id="以基于Blink内核的Chromium浏览器为例"><a href="#以基于Blink内核的Chromium浏览器为例" class="headerlink" title="以基于Blink内核的Chromium浏览器为例"></a>以基于Blink内核的Chromium浏览器为例</h3><p><img src="/hide/bro.jpg"></p>
<blockquote>
<p>Browser进程：这是浏览器的主进程，负责浏览器界面的显示、各个页面的管理。每次我们打开浏览器，都会启动一个Browser进程，结束该进程就会关闭我们的浏览器。</p>
</blockquote>
<p>浏览器进程有很多负责不同工作的线程（worker thread）</p>
<p>1: 其中包括绘制浏览器顶部按钮和导航栏输入框等组件的UI线程（UI thread）</p>
<p>2: 管理网络请求的网络线程（network thread）</p>
<p>3: 控制文件读写的存储线程（storage thread）等。</p>
<p>当在导航栏里面输入一个URL的时候，其实就是UI线程在处理你的输入。<br>1： UI线程（UI thread）首先会询问： 输入的字符串是一些搜索的关键词（search query）还是一个URL地址<br><img src="/hide/bro2.jpg"></p>
<p>2： UI线程会叫网络线程（network thread）初始化一个网络请求来获取站点的内容</p>
<p>3：网络线程在收到HTTP响应的主体（payload）流（stream）时，在必要的情况下它会先检查一下流的前几个字节以确定响应主体的具体媒体类型（MIME Type）。响应主体的媒体类型一般可以通过HTTP头部的Content-Type来确定，不过Content-Type有时候会缺失或者是错误的，这种情况下浏览器就要进行MIME类型嗅探来确定响应类型了。MIME类型嗅探并不是一件容易的事情，你可以从Chrome的源代码的注释来了解不同浏览器是如何根据不同的Content-Type来判断出主体具体是属于哪个媒体类型的。</p>
<p>如果响应的主体是一个HTML文件，浏览器会将获取的响应数据交给渲染进程（renderer process）来进行下一步的工作。如果拿到的响应数据是一个压缩文件（zip file）或者其他类型的文件，响应数据就会交给下载管理器（download manager）来处理。</p>
<p>网络线程在把内容交给渲染进程之前还会对内容做SafeBrowsing检查。如果请求的域名或者响应的内容和某个已知的病毒网站相匹配，网络线程会给用户展示一个警告的页面。除此之外，网络线程还会做CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。</p>
<p>4：寻找一个渲染进程（renderer process）</p>
<p>在网络线程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它就会告诉UI线程所有的数据都已经被准备好了。UI线程在收到网络线程的确认后会为这个网站寻找一个渲染进程（renderer process）来渲染界面。</p>
<blockquote>
<p>在第二步中当UI线程发送URL链接给网络线程后，它其实已经知晓它们要被导航到哪个站点了，所以在网络线程干活的时候，UI线程会主动地为这个网络请求启动一个渲染线程</p>
</blockquote>
<p><img src="/hide/bro5.jpg"></p>
<p>5: 提交（commit）导航<br>数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）.除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。</p>
<p>到了这个时候，导航栏会被更新，安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息。当前tab的会话历史（session history）也会被更新</p>
<p><img src="/hide/bro4.jpg"></p>
<p>6: 初始加载完成（Initial load complete）<br>当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。我会在后面的文章中讲述渲染进程渲染页面的具体细节。一旦渲染进程“完成”（finished）渲染，它会通过IPC告知浏览器进程（注意这发生在页面上所有帧（frames）的onload事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后UI线程就会停止导航栏上旋转的圈圈。</p>
<p><img src="/hide/bro3.jpg"></p>
<blockquote>
<p>Renderer进程：这是网页的渲染进程，负责页面的渲染工作，一般来说，一个页面都会对应一个Renderer进程，不过也有例外。</p>
</blockquote>
<blockquote>
<p>GPU进程：如果页面启动了硬件加速，浏览器就会开启一个GPU进程，但是最多只能有一个，当且仅当GPU硬件加速打开的时候才会被创建。<br>负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<p><img src="/hide/bro1.jpg"></p>
<h3 id="浏览器渲染的几个名词"><a href="#浏览器渲染的几个名词" class="headerlink" title="浏览器渲染的几个名词"></a><a href="https://juejin.cn/post/6844903959425974280">浏览器渲染的几个名词</a></h3><p>在概念上有四种并行树结构，它们的渲染目的略有不同：</p>
<blockquote>
<p>1: DOM树，这是我们的基本模型</p>
</blockquote>
<blockquote>
<p>2: RenderObject树，它与DOM树的可见节点有1:1的映射。RenderObjects知道如何绘制相应的DOM节点。</p>
</blockquote>
<blockquote>
<p>3: RenderLayer树，由映射到RenderObject树上RenderObject的RenderLayer组成。映射是多对一的，因为每个RenderObject要么与自己的RenderLayer关联，要么与拥有RenderLayer的第一个祖先的RenderLayer关联。RenderLayer树保留层之间的z顺序。</p>
</blockquote>
<blockquote>
<p>4: GraphicsLayer树，将GraphicsLayer映射为一对多renderlayer</p>
</blockquote>
<p><img src="/hide/tree.png"></p>
<blockquote>
<p>注： webkit 内核里面称为 RenderObject、RenderLayer<br>     Blink 里面称为 LayoutObject、PaintLayer</p>
</blockquote>
<h4 id="布局对象（LayoutObject）"><a href="#布局对象（LayoutObject）" class="headerlink" title="布局对象（LayoutObject）"></a>布局对象（LayoutObject）</h4><blockquote>
<p>一个 DOM 节点对应了一个布局对象</p>
</blockquote>
<h4 id="绘制层（PaintLayer）"><a href="#绘制层（PaintLayer）" class="headerlink" title="绘制层（PaintLayer）"></a>绘制层（PaintLayer）</h4><blockquote>
<p>根据层叠上下文，不同坐标空间的的布局对象将形成多个渲染层，以体现它们的层叠关系，对于满足形成层叠上下文条件的布局对象，浏览器会自动为其创建新的渲染层</p>
</blockquote>
<p>1：DOM树的Document节点对应的RenderView节点<br>2：DOM树中Document节点的子女节点，也就是HTML节点对应的RenderBlock节点<br>3：显式指定CSS位置的节点（position为absolute或者fixed）<br>4：具有透明效果的节点<br>5：具有CSS 3D属性的节点<br>6：使用Canvas元素或者Video元素的节点</p>
<h4 id="图形层（GraphicsLayer）"><a href="#图形层（GraphicsLayer）" class="headerlink" title="图形层（GraphicsLayer）"></a>图形层（GraphicsLayer）</h4><blockquote>
<p>GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图</p>
</blockquote>
<p>每个RenderLayer要么有自己的GraphicsLayer（如果是合成层），要么使用它的第一个祖先的GraphicsLayer。这类似于RenderObject与RenderLayers的关系。</p>
<p>每个GraphicsLayer都有一个GraphicsContext供相关的renderlayer绘制。在随后的合成过程中，合成器最终负责将GraphicsContexts的位图输出合并成最终的屏幕图像。</p>
<h4 id="合成层（CompositingLayer）"><a href="#合成层（CompositingLayer）" class="headerlink" title="合成层（CompositingLayer）"></a>合成层（CompositingLayer）</h4><blockquote>
<p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个</p>
</blockquote>
<h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>webkit渲染引擎流程<br><img src="/hide/webkit.png"></p>
<h4 id="Parse-HTML"><a href="#Parse-HTML" class="headerlink" title="Parse HTML"></a>Parse HTML</h4><p>1: DOM树的建立<br><img src="/hide/html.jpg"><br>2: CSSOM树的建立<br><img src="/hide/css.jpg"></p>
<h4 id="Layout阶段："><a href="#Layout阶段：" class="headerlink" title="Layout阶段："></a>Layout阶段：</h4><blockquote>
<p>经历Parse HTML之后得到DOM与CSSOM，计算每个元素的样式，得到一颗Layout tree，接着计算每个元素在页面中的尺寸与位置。前者称为样式计算，后者称为Layout计算。<br>针对输入的DOM与CSS树，计算样式，输出Layout tree、PaintLayer tree并计算每个节点所对应的尺寸和位置。</p>
</blockquote>
<h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><p>浏览器会遍历DOM中每个元素，从CSSOM中查找该元素匹配的样式定义，接着进行CSS选择器优先级排序，得到该元素最终计算后的样式，以类ComputedStyle体现</p>
<h5 id="创建LayoutObject"><a href="#创建LayoutObject" class="headerlink" title="创建LayoutObject"></a>创建LayoutObject</h5><p>以类Element、类ComputedStyle为参数，来实现针对某个DOM元素及其样式创建什么样的LayoutObject</p>
<p>浏览器在构建Layout tree的同时，还会同时生成另外一棵树：PainterLayer tree，它用来记录元素的渲染顺序；</p>
<h5 id="Layout计算"><a href="#Layout计算" class="headerlink" title="Layout计算"></a>Layout计算</h5><p>根据CSS：box model遍历并计算每个节点的尺寸位置，这些信息保存在类LayoutBox的实例变量frame_rect_中</p>
<h4 id="Paint阶段"><a href="#Paint阶段" class="headerlink" title="Paint阶段"></a>Paint阶段</h4><blockquote>
<p>记录绘制操作</p>
</blockquote>
<p>例如：生成一个DI，记录在屏幕的什么位置绘制一个红色的矩形（每个layout object 对应多个DI，背景，前景（文本）、轮廓…<br><img src="/hide/paint.png"></p>
<p>举例：一个页面中有个元素div，开发者给它设置了CSS动画（围绕Z轴旋转），页面内其它元素保持不变。</p>
<blockquote>
<p>1: 动画操作放到另外一个线程(称为Composite线程)去做；<br>2: JS线程绘制每个节点的逻辑实现，并不是立即的真正绘制，而是仅仅记录绘制的操作以及参数（称为draw commands或者draw records）；<br>3: 当另外一个线程真正处理动画时，根据位置判断动画节点是否与其它节点有重叠，如果有则重新绘制相关节点；</p>
</blockquote>
<blockquote>
<p>PaintLayer和PaintLayerStackingNode是一个CSS概念产生的类，为了更好的区分代码，并与后面的Composite阶段桥接起来， 浏览器创建了一个新的类GraphicsLayer(简称：GL)，并形成一颗新的树GraphicsLayer tree；</p>
</blockquote>
<p>GraphicsLayer与PaintLayer是一对多的关系，即：一个或多个PainterLayer在一个GraphicsLayer上绘制。</p>
<blockquote>
<p>拥有部分动画的DOM元素，对应的PaintLayer对象会创建一个GraphicsLayer对象;</p>
</blockquote>
<h2 id="优化对象"><a href="#优化对象" class="headerlink" title="优化对象"></a>优化对象</h2><p><img src="/hide/per1.png"><br><img src="/hide/per2.png"></p>
<p>3： 弹幕宽高通过计算获取，</p>
<h2 id="下步计划"><a href="#下步计划" class="headerlink" title="下步计划"></a>下步计划</h2><p>优化 实时fps</p>
<p><img src="/hide/cwnd.png"></p>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>1：弹幕 css3 动画会到主线程去执行</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://zhuanlan.zhihu.com/p/52396782">5分钟让你看懂CPU的结构和工作原理</a>1<br><a href="https://zhuanlan.zhihu.com/p/52184953">最通俗易懂的显卡参数讲解</a></p>
<p><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制</a><br><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">图形图像渲染原理</a><br><a href="https://zhuanlan.zhihu.com/p/48515392">Chromium Blink流程 PaintLayer和GraphicsLayer</a></p>
<p><a href="https://juejin.cn/post/6844904046411644941">一文看懂Chrome浏览器工作原理</a><br><a href="http://dev.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL 事务相关以及索引查询</title>
    <url>/2020/11/14/database/mysql-transaction/</url>
    <content><![CDATA[<blockquote>
<p>事务相关以及索引查询</p>
</blockquote>
<h2 id="一、事务相关"><a href="#一、事务相关" class="headerlink" title="一、事务相关"></a>一、事务相关</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>假如：小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h2 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h2><ul><li>
原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>
一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li>
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li>

</li></ul>## 并发事务带来哪些问题？
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题：

<ul><li>
脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>

</li><li>
丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li><li>

</li><li>
不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>

</li><li>
幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li><li>

</li></ul>
不可重复度和幻读区别：
不可重复读的重点是修改，幻读的重点在于新增或者删除。


<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h2 id="事务隔离级别有哪些-MySQL的默认隔离级别是？"><a href="#事务隔离级别有哪些-MySQL的默认隔离级别是？" class="headerlink" title="事务隔离级别有哪些?MySQL的默认隔离级别是？"></a>事务隔离级别有哪些?MySQL的默认隔离级别是？</h2><p>SQL 标准定义了四个隔离级别：</p>
<ul><li>
READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>
READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>
REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>
SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul>

<table width="556"><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table>

<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>
<p>mysql&gt; SELECT @@tx_isolation;<br>+—————–+<br>| @@tx_isolation  |<br>+—————–+<br>| REPEATABLE-READ |<br>+—————–+</p>
<p><span style="font-weight: bold; color: rgb(249, 150, 59);">注意</span>：与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</p>
<h2 id="二、索引相关"><a href="#二、索引相关" class="headerlink" title="二、索引相关"></a>二、索引相关</h2><h2 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h2><p>先从 MySQL 的基本存储结构说起<br><a href="https://www.webq.top/article/914" target="_blank">MySQL的基本存储结构是页 (记录都存在页里边) ：</a></p>
<p><img src="../../img/Innodb.jpg"><br><img src="../../img/sql_save.jpg"></p>
<ul><li>
各个数据页可以组成一个双向链表</li><li>
每个数据页中的记录又可以组成一个单向链表</li></ul>

<pre><code>- 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，\n    然后再遍历该槽对应分组中的记录即可快速找到指定的记录
- 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</code></pre>


<p>所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：</p>
<ol><li>
定位到记录所在的页：需要遍历双向链表，找到所在的页</li><li>
从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</li></ol>


<p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。</p>
<p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：<br><img src="../../img/sql_no_index.jpg"></p>
<p>要找到id为8的记录简要步骤：<br><img src="../../img/sql_index.jpg"></p>
<p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）</p>
<p>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。</p>
]]></content>
  </entry>
  <entry>
    <title>css图层</title>
    <url>/2020/11/14/css/layer/</url>
    <content><![CDATA[<blockquote>
<p>在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层</p>
</blockquote>
<p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p>
<h2 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h2><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <code>&lt;video&gt;</code> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <code>&lt;canvas&gt;</code> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<blockquote>
<p>注意：<br>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（<code>把绘图上下文的位图输出进行组合</code>）需要用到GPU，生成合成层的位图处理（<code>绘图上下文的工作</code>）是需要CPU。</p>
</blockquote>
<p>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</p>
<p><code>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</code></p>
<blockquote>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
</blockquote>
<h2 id="性能优化点："><a href="#性能优化点：" class="headerlink" title="性能优化点："></a>性能优化点：</h2><p>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 </p>
<ul>
<li><code>提升合成层的最好方式是使用 CSS 的 will-change属性。</code></li>
</ul>
<p>从合成层产生原因中，可以知道 will-change 设置为opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p>
<ul>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
</ul>
<p>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。</p>
<p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p>
<h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><p>合成层占用内存的问题</p>
<ul>
<li><p>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）</p>
</li>
<li><p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠<br>简单直接的方式：</p>
</li>
<li><p>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>css图层</title>
    <url>/2020/11/14/css/layer0/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/6844903959425974280#heading-6">浏览器层合成与页面渲染优化</a></p>
<h2 id="渲染对象（RenderObject）"><a href="#渲染对象（RenderObject）" class="headerlink" title="渲染对象（RenderObject）"></a>渲染对象（RenderObject）</h2><p>一个 DOM 节点对应了一个渲染对象，渲染对象依然维持着 DOM 树的树形结构。一个渲染对象知道如何绘制一个 DOM 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 DOM 节点。</p>
<h2 id="渲染层（RenderLayer）"><a href="#渲染层（RenderLayer）" class="headerlink" title="渲染层（RenderLayer）"></a>渲染层（RenderLayer）</h2><p>这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。能够导致浏览器为其创建新的渲染层的，包括以下几类常见的情况：</p>
<ul>
<li>根元素 document</li>
<li>有明确的定位属性（relative、fixed、sticky、absolute）</li>
<li>opacity &lt; 1</li>
<li>有 CSS fliter 属性</li>
<li>有 CSS mask 属性</li>
<li>有 CSS mix-blend-mode 属性且值不为 normal</li>
<li>有 CSS transform 属性且值不为 none</li>
<li>backface-visibility 属性为 hidden</li>
<li>有 CSS reflection 属性</li>
<li>有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto</li>
<li>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</li>
<li>overflow 不为 visible</li>
</ul>
<p>DOM 节点和渲染对象是一一对应的，满足以上条件的渲染对象就能拥有独立的渲染层。当然这里的独立是不完全准确的，并不代表着它们完全独享了渲染层，由于不满足上述条件的渲染对象将会与其第一个拥有渲染层的父元素共用同一个渲染层，因此实际上，这些渲染对象会与它的部分子元素共用这个渲染层。</p>
<h1 id="图形层（GraphicsLayer）"><a href="#图形层（GraphicsLayer）" class="headerlink" title="图形层（GraphicsLayer）"></a>图形层（GraphicsLayer）</h1><p>GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。<br>所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。</p>
<h2 id="合成层（CompositingLayer）"><a href="#合成层（CompositingLayer）" class="headerlink" title="合成层（CompositingLayer）"></a>合成层（CompositingLayer）</h2><p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。<br>那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：</p>
<ul>
<li>3D transforms：translate3d、translateZ 等</li>
<li>video、canvas、iframe 等元素</li>
<li>通过 Element.animate() 实现的 opacity 动画转换</li>
<li>通过 СSS 动画实现的 opacity 动画转换</li>
<li>position: fixed</li>
<li>具有 will-change 属性</li>
<li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li>
</ul>
<p>利用 will-change 属性，将 CPU 消耗高的渲染元素提升为一个新的合成层，才能开启 GPU 加速的，因此你也可以使用 transform: translateZ(0) 来解决这个问题。</p>
<blockquote>
<p>这里值得注意的是，不少人会将这些合成层的条件和渲染层产生的条件混淆，这两种条件发生在两个不同的层处理环节，是完全不一样的。</p>
</blockquote>
<h1 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h1><p>上边提到，满足某些显性的特殊条件时，渲染层会被浏览器提升为合成层。除此之外，在浏览器的 Composite 阶段，还存在一种隐式合成，部分渲染层在一些特定场景下，会被默认提升为合成层。<br>对于隐式合成，CSS GPU Animation 中是这么描述的：</p>
<blockquote>
<p>This is called implicit compositing: One or more non-composited elements that should appear above a composited one in the stacking order are promoted to composite layers.</p>
</blockquote>
<blockquote>
<p>(一个或多个非合成元素应出现在堆叠顺序上的合成元素之上，被提升到合成层。)</p>
</blockquote>
<p>这句话可能不好理解，它其实是在描述一个交叠问题（overlap）。举个例子说明一下：</p>
<p>两个 absolute 定位的 div 在屏幕上交叠了，根据 z-index 的关系，其中一个 div 就会”盖在“了另外一个上边。</p>
<p>这个时候，如果处于下方的 div 被加上了 CSS 属性：transform: translateZ(0)，就会被浏览器提升为合成层。提升后的合成层位于 Document 上方，假如没有隐式合成，原本应该处于上方的 div 就依然还是跟 Document 共用一个 GraphicsLayer，层级反而降了，就出现了元素交叠关系错乱的问题。</p>
<p>所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。</p>
]]></content>
  </entry>
  <entry>
    <title>CommonJS,AMD,CMD,ES6</title>
    <url>/2020/11/14/frame/cmd-amd-es6/</url>
    <content><![CDATA[<blockquote>
<p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统</p>
</blockquote>
<h2 id="一、CommonJS"><a href="#一、CommonJS" class="headerlink" title="一、CommonJS"></a>一、CommonJS</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">//在这里写上需要向外暴露的函数、变量</span></span><br><span class="line">    add: add,</span><br><span class="line">    basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<h2 id="二、AMD和require-js"><a href="#二、AMD和require-js" class="headerlink" title="二、AMD和require.js"></a>二、AMD和require.js</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。</p>
<p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&amp;lt;script src=<span class="string">&quot;js/require.js&quot;</span>&gt;<span class="string">&quot;js/main&quot;</span>&gt;&amp;lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    $(<span class="string">&quot;#sum&quot;</span>).html(sum);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="三、CMD和sea-js"><a href="#三、CMD和sea-js" class="headerlink" title="三、CMD和sea.js"></a>三、CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">            b.foo()</span><br><span class="line">        &#125; </span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">        b.doSomething()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="四、ES6-Module"><a href="#四、ES6-Module" class="headerlink" title="四、ES6 Module"></a>四、ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** export default **/</span></span><br><span class="line"><span class="comment">//定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        ele.textContent = math.add(<span class="number">99</span> + math.basicNum);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<h2 id="五、-ES6-模块与-CommonJS-模块的差异"><a href="#五、-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="五、 ES6 模块与 CommonJS 模块的差异"></a>五、 ES6 模块与 CommonJS 模块的差异</h2><h2 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h2><ul>
<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>

<h2 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h2><ul>
<li>

<p>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</p>
</li>
<li>

<p>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</p>
</li>
</ul>




<p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c#heading-4" target="_blank">CommonJS,AMD,CMD,ES6</a></p>
<p><a href="https://blog.csdn.net/ixygj197875/article/details/79263942" target="_blank">ES6模块与CommonJS模块的差异</a></p>
]]></content>
  </entry>
  <entry>
    <title>express-session之数据保存mongodb</title>
    <url>/2020/11/14/frame/express-session-mongo/</url>
    <content><![CDATA[<blockquote>
<p>session数据存储空间一般是在内存中开辟的，那么在内存中的session显然是存在极大的数据丢失的隐患的，比如系统掉电，所有的会话数据就会丢失，这里主要介绍session持久化保存到mongoDB的工具connect-mongo。</p>
</blockquote>
<p>express-session中间件将会话数据存储在服务器上；它仅将会话标识（而非会话数据）保存在 cookie 中。从1.5.0版本开始, express-session不再依赖cookie-parser,直接通过req/res读取/写入;默认存储位置内存存储(服务器端),</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install express-session connect-mongo</span><br><span class="line"> app .use (</span><br><span class="line">    session (&#123;</span><br><span class="line">      secret:   secret ,</span><br><span class="line">      name:   <span class="string">&#x27;session_id&#x27;</span> ,</span><br><span class="line">      saveUninitialized:   <span class="literal">false</span> ,</span><br><span class="line">   <span class="comment">// 在存储一些新数据之前，不创建session</span></span><br><span class="line">      resave:   <span class="literal">false</span> ,</span><br><span class="line">   <span class="comment">// 如果没有发生任何修改不储存session。</span></span><br><span class="line">      store:   <span class="keyword">new</span>   MongoStore (&#123;</span><br><span class="line">        url: <span class="string">&#x27;mongodb://127.0.0.1:27017/k-blog&#x27;</span> ,</span><br><span class="line">        touchAfter:   <span class="number">24</span> * <span class="number">3600</span>   <span class="comment">// 单位是秒</span></span><br><span class="line">     &#125;),</span><br><span class="line">      cookie:  &#123;</span><br><span class="line">        maxAge: <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span> <span class="comment">//单位毫秒</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>


<p> express-session</p>
<ul>
<li><p>1.、name - cookie的名字（原属性名为 key）。（默认：’connect.sid’）</p>
</li>
<li><p>2、 store - session存储实例 </p>
</li>
<li><p>3.、secret - 用它来对session cookie签名，防止篡改 </p>
</li>
<li><p>4、 cokie - session cookie设置 （默认：{ path: ‘/‘, httpOnly: true,secure: false, maxAge: null }）</p>
</li>
<li><p>5、 genid - 生成新session ID的函数 （默认使用uid2库） </p>
</li>
<li><p>6、 rolling - 在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</p>
</li>
<li><p>7、 resave - 强制保存session即使它并没有变化 （默认： true） </p>
</li>
<li><p>8、 proxy - 当设置了secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为true时，<br>”x-forwarded-proto” header 将被使用。当设定为false时，所有headers将被忽略。当该属性没有被设定时，将使用Express的trust proxy。 </p>
</li>
<li><p>9、saveUninitialized - 强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于<br>未初始化状态。在设定一个cookie前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true） </p>
</li>
<li><p>10、unset - 控制req.session是否取消（例如通过 delete，或者将它的值设置为null）。这可以使session保持存储<br>状态但忽略修改或删除的请求（默认：keep）</p>
</li>
<li><p>express-session的一些方法:<br>1、ession.destroy():删除session，当检测到客户端关闭时调用。<br>2、Session.reload():当session有修改时，刷新session。<br>3、Session.regenerate()：将已有session初始化。<br>4、Session.save()：保存session。</p>
</li>
</ul>
<p>connect-mongo</p>
<p>ttl: 14 * 24 * 60 * 60 //session保存时间，默认14天<br>autoRemove:’native’ //这是一个基本的默认设置。<br>autoRemoveInterval ： 10 // 单位分钟，当autoRemove为‘interval’定时删除<br>一：url： ‘mongodb://localhost/test-app’, // mongodb 地址<br>collection： 集合名称，默认为sessions</p>
<p>mongoOptions：{}</p>
<p>二：mongooseConnection</p>
<p>三：db </p>
<p>四：dbPromise : </p>
<p>touchAfter: 24*3600 //单位是秒</p>
<p>这样只要在24小时内，无论你发多少个请求，session只会被更新一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">serialize：自定义序列化函数</span><br><span class="line"></span><br><span class="line">unserialize：自定义反序列化函数</span><br><span class="line">stringify：默认是<span class="literal">true</span>,如果为<span class="literal">true</span>则序列化和反序列化使用原生的<span class="built_in">JSON</span>.xxx处理.</span><br><span class="line">transformId：<span class="function"><span class="keyword">function</span>将<span class="title">sessionId</span>转为你想要的任何键然后进行储存</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><a href="https://segmentfault.com/a/1190000017383466" target="_blank" style="font-size: x-large;">二、三、四mongo的连接方法看这</a></p>
]]></content>
  </entry>
  <entry>
    <title>nuxt的运行原理</title>
    <url>/2020/11/14/frame/nuxt/</url>
    <content><![CDATA[<p>通过查看nuxt.js工程目录下的package.json文件，我们可以看到下列几条指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;nuxt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;nuxt build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;nuxt start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;generate&quot;</span>: <span class="string">&quot;nuxt generate&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合官网的介绍，我们可以知道不同的指令对应着不同的功能：<table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>nuxt</td><td>开启一个监听3000端口的服务器，同时提供hot-reloading功能</td></tr><tr><td>nuxt build</td><td>构建整个应用，压缩合并JS和CSS文件（用于生产环境）</td></tr><tr><td>nuxt start</td><td>开启一个生产模式的服务器（必须先运行nuxt build命令）</td></tr><tr><td>nuxt generate</td><td>构建整个应用，并为每一个路由生成一个静态页面（用于静态服务器）</td></tr></tbody></table><br>以上几条指令，也就是本文将要分析的重点：究竟这些指令的背后，nuxt都做了一些什么样的工作呢？</p>
<h2 id="三、执行指令"><a href="#三、执行指令" class="headerlink" title="三、执行指令"></a>三、执行指令</h2><p>打开nuxt.js的工程目录，进入到到bin目录，我们可以看到5个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|__ nuxt</span><br><span class="line">|__ nuxt-build</span><br><span class="line">|__ nuxt-dev</span><br><span class="line">|__ nuxt-generate</span><br><span class="line">|__ nuxt-start</span><br></pre></td></tr></table></figure>

<p>每个文件对应着不同的指令。下面我们通过一张图来分析每一条指令的执行过程：<br><img src="/img/nuxt1.png"></p>
<p>从上图可知，每一条指令基本都是做了这么几件事情：<li><br>读取nuxt.config.js文件的配置；</li><li><br>实例化Nuxt()类，并把上一步读取到的配置覆盖Nuxt()类的默认配置；</li><li><br>执行各自具体的方法函数。</li><br>对应代码如下（节选）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nuxtConfigFile &#x3D; resolve(rootDir, &#39;nuxt.config.js&#39;)</span><br><span class="line"></span><br><span class="line">var options &#x3D; &#123;&#125;</span><br><span class="line">if (fs.existsSync(nuxtConfigFile)) &#123;</span><br><span class="line">        options &#x3D; require(nuxtConfigFile)</span><br><span class="line">    &#125;</span><br><span class="line">if (typeof options.rootDir !&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        options.rootDir &#x3D; rootDir</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var nuxt &#x3D; new Nuxt(options)</span><br><span class="line">nuxt.build()</span><br></pre></td></tr></table></figure>

<p>第一步读取配置以及配置的内容可以查看<a href="https://nuxtjs.org/api/configuration-build" rel="nofollow noreferrer" target="_blank">官网说明</a>，下面我们将会对第二步和第三步进行深入探讨。</p>
<h2 id="四、Nuxt-类"><a href="#四、Nuxt-类" class="headerlink" title="四、Nuxt()类"></a>四、Nuxt()类</h2><p>进入到nuxt/lib目录，我们可以看到如下的文件目录结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|__ app</span><br><span class="line">|__ build</span><br><span class="line">    |__ index.js</span><br><span class="line">    |__ webpack</span><br><span class="line">|__ generate.js</span><br><span class="line">|__ nuxt.js</span><br><span class="line">|__ render.js</span><br><span class="line">|__ server.js</span><br><span class="line">|__ utils.js</span><br><span class="line">|__ views</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目录当中的nuxt.js文件，就是我们要实例化的Nuxt()类的所在，让我们来看看它都包含一些什么内容，以及各自都有些什么作用：<br><img src="/img/nuxt2.png"></p>
<p>上图中每一步都可以在具体的代码中自行浏览。在用户输入指令并实例化了Nuxt()类以后，实例化出来的nuxt对象就会执行图中打了绿色对勾的几个方法：build(), render(), renderRoute(), renderAndGetWindow()以及generate()方法。<br>同时，Nuxt()类也提供了一个close()公有方法，用于关闭其所开启的服务器。</p>
<h2 id="五、build-方法"><a href="#五、build-方法" class="headerlink" title="五、build()方法"></a>五、build()方法</h2><p>build()方法对应着nuxt/lib/build/index.js文件，其基本构成如下：<br><img src="/img/nuxt3.png"></p>
<p>简单来说，build()方法在判断完运行条件后，会先初始化产出目录.nuxt，然后通过不同目录下的文件结构来生成一系列的配置，写入模板文件后输出到.nuxt目录。接下来，则会根据不同的开发环境来调用不同的webpack配置，运行不同的webpack构建方案。</p>
<h2 id="六、render-js文件"><a href="#六、render-js文件" class="headerlink" title="六、render.js文件"></a>六、render.js文件</h2><p>在nuxt/lib目录下找到render.js文件，它包含着我们即将要分析的三个方法：render(), renderRoute(), renderAndGetWindow()。<br><img src="/img/nuxt4.png"></p>
<p>通过这张图片，我们可以知道nuxt对于处理“客户端渲染”与“服务端渲染”的逻辑其实是非常清晰的。<br>首先，在render()方法在处理完一系列的路径问题后，会调用renderRoute()方法，获取响应所需内容并完成响应。<br>其中renderRoute()方法会判断当前响应是否应执行服务端渲染。如果是，则调用vue提供的bundleRenderer()方法，把html内容渲染完毕以后再整体输出；如果不是，则直接输出一个&lt;div id=”__nuxt”&gt;&lt;/div&gt;字符串，交由客户端渲染。<br>最后，通过renderAndGetWindow()来检查输出的html是否存在问题，然后发出通知，表明html可用。# ## 七、generate.js文件<br>最后我们来分析一下generate.js文件。我们知道nuxt generate指令会为page目录下的每一个页面文件单独生成一个html静态页面，功能非常贴心。那么generate.js到底是怎么工作的呢？<br><img src="/img/nuxt5.png"></p>
<p>在执行nuxt generate时，它会先执行前文已经分析过的build()方法，产出编译后的文件；然后会初始化dist目录，调用resolveRouteParams()方法，读取产出后的路由配置并整理。然后通过fs.writeFile()等API，把内容挨个写入文件并输出，最后再统计总的generate()运行时间。</p>
]]></content>
  </entry>
  <entry>
    <title>React  生命周期</title>
    <url>/2020/11/14/frame/react/</url>
    <content><![CDATA[<blockquote>
<p>React生命周期主要包括三个阶段：初始化阶段、运行中阶段和销毁阶段</p>
</blockquote>
<p><img src="/img/react.webp"></p>
<p>组件的生命周期可分成三个状态：<ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul><br>生命周期的方法有：<ul><li><br><b>componentWillMount</b> 在渲染前调用,在客户端也在服务端。</li><li><br><b>componentDidMount</b> : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。</li><li><br><b>componentWillReceiveProps</b> 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。</li><li><br><b>shouldComponentUpdate</b> 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。<br>可以在你确认不需要更新组件时使用。</li><li><br><b>componentWillUpdate</b>在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</li><li><br><b>componentDidUpdate</b> 在组件完成更新后立即调用。在初始化时不会被调用。</li><li><br><b>componentWillUnmount</b>在组件从 DOM 中移除之前立刻被调用。</li><li>## 可以用如下代码测试</li></ul></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;9、子组件将要接收到新属性&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10、子组件是否需要更新&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (newProps.number &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11、子组件将要更新&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;13、子组件更新完成&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;14、子组件将卸载&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12、子组件挂载中&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.number&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        <span class="comment">//1、加载默认属性</span></span><br><span class="line">        name: <span class="string">&#x27;sls&#x27;</span>,</span><br><span class="line">        age:<span class="number">23</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//2、加载默认状态</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3、父组件挂载之前&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5、父组件挂载完成&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;6、父组件是否需要更新&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (newState.number&lt;<span class="number">15</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;7、父组件将要更新&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;8、父组件更新完成&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            number: <span class="built_in">this</span>.state.number + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4、render(父组件挂载)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.number&lt;<span class="number">10</span>?<span class="xml"><span class="tag">&lt;<span class="name">SubCounter</span> <span class="attr">number</span>=<span class="string">&#123;this.state.number&#125;/</span>&gt;</span></span>:<span class="literal">null</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="根据上图：React的生命周期可以用如下一个类来表示"><a href="#根据上图：React的生命周期可以用如下一个类来表示" class="headerlink" title="根据上图：React的生命周期可以用如下一个类来表示"></a>根据上图：React的生命周期可以用如下一个类来表示</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">React</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    config: any;</span><br><span class="line">    state: any;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">config: any</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.config.componentWillMount();  <span class="comment">// 初始化之前</span></span><br><span class="line">        <span class="built_in">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行初始化相关操作</span></span><br><span class="line">        <span class="built_in">this</span>.config.componentDidMount();</span><br><span class="line">##         // 初始化结束    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当父组件重新render() props改变</span></span><br><span class="line">    private <span class="function"><span class="title">parentRender</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">            <span class="built_in">this</span>.config.componentWillReceiveProps(); </span><br><span class="line">                    <span class="built_in">this</span>.shouldUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 当state更新时调用此方法</span></span><br><span class="line">        private <span class="function"><span class="title">dataUpdate</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">                <span class="built_in">this</span>.shouldUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">        private <span class="function"><span class="title">shouldUpdate</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">                <span class="comment">// 由外部来判断是否需要更新</span></span><br><span class="line">        &lt;span style=<span class="string">&quot;font-size: large; color: rgb(194, 79, 74);&quot;</span>&gt;<span class="comment">//一般通过该函数来优化性能：</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.config.shouldComponentUpdate()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.config.componentWillUpdate();</span><br><span class="line">                <span class="built_in">this</span>.render();</span><br><span class="line">                <span class="built_in">this</span>.config.componentDidUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">        <span class="function"><span class="title">destroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.config.componentWillUnmount();</span><br><span class="line">            <span class="comment">// 销毁一些监听函数 组件之类的</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2020/11/14/frame/vue-life/</url>
    <content><![CDATA[<p>从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数！</p>
<ul>
<li>beforecreated<blockquote>
<p>el 和 data 并未初始化 </p>
</blockquote>
</li>
<li>created<blockquote>
<p>完成了 data 数据的初始化，el没有</p>
</blockquote>
</li>
<li>beforeMount<blockquote>
<p>完成了 el 和 data 初始化</p>
</blockquote>
</li>
<li>mounted<blockquote>
<p>完成挂载</p>
</blockquote>
</li>
</ul>
<p>另外在标红处，我们能发现el还是 ，这里就是应用的  Virtual DOM （虚拟Dom）技术，先把坑占住了。到后面 mounted 挂载的时候再把值渲染进去。<br><img src="/img/vue1.png"></p>
<ul>
<li>update 相关<br>这里我们在 chrome console里执行以下命令<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.message= <span class="string">&#x27;yes !! I do&#x27;</span>; </span><br></pre></td></tr></table></figure>
下面就能看到data里的值被修改后，将会触发update的操作。<br><img src="/img/vue2.png"></li>
<li>*destroy相关<br>有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。因为这个Vue实例已经不存在了。</li>
</ul>
<p>app.$destroy();<br><img src="/img/vue3.png"><br>生命周期总结</p>
<p>beforecreate : 举个栗子：可以在这加个loading事件</p>
<p>created ：在这结束loading，还做一些初始化，实现函数自执行</p>
<p>mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
<p>beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/vue/2.1.3/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">          el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">              message : <span class="string">&quot;xuxiao is boy&quot;</span> </span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">       beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.group(<span class="string">&#x27;beforeCreate 创建前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span> , <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//undefined </span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message)  </span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;created 创建完毕状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化 </span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;beforeMount 挂载前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + (<span class="built_in">this</span>.$el)); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化  </span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化  </span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;mounted 挂载结束状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);    </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化 </span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeUpdate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);   </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el); </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);    </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        destroyed: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.group(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);  </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="根据下图：vue的生命周期可以用如下一个类来表示"><a href="#根据下图：vue的生命周期可以用如下一个类来表示" class="headerlink" title="根据下图：vue的生命周期可以用如下一个类来表示"></a>根据下图：vue的生命周期可以用如下一个类来表示</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface DataInterface &#123;</span><br><span class="line">    [key: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ConfigInterface &#123;</span><br><span class="line">    el: string;</span><br><span class="line">    data: DataInterface;</span><br><span class="line">    beforeCreate?: <span class="built_in">Function</span>;</span><br><span class="line">    created?: <span class="built_in">Function</span>;</span><br><span class="line">    beforeMount?: <span class="built_in">Function</span>;</span><br><span class="line">    mounted?: <span class="built_in">Function</span>;</span><br><span class="line">    beforeUpdate?: <span class="built_in">Function</span>;</span><br><span class="line">    updated?: <span class="built_in">Function</span>;</span><br><span class="line">    beforeDestroy?: <span class="built_in">Function</span>;</span><br><span class="line">    destroyed?: <span class="built_in">Function</span>;</span><br><span class="line">    templete?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">        config: ConfigInterface;</span><br><span class="line">    $el: HTMLElement;</span><br><span class="line">    $data: DataInterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">config: ConfigInterface</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.config = &#123;</span><br><span class="line">                el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            beforeCreate: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            created: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            beforeMount: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            mounted: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            beforeUpdate: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            updated: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            beforeDestroy: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            destroyed: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">            ...config,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">this</span>.config.beforeCreate();  <span class="comment">// 初始化之前</span></span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            &lt;span style=<span class="string">&quot;color: rgb(249, 150, 59);&quot;</span>&gt;<span class="comment">// 执行初始化相关操作</span></span><br><span class="line">        <span class="built_in">this</span>.$data = <span class="built_in">this</span>.config.data; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(249, 150, 59);&quot;</span>&gt;</span>// 生成$data</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        this.config.created();</span></span><br><span class="line"><span class="xml">        if (this.config.el) &#123;</span></span><br><span class="line"><span class="xml">                this.hasTemplete();</span></span><br><span class="line"><span class="xml">        &#125; else &#123;</span></span><br><span class="line">                &lt;span style=&quot;color: rgb(249, 150, 59);&quot;&gt;// 等待外部调用vm.$mount(el)</span><br><span class="line">            // 再执行---&gt; this.hasTemplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private hasTemplete() &#123;</span><br><span class="line">            if (this.config.templete) &#123;</span><br><span class="line">                // 用传入的值渲染容器</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                // 用el的outHTML渲染容器</span><br><span class="line">        &#125;</span><br><span class="line">        this.$el = ...; // 生成$el</span><br><span class="line">        this.config.beforeMount();</span><br><span class="line">        &lt;span style=&quot;color: rgb(249, 150, 59);&quot;&gt;// 向this.$el挂载数据</span><br><span class="line">        this.config.mounted(); </span><br><span class="line">&lt;h2&gt;        &lt;span style=&quot;color: rgb(249, 150, 59);&quot;&gt;// 初始化结束&lt;/h2&gt;    &#125;</span><br><span class="line">    &lt;span style=&quot;color: rgb(249, 150, 59);&quot;&gt;// 当数据更新时调用此方法</span><br><span class="line">    private dataUpdate() &#123; </span><br><span class="line">            // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</span><br><span class="line">        // 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</span><br><span class="line">        this.config.beforeUpdate(); </span><br><span class="line">        // 渲染数据到页面</span><br><span class="line">        this.config.updated(); </span><br><span class="line">    &#125;</span><br><span class="line">    &lt;span style=&quot;color: rgb(249, 150, 59);&quot;&gt;// 销毁</span><br><span class="line">    destroy() &#123;</span><br><span class="line">            this.config.beforeDestroy();</span><br><span class="line">        // 销毁一些监听函数 组件之类的</span><br><span class="line">        this.config.destroyed(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Vue; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/vue-life.jpeg" alt="alt &#39;&#39;"></p>
]]></content>
  </entry>
  <entry>
    <title>Vue中的nextTick</title>
    <url>/2020/11/14/frame/vue-nextTick/</url>
    <content><![CDATA[<blockquote>
<p>MutationObserver是HTML5中的新API，是个用来监视DOM变动的接口</p>
</blockquote>
<p>nextTick的主要应用的场景及原因<ul><li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中</li></ul><br>在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。<ul><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</li></ul><br>具体原因在Vue的官方文档中详细解释：</p>
<blockquote>
<p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。</p>
</blockquote>
<blockquote>
<p>例如，当你设置vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
</blockquote>
<h2 id="nextTick源码浅析"><a href="#nextTick源码浅析" class="headerlink" title="nextTick源码浅析"></a>nextTick源码浅析</h2><p>作用<br>Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。<br>源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = []</span><br><span class="line">    <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        pending = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">        callbacks.length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">            copies[i]()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">    <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">    <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">    <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">    <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">    <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;amp;&amp;amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">        <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;</span><br><span class="line"></span><br><span class="line">        timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            p.then(nextTickHandler).catch(logError)</span><br><span class="line">            <span class="comment">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">            <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">            <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">            <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">            <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">            <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;amp;&amp;amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;amp;&amp;amp; (</span><br><span class="line">        isNative(MutationObserver) ||</span><br><span class="line">        <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">        MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">        <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">        <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">        observer.observe(textNode, &#123;</span><br><span class="line">            characterData: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">            textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fallback to setTimeout</span></span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _resolve</span><br><span class="line">        callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cb.call(ctx)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">                _resolve(ctx)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span></span><br><span class="line">        timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;amp;&amp;amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            _resolve = resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，先了解nextTick中定义的三个重要变量。<ul><li>callbacks</li></ul><br>用来存储所有需要执行的回调函数<ul><li>pending</li></ul><br>用来标志是否正在执行回调函数<ul><li>timerFunc</li></ul><br>用来触发执行回调函数<br>接下来，了解nextTickHandler()函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">        copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数用来执行callbacks里存储的所有回调函数。<br>接下来是将触发方式赋值给timerFunc。<ul><li>先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数；</li><li>否则，如果支持MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。</li><li>如果都不支持，则利用setTimeout设置延时为0。</li></ul><br>最后是queueNextTick函数。因为nextTick是一个即时函数，所以queueNextTick函数是返回的函数，接受用户传入的参数，用来往callbacks里存入回调函数。</p>
<p><img src="/img/vue-nexttick.png"></p>
<p>上图是整个执行流程，关键在于timeFunc()，该函数起到延迟执行的作用。</p>
<p>从上面的介绍，可以得知timeFunc()一共有三种实现方式。<ul><li>Promise</li><li>MutationObserver</li><li>setTimeout</li></ul><br>其中Promise和setTimeout很好理解，是一个异步任务，会在同步任务以及更新DOM的异步任务之后回调具体函数。<br>下面着重介绍一下MutationObserver。<br>MutationObserver是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。 调用过程很简单，但是有点不太寻常：你需要先给他绑回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> MutationObserver(callback)</span><br></pre></td></tr></table></figure>

<p>通过给MutationObserver的构造函数传入一个回调，能得到一个MutationObserver实例，这个回调就会在MutationObserver实例监听到变动时触发。<br>这个时候你只是给MutationObserver实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的observer方法就可以完成这一步:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domTarget = 你想要监听的dom节点</span><br><span class="line">mo.observe(domTarget, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">//说明监听文本内容的修改。</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/vue-nexttick2.png"></p>
<p>在nextTick中 MutationObserver的作用就如上图所示。在监听到DOM更新后，调用回调函数。</p>
<p>其实使用 MutationObserver的原因就是 nextTick想要一个异步API，用来在当前的同步代码执行完毕后，执行我想执行的异步回调，包括Promise和 setTimeout都是基于这个原因。其中深入还涉及到microtask等内容</p>
<p><a href="https://juejin.im/post/5a6fdb846fb9a01cc0268618" target="_blank">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/11/19/doc/dp/</url>
    <content><![CDATA[<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<h3 id="a1">单例模式</h3>

<p>单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<p>应用场景：</p>
<p>创建唯一的浮窗(闭包)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> result || ( result = fn .apply(<span class="built_in">this</span>, <span class="built_in">arguments</span> ) );</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement( <span class="string">&#x27;div&#x27;</span> );</span><br><span class="line">    div.innerHTML = <span class="string">&#x27;我是登录浮窗&#x27;</span>;</span><br><span class="line">    div.style.display = <span class="string">&#x27;none&#x27;</span>;  </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> createSingleLoginLayer = getSingle( createLoginLayer );</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">&#x27;loginBtn&#x27;</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> loginLayer = createSingleLoginLayer(); </span><br><span class="line">    loginLayer.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="a2">策略模式</h3>

<p>策略模式 （Strategy Pattern）又称政策模式，其定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。封装的策略算法一般是独立的，策略模式根据输入来调整采用哪个算法。关键是策略的实现和使用分离。</p>
<p>实例：（螺丝刀与螺丝刀头、车与轮胎）</p>
<p>在这些场景中，有以下特点：</p>
<p>螺丝刀头/轮胎（策略）之间相互独立，但又可以相互替换；</p>
<p>螺丝刀/车（封装上下文）可以根据需要的不同选用不同的策略；</p>
<p>应用场景</p>
<p>奖金计算，绩效为 S 的人年 终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calculateBonus = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> strategies = &#123;</span><br><span class="line">        <span class="string">&quot;S&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;A&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;B&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get: <span class="function">(<span class="params">level, salary</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> strategies[level] &amp;&amp; strategies[level](salary)</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function">(<span class="params">level, fn</span>) =&gt;</span> &#123;</span><br><span class="line">            strategies[level] = strategies[level] || fn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">calculateBonus.set( <span class="string">&#x27;C&#x27;</span>, <span class="function">(<span class="params">salary</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">1</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">calculateBonus.get( <span class="string">&#x27;S&#x27;</span>, <span class="number">20000</span> );<span class="comment">// 输出:80000</span></span><br><span class="line">calculateBonus.get( <span class="string">&#x27;A&#x27;</span>, <span class="number">10000</span> );<span class="comment">// 输出:30000</span></span><br></pre></td></tr></table></figure>

<p>策略模式的优缺点</p>
<p>策略模式将算法的实现和使用拆分，这个特点带来了很多优点：</p>
<p>1、策略之间相互独立，但策略可以自由切换，这个策略模式的特点给策略模式带来很多灵活性，也提高了策略的复用率；</p>
<p>2、如果不采用策略模式，那么在选策略时一般会采用多重的条件判断，采用策略模式可以避免多重条件判断，增加可维护性；</p>
<p>3、可扩展性好，策略可以很方便的进行扩展；</p>
<p>策略模式的缺点：</p>
<p>1、策略相互独立，因此一些复杂的算法逻辑无法共享，造成一些资源浪费；</p>
<p>2、如果用户想采用什么策略，必须了解策略的实现，因此所有策略都需向外暴露，这是违背迪米特法则/最少知识原则的，也增加了用户对策略对象的使用成本。<br><a href="//mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556974&idx=1&sn=2632dafaf94073989bb7fb5ab2610fc2&chksm=80255bafb752d2b93af37e76a2ee068c45e52a6b7d541d515d04807b18e41a8d697cbb0eac0f&mpshare=1&scene=1&srcid=&sharer_sharetime=1567996467029&sharer_shareid=7eef991d3e8f3a93c7682f2434cb1474&rd2werd=1#wechat_redirect" target="_blank" rel="noopener noreferrer">参考链接</a></p>
<h3 id="a3">代理模式</h3>

<p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>故事背景：</p>
<p>假设当 A 在心情好的时候收到花，小明表白成功的几率有 60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。<br>小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花 被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。<br>但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选 择 A 心情好的时候把花转交给 A</p>
<p>代码实现:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Flower = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> xiaoming = &#123;</span><br><span class="line">    sendFlower: <span class="function"><span class="keyword">function</span>(<span class="params"> target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> flower = <span class="keyword">new</span> Flower();</span><br><span class="line">        target.receiveFlower( flower ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> B = &#123;</span><br><span class="line">    receiveFlower: <span class="function"><span class="keyword">function</span>(<span class="params"> flower </span>)</span>&#123;</span><br><span class="line">        A.listenGoodMood(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">const</span> flower = <span class="keyword">new</span> Flower(); </span><br><span class="line">            A.receiveFlower( flower );</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> A = &#123;</span><br><span class="line">    receiveFlower: <span class="function"><span class="keyword">function</span>(<span class="params"> flower </span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 监听 A 的好心情</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;收到花 &#x27;</span> + flower ); </span><br><span class="line">    &#125;,</span><br><span class="line">    listenGoodMood: <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 假设 10 秒之后 A 的心情变好</span></span><br><span class="line">            fn(); </span><br><span class="line">        &#125;, <span class="number">10000</span> );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.sendFlower( B );</span><br></pre></td></tr></table></figure>

<p>由上面的例子可以引出两种代理模式</p>
<p>保护代理</p>
<p>代理 B 可以帮助 A 过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理 B 处被拒绝掉</p>
<p>虚拟代理</p>
<p>假设现实中的花价格不菲，导致在程序世界里，new Flower 也是一个代价昂贵的操作， 那么我们可以把 new Flower 的操作交给代理 B 去执行，代理 B 会选择在 A 心情好时再执行 new Flower</p>
<p>虚拟代理实现图片预加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">&#x27;img&#x27;</span> );     </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( imgNode );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">             imgNode.src = src; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image; </span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myImage.setSrc( <span class="built_in">this</span>.src ); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;</span><br><span class="line">             myImage.setSrc( <span class="string">&#x27;file:// /C:/Users/svenzeng/Desktop/loading.gif&#x27;</span> );</span><br><span class="line">             img.src = src;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&#x27;</span> );</span><br></pre></td></tr></table></figure>

<p>虚拟代理合并HTTP请求<br>假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同 步到另外一台备用服务器上面。当一次选中过多时，会产生频繁的网络请求。将带来很大的开销。可以通过一个代理函数 proxySynchronousFile 来收集一段时间之内的请求， 最后一次性发送给服务器 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> synchronousFile = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;开始同步文件，id 为: &#x27;</span> + id );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxySynchronousFile = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = [], <span class="comment">// 保存一段时间内需要同步的 ID</span></span><br><span class="line">    timer; <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">        cache.push( id );</span><br><span class="line">            <span class="keyword">if</span> ( timer )&#123; <span class="comment">// 保证不会覆盖已经启动的定时器</span></span><br><span class="line">                 <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            synchronousFile( cache.join( <span class="string">&#x27;,&#x27;</span> ) ); </span><br><span class="line">            <span class="built_in">clearTimeout</span>( timer ); <span class="comment">// 清空定时器 </span></span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            cache.length = <span class="number">0</span>; <span class="comment">// 清空 ID 集合</span></span><br><span class="line">        &#125;, <span class="number">2000</span> ); </span><br><span class="line">    &#125;<span class="comment">// 2 秒后向本体发送需要同步的 ID 集合</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkbox = <span class="built_in">document</span>.getElementsByTagName( <span class="string">&#x27;input&#x27;</span> );</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>, c; c = checkbox[ i++ ]; )&#123;</span><br><span class="line">      c.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">this</span>.checked === <span class="literal">true</span> )&#123;</span><br><span class="line">          proxySynchronousFile( <span class="built_in">this</span>.id ); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.im/post/5c10ff28518825778a56cb3e" target="_blank" rel="noopener noreferrer">参考链接</a></p>
<h3 id="a4">观察者模式</h3>

<p>定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。</p>
<p>DOM 事件</p>
<p>实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，来看看下面这两句简单的代码发生了什么事情:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span> );</span><br><span class="line"><span class="built_in">document</span>.body.click(); <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure>

<p>发布-订阅模式的通用实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> event = &#123;</span><br><span class="line">    clientList: [],</span><br><span class="line">    listen: <span class="function">(<span class="params"> key, fn </span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">this</span>.clientList[key] )&#123;</span><br><span class="line">            <span class="built_in">this</span>.clientList[key] = []; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.clientList[key].push(fn) <span class="comment">// 订阅的消息添加进缓存列表 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    trigger: <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">Array</span>.prototype.shift.call( arg ),</span><br><span class="line">        fns = <span class="built_in">this</span>.clientList[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="comment">// 如果没有绑定对应的消息 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = fns[i++]; </span>)</span>&#123;</span><br><span class="line">            fn.apply( <span class="built_in">this</span>, arg ); <span class="comment">// (2) // arg 是 trigger 时带上的参数</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function">(<span class="params"> key, fn </span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> fns = <span class="built_in">this</span>.clientList[key];</span><br><span class="line">        <span class="keyword">if</span> ( !fns )&#123; <span class="comment">// 如果 key 对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !fn )&#123; <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></span><br><span class="line">            fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">let</span> l = fns.length - <span class="number">1</span>; l &gt;=<span class="number">0</span>; l-- )&#123; <span class="comment">// 反向遍历订阅的回调函数列表 const _fn = fns[ l ];</span></span><br><span class="line">                <span class="keyword">if</span> ( _fn === fn )&#123;</span><br><span class="line">                    fns.splice( l, <span class="number">1</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能:</span><br><span class="line"><span class="keyword">const</span> installEvent = <span class="function"><span class="params">obj</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i <span class="keyword">in</span> event )&#123;</span><br><span class="line">        obj[ i ] = event[ i ]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能: </span><br><span class="line"><span class="keyword">const</span> salesOffices = &#123;&#125;;</span><br><span class="line">installEvent( salesOffices );</span><br><span class="line"></span><br><span class="line">salesOffices.listen( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;价格= &#x27;</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line">salesOffices.listen( <span class="string">&#x27;squareMeter100&#x27;</span>, <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;价格= &#x27;</span> + price );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger( <span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">2000000</span> ); <span class="comment">// 价格= 2000000</span></span><br><span class="line">salesOffices.trigger( <span class="string">&#x27;squareMeter100&#x27;</span>, <span class="number">3000000</span> ); <span class="comment">// 价格= 3000000</span></span><br></pre></td></tr></table></figure>
<h3 id="a5">命令模式</h3>

<p>用于将一个请求封装成为对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及执行可撤销的操作。</p>
<p>菜单例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顾客点餐</span></span><br><span class="line"><span class="keyword">const</span> Customer = <span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        book: <span class="function"><span class="keyword">function</span>(<span class="params">food, time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> command.execute(food, time);</span><br><span class="line">        &#125;,</span><br><span class="line">        undo: <span class="function"><span class="keyword">function</span>(<span class="params">menu</span>) </span>&#123;</span><br><span class="line">            command.undo(menu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务员，拥有点餐方法和撤销点餐方法</span></span><br><span class="line"><span class="keyword">const</span> foodCommand = <span class="function"><span class="keyword">function</span>(<span class="params">cook</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params">food, time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> timer = cook.willCook(food, time);</span><br><span class="line">            <span class="keyword">return</span> timer;</span><br><span class="line">        &#125;, </span><br><span class="line">        undo: <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">            cook.unCook(food);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厨师</span></span><br><span class="line"><span class="keyword">const</span> cook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        willCook: <span class="function"><span class="keyword">function</span>(<span class="params">food, time</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;时间在&#x27;</span> + time + <span class="string">&quot;：开始煮：&quot;</span> + food);</span><br><span class="line">            <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(food + <span class="string">&#x27;完成了&#x27;</span>);</span><br><span class="line">            &#125;, time);</span><br><span class="line">            <span class="keyword">return</span> timer;</span><br><span class="line">        &#125;,</span><br><span class="line">        unCook: <span class="function"><span class="keyword">function</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> command = foodCommand(cook());</span><br><span class="line"><span class="keyword">const</span> customer = Customer(command);</span><br><span class="line"><span class="keyword">const</span> receipt = customer.book(<span class="string">&#x27;西红寺炒鸡蛋&#x27;</span>, <span class="number">5000</span>); <span class="comment">// 5秒后炒完菜</span></span><br><span class="line"></span><br><span class="line">customer.undo(receipt); <span class="comment">//  做了取消操作，则不会炒菜</span></span><br></pre></td></tr></table></figure>
<h3> 代理模式与命令模式区别</h3>

<p> JavaScript 可以用高阶函数非常方便地实现命令模式。命令模式在 JavaScript 语言中是一种隐形的模式。</p>
<p>在代理(委托)模式中，调用者就是委托者，执行者就是被委托者，委托者和被委托者接口定义是相同的；在命令模式中，调用者不关注执行者的接口定义是否和它一致。</p>
<p>在调用时机上，代理模式的具体执行是只能在特定的调用者内部执行(接口相同)；命令模式的具体执行可以在任何调用者内部执行(接口不相同也可以)。</p>
<h3 id="a6"> 迭代器模式</h3>

<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<p>内部迭代器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, callback </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">const</span> i = <span class="number">0</span>, l = ary.length; i &lt; l; i++ )&#123;</span><br><span class="line">         callback.call( ary[i], i, ary[ i ] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">each( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123; </span><br><span class="line">    alert ( [ i, n ] );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>外部迭代器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        current += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> isDone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current &gt;= obj.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> getCurrItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> obj[ current ];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: next,</span><br><span class="line">        isDone: isDone,</span><br><span class="line">        getCurrItem: getCurrItem </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params"> iterator1, iterator2 </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( !iterator1.isDone() &amp;&amp; !iterator2.isDone() )&#123;</span><br><span class="line">    <span class="keyword">if</span> ( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> ( <span class="string">&#x27;iterator1 和 iterator2 不相等&#x27;</span> );</span><br><span class="line">    &#125; </span><br><span class="line">    iterator1.next(); </span><br><span class="line">    iterator2.next();</span><br><span class="line">&#125;</span><br><span class="line">alert ( <span class="string">&#x27;iterator1 和 iterator2 相等&#x27;</span> ); &#125;</span><br><span class="line"><span class="keyword">const</span> iterator1 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br><span class="line"><span class="keyword">const</span> iterator2 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br><span class="line">compare( iterator1, iterator2 ); <span class="comment">// 输出:iterator1 和 iterator2 相等</span></span><br></pre></td></tr></table></figure>

<p>倒序迭代器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseEach = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, callback </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> l = ary.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123;</span><br><span class="line">        callback( l, ary[ l ] ); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">reverseEach( [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( n ); <span class="comment">// 分别输出:2, 1 ,0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>中止迭代器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, callback </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>, l = ary.length; i &lt; l; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( callback( i, ary[ i ] ) === <span class="literal">false</span> )&#123; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">each( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n &gt; <span class="number">3</span> )&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log( n );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="a7">组合模式</h3>

<p>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="未完，待续……"><a href="#未完，待续……" class="headerlink" title="未完，待续……"></a>未完，待续……</h3><h3 id="a8">8. 组合模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a9">装饰器模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a10"> 外观模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a11"> 享元模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a12"> 代理模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a13"> 责任链模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a14">命令模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a15"> 解释器模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a16"> 迭代器模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a17">中介者模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a18">备忘录模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a19">观察者模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a20">状态模式</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a21">介绍</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a22">验证</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="a23">验证</h3>








<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>CORS settings attributes</title>
    <url>/2020/11/14/html/cors/</url>
    <content><![CDATA[<blockquote>
<p>在HTML5中，一些 HTML 元素提供了对 CORS 的支持， 例如<code>&lt;img&gt;和 &lt;video&gt;</code>均有一个跨域属性 (crossOriginproperty)，它允许你配置元素获取数据的 CORS 请求。</p>
</blockquote>
<p>默认情况下 （即未指定crossOrigin属性时）, CORS 根本不会使用。<br>如<a href="https://www.w3.org/TR/cors/#user-credentials" target="_blank">Terminology section of the CORS specification</a>中的描述，“anonymous” 关键字说明不会通过 cookies，客户端 SSL 证书或 HTTP 认证交换用户凭据。<br>即使是无效的关键字和空字符串也会被当作anonymous关键字使用。</p>
<h2 id="示例-使用-crossorigin-的-script-元素"><a href="#示例-使用-crossorigin-的-script-元素" class="headerlink" title="示例: 使用 crossorigin 的 script 元素"></a>示例: 使用 crossorigin 的 script 元素</h2><p>你可以使用下面的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="nofollow"><code>&lt;script&gt;</code></a>元素告诉一个浏览器执行来自<a href="https://example.com/example-framework.js%E7%9A%84%E8%84%9A%E6%9C%AC%E8%80%8C%E4%B8%8D%E5%8F%91%E9%80%81%E7%94%A8%E6%88%B7%E5%87%AD%E6%8D%AE%E3%80%82">https://example.com/example-framework.js的脚本而不发送用户凭据。</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/example-framework.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="“被污染”的-canvas"><a href="#“被污染”的-canvas" class="headerlink" title="“被污染”的 canvas"></a>“被污染”的 canvas</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image" target="_blank">MDN</a></p>
<p>尽管不通过 CORS 就可以在画布中使用图片，但是这会污染画布。一旦画布被污染，你就无法读取其数据。例如，你不能再使用画布的toBlob(),toDataURL()或getImageData()方法，调用它们会抛出安全错误。<br>这种机制可以避免未经许可拉取远程网站信息而导致的用户隐私泄露。</p>
<h2 id="示例-存储一张外部域中的图片"><a href="#示例-存储一张外部域中的图片" class="headerlink" title="示例: 存储一张外部域中的图片"></a>示例: 存储一张外部域中的图片</h2><p>你必须有一个可以对图片响应正确Access-Control-Allow-Origin响应头的服务器。你可以使用以下片段 (来自<a rel="noopener" href="https://github.com/h5bp/server-configs-apache/blob/fc379c45f52a09dd41279dbf4e60ae281110a5b0/src/.htaccess#L36-L53">HTML5 Boilerplate Apache server configs</a>) 实现正确响应头。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_setenvif.c</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">IfModule</span> <span class="attr">mod_headers.c</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FilesMatch</span> &quot;\\<span class="attr">.</span>(<span class="attr">cur</span>|<span class="attr">gif</span>|<span class="attr">ico</span>|<span class="attr">jpe</span>?<span class="attr">g</span>|<span class="attr">png</span>|<span class="attr">svgz</span>?|<span class="attr">webp</span>)$&quot;&gt;</span></span><br><span class="line">      SetEnvIf Origin &quot;:&quot; IS_CORS</span><br><span class="line">      Header set </span><br><span class="line">        Access-Control-Allow-Origin &quot;*&quot; env=IS_CORS</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FilesMatch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">IfModule</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完毕后，你就可以将这些图片保存到<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/Storage" title="/zh-CN/docs/Web/Guide/API/DOM/Storage">DOM 存储</a>中了，就像这些图片在你自己域名之下一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image,</span><br><span class="line">    canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>),</span><br><span class="line">    src = <span class="string">&quot;http://example.com/image&quot;</span>; </span><br><span class="line">    <span class="comment">// insert image url here</span></span><br><span class="line"></span><br><span class="line">img.crossOrigin = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line"></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    canvas.width = img.width;</span><br><span class="line">    canvas.height = img.height;</span><br><span class="line">    ctx.drawImage( img, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(</span><br><span class="line">        <span class="string">&quot;savedImageData&quot;</span>,</span><br><span class="line">        canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">img.src = src;</span><br><span class="line"><span class="comment">// make sure the load event fires for cached images too</span></span><br><span class="line"><span class="keyword">if</span> ( img.complete || img.complete === <span class="literal">undefined</span> ) &#123;</span><br><span class="line">    img.src = <span class="string">&quot;data:image/</span></span><br><span class="line"><span class="string">    gif;base64,R0lGODlhAQABAIAAAAAAAP</span></span><br><span class="line"><span class="string">    ...ywAAAAAAQABAAACAUwAOw==&quot;</span>;</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
  </entry>
  <entry>
    <title>使用pushState()改变url而不刷新</title>
    <url>/2020/11/14/html/history-2/</url>
    <content><![CDATA[<blockquote>
<p>HTML5提供history接口，把URL以state的形式添加或者替换到浏览器中，其实现函数正是 pushState 和 replaceState。</p>
</blockquote>
<h2 id="pushState-例子"><a href="#pushState-例子" class="headerlink" title="pushState 例子"></a>pushState 例子</h2><p>pushState() 的基本参数是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(state, title, url);</span><br></pre></td></tr></table></figure>
<p>其中state和title都可以为空，但是推荐不为空，应当创建state来配合popstate监听。<br>例如，我们通过pushState现改变URL而不刷新页面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code from http://caibaojian.com/book/</span></span><br><span class="line"><span class="keyword">var</span> state = (&#123;</span><br><span class="line">    </span><br><span class="line">url: ~href, </span><br><span class="line">title: ~title,</span><br><span class="line"> ~additionalKEY: ~additionalVALUE</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(state, ~title, ~href);</span><br></pre></td></tr></table></figure>
<p>其中带有“<del>”符号的是自定义内容。就可以把这个</del>href（URL）推送到浏览器的历史里。<br>如果想要改变网页的标题，应该：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title= ~newTitle;</span><br></pre></td></tr></table></figure>
<p>注意只是pushState是不能改变网页标题的哦。</p>
<h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><p><button onclick="history.pushState( null, null, '/book/');">点我试试</button> </p>
<p>（实现函数onclick = history.pushState( null, null, ‘/book/‘); ）。<br>实际上这个博客在文章之间也部署了这个技术。</p>
<h2 id="replaceState-同理"><a href="#replaceState-同理" class="headerlink" title="replaceState 同理"></a>replaceState 同理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.replaceState( state, ~title, ~href);</span><br></pre></td></tr></table></figure>

<h2 id="pushState、replaceState-的区别"><a href="#pushState、replaceState-的区别" class="headerlink" title="pushState、replaceState 的区别"></a>pushState、replaceState 的区别</h2><p>pushState()可以创建历史，可以配合popstate事件，而replaceState()则是替换掉当前的URL，不会产生历史。<br>限制因素<br>只能用同域的URL替换，例如你不能用<a href="http://baidu.com去替换http//google.com%E3%80%82">http://baidu.com去替换http://google.com。</a><br>而且state对象不存储不可序列化的对象如DOM。</p>
<h2 id="Ajax-配合-pushState-例子"><a href="#Ajax-配合-pushState-例子" class="headerlink" title="Ajax 配合 pushState 例子"></a>Ajax 配合 pushState 例子</h2><p>现在用Ajax + pushState来提供全新的<a href="http://caibaojian.com/t/ajax" title="View all posts in ajax" target="_blank">ajax</a>调用风格。以<a href="http://caibaojian.com/jquery/" title="jQuery手册">jQuery</a>为例，为了<a href="http://caibaojian.com/t/seo" title="seo">seo</a>需要，<br>应该为a标签的onclick添加方法。<a href="http://caibaojian.com/book/">·</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;~target a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    evt.preventDefault(); <span class="comment">// 阻止默认的跳转操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uri=$(<span class="built_in">this</span>).attr(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> newTitle=ajax_Load(uri);<span class="comment">// 你自定义的Ajax加载函数，例如它会返回newTitle</span></span><br><span class="line">    <span class="built_in">document</span>.title=newTitle; <span class="comment">// 分配新的页面标题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history.pushState) &#123;</span><br><span class="line">        <span class="keyword">var</span> state=(&#123;</span><br><span class="line">            url: uri, <span class="attr">title</span>: newTitle</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.history.pushState(state, newTitle, uri);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">window</span>.location.href=<span class="string">&quot;#!&quot;</span>+~fakeURI; </span><br><span class="line">    &#125; <span class="comment">// 如果不支持，使用旧的解决方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax_Load</span>(<span class="params">uri</span>)</span>&#123; ... <span class="keyword">return</span> newTitle; &#125; </span><br><span class="line"><span class="comment">// 你自定义的ajax函数，例如它会返回newTitle</span></span><br></pre></td></tr></table></figure>
<p>即可完成pushState。至于新标题newTitle的获取就是另外的问题了，例如你可以为a标签分配&gt;·<br>另外如果需要对新加载的页面的连接同样使用这个ajax，则需要对新内容的a标签重新部署，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;~newContentTarget a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="pushState-配合-popstate-监听"><a href="#pushState-配合-popstate-监听" class="headerlink" title="pushState 配合 popstate 监听"></a>pushState 配合 popstate 监听</h2><blockquote>
<p>注意：<br>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定事件处理函数.</span></span><br><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;location: &quot;</span> + <span class="built_in">document</span>.location + <span class="string">&quot;, state: &quot;</span> + <span class="built_in">JSON</span>.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&quot;title 1&quot;</span>, <span class="string">&quot;?page=1&quot;</span>);</span><br><span class="line"><span class="comment">//添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1</span></span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&quot;title 2&quot;</span>, <span class="string">&quot;?page=2&quot;</span>);</span><br><span class="line"><span class="comment">//添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&quot;title 3&quot;</span>, <span class="string">&quot;?page=3&quot;</span>); </span><br><span class="line"><span class="comment">//修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3</span></span><br><span class="line"></span><br><span class="line">history.back(); </span><br><span class="line"><span class="comment">// 弹出 &quot;location: http://example.com/example.html?page=1, state: &#123;&quot;page&quot;:1&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">history.back(); </span><br><span class="line"><span class="comment">// 弹出 &quot;location: http://example.com/example.html, state: null</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>);  </span><br><span class="line"><span class="comment">// 弹出 &quot;location: http://example.com/example.html?page=3, state: &#123;&quot;page&quot;:3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>CSS 与 JS 阻塞 DOM 解析和渲染的</title>
    <url>/2020/11/14/html/html-render/</url>
    <content><![CDATA[<p>link 标签放在头部性能会高一点，少一点人知道如果 script 与 link 同时在头部的话， script 在上可能会更好</p>
<h2 id="CSS不会阻塞-DOM-的解析"><a href="#CSS不会阻塞-DOM-的解析" class="headerlink" title="CSS不会阻塞 DOM 的解析"></a>CSS不会阻塞 DOM 的解析</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: lightgreen;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意哦！这里说的是 DOM 解析，证明的例子如下，首先在头部插入</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;/*.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>，</span><br></pre></td></tr></table></figure>
<p>JS 文件的内容是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.querySelecotor(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);  </span><br></pre></td></tr></table></figure>


<ul>
<li>defer : 用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。设置这个属性，能保证 DOM 解析后马上打印出 div。</li>
</ul>
<p>之后将</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;3s.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- (文件下载要3s) --&gt;</span></span><br></pre></td></tr></table></figure>
<p>插入 HTML 文件的任一位置，打开浏览器，可以看到是首先打印出 div 这个 DOM 节点，过 3s 左右之后才渲染出样式。这就证明了 CSS 是不会阻塞 DOM 的解析的，尽管 CSS 下载需要 3s，但这个过程中，浏览器不会傻等着 CSS 下载完，而是会解析 DOM 的。</p>
<p>浏览器是解析 DOM 生成 DOM Tree，结合 CSS 生成的 CSS Tree，最终组成 render tree，再渲染页面。</p>
<p>由此可见，在此过程中 CSS 完全无法影响 DOM Tree，因而无需阻塞 DOM 解析。</p>
<h2 id="CSS-阻塞页面渲染"><a href="#CSS-阻塞页面渲染" class="headerlink" title="CSS 阻塞页面渲染"></a>CSS 阻塞页面渲染</h2><p>如果 CSS 不会阻塞页面阻塞渲染，那么 CSS 文件下载之前，浏览器就会渲染出一个浅绿色的 div，之后再变成浅蓝色。（渲染是有成本的）。</p>
<blockquote>
<p>浏览器会尽量减少渲染的次数，CSS 顺理成章地阻塞页面渲染。</p>
</blockquote>
<p>然而，事情总有奇怪的，请看这例子，HTML 头部结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;*.css&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;*.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>答案是浏览器会转圈圈三秒，但此过程中不会打印任何东西</p>
</li>
<li><p>之后呈现出一个浅蓝色的 div</p>
</li>
<li><p>再打印出 null</p>
</li>
</ul>
<p>其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等 CSS 控制的属性，浏览器是需要计算的，也就是依赖于 CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行 JS。因而造成了之前例子的情况。</p>
<p>所以，看官大人明白为何 script 与 link 同时在头部的话， script 在上可能会更好了么？之所以是可能，是因为如果 link 的内容下载更快的话，是没影响的，但反过来的话，JS 就要等待了，然而这些等待的时间是完全不必要的。</p>
<h2 id="JS-阻塞-DOM-解析"><a href="#JS-阻塞-DOM-解析" class="headerlink" title="JS 阻塞 DOM 解析"></a>JS 阻塞 DOM 解析</h2><p>首先我们需要一个新的 JS 文件，插入header，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行数s的js</span></span><br><span class="line"><span class="keyword">const</span> div =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);</span><br></pre></td></tr></table></figure>

<ul>
<li>1.浏览器转圈圈一会，这过程中不会有任何东西出现。</li>
<li>2.之后打印出 null，</li>
<li>3.再出现一个浅绿色的 div。</li>
</ul>
<blockquote>
<p>现象就足以说明 JS 阻塞 DOM 解析了。</p>
</blockquote>
<p>其实原因也很好理解，浏览器并不知道脚本的内容是什么，如果先行解析下面的 DOM，万一脚本内全删了后面的 DOM，浏览器就白干活了。更别谈丧心病狂的 document.write。浏览器无法预估里面的内容，那就干脆全部停住，等脚本执行完再干活就好了。</p>
<p>解决方案：</p>
<ul>
<li>1.如果 JS 文件体积太大，同时你确定没必要阻塞 DOM 解析的话，不妨按需要加上 defer 或者 async 属性，此时脚本下载的过程中是不会阻塞 DOM 解析的。</li>
<li>2.如果是文件执行时间太长，不妨分拆一下代码，不用立即执行的代码，可以使用一下以前的黑科技：setTimeout()。当然，现代的浏览器很聪明，它会“偷看”之后的 DOM 内容，碰到如 link 、script 和 img 等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载。</li>
</ul>
<blockquote>
<p>浏览器遇到  script  标签时，会触发页面渲染</p>
</blockquote>
<p>这个细节可能不少看官大人并不清楚，其实这才是解释上面为何 JS 执行会等待 CSS 下载的原因。先上例子,HTML 内 body 的结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/3s.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">          background: lightgrey;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/4s.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;3s.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子也是很极端的例子，但不妨碍它透露给我们很多重要的信息。想象一下，页面会怎样呢？<br>答案是先浅绿色，再浅灰色，最后浅蓝色。</p>
<p>由此可见，每次碰到 script 标签时，浏览器都会渲染一次页面。这是基于同样的理由，浏览器不知道脚本的内容，因而碰到脚本时，只好先渲染页面，确保脚本能获取到最新的 DOM 元素信息，尽管脚本可能不需要这些信息。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述，我们得出这样的结论：</p>
<ul>
<li>CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。</li>
<li>JS 阻塞 DOM 解析，但浏览器会”偷看”DOM，预先下载相关资源。</li>
<li>浏览器遇到 script 且没有 defer 或 async 属性的 标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。</li>
</ul>
<p>所以，如果头部同时有 script 与 link 的情况下，最好将 script 放在 link 上面</p>
]]></content>
  </entry>
  <entry>
    <title>pushState、replaceState、popstate 事件阻塞 DOM 解析和渲染的</title>
    <url>/2020/11/14/html/history/</url>
    <content><![CDATA[<blockquote>
<p>HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate 配合使用。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank">MDN</a></p>
<p>使用 history.pushState() 可以改变referrer，它在用户发送 <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" title="en/XMLHttpRequest">XMLHttpRequest</a> 请求时在HTTP头部使用，改变state后创建的 <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" title="en/XMLHttpRequest">XMLHttpRequest</a> 对象的referrer都会被改变。因为referrer是标识创建  <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" title="en/XMLHttpRequest">XMLHttpRequest</a> 对象时 this 所代表的window对象中document的URL。</p>
<h2 id="pushState-方法的例子"><a href="#pushState-方法的例子" class="headerlink" title="pushState() 方法的例子"></a>pushState() 方法的例子</h2><p>假设在 <a href="http://mozilla.org/foo.html">http://mozilla.org/foo.html</a> 中执行了以下 JavaScript 代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line">history.pushState(stateObj, <span class="string">&quot;page 2&quot;</span>, <span class="string">&quot;bar.html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这将使浏览器地址栏显示为 <a href="http://mozilla.org/bar.html%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD">http://mozilla.org/bar.html，但并不会导致浏览器加载</a> bar.html ，甚至不会检查bar.html 是否存在。<br>假设现在用户又访问了 <a href="http://google.com,然后点击了返回按钮.此时,地址栏将显示/">http://google.com，然后点击了返回按钮。此时，地址栏将显示</a> <a href="http://mozilla.org/bar.html%EF%BC%8C%E5%90%8C%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%BC%9A%E8%A7%A6%E5%8F%91">http://mozilla.org/bar.html，同时页面会触发</a> popstate 事件，事件对象state中包含了 stateObj 的一份拷贝。页面本身与 foo.html 一样，尽管其在 popstate  事件中可能会修改自身的内容。<br>如果我们再次点击返回按钮，页面URL会变为<a href="http://mozilla.org/foo.html%EF%BC%8C%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1document%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA">http://mozilla.org/foo.html，文档对象document会触发另外一个</a> popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。</p>
<h2 id="pushState-方法"><a href="#pushState-方法" class="headerlink" title="pushState() 方法"></a>pushState() 方法</h2><p>pushState() 需要三个参数: </p>
<ul>
<li><p>一个状态对象,</p>
<p>  状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。</p>
<p>  状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.</p>
</li>
<li><p>一个标题 (目前被忽略),<br> 标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。</p>
</li>
<li><p>(可选的) 一个URL.<br>   该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</p>
</li>
</ul>
<blockquote>
<p>注意: 从 Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) 到 Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2)，传递的对象是使用JSON进行序列化的。 从  Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)开始，该对象的序列化将使用<a href="https://developer.mozilla.org/en/DOM/The_structured_clone_algorithm" title="en/DOM/The structured clone algorithm">结构化克隆算法</a>。这将会使更多对象可以被安全的传递。</p>
</blockquote>
<pre><code>    在某种意义上，调用 pushState() 与 设置 window.location = &quot;#foo&quot; 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点：
    新的 URL 可以是与当前URL同源的任意URL 。而设置 window.location 仅当你只修改了哈希值时才保持同一个document
    如果需要，你可以不必改变URL。而设置 window.location = &quot;#foo&quot;;在当前哈希不是 #foo 的情况下， 仅仅是新建了一个新的历史记录项。
    你可以为新的历史记录项关联任意数据。而基于哈希值的方式，则必须将所有相关数据编码到一个短字符串里。 
    假如 标题 在之后会被浏览器用到，那么这个数据是可以被使用的（哈希则不然）。</code></pre>
<blockquote>
<p>注意 pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。</p>
</blockquote>
<p>在 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL">XUL</a> 文档中，它创建指定的 XUL 元素。</p>
<p>在其它文档中，它创建一个命名空间URI为null的元素。</p>
<h2 id="replaceState-方法"><a href="#replaceState-方法" class="headerlink" title="replaceState() 方法"></a>replaceState() 方法</h2><p>history.replaceState() 的使用与 history.pushState() 非常相似，区别在于  </p>
<ul>
<li>replaceState()  是修改了当前的历史记录项而不是新建一个。 注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。</li>
<li>replaceState() 的使用场景在于为了响应用户操作，你想要更新状态对象state或者当前历史记录的URL。</li>
</ul>
<blockquote>
<p>注意： 从Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) 到 Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2)，传递的对象是使用JSON进行序列化的。 从  Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)开始，该对象的序列化将使用<a href="https://developer.mozilla.org/en/DOM/The_structured_clone_algorithm" title="en/DOM/The structured clone algorithm">结构化克隆算法</a>。这将会使更多对象可以被安全的传递。</p>
</blockquote>
<h2 id="replaceState-方法示例"><a href="#replaceState-方法示例" class="headerlink" title="replaceState() 方法示例"></a>replaceState() 方法示例</h2><p>假设 <a href="http://mozilla.org/foo.html">http://mozilla.org/foo.html</a> 执行了如下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateObj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line">history.pushState(stateObj, <span class="string">&quot;page 2&quot;</span>, <span class="string">&quot;bar.html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上文2行代码可以在 “pushState()方法示例” 部分找到。然后，假设<a href="http://mozilla.org/bar.html%E6%89%A7%E8%A1%8C%E4%BA%86%E5%A6%82%E4%B8%8B">http://mozilla.org/bar.html执行了如下</a> JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.replaceState(stateObj, <span class="string">&quot;page 3&quot;</span>, <span class="string">&quot;bar2.html&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这将会导致地址栏显示<a href="http://mozilla.org/bar2.html,%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E4%B8%8D%E4%BC%9A%E5%8E%BB%E5%8A%A0%E8%BD%BDbar2.html">http://mozilla.org/bar2.html,，但是浏览器并不会去加载bar2.html</a> 甚至都不需要检查 bar2.html 是否存在。</p>
<p>假设现在用户重新导向到了<a href="http://www.microsoft.com,然后点击了回退按钮.这里,地址栏会显示http//mozilla.org/bar2.html%E3%80%82%E5%81%87%E5%A6%82%E7%94%A8%E6%88%B7%E5%86%8D%E6%AC%A1%E7%82%B9%E5%87%BB%E5%9B%9E%E9%80%80%E6%8C%89%E9%92%AE%EF%BC%8C%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BC%9A%E6%98%BE%E7%A4%BAhttp://mozilla.org/foo.html%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%B7%B3%E8%BF%87%E4%BA%86bar.html%E3%80%82">http://www.microsoft.com，然后点击了回退按钮。这里，地址栏会显示http://mozilla.org/bar2.html。假如用户再次点击回退按钮，地址栏会显示http://mozilla.org/foo.html，完全跳过了bar.html。</a></p>
<h2 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h2><p>每当活动的历史记录项发生变化时， popstate 事件都会被传递给window对象。如果当前活动的历史记录项是被 pushState 创建的，或者是由 replaceState 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。</p>
<p>使用示例请参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate" title="window.onpopstate是popstate事件在window对象上的事件处理程序.">window.onpopstate</a> 。</p>
<h2 id="获取当前状态"><a href="#获取当前状态" class="headerlink" title="获取当前状态"></a>获取当前状态</h2><p>页面加载时，或许会有个非null的状态对象。这是有可能发生的，</p>
<p>举个例子:</p>
<p>假如页面（通过pushState() 或 replaceState() 方法）设置了状态对象而后用户重启了浏览器。那么当页面重新加载时，页面会接收一个onload事件，但没有 popstate 事件。然而，假如你读取了history.state属性，你将会得到如同popstate 被触发时能得到的状态对象。</p>
<p>你可以读取当前历史记录项的状态对象state，而不必等待popstate 事件， 只需要这样使用history.state 属性： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentState = history.state;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>通过rel=&quot;preload&quot;进行内容预加载</title>
    <url>/2020/11/14/html/link-preload/</url>
    <content><![CDATA[<blockquote>
<p>link 元素的 rel 属性的属性值preload能够让你在你的HTML页面中 head元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的</p>
</blockquote>
<p>对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。本文提供了一个如何有效使用preload机制的基本说明。</p>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p>link 标签最常见的应用情形就是被用来加载CSS文件，进而装饰你的页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles/main.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是在这里，我们将使用preload作为rel属性的属性值。这种做法将把<link> 元素塞入一个预加载器中，这个预加载器也将用于其他我们所需要的，各种各样的，任意类型的资源。为了完成基本的配置，你还需要通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-href">href</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-as">as</a> 属性指定需要被预加载资源的资源路径及其类型。<br>一个简单的例子可能看起来像下面这样 （在这里可以查看示例的<a rel="noopener" href="https://github.com/mdn/html-examples/tree/master/link-rel-preload/js-and-css">JS和CSS源代码</a>，或是<a rel="noopener" href="https://mdn.github.io/html-examples/link-rel-preload/js-and-css/">在线实例</a>）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS and CSS preload example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>bouncing balls<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们预加载了CSS和JavaScript文件，所以在随后的页面渲染中，一旦需要使用它们，它们就会立即可用。这个例子本身可能有些平淡，但预加载的好处可以更清晰直观的得到展示，在随后的渲染过程中，这些资源得到有效使用。对于更大的文件来说，也是如此。 例如那些在CSS文件中指向的资源，比如字体或是图片；再比如更大的图片和视频文件。</p>
<p>preload 还有许多其他好处。使用 as 来指定将要预加载的内容的类型，将使得浏览器能够：</p>
<ul>
<li>更精确地优化资源加载优先级。</li>
<li>匹配未来的加载需求，在适当的情况下，重复利用同一资源。<br>为资源应用正确的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">内容安全策略</a>。<br>为资源设置正确的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept">Accept</a> 请求头。</li>
</ul>
<h2 id="哪些类型的内容可以被预加载？"><a href="#哪些类型的内容可以被预加载？" class="headerlink" title="哪些类型的内容可以被预加载？"></a>哪些类型的内容可以被预加载？</h2><p>许多不同类型的内容都可以被预加载，一些主要可用的 as 属性值列举如下：</p>
<ul>
<li>audio: 音频文件。</li>
<li>document: 一个将要被嵌入到<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/frame">frame</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" >iframe</a>内部的HTML文档。</li>
<li>embed: 一个将要被嵌入到<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" title="HTML <embed> 元素将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供。"><embed></a>元素内部的资源。</li>
<li>fetch: 那些将要通过fetch和XHR请求来获取的资源，比如一个ArrayBuffer或JSON文件。</li>
<li>font: 字体文件。</li>
<li>image: 图片文件。</li>
<li>object: 一个将会被嵌入到<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed" title="HTML <embed> 元素将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供。"><embed></a>元素内的文件。</li>
<li>script: JavaScript文件。</li>
<li>style: 样式表。</li>
<li>track: WebVTT文件。</li>
<li>worker: 一个JavaScript的web worker或shared worker。</li>
<li>video: 视频文件。</li>
</ul>
<p>注意: 你可以通过进一步阅读<a rel="noopener" href="https://w3c.github.io/preload/#link-element-extensions">link element extensions</a>来了解关于这些属性值以及其他在Preload方案中预期将采纳的特性的细节。同样需要注意的是，关于as属性的有效值得完整列表是由Fetch方案来制定的，可以查看<a rel="noopener" href="https://fetch.spec.whatwg.org/#concept-request-destination">request destinations</a>来进行了解。</p>
<h2 id="包含一个MIME类型"><a href="#包含一个MIME类型" class="headerlink" title="包含一个MIME类型"></a>包含一个MIME类型</h2><p>link 元素可以接受一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-type">type</a>属性。这一属性可以包含该元素所 指向资源的MIME类型。在浏览器进行 预加载的时候，这个属性值将会 非常有用——浏览器将使用type属性来判断它是否支持这一资源，如果浏览器支持这一类型资源的预加载，下载将会开始，否则便对其加以忽略。</p>
<p>你可以在我们的视频示例中看到一个与此有关的示例（<a href="https://github.com/mdn/html-examples/tree/master/link-rel-preload/video" target="_blank">查看完整源码</a>，也可以<a href="https://mdn.github.io/html-examples/link-rel-preload/js-and-css/" target="_blank">查看在线示例</a>）:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Video preload example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sintel-short.mp4&quot;</span> <span class="attr">as</span>=<span class="string">&quot;video&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;sintel-short.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;sintel-short.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML5 video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sintel-short.mp4&quot;</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个实例中，支持MP4格式的浏览器将仅预加载并使用MP4资源，以使得视频播放器的表现尽可能的流畅，或者说，为用户提供更好的响应。而不支持MP4格式的浏览器仍然能够加载视频的WebM版本，但无法体验到预加载带来的良好体验。这个例子展示了预加载机制如何与渐进式增强的哲学进行有机的结合。</p>
<h2 id="跨域获取"><a href="#跨域获取" class="headerlink" title="跨域获取"></a>跨域获取</h2><p>如果你已经有了一个可以正确工作的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a>设置，那么你也可以同样成功的预加载那些跨域资源，只需要你在<link>元素中设置好<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-crossorigin">crossorigin</a>属性即可。</p>
<p>一个有趣的情况是，如果你需要获取的是字体文件，那么即使是非跨域的情况下，也需要应用这一属性。因为各种各样的原因，这些获取请求必须使用以匿名模式使用CORS（如果你对其中的细节感兴趣，可以查看<a href="https://drafts.csswg.org/css-fonts/#font-fetching-requirements" target="_blank">Font fetching requirements</a>一文）。</p>
<p>我们将以这个情况作为一个示例——首先是由于字体文件的加载是预加载方面一个好的用例，其次，这也比真正的配置一个跨域请求的例子要简单许多。你可以查看 <a href="https://github.com/mdn/html-examples/tree/master/link-rel-preload/fonts" target="_blank">在Github上的示例源代码</a>（也可以查看<a href="https://mdn.github.io/html-examples/link-rel-preload/fonts/" target="_blank">在线示例</a>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web font example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span><span class="attr">href</span>=<span class="string">&quot;fonts/cicle_fina-webfont.eot&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/vnd.ms-fontobject&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/cicle_fina-webfont.woff2&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/woff2&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/cicle_fina-webfont.woff&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/woff&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/cicle_fina-webfont.ttf&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/ttf&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/cicle_fina-webfont.svg&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/zantroke-webfont.eot&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/vnd.ms-fontobject&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/zantroke-webfont.woff2&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/woff2&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/zantroke-webfont.woff&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/woff&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/zantroke-webfont.ttf&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/ttf&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/zantroke-webfont.svg&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，在这里，我们不仅通过配置type属性提供了一个MIME类型的暗示，我们也提供了一个crossorigin 属性来处理CORS问题。</p>
<h2 id="包含媒体"><a href="#包含媒体" class="headerlink" title="包含媒体"></a>包含媒体</h2><link>元素有一个很棒的特性是它们能够接受一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-media">media</a>属性。它们可以接受<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media#Media_types">媒体类型</a>或有效的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries">媒体查询</a>作为属性值，这将令你能够使用响应式的预加载！
让我们来看一个简单的示例（可以查看<a href="https://github.com/mdn/html-examples/tree/master/link-rel-preload/media" target="_blank">Github上的源代码</a>或<a href="https://mdn.github.io/html-examples/link-rel-preload/media/" target="_blank">在线示例</a>）：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Responsive preload example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;bg-image-narrow.png&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">media</span>\&quot;(<span class="attr">max-width:</span> <span class="attr">600px</span>)&quot;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;bg-image-wide.png&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 601px)&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My site<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> mediaQueryList = <span class="built_in">window</span>.matchMedia(<span class="string">&quot;(max-width: 600px)&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> header = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;header&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">if</span>(<span class="params">mediaQueryList.matches</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          header.style.backgroundImage = <span class="string">&#x27;url(bg-image-narrow.png)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          header.style.backgroundImage = <span class="string">&#x27;url(bg-image-wide.png)&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到我们在link元素中包含了一个media属性，因此，当用户在使用较窄屏幕的设备时，较窄的图片将会被预加载，而在较宽的设备上，较宽的图片将被预加载。然后我们仍需要在header元素上附加合适的图片——通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia" title="返回一个新的MediaQueryList 对象，表示指定的媒体查询字符串解析后的结果。">Window.matchMedia</a> / <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList" title="一个MediaQueryList对象在一个document上维持着一系列的媒体查询，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。">MediaQueryList</a> 来加以实现（可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Testing_media_queries">Testing media queries</a>一文来了解更多信息）。<br>这一特性将使另一种情况成为可能——字体在随着页面渲染完成的时候即可使用，减少了FOUT (无样式字体闪烁，flash of unstyled text)问题。<br>值得注意的是，这一特特性并不仅限于图片，或其他有着同样类型的文件，还有更多想象空间。比如，你可以在用户仅有较窄的屏幕，CPU和带宽资源较为有限的情况下预加载并展示一个简单的SVG图表，而在用户资源较为充裕的时候再去加载一系列复杂的JavaScript文件以显示一个有交互功能的3D模型。</p>
<h2 id="脚本化与预加载"><a href="#脚本化与预加载" class="headerlink" title="脚本化与预加载"></a>脚本化与预加载</h2><p>另一项很棒的关于预加载的事情是，如果需要，你可以完全以脚本化的方式来执行这些预加载操作。例如，我们在这里创建一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLLinkElement" target="_blank">HTMLLinkElement</a>实例，然后将他们附加到DOM上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadLink = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">preloadLink.href = <span class="string">&quot;myscript.js&quot;</span>;</span><br><span class="line">preloadLink.rel = <span class="string">&quot;preload&quot;</span>;</span><br><span class="line">preloadLink.as = <span class="string">&quot;script&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(preloadLink);</span><br></pre></td></tr></table></figure>
<p>这意味着浏览器将预加载这个JavaScript文件，但并不实际执行它。<br>如果要对其加以执行，在需要的时候，你可以执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadedScript = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">preloadedScript.src = <span class="string">&quot;myscript.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(preloadedScript);</span><br></pre></td></tr></table></figure>
<p>当你需要预加载一个脚本，但需要推迟到需要的时候才令其执行时，这种方式会特别有用。</p>
<h2 id="其他资源预加载机制"><a href="#其他资源预加载机制" class="headerlink" title="其他资源预加载机制"></a>其他资源预加载机制</h2><p>还存在一些其他预加载机制，但没有哪个会比<code>&lt;link rel=&quot;preload&quot;&gt;</code>在大多数情况下更符合你的需要和预期：<br><code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 已经被许多浏览器支持了相当长的时间，但它是意图预获取一些资源，以备下一个导航/页面使用（比如，当你去到下一个页面时）。这很好，但对当前的页面并没有什么助益。此外，浏览器会给使用prefetch的资源一个相对较低的优先级——与使用preload的资源相比。毕竟，当前的页面比下一个页面相对更加重要。查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ">Link prefetching FAQ</a>可以了解更多细节。</p>
<p><code>&lt;link rel=&quot;subresource&quot;&gt;</code>被Chrome支持了有一段时间，并且已经有些搔到预加载当前导航/页面（所含有的资源）的痒处了。但它有一个问题——没有办法处理所获取内容的优先级（as也并不存在），所以最终，这些资源会以一个相当低的优先级被加载，这使得它能提供的帮助相当有限。</p>
<p>除以上这些意外，还有大量的基于脚本的资源加载器。但这些加载器对于浏览器的加载优先级队列完全束手无策，这也使得他们不得不屈服于同样的性能问题。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" style="font-size: x-large;">MDN</a><br></p>
]]></content>
  </entry>
  <entry>
    <title>HTML 中&lt;link&gt;元素</title>
    <url>/2020/11/14/html/link/</url>
    <content><![CDATA[<blockquote>
<p>HTML 中link元素规定了外部资源与当前文档的关系。 这个元素可用来为导航定义一个关系框架。这个元素最常于链接样式表。</p>
</blockquote>
<table><tbody><tr><th><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories">内容类型</a></th><td>元数据。如果使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemprop">itemprop</a> 属性, 则为 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#Flow_content">flow content</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#Phrasing_content">phrasing content</a>.</td></tr><tr><th>允许的元素内容</th><td>无，这是一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0" title="The definition of that term (空元素) has not been written yet; please consider contributing it!">空元素</a>。</td></tr><tr><th>标签省略</th><td>鉴于这是一个空元素，开始标签必须存在，结束标签必须不存在。</td></tr><tr><th>允许的父元素</th><td>任何可以接受元数据的元素.。如果使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemprop">itemprop</a>属性,，则其父元素可以是任何可接受 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#Phrasing_content">phrasing content</a> 的元素。</td></tr><tr><th>DOM接口</th><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLLinkElement" title="The HTMLLinkElement interface represents reference information for external resources and the relationship of those resources to a document and vice-versa. This object inherits all of the properties and methods of the HTMLElement interface.">HTMLLinkElement</a></td></tr></tbody></table>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>这个元素可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes">全局属性</a></p>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>该属性仅在 link 元素设置了 rel=”preload” 时才能使用。</p>
<p>它规定了 link 元素加载的内容的类型，对于内容的优先级、请求匹配、正确的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略</a>的选择以及正确的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept</a> 请求头的设置，这个属性是必需的。</p>
<h3 id="crossorigin"><a href="#crossorigin" class="headerlink" title="crossorigin"></a>crossorigin</h3><p>此枚举属性指定在加载相关图片时是否必须使用 CORS.<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_Enabled_Image"> 启用 CORS 的图片</a> 可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">canvas</a> 元素中使用, 并避免其被污染. </p>
<p>可取的值如下:</p>
<pre><code>&quot;anonymous&quot;

会发起一个跨域请求(即包含 Origin: HTTP 头). 但不会发送任何认证信息 (即不发送 cookie, X.509 证书和 HTTP 基本认证信息). 如果服务器没有给出源站凭证 (不设置 Access-Control-Allow-Origin: HTTP 头), 这张图片就会被`污染并限制使用`.

 &quot;use-credentials&quot;

会发起一个带有认证信息 (发送 cookie, X.509 证书和 HTTP 基本认证信息) 的跨域请求 (即包含 Origin: HTTP 头). 如果服务器没有给出源站凭证 (不设置 Access-Control-Allow-Origin: HTTP 头), 这张图片就会被`污染并限制使用`.</code></pre>
<p>当不设置此属性时, 资源将会不使用 CORS 加载 (即不发送 Origin: HTTP 头), 这将阻止其在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" >canvas</a> 元素中进行使用. 若设置了非法的值, 则视为使用 anonymous. 前往 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes">CORS settings attributes</a> 获取更多信息.</p>
<h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3><p>此属性被用于禁用链接关系. 配合脚本使用, 该属性可以用来启用或禁用多个样式表链接.</p>
<blockquote>
<p>使用注意: 虽然在 HTML 标准中没有 disabled 属性, 但在 HTMLLinkElement DOM 对象中确实存在 disabled 属性.</p>
</blockquote>
<p>使用 disabled 作为 HTML 属性是非标准的, 并且只有部分浏览器使用 (<a rel="noopener" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27677">W3 #27677</a>)。</p>
<p>所以不要使用它。要达到类似的效果, 可以选用以下方法:</p>
<blockquote>
<p>如果 disabled 属性已经直接加入到页面元素中, 可以改为不引入这个这个 link元素</p>
</blockquote>
<blockquote>
<p>通过脚本为该样式表 DOM 对象设置 disabled 属性.</p>
</blockquote>
<h3 id="href"><a href="#href" class="headerlink" title="href"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link">href</a></h3><h3 id="hreflang"><a href="#hreflang" class="headerlink" title="hreflang"></a>hreflang</h3><p>此属性指明了被链接资源的语言. 其意义仅供参考。可取的值参见 <a rel="noopener" href="http://www.ietf.org/rfc/bcp/bcp47.txt">BCP47</a>。仅当设置了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a#attr-href">href</a> 属性时才应设置该属性。</p>
<h3 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h3><p>包含行内元数据，它是一个你用浏览器获取的资源文件的哈希值，以base64编码的方式加的密，这样用户能用它来验证一个获取到的资源,在传送时未被非法篡改，详情查看<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a>。</p>
<h3 id="media"><a href="#media" class="headerlink" title="media"></a>media</h3><p>这个属性规定了外部资源适用的媒体类型。它的值必须是”<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">媒体查询</a>“。这个属性使得用户代理能选择最适合设备运行的媒体类型。</p>
<blockquote>
<p>使用注意：<br>在HTML 4中，该属性只能是一组以空白符作为分隔的媒体描述文字，比如”<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">媒体类型</a>“规定了该元素可取的属性，如print、screen、aural、braille。HTML5将该属性值扩展为任意类型的”<a rel="nofollow" href="https://developer.mozilla.org/zh-CN/docs/CSS/Media_queries">媒体查询</a>“，”媒体查询”将HTML4的属性值都包括在内。<br>不支持”<a rel="nofollow" href="https://developer.mozilla.org/zh-CN/docs/CSS/Media_queries">CSS3 媒体查询</a>“的浏览器并不会强行识别这些链接，因此忘了设置备用link，即那些可用于HTML4的link。</p>
</blockquote>
<h3 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h3><p>此属性指明被链接文档对于当前文档的关系。这个属性一定得是一个由空格分开的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types">链接类型值</a>的列表。 这个属性最通常的用法是指向一个连接到外部样式表的链接：将rel的值设置为stylesheet，href属性设置为外部样式表的URL来构造网页。网络电视还支持使用下一个rel的值在一系列页面中预加载下一个页面。</p>
<h3 id="sizes"><a href="#sizes" class="headerlink" title="sizes"></a>sizes</h3><p>这个属性定义了包含相应资源的可视化媒体中的icons的大小。它只有在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#attr-rel">rel</a>包含icon的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types">link类型值</a>。它可能有如下的规则。</p>
<p>any，意味着这个icon能够被缩放到任意尺寸当它是矢量形式，比如image/svg+xml。<br>一个由空白符分隔的尺寸列表。每一个都以x 或 X给出。尺寸列表中的每一个尺寸都必须包含在资源里。</p>
<blockquote>
<p>用法注意：</p>
</blockquote>
<p>大多数的icon格式只能存储一个icon。因此绝大多数使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-sizes">sizes</a>时只包含一个值。微软的ICO格式和苹果的ICNS格式都是这样，ICO使用得更加广泛，推荐你使用它。<br>苹果的IOS系统并不支持这个属性，于是苹果的IPhone以及IPad使用特殊的、非标准的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types">link类型值</a>去定义作为Web Clip或开始占位符：apple-touch-icon 和 apple-touch-startup-icon。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>Defines the frame or window name that has the defined linking relationship or that will show the rendering of any linked resource.</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>这个属性被用于定义链接的内容的类型。这个属性的值应该是像text/html，text/css等MIME类型。这个属性常用的用法是定义链接的样式表，最常用的值是表明了CSS的text/css。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6">样式表加载事件</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link#%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"></a>能够通过监听发生在样式表上的事件知道什么时候样式表加载完毕。同样的，你能够通过监听error事件检测到是否在加载样式表的过程中出现错误。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">sheetLoaded</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// Do something interesting; the sheet has been loaded</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">sheetError</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;An error occurred loading the stylesheet!&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystylesheet.css&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;sheetLoaded()&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;sheetError()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>link 标签只能出现在head元素中，然而可以出现多个link标签。<br>HTML 3.2只为link元素定义了href, methods, rel，rev，title，和urn属性。<br>HTML 2为link标签定义了 href, methods，rel，rev，title，和 urn 属性，methods 和 urn随后从规范中移除。<br>HTML和XHTML规范为link定义了事件处理，但是并不清楚它们将会怎样被使用。<br>在XHTML 1.0中，空元素link要求有尾随斜线，像这样link。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link">MDN</a></p>
]]></content>
  </entry>
  <entry>
    <title>rel=nofollow属性</title>
    <url>/2020/11/14/html/nofollow/</url>
    <content><![CDATA[<blockquote>
<p>nofollow是HTML元标签(meta)的content属性和链接标签(a)的rel属性的一个值，告诉机器(爬虫)无需追踪目标页，为了对抗blogspam(博客垃圾留言信息)，Google推荐使用nofollow，告诉搜索引擎爬虫无需抓取目标页，同时告诉搜索引擎无需将的当前页的Pagerank传递到目标页。但是如果你是通过sitemap直接提交该页面，爬虫还是会爬取，这里的nofollow只是当前页对目标页的一种态度，并不代表其他页对目标页的态度。</p>
</blockquote>
<h2 id="nofollow的使用"><a href="#nofollow的使用" class="headerlink" title="nofollow的使用"></a>nofollow的使用</h2><p>nofollow有<br>两种用法：</p>
<ul>
<li>用于meta元标签：<code>&lt;meta name=&quot;robots&quot; content=&quot;nofollow&quot; /&gt;</code>，告诉爬虫该页面上所有链接都无需追踪。</li>
<li>用于a标签：<code>&lt;a href=&quot;login.aspx&quot; rel=&quot;nofollow&quot;&gt;登录&lt;/a&gt;</code>,告诉爬虫该页面无需追踪。<h3 id="nofollow的作用"><a href="#nofollow的作用" class="headerlink" title="nofollow的作用"></a>nofollow的作用</h3></li>
</ul>
<p>nofollow主要有三个作用：</p>
<ul>
<li>防止不可信的内容，最常见的是博客上的垃圾留言与评论中为了获取外链的垃圾链接，为了防止页面指向一些拉圾页面和站点。</li>
<li>付费链接：为了防止付费链接影响Google的搜索结果排名，Google建议使用nofollow属性。</li>
<li>引导爬虫抓取有效的页面：避免爬虫抓取一些无意义的页面，影响爬虫抓取的效率。</li>
</ul>
<h3 id="PR修剪-Pagerank-Sculpting"><a href="#PR修剪-Pagerank-Sculpting" class="headerlink" title="PR修剪(Pagerank Sculpting)"></a>PR修剪(Pagerank Sculpting)</h3><p>nofollow的滥用，一些SEO为了做到搜索引擎的最大优化，通过nofollow来控制PR的流动，可以很好的优化一些特定页面。当然这种优化比较适合一些已经积淀了相当数量PR的老站点。为了防止PR修剪和nofollow的滥用，Google已经减弱了nofollow的作用，以前的nofollow不仅仅不会造成PR流动，同时不会造成PR损失，现在的nofollow规定虽然也不会造成PR流向目标页，但是原本流向的目标页的将会损失掉。比方当前页PR为1，而且页面上有10个链接，其中一个是nofollow的链接，根据先前的nofollow的规定，每个非nofollow链接指向的目标页将获得1/9的PR，含nofollow的链接不能获得PR，而根据现在Google对nofollow的新规定，非nofollow链接指向的目标页只能获得1/10，nofollow链接同样不能获得PR，也就是损失了1/10的PR。</p>
<h2 id="SEO建议"><a href="#SEO建议" class="headerlink" title="SEO建议"></a>SEO建议</h2><p>nofollow在Google的作用已经很弱，所以SEO要控制站点的PR的流动，避免链接指向垃圾页面，只能靠人工审核的方法。</p>
<h2 id="SEO基础更多阅读"><a href="#SEO基础更多阅读" class="headerlink" title="SEO基础更多阅读"></a>SEO基础更多阅读</h2><p><a target="_blank" href="http://www.cnblogs.com/shuchao/archive/2009/09/17/url-normalization.html">URL规范化(URL normalization)</a></p>
<p><a target="_blank" href="http://www.cnblogs.com/shuchao/archive/2009/09/14/keyword-stuffing.html">关键词堆砌(Keyword Stuffing)</a></p>
<p><a target="_blank" href="http://www.cnblogs.com/shuchao/archive/2009/09/13/cloaking.html">隐藏页(Cloaking)、伪装、障眼法</a></p>
<p><a target="_blank" href="http://www.cnblogs.com/shuchao/archive/2009/09/12/Doorway-Page.html">桥页(Bridge Page)，门页(Doorway Page)</a></p>
<p><a target="_blank" href="http://www.cnblogs.com/shuchao/archive/2009/09/10/link-rot.html">链接无效(link rot)、链接出错</a></p>
]]></content>
  </entry>
  <entry>
    <title>video新版本 Chrome自动播放报错</title>
    <url>/2020/11/14/html/video-auto-err/</url>
    <content><![CDATA[<blockquote>
<p>解决新版本 Chrome 提示 DOMException: The play() request was interrupted</p>
</blockquote>
<h2 id="解决新版本-Chrome-提示"><a href="#解决新版本-Chrome-提示" class="headerlink" title="解决新版本 Chrome 提示"></a>解决新版本 Chrome 提示</h2><p>DOMException: The play() request was interrupted<br>大概在一些新版本的浏览器中，我们是用 audio 或者 video 进行媒体资源播放的时候，可能会在控制台看到这个输出:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) DOMException: The play() request was interrupted by a call to pause(). </span><br></pre></td></tr></table></figure>

<p>Or</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) DOMException: The play() request was interrupted by a <span class="keyword">new</span> load request.  </span><br></pre></td></tr></table></figure>

<h2 id="如何触发？"><a href="#如何触发？" class="headerlink" title="如何触发？"></a>如何触发？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video id=<span class="string">&quot;video&quot;</span> preload=<span class="string">&quot;none&quot;</span> src=<span class="string">&quot;https://example.com/file.mp4&quot;</span>&gt;&lt;/video&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">  video.play(); <span class="comment">// &lt;-- This is asynchronous!</span></span><br><span class="line">  video.pause();</span><br><span class="line">&lt;/script&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码会造成下面的异常错误:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) DOMException: The play() request was interrupted by a call to pause(). </span><br></pre></td></tr></table></figure>

<p>上面的 video 的 设置了 preload = ‘none’ ，视频并没有提前加载，因此在触发 video.play() 并不能立即播放。<br>从 Chrome 50 的版本后 触发 video.play 会返回一个 Promise 对象 ，如果播放成功，则 Promise 会触发，然后 playing 事件同时也会触发。如果播放失败，则会触发 Promise 的 reject,参数会带有错误的信息。<br>现在触发的顺序：</p>
<ul>
<li>video.play() 异步的去加载 video 内容，</li>
<li>video.pause() 中断视频的加载，因为视频并没有就绪</li>
<li>video.play() 异步的 rejects<br>因为我们并没有处理 video.play 的 Promise ，然后一个错误的信息会暴露出来。<br>video.pause() 不光会打断一个视频的播放，而且会完全重置一个视频的播放的状态，包括 buffer 和 video.load这些<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/file.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="comment">// Show loading animation.</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> playPromise = video.play();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (playPromise !== <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="javascript">        playPromise.then(<span class="function"><span class="params">_</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 这个时候可以安全的暂停</span></span></span><br><span class="line">      video.pause();</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    .catch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如今现在 HTMLMediaElement.play() 支持返回 Promise 已经在 Chrome, Firefox, Opera, 以及 Safari Edge 实现了。</p>
]]></content>
  </entry>
  <entry>
    <title>视频播放</title>
    <url>/2020/11/14/html/video-play/</url>
    <content><![CDATA[<p>随着流量时代的到来和硬件技术的提升，越来越多的网站希望能在PC端或移动端播放自己的视频，而 video的兼容性的逐渐完善，使得开发者更愿意使用它来实现视频播放场景。</p>
<p><a href="https://juejin.im/post/5b189712f265da6e235488c1/">视频播放–踩坑小计</a></p>
<hr>
<h2 id="场景一：自动播放"><a href="#场景一：自动播放" class="headerlink" title="场景一：自动播放"></a>场景一：自动播放</h2><blockquote>
<p>autoPlay : boolean</p>
</blockquote>
<p>指定后，视频会马上自动开始播放，不会停下来等着数据载入结束。</p>
<p>视频自动播放可以在页面打开且资源加载足够的情况下让视频自动播放，减少一次用户点击的交互，同时可以应用在动效背景、H5仿视频通话的功能。不过由于各种原因，自动播放无论在PC端还是移动端都有不同程度的限制。<a href="www.webq.top/video-auto">看下一篇</a></p>
<ul>
<li>移动端 IOS</li>
</ul>
<p>早期必须要有用户手势（user gesture）video标签才可以播放；<br>从版本10开始修改了video的规则，<a href="https://link.juejin.im/?target=https://webkit.org/blog/6784/new-video-policies-for-ios/">苹果放宽了inline和autoplay</a>，策略如下（仅适用于Safari浏览器）：</p>
<p>video  </p>
<blockquote>
<p>elements will be allowed to autoplay  without a user gesture if their source media contains no audio tracks.(无音频源的 video 元素 允许自动播放)</p>
</blockquote>
<p>video muted  </p>
<blockquote>
<p>elements will also be allowed to autoplay without a user gesture.</p>
</blockquote>
<p>禁音的 video 元素允许自动播放</p>
<blockquote>
<p>If a ‘video’  element gains an audio track or becomes un-muted without a user gesture, playback will pause.</p>
</blockquote>
<p>如果 video 元素在没有用户手势下有了音频源或者变成非禁音，会暂停播放</p>
<p>video autoplay</p>
<blockquote>
<p> elements will only begin playing when visible on-screen such as when they are scrolled into the viewport, made visible through CSS, and inserted into the DOM.</p>
</blockquote>
<p>video 元素屏幕可见才开始播放</p>
<p>video autoplay</p>
<blockquote>
<p> elements will pause if they become non-visible, such as by being scrolled out of the viewport.</p>
</blockquote>
<p>video元素不可见后停止播放</p>
<ul>
<li>安卓</li>
</ul>
<p>早期 同样需要用户手势才可以播放；<br>安卓的 chrome 53 后<a href="https://link.juejin.im/?target=https://developers.google.com/web/updates/2016/07/autoplay">放宽了自动播放策略</a>，策略不同于IOS的Safari，需要同时对 video 设置 autoplay  和 muted （是否禁音），才允许自动播放；</p>
<p>安卓的 FireFox 和 UC 浏览器 支持任何情况下的自动播放；</p>
<p>安卓的其他浏览器暂时不清楚情况；</p>
<ul>
<li>PC端</li>
</ul>
<p>早期是支持自动播放，但近来 Safari、Chrome陆续修改了自动播放的策略……</p>
<p>Safari 浏览器<br>Safari 10  后带音频的视频和音频默认禁止自动播放，<a href="https://webkit.org/blog/7734/auto-play-policy-changes-for-macos">更多信息可以参考这篇文章；</a></p>
<p>Chrome 浏览器</p>
<p>禁音的视频依旧可以播放，带声音的视频会根据媒体参与指数 来决定能否自动播放，那什么是媒体参与指数？官方给了解释和相关的维度：</p>
<blockquote>
<p>MEI 是一个评估用户对于当前站点的媒体参与程度的指数，它取决于下面几个维度:</p>
</blockquote>
<ul>
<li>用户在媒体上停留时间超过了 7秒以上</li>
<li>音频必须是展示出来，并且没有静音</li>
<li>与 video 之间有过交互</li>
<li>媒体的尺寸不小于 200x140.</li>
</ul>
<p><strong><em>检测能否自动播放</em></strong></p>
<p>好在无论是 Safari 还是 Chrome，在限制了自动播放的同时，提供了检测视频是否能自动播放的机制，以便于开发者在发现无法自动播放时有备选方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>).play();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (promise !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        promise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Auto-play was prevented</span></span><br><span class="line">        <span class="comment">// Show a UI element to let the user manually start playback</span></span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Auto-play started</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考</p>
<p><strong><em>为什么早期禁止视频自动播放?</em></strong></p>
<p>because it can be disruptive, many users don’t like it.<br><a href="https://link.juejin.im/?target=http://ux.stackexchange.com/questions/5252/video-and-audio-autoplay-evidence-that-its-bad-practice">(因为它是破坏性的、需要大量流量同时很多用户不喜欢它)</a></p>
<p><strong><em>为什么又允许自动播放?</em></strong></p>
<ul>
<li><p>有些开发者使用其他方式如 canvas、gif 等来实现视频自动播放的效果，但是性能上、流量消耗上都远不如视频播放；</p>
</li>
<li><p>现在流量便宜了、手机硬件越来越好了；</p>
</li>
<li><p>用户可以通过设置来禁止自动播放（开启省流量模式等）；</p>
</li>
</ul>
<p><strong><em>为什么 IOS 下微信和钉钉可以自动播放带声音的视频？</em></strong></p>
<p>确实发现在微信经常能看到自动播放的H5，但是作者自己写的设置了 autoplay、playsInline 的视频播放样例，在微信上依旧无法自动播放，而在钉钉上却可以自动播放</p>
<table>
<thead>
<tr>
<th>系统-浏览器</th>
<th>带声音</th>
<th>不带声音</th>
</tr>
</thead>
<tbody><tr>
<td>IOS 钉钉</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>IOS Safari</td>
<td>禁止</td>
<td>自动播放</td>
</tr>
<tr>
<td>IOS 微信</td>
<td>禁止</td>
<td>禁止</td>
</tr>
</tbody></table>
<p>通过查询资料，IOS WebAPP 开发都是基于 IOS 提供的浏览器内核进行开发的 ，所以在 WebAPP 的 webview 中可以修改自动播放的表现，钉钉明显是支持自动播放，微信则是禁止自动播放，但是提供了内置事件来支持自动播放：</p>
<p>微信下通过 WeixinJSBridgeReady 事件进行自动播放：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        video.play();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="场景二：全屏处理"><a href="#场景二：全屏处理" class="headerlink" title="场景二：全屏处理"></a>场景二：全屏处理</h2><p>在移动端浏览器，  video 在用户点击播放或者通过API video.play() 触发播放时，会强制以全屏置顶的形式进行播放，设计的初衷可能是因为全屏能提供更好的用户体验，但有时候开发者希望能自己控制是否全屏从而实现其他需求。</p>
<blockquote>
<p>playsinline 取消全屏</p>
</blockquote>
<p>如果想实现不全屏播放，只需在video标签加个 playsinline   属性即可，这个属性在基于webkit内核的移动端浏览器 基本没问题，实在不行就再加个 webkit-playsinline  ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&#123;videoUrl&#125;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">webkit-playsinline</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">playsinline</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么对于其他内核的浏览器要怎么处理呢？这个时候要了解下目前市场上存在的浏览器有哪些。</p>
<blockquote>
<p>playsinline 兼容性</p>
</blockquote>
<p>首先要知道全球目前四个浏览器内核：</p>
<ul>
<li>微软IE的Trident </li>
</ul>
<p>网景最初研发后卖给Mozilla基金会并演化成火狐的Gecko </p>
<ul>
<li><p>KDE的开源内核Webkit </p>
</li>
<li><p>Opera的Presto</p>
</li>
</ul>
<p>其中：</p>
<blockquote>
<p>Trident 在移动端主要为WP7系统内置浏览器</p>
</blockquote>
<blockquote>
<p>Presto 在所有联网设备上都使用，移动终端上主要为 Opera Mobile、OperaMini、欧朋浏览器以及欧朋HD Beta版</p>
</blockquote>
<blockquote>
<p>Webkit 内核的适用范围则较为广泛，Android原生浏览器、苹果的Safari、谷歌的Chrome(Android4.0使用)都是基于Webkit开源内核开发的。</p>
</blockquote>
<p>而国内常见的PC浏览器如UC浏览器、QQ浏览器、百度手机浏览器、360安全浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器 以及移动端的UC、QQ、百度等手机浏览器 都是根据Webkit修改过来的内核，本质上我们可以认为市场上移动端用户使用的基本上都是webkit内核或者基于 webkit 内核做修改的浏览器，所以 playsinline 的兼容性非常好！</p>
<hr>
<h2 id="场景三：播放控制"><a href="#场景三：播放控制" class="headerlink" title="场景三：播放控制"></a>场景三：播放控制</h2><p>video 元素有提供多个行为事件供开发者控制视频播放，兼容性比较好的有 onended  、 ontimeupdate、onplay、onplaying 等，有些事件在不同浏览器不同设备上的的表现情况并不一致，</p>
<blockquote>
<p>例如：ios 下监听’canplay’（是否已缓冲了足够的数据可以流畅播放）,当加载时是不会触发的，即使preload=”auto” 也没用，但在 pc 的 Chrome 调试器下，是会在加载阶段就触发。ios 需要播放后才会触发。</p>
</blockquote>
<p><strong><em>部分事件在不同系统、设备、浏览器下显示的特性不一致，使用的时候需谨慎。</em></strong></p>
<hr>
<h2 id="场景四：隐藏播放控件"><a href="#场景四：隐藏播放控件" class="headerlink" title="场景四：隐藏播放控件"></a>场景四：隐藏播放控件</h2><h3 id="controls"><a href="#controls" class="headerlink" title="controls"></a>controls</h3><blockquote>
<p>加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。</p>
</blockquote>
<blockquote>
<p>controls 属性规定浏览器应该为视频提供播放控件，反之则隐藏播放控件，那么开发者可以自定义自己的播放控件。隐藏播放控件在 PC 端和 IOS 移动端兼容性良好，而在安卓移动端并不支持隐藏控件 ，不过还是可以通过一些方法来实现。</p>
</blockquote>
<hr>
<p>黑科技法</p>
<p>比较黑科技的方法是放大视频，把控件条移到视野之外，从而达到隐藏的效果！其实就是让视频元素比父容器还大，这样底部的控制条就会在父容器外面，然后父容器设置为：overflow:hidden  实现隐藏播放控件的方法！<br>缺点是视频会被放大，需要提前留好空白供放大用。</p>
<p>微信浏览器</p>
<p>腾讯的android团队的x5内核团队放开了视频播放的限制，视频不一定调用它们那个备受诟病的视频播放器了，利用x5-video-player-type=&quot;h5&quot; 属性隐藏控件元素，同时视频不再置顶，允许其他元素浮动在顶层 。</p>
]]></content>
  </entry>
  <entry>
    <title>音视频自动播放问题</title>
    <url>/2020/11/14/html/video-auto/</url>
    <content><![CDATA[<p>不同浏览器下 autoplay 的限制策略和方案的整理</p>
<hr>
<h3 id="一、Chrome-浏览器"><a href="#一、Chrome-浏览器" class="headerlink" title="一、Chrome 浏览器"></a>一、Chrome 浏览器</h3><p>2018 年 4 月份发布的 Chrome 66 正式关掉了声音自动播放</p>
<ul>
<li>静音自动播放总是允许的。</li>
<li>在下列情况下允许使用声音自动播放：</li>
<li>用户已经与域进行了交互（点击，tap 等）。在桌面上，用户的**<em>媒体参与指数阈值**</em>(MEI)已被越过，这意味着用户以前播放带有声音的视频。在移动设备上，用户已将该网站添加到主屏幕。顶部框架可以将自动播放权限授予其 iframe 以允许自动播放声音。</li>
</ul>
<p>MEI 是一个评估用户对于当前站点的媒体参与程度的指数，它取决于</p>
<ul>
<li>  用户在媒体上停留时间超过了 7 秒以上</li>
<li>  音频必须是展示出来，并且没有静音</li>
<li>  与 video 之间有过交互</li>
<li>  媒体的尺寸不小于 200x140</li>
</ul>
<blockquote>
<p>Chrome-应对方案</p>
</blockquote>
<ul>
<li>不要假设视频会播放，并且在视频不是真正播放时不要显示暂停按钮。</li>
<li>根据 promise 结果，判断当前媒体是否支持 autoplay</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">document</span>.querySelector(<span class="string">&quot;video&quot;</span>).play();</span><br><span class="line"><span class="keyword">if</span> (promise !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    promise</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Auto-play was prevented</span></span><br><span class="line">            <span class="comment">// Show a UI element to let the user manually start playback</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Auto-play started</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不支持，有 3 个选择，</p>
</blockquote>
<ul>
<li>静音自动播放，</li>
<li>或者选择弹出 dialog 引导用户产生一次交互，在 event 回调里调用 play()</li>
<li>提高 Chrome 浏览器的 MEI 指数</li>
</ul>
<hr>
<h2 id="Safari-浏览器"><a href="#Safari-浏览器" class="headerlink" title="Safari 浏览器"></a>Safari 浏览器</h2><p>Safari11 允许用户通过「此网站的设置」选项，让用户控制哪些网站可以自动播放音视频</p>
<p> 判断当前媒体是否支持 autoplay</p>
<blockquote>
<p>如果不支持，有 3 个选择</p>
</blockquote>
<ul>
<li>静音自动播放引导用户对浏览器设置为【允许自动播放】</li>
<li>弹出 dialog 引导用户产生一次交互</li>
<li>在 event 回调里调用 play()</li>
</ul>
<hr>
<h2 id="三、Firefox"><a href="#三、Firefox" class="headerlink" title="三、Firefox"></a>三、Firefox</h2><p> Firefox 66 和 Firefox for Android 开始，Firefox 将默认阻止音频和视频的自动播放</p>
<p>Firefox 也支持静音自动播放，只需将 HTMLMediaElement 的“muted”属性设置为 true，即可启用自动播放功能</p>
]]></content>
  </entry>
  <entry>
    <title>HTML 音频/视频 DOM 参考手册</title>
    <url>/2020/11/14/html/video/</url>
    <content><![CDATA[<blockquote>
<p>HTML5 DOM 为 <code>&lt;audio&gt; 和 &lt;video&gt;</code> 元素提供了方法、属性和事件。</p>
</blockquote>
<h2 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a><a href="https://www.w3cschool.cn/htmltags/ref-av-dom.html" target="_blank">W3C</a></h2><h2 id="HTML-音频-视频-方法"><a href="#HTML-音频-视频-方法" class="headerlink" title="HTML 音频/视频 方法"></a>HTML 音频/视频 方法</h2><table><tbody><tr><th align="left" width="25%">方法</th><th align="left" width="75%">描述</th></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-met-addtexttrack.html" style="text-decoration-line: line-through;">addTextTrack()</a></td><td>向音频/视频添加新的文本轨道。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-met-canplaytype.html">canPlayType()</a></td><td>检测浏览器是否能播放指定的音频/视频类型。<a href="https://www.w3cschool.cn/htmltags/av-met-canplaytype.html" target="_blank">手册</a></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-met-load.html">load()</a></td><td>重新加载音频/视频元素。更改来源或其他设置后对音频/视频（audio/video）元素进行更新</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-met-play.html">play()</a></td><td>开始播放音频/视频。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-met-pause.html">pause()</a></td><td>暂停当前播放的音频/视频。</td></tr></tbody></table>

<h2 id="HTML-音频-视频属性"><a href="#HTML-音频-视频属性" class="headerlink" title="HTML 音频/视频属性"></a>HTML 音频/视频属性</h2><table><tbody><tr><th align="left" width="25%">属性</th><th align="left" width="75%">描述</th></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-audiotracks.html" style="text-decoration-line: line-through;">audioTracks</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示可用音频轨道的 AudioTrackList 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-autoplay.html">autoplay</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>是否在加载完成后随即播放音频/视频。默认：false</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-buffered.html">buffered</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示音频/视频已缓冲部分的 TimeRanges 对象。<ul><li>length - 获得音频/视频中已缓冲范围的数量</li><li>start(<em>index</em>) - 获得某个已缓冲范围的开始位置</li><li>end(<em>index</em>) - 获得某个已缓冲范围的结束位置</li></ul><p><strong>注释：</strong>第一个缓冲范围的<em>下标</em>是 0。</p></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-controller.html" style="text-decoration-line: line-through;">controller</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示音频/视频当前媒体控制器的 MediaController 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-controls.html">controls</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频是否显示控件（比如播放/暂停等）。</td></tr><tr><td>crossOrigin</td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频的 CORS 设置。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-currentsrc.html">currentSrc</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>当前音频/视频的 URL。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-currenttime.html">currentTime</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频中的当前播放位置（以秒计）。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-defaultmuted.html">defaultMuted</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频默认是否静音。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-defaultplaybackrate.html">defaultPlay<span style="text-decoration-line: line-through;">backRate</span></a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频的默认播放速度。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-duration.html">duration</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>当前音频/视频的长度（以秒计）。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-ended.html">ended</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>音频/视频的播放是否已结束。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-error.html">e<span style="text-decoration-line: line-through;">rror</span></a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示音频/视频错误状态的 MediaError 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-loop.html">loop</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频是否应在结束时重新播放。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-mediagroup.html">mediaGroup</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频所属的组合（用于连接多个音频/视频元素）。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-muted.html">muted</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频是否静音。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-networkstate.html">networkState</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>音频/视频的当前网络状态。<ul><li>0 = NETWORK_EMPTY - 音频/视频尚未初始化</li><li>1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络</li><li>2 = NETWORK_LOADING - 浏览器正在下载数据</li><li>3 = NETWORK_NO_SOURCE - 未找到音频/视频来源</li></ul></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-paused.html">paused</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频是否暂停。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-playbackrate.html">playbackRate</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频播放的速度。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-played.html">played</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示音频/视频已播放部分的 TimeRanges 对象。<ul><li>length - 获得音频/视频中已播范围的数量</li><li>start(<em>index</em>) - 获得某个已播范围的开始位置</li><li>end(<em>index</em>) - 获得某个已播范围的结束位置</li></ul><p><strong>注释：</strong>第一段已播范围的下标 <em>index</em> 是 0。</p></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-preload.html">preload</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频是否应该在页面加载后进行加载。<br><table><tbody><tr><td>auto</td><td>指示一旦页面加载，则开始加载音频/视频。</td></tr><tr><td>metadata</td><td>指示当页面加载后仅加载音频/视频的元数据。</td></tr><tr><td>none</td><td>指示页面加载后不应加载音频/视频。</td></tr></tbody></table></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-readystate.html">readyState</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>音频/视频当前的就绪状态。<ul><li>0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息</li><li>1 = HAVE_METADATA - 关于音频/视频就绪的元数据</li><li>2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒</li><li>3 = H<span lang="no-bok">AVE_FUTURE_DATA</span> - 当前及至少下一帧的数据是可用的</li><li>4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放</li></ul><br></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-seekable.html">seekable</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示音频/视频可寻址部分的 TimeRanges 对象。<br><ul><li>length - 获得音频/视频中可寻址范围的数量</li><li>start(<em>index</em>) - 获得可寻址范围的开始位置</li><li>end(<em>index</em>) - 获得可寻址范围的结束位置</li></ul><p><strong>注释：</strong>第一个可寻址范围的下标 <em>index</em> 是 0。</p></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-seeking.html">seeking</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>用户是否正在音频/视频中进行查找。<br><table><tbody><tr><td>Boolean</td><td>true|false。如果用户正在寻址，则为 true，否则为 false。</td></tr></tbody></table></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-src.html">src</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频元素的当前来源。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-startdate.html" style="text-decoration-line: line-through;">startDate</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示当前时间偏移的 Date 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-texttracks.html">textTrac<span style="text-decoration-line: line-through;">ks</span></a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示可用文本轨道的 TextTrackList 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-videotracks.html" style="text-decoration-line: line-through;">videoTracks</a></td><td><span style="color: rgb(249, 150, 59);">返回</span>表示可用视频轨道的 VideoTrackList 对象。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-prop-volume.html">volume</a></td><td><span style="color: rgb(249, 150, 59);">设置或返回</span>音频/视频的音量。</td></tr></tbody></table>

<h2 id="HTML-音频-视频事件"><a href="#HTML-音频-视频事件" class="headerlink" title="HTML 音频/视频事件"></a>HTML 音频/视频事件</h2><p>当音频/视频处于加载过程中时，会依次发生以下事件：</p><h3><ol><li><span style="color: rgb(0, 0, 0);"><a href="https://www.w3cschool.cn/htmltags/av-event-loadstart.html" style="">loadstart</a></span></li></ol><ol><li><a href="https://www.w3cschool.cn/htmltags/av-event-durati.html" style="color: rgb(0, 0, 0);">durationchange</a></li></ol><ol><li><a href="https://www.w3cschool.cn/htmltags/av-event-loadedmetadata.html" style="color: rgb(0, 0, 0);">loadedmetadata</a></li></ol><ol><li><a href="https://www.w3cschool.cn/htmltags/av-event-loadeddata.html" style="color: rgb(0, 0, 0);">loadeddata</a></li></ol><ol><li><a href="https://www.w3cschool.cn/htmltags/av-event-progress.html" style="color: rgb(0, 0, 0);">progress</a></li></ol><ol><li><span style="color: rgb(0, 0, 0);">canplay</span></li></ol><ol><li><a href="https://www.w3cschool.cn/htmltags/av-event-canplaythrough.html" style="color: rgb(0, 0, 0);">canplaythrough</a></li></ol></h3><table><tbody><tr><th align="left" width="25%">事件</th><th align="left" width="75%">描述</th></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-abort.html">abort</a></td><td>当音频/视频的加载已放弃时触发。<br><strong>提示：</strong> 影响多媒体数据加载的事件有：<ul><li>emptied</li><li><a href="https://www.w3cschool.cn/htmltags/av-event-error.html">error</a></li><li><a href="https://www.w3cschool.cn/htmltags/av-event-stalled.html">stalled</a></li><li><a href="https://www.w3cschool.cn/htmltags/av-event-suspend.html">suspend</a></li></ul></td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-canplay.html">canplay</a></td><td>当浏览器可以开始播放音频/视频时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-canplaythrough.html">canplaythrough</a></td><td>当浏览器可在不因缓冲而停顿的情况下进行播放时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-durati.html">durationchange</a></td><td>当音频/视频的时长已更改时触发。</td></tr><tr><td>emptied</td><td>当目前的播放列表为空时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-ended.html">ended</a></td><td>当目前的播放列表已结束时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-error.html">error</a></td><td>当在音频/视频加载期间发生错误时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-loadeddata.html">loadeddata</a></td><td>当浏览器已加载音频/视频的当前帧时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-loadedmetadata.html">loadedmetadata</a></td><td>当浏览器已加载音频/视频的元数据时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-loadstart.html">loadstart</a></td><td>当浏览器开始查找音频/视频时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-pause.html">pause</a></td><td>当音频/视频已暂停时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-play.html">play</a></td><td>当音频/视频已开始或不再暂停时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-playing.html">playing</a></td><td>当音频/视频在因缓冲而暂停或停止后已就绪时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-progress.html">progress</a></td><td>当浏览器正在下载音频/视频时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-ratechange.html">ratechange</a></td><td>当音频/视频的播放速度已更改时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-seeked.html">seeked</a></td><td>当用户已移动/跳跃到音频/视频中的新位置时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-seeking.html">seeking</a></td><td>当用户开始移动/跳跃到音频/视频中的新位置时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-stalled.html">stalled</a></td><td>当浏览器尝试获取媒体数据，但数据不可用时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-suspend.html">suspend</a></td><td>当浏览器刻意不获取媒体数据时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-timeupdate.html">timeupdate</a></td><td>当目前的播放位置已更改时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-volumechange.html">volumechange</a></td><td>当音量已更改时触发。</td></tr><tr><td><a href="https://www.w3cschool.cn/htmltags/av-event-waiting.html">waiting</a></td><td>当视频由于需要缓冲下一帧而停止时触发。</td></tr></tbody></table>]]></content>
  </entry>
  <entry>
    <title>MessageChannel</title>
    <url>/2020/11/14/js/MessageChannel/</url>
    <content><![CDATA[<blockquote>
<p>在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate。而常见的 micro task 有 MutationObsever 和 Promise.then。</p>
</blockquote>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a><a href="https://www.jianshu.com/p/4f07ef18b5d7" target="_blank">原文地址</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/postMessage" target="_blank">Worker.postMessage()</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank">MessageChannel</a></p>
<h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>var channel = new MessageChannel();</p>
<p>这样就创建了一个管道。</p>
<h2 id="实例属性："><a href="#实例属性：" class="headerlink" title="实例属性："></a>实例属性：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">channel.port1</span><br><span class="line">channel.port2</span><br></pre></td></tr></table></figure>


<p>获取实例的两个端口，注意的是，两个端口都是只读的。</p>
<p>简单来说，MessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接收从另一个端口传过来的数据。</p>
<p>一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port1 = channel.port1;</span><br><span class="line"><span class="keyword">var</span> port2 = channel.port2;</span><br><span class="line">port1.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;port1收到来自port2的数据：&quot;</span> + event.data);</span><br><span class="line">    &#125;</span><br><span class="line">port2.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;port2收到来自port1的数据：&quot;</span> + event.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">port1.postMessage(<span class="string">&quot;发送给port2&quot;</span>);</span><br><span class="line">    port2.postMessage(<span class="string">&quot;发送给port1&quot;</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>（1）深拷贝</p>
<p>MessageChannel还可以用于深拷贝，我们都知道深拷贝一般用JSON.parse(JSON.stringify(object))就可以解决了，</p>
<p>也知道这种方法的局限性：</p>
<ul>
<li>会忽略 undefined
</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>

<p>undefined和函数会被忽略，而尝试拷贝循环引用的对象则会报错：</p>
<p>一般来说，这个方法都能解决大部分问题，而且性能也是最好的。</p>
<p>但是MessageChannel的postMessage传递的数据也是深拷贝的，这和web worker的postMessage一样。而且还可以拷贝undefined和循环引用的对象。</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有undefined + 循环引用</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            b: &#123;</span><br><span class="line">            c: <span class="number">2</span>,</span><br><span class="line">            d: <span class="number">3</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        f: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj.c = obj.b;</span><br><span class="line">    obj.e = obj.a</span><br><span class="line">    obj.b.c = obj.c</span><br><span class="line">    obj.b.d = obj.b</span><br><span class="line">    obj.b.e = obj.b.c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">        port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">        port1.postMessage(obj);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deepCopy(obj).then(<span class="function">(<span class="params">copy</span>) =&gt;</span> &#123;           <span class="comment">// 请记住`MessageChannel`是异步的这个前提！</span></span><br><span class="line">            <span class="keyword">let</span> copyObj = copy;</span><br><span class="line">            <span class="built_in">console</span>.log(copyObj, obj)</span><br><span class="line">            <span class="built_in">console</span>.log(copyObj == obj)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但拷贝有函数的对象时，还是会报错：</p>
<p>这时候可能就要用到<a href="https://www.npmjs.com/package/lodash" target="_blank" rel="nofollow">lodash</a>这样的函数库了。</p>
<h2 id="（2）此特性在-Web-Worker-中可以使用。"><a href="#（2）此特性在-Web-Worker-中可以使用。" class="headerlink" title="（2）此特性在 Web Worker 中可以使用。"></a>（2）此特性在 Web Worker 中可以使用。</h2><p>当我们使用多个web worker并想要在两个web worker之间实现通信的时候，MessageChannel也可以派上用场：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker1 = <span class="keyword">new</span> Worker(<span class="string">&quot;worker1.js&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker2 = <span class="keyword">new</span> Worker(<span class="string">&quot;worker2.js&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span></span><br><span class="line">    worker1.postMessage(&#123; port1: channel.port1 &#125;);</span><br><span class="line">    worker2.postMessage(&#123; port2: channel.port2 &#125;);</span><br><span class="line"><span class="javascript">    worker2.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> port1 = event.data.port1;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        port1.postMessage(<span class="string">&quot;this is from worker2&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> port2 = event.ports;</span><br><span class="line">    port2.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        self.postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始我写出如上代码，结果报了这样的错误：</p>
<p>worker的数据传递是深复制的，这里报错说MessagePort不能复制。</p>
<p>于是我查了一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/postMessage" target="_blank" rel="nofollow">Worker.postMessage()</a>。</p>
<p>发现这个方法有第二个可选的数组参数，可以将MessagePort传入，然后将控制权交给要发送到的worker。（这两句是我翻译的（如果还没有被大神改掉的话），翻译得不好别打我哈）</p>
<p>于是我把代码改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> w1 = <span class="keyword">new</span> Worker(<span class="string">&quot;worker1.js&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> w2 = <span class="keyword">new</span> Worker(<span class="string">&quot;worker2.js&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    w1.postMessage(<span class="string">&quot;port1&quot;</span>, [ch.port1]);</span><br><span class="line">    w2.postMessage(<span class="string">&quot;port2&quot;</span>, [ch.port2]);</span><br><span class="line">    w2.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker1.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span>  port = e.ports[<span class="number">0</span>];</span><br><span class="line">    port.postMessage(<span class="string">&quot;this is from worker1&quot;</span>)        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker2.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> port = e.ports[<span class="number">0</span>];</span><br><span class="line">    port.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        postMessage(e.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>由于在worker中无法使用console.log，因此我们通过给w2绑定onmessage回调函数来验证传递是否成功。最终我们可以看到控制台中输出</p>
<p>this is from worker1</p>
<p>传递的路径为：</p>
<p>w1=&gt; ch1 =&gt; ch2 =&gt; w2</p>
]]></content>
  </entry>
  <entry>
    <title>MutationObserver</title>
    <url>/2020/11/14/js/MutationObserver/</url>
    <content><![CDATA[<blockquote>
<p>MutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。</p>
</blockquote>
<p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>
<p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。</p>
<p>但是，它与事件有一个本质不同：</p>
<ul>
<li>事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；</li>
<li>Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</li>
</ul>
<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个 p 元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。<br>Mutation Observer 有以下特点。</p>
<ul>
<li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li>
<li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li>
<li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>
</ul>
<p>每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observer</span>) </span>&#123;</span><br><span class="line">      mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="MutationObserver-的实例方法"><a href="#MutationObserver-的实例方法" class="headerlink" title="MutationObserver 的实例方法"></a>MutationObserver 的实例方法</h2><h3 id="observe"><a href="#observe" class="headerlink" title="observe()"></a>observe()</h3><p>observe方法用来启动监听，它接受两个参数。</p>
<ul>
<li>第一个参数：所要观察的 DOM 节点</li>
<li>第二个参数：一个配置对象，指定所要观察的特定变动</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;article&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  options = &#123;</span><br><span class="line">    <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;attributes&#x27;</span>:<span class="literal">true</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">observer.observe(article, options);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中，observe方法接受两个参数</p>
<ul>
<li><p>第一个是所要观察的DOM元素是article，</p>
</li>
<li><p>第二个是所要观察的变动类型（子节点变动和属性变动）。</p>
</li>
</ul>
<p>观察器所能观察的 DOM 变动类型（即上面代码的options&lt;对象），有以下几种。</p>
<ul>
<li><code>childList</code>：子节点的变动（指新增，删除或者更改）。</li>
<li><code>attributes</code>：属性的变动。</li>
<li><code>characterData</code>：节点内容或节点文本的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在option对象中指定它的值为true。</p>
<blockquote>
<p>需要注意的是，必须同时指定childList、attributes和characterData中的一种或多种，若未均指定将报错。<br>除了变动类型，options对象还可以设定以下属性：</p>
</blockquote>
<ul>
<li>subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li>
<li>attributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。</li>
<li>characterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值。</li>
<li>attributeFilter：数组，表示需要观察的特定属性（比如[‘class’,’src’]）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始监听文档根节点（即&lt;html&gt;标签）的变动</span></span><br><span class="line">mutationObserver.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">    attributes: <span class="literal">true</span>,</span><br><span class="line">    characterData: <span class="literal">true</span>,</span><br><span class="line">    childList: <span class="literal">true</span>,</span><br><span class="line">    subtree: <span class="literal">true</span>,</span><br><span class="line">    attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">    characterDataOldValue: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对一个节点添加观察器，就像使用addEventListener方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。但是，如果指定不同的options对象，就会被当作两个不同的观察器。<br>下面的例子是观察新增的子节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNodes = [];</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">      mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mutation.addedNodes.length; i++) &#123;</span><br><span class="line">            insertedNodes.push(mutation.addedNodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(<span class="built_in">document</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(insertedNodes);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="disconnect方法用来停止观察。调用该方法后，DOM-再发生变动，也不会触发观察器。"><a href="#disconnect方法用来停止观察。调用该方法后，DOM-再发生变动，也不会触发观察器。" class="headerlink" title="disconnect方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。"></a>disconnect方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">observer.disconnect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。"><a href="#takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。" class="headerlink" title="takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。"></a>takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">observer.takeRecords();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存所有没有被观察器处理的变动</span></span><br><span class="line"><span class="keyword">var</span> changes = mutationObserver.takeRecords();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">mutationObserver.disconnect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MutationRecord 对象DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个MutationRecord&lt;实例所组成的数组。<br>MutationRecord对象包含了DOM的相关信息，有如下属性：</p>
<ul>
<li>type：观察的变动类型（attribute、characterData或者childList）。</li>
<li>target：发生变动的DOM节点。</li>
<li>addedNodes：新增的DOM节点。</li>
<li>removedNodes：删除的DOM节点。</li>
<li>previousSibling：前一个同级节点，如果没有则返回null。</li>
<li>nextSibling：下一个同级节点，如果没有则返回null。</li>
<li>attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。</li>
<li>oldValue：变动前的值。这个属性只对attribute&lt;和characterData&lt;变动有效，如果发生*childList变动，则返回null。</li>
</ul>
<p>应用示例</p>
<blockquote>
<p>子元素的变动</p>
</blockquote>
<p>下面的例子说明如何读取变动记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params">records</span>)</span>&#123;</span><br><span class="line">    records.map(<span class="function"><span class="keyword">function</span>(<span class="params">record</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Mutation type: &#x27;</span> + record.type);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Mutation target: &#x27;</span> + record.target);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;subtree&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mo.observe(<span class="built_in">document</span>.body, option);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的观察器，观察body的所有下级节点（childList表示观察子节点，subtree&lt;表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p>
<blockquote>
<p>属性的变动</p>
</blockquote>
<p>下面的例子说明如何追踪属性的变动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params">records</span>) </span>&#123;</span><br><span class="line">      records.map(<span class="function"><span class="keyword">function</span> (<span class="params">record</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Previous attribute value: &#x27;</span> + record.oldValue);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;#my_element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="string">&#x27;attributes&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;attributeOldValue&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">mo.observe(element, options);</span><br></pre></td></tr></table></figure>
<p>上面代码先设定追踪属性变动（’attributes’: true），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p>
<p>取代 DOMContentLoaded 事件</p>
<p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，因此也就没有必要使用DOMContentLoaded&lt;事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line">observer.observe(<span class="built_in">document</span>.documentElement, &#123;</span><br><span class="line">    childList: <span class="literal">true</span>,</span><br><span class="line">    subtree: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中，监听document.documentElement（即HTML节点）的子节点的变动，subtree属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。<br>下面的代码，使用MutationObserver&lt;对象封装一个监听 DOM 生成的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>)</span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> listeners = [];</span><br><span class="line">    <span class="keyword">var</span> doc = win.document;</span><br><span class="line">    <span class="keyword">var</span> MutationObserver = win.MutationObserver || win.WebKitMutationObserver;</span><br><span class="line">    <span class="keyword">var</span> observer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">selector, fn</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 储存选择器和回调函数</span></span><br><span class="line">        listeners.push(&#123;</span><br><span class="line">            selector: selector,</span><br><span class="line">            fn: fn</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">!observer</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 监听document变化</span></span><br><span class="line">            observer = <span class="keyword">new</span> MutationObserver(check);</span><br><span class="line">            observer.observe(doc.documentElement, &#123;</span><br><span class="line">                    childList: <span class="literal">true</span>,</span><br><span class="line">                    subtree: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查该节点是否已经在DOM中</span></span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否匹配已储存的节点</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">            <span class="comment">// 检查指定节点是否有匹配</span></span><br><span class="line">            <span class="keyword">var</span> elements = doc.querySelectorAll(listener.selector);</span><br><span class="line">            <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.length; j++</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> element = elements[j];</span><br><span class="line">                <span class="comment">// 确保回调函数只会对该元素调用一次</span></span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params">!element.ready</span>)</span>&#123;</span><br><span class="line">                    element.ready = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 对该节点调用回调函数</span></span><br><span class="line">                listener.fn.call(element, element);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露ready</span></span><br><span class="line">    win.ready = ready;</span><br><span class="line">&#125;)(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">ready(<span class="string">&#x27;.foo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>addEventListener 详解以及应用</title>
    <url>/2020/11/14/js/addEventListener/</url>
    <content><![CDATA[<blockquote>
<p>将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)</p>
</blockquote>
<h2 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#The_event_listener_callback" target="_blank">MDN</a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Gecko/Mozilla only</span></span><br><span class="line">target.addEventListener(type, listener[, useCapture, wantsUntrusted]);</span><br></pre></td></tr></table></figure>


<dt><h3>type</h3></dt><dd>表示监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">事件类型</a>的字符串。</dd><dt>listener</dt><dd>当所监听的事件类型触发时，会接收到一个事件通知（实现了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" title="此页面仍未被本地化, 期待您的翻译!">Event</a> 接口的对象）对象。listener 必须是一个实现了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventListener" title="当EventListener 所注册的事件发生的时候，该方法会被调用。">EventListener</a> 接口的对象，（该对象中有handleEvent方法），或者是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions">函数</a></dd>

<p>options 可选<dd>一个指定有关 listener 属性的可选参数对象。可用的选项如下：</p>
<ul><li>

<p>capture:  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" title="此页面仍未被本地化, 期待您的翻译!">Boolean</a>，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li><li>once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li><li>passive: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" title="此页面仍未被本地化, 期待您的翻译!">Boolean</a>，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</li><li>&gt; mozSystemGroup: 只能在 XBL 或者是 Firefox’ chrome 使用，这是个Boolean，表示 listener 被添加到 system group。</li></ul></dd></p>
<h2 id="useCapture-可选"><a href="#useCapture-可选" class="headerlink" title="useCapture  可选"></a>useCapture  可选</h2><dd><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" title="此页面仍未被本地化, 期待您的翻译!">Boolean</a>，在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener。 当userCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。进一步的解释可以查看 <a rel="noopener" href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow" title="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow">事件流</a> 及 <a rel="noopener" href="http://www.quirksmode.org/js/events_order.html#link4">JavaScript Event order</a> 文档。 如果没有指定， useCapture 默认为 false 。</dd>

<p>关于passive：某乎上这样说：</p>
<p>当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。</p>
<h2 id="检测-passive-值"><a href="#检测-passive-值" class="headerlink" title="检测 passive 值"></a>检测 passive 值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> passiveSupported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> options = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&quot;passive&quot;</span>, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          passiveSupported = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, options);</span><br><span class="line">&#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">someElement.addEventListener(<span class="string">&quot;mouseup&quot;</span>, handleMouseUp, passiveSupported</span><br><span class="line">                               ? &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125; : <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleEvent</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;touchstart&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;mousedown&#x27;</span>:</span><br><span class="line">            <span class="comment">// dosomething</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;touchmove&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;mousemove&#x27;</span>:</span><br><span class="line">            <span class="comment">// dosomething</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;touchend&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;mouseup&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;touchcancel&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;mousecancel&#x27;</span>:</span><br><span class="line">            <span class="comment">// dosomething</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_addDOMEvents</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._handleDOMEvents(addEvent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_removeDOMEvents</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._handleDOMEvents(removeEvent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_handleDOMEvents</span>(<span class="params">eventOperation</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用name上的handleEvent方法</span></span><br><span class="line">    eventOperation(<span class="built_in">this</span>.container, <span class="string">&#x27;touchstart&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    eventOperation(<span class="built_in">window</span>, <span class="string">&#x27;touchend&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    eventOperation(<span class="built_in">this</span>.container, <span class="string">&#x27;mousedown&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    eventOperation(<span class="built_in">window</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addEvent</span>(<span class="params">el, type, fn, capture, passive = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">        el.addEventListener(type, fn, &#123;passive, <span class="attr">capture</span>: !!capture&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">removeEvent</span>(<span class="params">el, type, fn, capture, passive = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">        el.removeEventListener(type, fn, &#123;passive, <span class="attr">capture</span>: !!capture&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> vendor = (() =&amp;gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// first pick up standard to fix #743</span></span><br><span class="line">  <span class="keyword">let</span> transformNames = &#123;</span><br><span class="line">        standard: <span class="string">&#x27;transform&#x27;</span>,</span><br><span class="line">    webkit: <span class="string">&#x27;webkitTransform&#x27;</span>,</span><br><span class="line">    Moz: <span class="string">&#x27;MozTransform&#x27;</span>,</span><br><span class="line">    O: <span class="string">&#x27;OTransform&#x27;</span>,</span><br><span class="line">    ms: <span class="string">&#x27;msTransform&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> transformNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementStyle[transformNames[key]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prefixStyle</span>(<span class="params">style</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vendor === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vendor === <span class="string">&#x27;standard&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (style === <span class="string">&#x27;transitionEnd&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;transitionend&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> style</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vendor + style.charAt(<span class="number">0</span>).toUpperCase() + style.substr(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> transform = prefixStyle(<span class="string">&#x27;transform&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> transition = prefixStyle(<span class="string">&#x27;transition&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">e, eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ev = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>)</span><br><span class="line">    ev.initEvent(eventName, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    ev.pageX = e.pageX</span><br><span class="line">    ev.pageY = e.pageY</span><br><span class="line">    e.target.dispatchEvent(ev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">e, event = <span class="string">&#x27;click&#x27;</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> eventSource</span><br><span class="line">  <span class="keyword">if</span> (e.type === <span class="string">&#x27;mouseup&#x27;</span> || e.type === <span class="string">&#x27;mousecancel&#x27;</span>) &#123;</span><br><span class="line">        eventSource = e</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.type === <span class="string">&#x27;touchend&#x27;</span> || e.type === <span class="string">&#x27;touchcancel&#x27;</span>) &#123;</span><br><span class="line">        eventSource = e.changedTouches[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> posSrc = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (eventSource) &#123;</span><br><span class="line">        posSrc.screenX = eventSource.screenX || <span class="number">0</span></span><br><span class="line">    posSrc.screenY = eventSource.screenY || <span class="number">0</span></span><br><span class="line">    posSrc.clientX = eventSource.clientX || <span class="number">0</span></span><br><span class="line">    posSrc.clientY = eventSource.clientY || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ev</span><br><span class="line">  <span class="keyword">const</span> bubbles = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> cancelable = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> MouseEvent !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [在此查看几个参数是意义](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/initMouseEvent)</span></span><br><span class="line">            ev = <span class="keyword">new</span> MouseEvent(event, extend(&#123;</span><br><span class="line">                bubbles,</span><br><span class="line">                cancelable</span><br><span class="line">            &#125;, posSrc))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            createEvent()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createEvent()</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 过时的方式</span></span><br><span class="line">    ev = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>)</span><br><span class="line">        ev.initEvent(event, bubbles, cancelable)</span><br><span class="line">        extend(ev, posSrc)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// forwardedTouchEvent set to true in case of the conflict with fastclick</span></span><br><span class="line">      ev.forwardedTouchEvent = <span class="literal">true</span></span><br><span class="line">      ev._constructed = <span class="literal">true</span></span><br><span class="line">      e.target.dispatchEvent(ev)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dblclick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">          click(e, <span class="string">&#x27;dblclick&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/11/14/js/binary-tree/</url>
    <content><![CDATA[<p>二叉搜索树需要有如下的方法:<ul><li><br>insert(key): 向树中插入一个新的键</li><li><br>inOrderTraverse(): 通过中序遍历方式，遍历所有节点</li><li><br>preOrderTranverse(): 通过先序遍历方式，遍历所有节点</li><li><br>postOrderTranverse(): 通过后序遍历方式，遍历所有节点</li><li><br>min(): 返回树中最小的值</li><li><br>max(): 返回树中最大的值</li><li><br>search(key): 搜索某个值，在树中则返回true</li><li><br>remove(key): 从树中移除某个键</li></ul></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二叉搜索树的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉搜索树键的构造函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>key 要生成的键值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 键值</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树的根节点，不存在时表示为Null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@type <span class="type">&#123;Null or Number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 插入某个键到二叉树中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>key 要插入的键值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 用传入的值生成二叉树的键</span></span><br><span class="line">        <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 根节点为Null时，传入的键则为根节点</span></span><br><span class="line">        <span class="comment">// 否则调用insertNode函数来插入子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于插入子节点。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node    根节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>newNode 要插入的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//由于二叉搜索树的性质，所以当键值小于当前所在节点的键值</span></span><br><span class="line">        <span class="comment">//则使得左子结点成为新的要比较的节点，进行递归调用</span></span><br><span class="line">        <span class="comment">//如果左子结点为null，则将键值赋值给左子结点。</span></span><br><span class="line">        <span class="comment">//如果键值大于当前所在节点的键值，原理同上。</span></span><br><span class="line">        <span class="keyword">if</span> (newNode.key &gt; node.key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(node.left, newNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = newNode</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(node.right, newNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> printNode = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中序遍历操作，常用于排序。会把树中元素从小到大的打印出来。</span></span><br><span class="line"><span class="comment">    * 因为在javascript的递归中，遇到递归是，会优先调用递归的函数。直到递归不再进行。</span></span><br><span class="line"><span class="comment">    * 然后会在递归调用的最后一个函数中执行其它语句。再一层层的升上去。</span></span><br><span class="line"><span class="comment">    * 所以中序遍历会有从小到大的输出结果。</span></span><br><span class="line"><span class="comment">    * 后续的先序和后续遍历和这个原理差不多，取决于callback放在哪儿。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        inOrderTraverseNode(root, callback);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中序遍历的辅助函数，用于遍历节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span>   </span>node     遍历开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点不为NULL则继续递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            inOrderTraverseNode(node.left, callback);</span><br><span class="line">            <span class="comment">// 获取到节点后，调用的函数</span></span><br><span class="line">            callback(node.key);</span><br><span class="line">            inOrderTraverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前序遍历操作，常用于打印一个结构化的文档</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.preOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        preOrderTranverseNode(root, callback);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前序遍历的辅助函数，用于遍历节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span>   </span>node     遍历开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> preOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback(node.key);</span><br><span class="line">            preOrderTranverseNode(node.left, callback);</span><br><span class="line">            preOrderTranverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 后序遍历操作，常用于计算所占空间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        postOrderTranverseNode(root, callback);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 后序遍历的辅助函数，用于遍历节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span>   </span>node     遍历开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 获取到节点后的回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> postOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">        postOrderTranverseNode(node.left, callback);</span><br><span class="line">        postOrderTranverseNode(node.right, callback);</span><br><span class="line">        callback(node.key);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回树中最小的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Function&#125;</span> </span>min函数的辅助函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNode(root);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * min函数的辅助函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node 查找开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;key&#125;</span>      </span>节点的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">            <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">            <span class="keyword">while</span> (node &amp;amp;&amp;amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回树中最大的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Function&#125;</span> </span>max函数的辅助函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxNode(root);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * max函数的辅助函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node 查找开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Key&#125;</span>      </span>节点的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;amp;&amp;amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 搜索某个值是否存在于树中</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>key 搜索开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Function&#125;</span>     </span>search函数的辅助函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root, key);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * search函数的辅助函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node 搜索开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Key&#125;</span> </span>key  要搜索的键值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>      </span>找到节点则返回true，否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            searchNode(node.left, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            searchNode(node.right, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果该节点值等于传入的值，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从树中移除某个键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Key&#125;</span> </span>key 要移除的键值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Function&#125;</span>     </span>remove函数的辅助函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        root = removeNode(root, key);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * remove函数的辅助函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node 搜索开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Key&#125;</span> </span>key   要移除的键值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>   </span>移除成功则返回true，否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到节点前，继续递归调用。</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            node.left = removeNode(node.left, key)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            node.right = removeNode(node.right, key)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一种场景：只是一个叶节点</span></span><br><span class="line">            <span class="comment">// 这种情况只需要直接把节点赋值为null即可</span></span><br><span class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;amp;&amp;amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            node = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 处理完直接return节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二种场景：有一个子节点</span></span><br><span class="line">            <span class="comment">// 如果左节点为null，则代表右节点存在。</span></span><br><span class="line">            <span class="comment">// 于是把当前节点赋值为存在的那个子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="comment">// 处理完直接return节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="comment">// 处理完直接return节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种场景：有两个子节点</span></span><br><span class="line">            <span class="comment">// 首先加入辅助节点，同时找寻右子节点中的最小节点</span></span><br><span class="line">            <span class="comment">// 并把当前节点替换为右子节点中的最小节点</span></span><br><span class="line">            <span class="comment">// 同时为了避免节点重复，移除右子节点中的最小节点</span></span><br><span class="line">            <span class="keyword">var</span> aux = findMinNode(node.right);</span><br><span class="line">            node.key = aux.key;</span><br><span class="line"></span><br><span class="line">            node.right = removeNode(node.right, aux.key);</span><br><span class="line">            <span class="comment">// 处理完直接return节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * remove函数的辅助函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Node&#125;</span> </span>node 查找开始的节点，默认为root</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Node&#125;</span>      </span>最小的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">            <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">            <span class="keyword">while</span> (node &amp;amp;&amp;amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line">tree.insert(<span class="number">1</span>)</span><br><span class="line">tree.insert(<span class="number">4</span>)</span><br><span class="line">tree.insert(<span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">6</span>)</span><br><span class="line">tree.insert(<span class="number">8</span>)</span><br><span class="line">tree.insert(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tree.search(<span class="number">1</span>) ? <span class="string">&quot;key 1 find&quot;</span> : <span class="string">&quot;key 1 not find&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tree.search(<span class="number">22</span>) ? <span class="string">&quot;key 22 find&quot;</span> : <span class="string">&quot;key 22 not find&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>bind 的polyfill补充</title>
    <url>/2020/11/14/js/bind-polyfill/</url>
    <content><![CDATA[<p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank">原文地址</a></p>
<p>bind 函数的三个特点：</p>
<ol><li>1.返回一个函数</li><li>2.可以传入参数</li><li>3.一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</li></ol>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Yes, it does work with `new funcA.bind(thisArg, args)`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ArrayPrototypeSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">        <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">otherThis</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">            <span class="comment">// internal IsCallable function</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function.prototype.bind- what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseArgs= ArrayPrototypeSlice .call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        baseArgsLength = baseArgs.length,</span><br><span class="line">        fToBind = <span class="built_in">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// reset to default base arguments       baseArgs.length = baseArgsLength; </span></span><br><span class="line">            baseArgs.push.apply(baseArgs, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，</span></span><br><span class="line">            将绑定函数的 <span class="built_in">this</span> 指向该实例，可以让实例获得来自绑定函数的值       <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">                fNOP.prototype.isPrototypeOf(<span class="built_in">this</span>) ? <span class="built_in">this</span> : otherThis, baseArgs</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">            <span class="comment">// Function.prototype doesn&#x27;t have a prototype property</span></span><br><span class="line">            fNOP.prototype = <span class="built_in">this</span>.prototype; </span><br><span class="line">        &#125;</span><br><span class="line">        fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> fBound;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)();</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>运用一个空函数做中转，在直接修改 fBound.prototype 的时候，就不会修改绑定函数的 prototype</p>
<p>但是像fn.prototype.name.type = 8888</p>
<p>还是会修改绑定函数的prototype<br>但是原生的bind返回的函数是没有prototype属性的，<br>也就是无法访问到绑定函数的原型链</p>
]]></content>
  </entry>
  <entry>
    <title>Function.prototype.bind()</title>
    <url>/2020/11/14/js/bind/</url>
    <content><![CDATA[<blockquote>
<p>bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank">原文地址</a></p>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
<h3 id="thisArg："><a href="#thisArg：" class="headerlink" title="thisArg："></a>thisArg：</h3><p>调用绑定函数时作为this参数传递给目标函数的值。 如果使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" title="new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。">new</a>运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果bind函数的参数列表为空，执行作用域的this将被视为新函数的thisArg。</p>
<h3 id="arg1-arg2-…"><a href="#arg1-arg2-…" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h3><pre><code>当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。
### 返回值：
    返回一个原函数的拷贝，并拥有指定的this值和初始参数。</code></pre>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E5%88%9B%E5%BB%BA%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0" style="color: rgb(249, 150, 59);">创建绑定函数</a></p>
<p>bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.x = <span class="number">9</span>;    <span class="comment">// 在浏览器中，this指向全局的 &quot;window&quot; 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">        x: <span class="number">81</span>,</span><br><span class="line">        getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX();   </span><br><span class="line"><span class="comment">// 返回9 - 因为函数是在全局作用域中调用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新函数，把 &#x27;this&#x27; 绑定到 module 对象</span></span><br><span class="line"><span class="comment">// 新手可能会将全局变量 x 与 module 的属性 x 混淆</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>


<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>bind()的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为bind()的参数写在this后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addArguments</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = addArguments(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class="line"><span class="keyword">var</span> addThirtySeven = addArguments.bind(<span class="literal">null</span>, <span class="number">37</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); </span><br><span class="line"><span class="comment">// [37]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// [37, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = addThirtySeven(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 37 + 5 = 42 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = addThirtySeven(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br></pre></td></tr></table></figure>
<h2 id="配合-setTimeout"><a href="#配合-setTimeout" class="headerlink" title="配合 setTimeout"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E9%85%8D%E5%90%88_setTimeout" style="color: rgb(249, 150, 59);">配合 setTimeout</a></h2><p>在默认情况下，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" title="WindowOrWorkerGlobalScope 混合的 setTimeout()方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。">window.setTimeout()</a> 时，this 关键字会指向 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" title="The window object represents a window containing a DOM document; the document property points to the DOM document loaded in that window.">window</a> （或global）对象。当类的方法中需要 this 指向类的实例时，你可能需要显式地把 this 绑定到回调函数，就不会丢失该实例的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LateBloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 1 秒钟后声明 bloom</span></span><br><span class="line">LateBloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="built_in">this</span>.declare.bind(<span class="built_in">this</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LateBloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am a beautiful flower with &#x27;</span> +</span><br><span class="line">    <span class="built_in">this</span>.petalCount + <span class="string">&#x27; petals!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flower = <span class="keyword">new</span> LateBloomer();</span><br><span class="line">flower.bloom();  <span class="comment">// 一秒钟后, 调用&#x27;declare&#x27;方法</span></span><br></pre></td></tr></table></figure>
<h2 id="快捷调用"><a href="#快捷调用" class="headerlink" title="快捷调用"></a>快捷调用</h2><p>在你想要为一个需要特定的 this 值的函数创建一个捷径（shortcut）的时候，bind() 也很好用。<br>你可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="The source for this interactive demo is stored in a GitHub repository. If you'd like to contribute to the interactive demo project, please clone https://github.com/mdn/interactive-examples and send us a pull request.">Array.prototype.slice</a> 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，就拿它来举例子吧。你可以简单地这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">slice.apply(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>用 bind()可以使这个过程变得简单。在下面这段代码里面，slice 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" title="Function.prototype 属性存储了 Function 的原型对象。">Function.prototype</a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。">apply()</a> 方法的绑定函数，并且将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" title="Array.prototype  属性表示 Array 构造函数的原型，并允许您向所有Array对象添加新的属性和方法。">Array.prototype</a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="The source for this interactive demo is stored in a GitHub repository. If you'd like to contribute to the interactive demo project, please clone https://github.com/mdn/interactive-examples and send us a pull request.">slice()</a> 方法作为 this 的值。这意味着我们压根儿用不着上面那个 apply()调用了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与前一段代码的 &quot;slice&quot; 效果相同</span></span><br><span class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.apply.bind(unboundSlice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">slice(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">        <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">            <span class="comment">// internal IsCallable function</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="built_in">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">                <span class="keyword">return</span> fToBind.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                        ? <span class="built_in">this</span></span><br><span class="line">                        : oThis,</span><br><span class="line">                        <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                        aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">            <span class="comment">// Function.prototype doesn&#x27;t have a prototype property</span></span><br><span class="line">            fNOP.prototype = <span class="built_in">this</span>.prototype; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS HEX十六进制与RGB, HSL颜色的相互转换</title>
    <url>/2020/11/14/js/color-hex-rgb/</url>
    <content><![CDATA[<blockquote>
<p>JavaScript颜色转换的核心就是进制间的转换。RGB格式其实就是十进制表示法，所以，十六进制颜色与RGB颜色的转换就是十六进制与十进制之间的转换。</p>
</blockquote>
<p>十六进制转换为十进制相对容易些，核心代码如下示例：parseInt(“0xFF”)，其结果就是255，”0x”就表明当前是16进制，由于parseInt后面无参数，默认就是转换为10进制了。</p>
<h2 id="一：十进制—–-gt-十六进制颜色"><a href="#一：十进制—–-gt-十六进制颜色" class="headerlink" title="一：十进制—–&gt;十六进制颜色"></a>一：十进制—–&gt;十六进制颜色</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getHexColor(colorValue: number): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + (<span class="string">&#x27;000000&#x27;</span> + colorValue.toString(<span class="number">16</span>)).slice(-<span class="number">6</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="二：十六进制—–-gt-rgb颜色"><a href="#二：十六进制—–-gt-rgb颜色" class="headerlink" title="二：十六进制—–&gt;rgb颜色"></a>二：十六进制—–&gt;rgb颜色</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">var</span> hexToRgb = <span class="function"><span class="keyword">function</span>(<span class="params">hex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rgb = [];</span><br><span class="line">        hex = hex.substr(<span class="number">1</span>);<span class="comment">//去除前缀 # 号</span></span><br><span class="line">        <span class="keyword">if</span> (hex.length === <span class="number">3</span>) &#123; <span class="comment">// 处理 &quot;#abc&quot; 成 &quot;#aabbcc&quot;</span></span><br><span class="line">            hex = hex.replace(<span class="regexp">/(.)/g</span>, <span class="string">&#x27;$1$1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hex.replace(<span class="regexp">/../g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">            rgb.push(<span class="built_in">parseInt</span>(color, <span class="number">0x10</span>));<span class="comment">//按16进制将字符串转换为数字</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + rgb.join(<span class="string">&quot;,&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三：rgb—–-gt-十六进制颜色"><a href="#三：rgb—–-gt-十六进制颜色" class="headerlink" title="三：rgb—–&gt;十六进制颜色##"></a>三：rgb—–&gt;十六进制颜色##</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> rgbToHex = <span class="function"><span class="keyword">function</span>(<span class="params">rgb</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// rgb(x, y, z)</span></span><br><span class="line">        <span class="keyword">var</span> color = rgb.toString().match(<span class="regexp">/\\d+/g</span>); <span class="comment">// 把 x,y,z 推送到 color 数组里</span></span><br><span class="line">        <span class="keyword">var</span> hex = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// &#x27;Number.toString(16)&#x27; 是JS默认能实现转换成16进制数的方法.</span></span><br><span class="line">            <span class="comment">// &#x27;color[i]&#x27; 是数组，要转换成字符串.</span></span><br><span class="line">            <span class="comment">// 如果结果是一位数，就在前面补零。例如： A变成0A</span></span><br><span class="line">            hex += (<span class="string">&quot;0&quot;</span> + <span class="built_in">Number</span>(color[i]).toString(<span class="number">16</span>)).slice(-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> hex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四：十进制—–-gt-rgb颜色"><a href="#四：十进制—–-gt-rgb颜色" class="headerlink" title="四：十进制—–&gt;rgb颜色"></a>四：十进制—–&gt;rgb颜色</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> alpha = number &gt; <span class="number">24</span> &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">const</span> red = number &gt; <span class="number">16</span> &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">const</span> green = number &gt; <span class="number">8</span> &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">const</span> blue = number &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>, <span class="subst">$&#123;green&#125;</span>, <span class="subst">$&#123;blue&#125;</span>, <span class="subst">$&#123;alpha&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">number</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">let</span> color = number;    </span><br><span class="line">    <span class="keyword">const</span> blue = <span class="built_in">parseInt</span>(color % <span class="number">0x100</span>, <span class="number">10</span>);</span><br><span class="line">    color = color &gt; <span class="number">8</span>;    </span><br><span class="line">    <span class="keyword">const</span> green = <span class="built_in">parseInt</span>(color % <span class="number">0x100</span>, <span class="number">10</span>);    </span><br><span class="line">    color = color &gt; <span class="number">8</span>;    </span><br><span class="line">    <span class="keyword">const</span> red = <span class="built_in">parseInt</span>(color % <span class="number">0x100</span>, <span class="number">10</span>);    </span><br><span class="line">    <span class="keyword">const</span> alpha = (<span class="built_in">parseInt</span>(color &gt; <span class="number">8</span>, <span class="number">10</span>) / <span class="number">0xFF</span>).toFixed(<span class="number">1</span>);       </span><br><span class="line">    <span class="keyword">return</span>  <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>, <span class="subst">$&#123;green&#125;</span>, <span class="subst">$&#123;blue&#125;</span>, <span class="subst">$&#123;alpha&#125;</span>)`</span>;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="五：hsl—–-gt-rgb"><a href="#五：hsl—–-gt-rgb" class="headerlink" title="五：hsl—–&gt;rgb"></a>五：hsl—–&gt;rgb</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HSL颜色值转换为RGB. </span></span><br><span class="line"><span class="comment">    * 换算公式改编自 http://en.wikipedia.org/wiki/HSL_color_space.</span></span><br><span class="line"><span class="comment">    * h, s, 和 l 设定在 [0, 1] 之间</span></span><br><span class="line"><span class="comment">    * 返回的 r, g, 和 b 在 [0, 255]之间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  h       色相</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  s       饱和度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  l       亮度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return  </span>Array           RGB色值数值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hslToRgb</span>(<span class="params">h, s, l</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r, g, b;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">s == <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">            r = g = b = l; <span class="comment">// achromatic</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> hue2rgb = <span class="function"><span class="keyword">function</span> <span class="title">hue2rgb</span>(<span class="params">p, q, t</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t &amp;lt; <span class="number">0</span>) t += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &gt; <span class="number">1</span>) t -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(t &amp;lt; <span class="number">1</span>/<span class="number">6</span>) <span class="keyword">return</span> p + (q - p) * <span class="number">6</span> * t;</span><br><span class="line">                <span class="keyword">if</span>(t &amp;lt; <span class="number">1</span>/<span class="number">2</span>) <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">if</span>(t &amp;lt; <span class="number">2</span>/<span class="number">3</span>) <span class="keyword">return</span> p + (q - p) * (<span class="number">2</span>/<span class="number">3</span> - t) * <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> q = l &amp;lt; <span class="number">0.5</span> ? l * (<span class="number">1</span> + s) : l + s - l * s;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="number">2</span> * l - q;</span><br><span class="line">        r = hue2rgb(p, q, h + <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">        g = hue2rgb(p, q, h);</span><br><span class="line">        b = hue2rgb(p, q, h - <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">Math</span>.round(r * <span class="number">255</span>), <span class="built_in">Math</span>.round(g * <span class="number">255</span>), <span class="built_in">Math</span>.round(b * <span class="number">255</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六：rgb—–-gt-hls"><a href="#六：rgb—–-gt-hls" class="headerlink" title="六：rgb—–&gt;hls"></a>六：rgb—–&gt;hls</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * RGB 颜色值转换为 HSL.</span></span><br><span class="line"><span class="comment">    * 转换公式参考自 http://en.wikipedia.org/wiki/HSL_color_space.</span></span><br><span class="line"><span class="comment">    * r, g, 和 b 需要在 [0, 255] 范围内</span></span><br><span class="line"><span class="comment">    * 返回的 h, s, 和 l 在 [0, 1] 之间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  r       红色色值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  g       绿色色值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param   </span>Number  b       蓝色色值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return  </span>Array           HSL各值数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgbToHsl</span>(<span class="params">r, g, b</span>) </span>&#123;</span><br><span class="line">        r /= <span class="number">255</span>, g /= <span class="number">255</span>, b /= <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="built_in">Math</span>.max(r, g, b), min = <span class="built_in">Math</span>.min(r, g, b);</span><br><span class="line">        <span class="keyword">var</span> h, s, l = (max + min) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (max == min)&#123; </span><br><span class="line">            h = s = <span class="number">0</span>; <span class="comment">// achromatic</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> d = max - min;</span><br><span class="line">            s = l &gt; <span class="number">0.5</span> ? d / (<span class="number">2</span> - max - min) : d / (max + min);</span><br><span class="line">            <span class="function"><span class="title">switch</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> r: h = (g - b) / d + (g &amp;lt; b ? <span class="number">6</span> : <span class="number">0</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> g: h = (b - r) / d + <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> b: h = (r - g) / d + <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        h /= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [h, s, l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="七：rgb—-gt-hsb-hsv"><a href="#七：rgb—-gt-hsb-hsv" class="headerlink" title="七：rgb—-&gt;hsb/hsv"></a>七：rgb—-&gt;hsb/hsv</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgbToHsv</span>(<span class="params">r, g, b</span>) </span>&#123;</span><br><span class="line">        r = r / <span class="number">255</span>;</span><br><span class="line">        g = g / <span class="number">255</span>;</span><br><span class="line">        b = b / <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">var</span> h, s, v;</span><br><span class="line">        <span class="keyword">var</span> min = <span class="built_in">Math</span>.min(r, g, b);</span><br><span class="line">        <span class="keyword">var</span> max = v = <span class="built_in">Math</span>.max(r, g, b);</span><br><span class="line">        <span class="keyword">var</span> l = (min + max) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">var</span> difference = max - min;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (max == min) &#123;</span><br><span class="line">            h = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (max) &#123;</span><br><span class="line">            <span class="keyword">case</span> r:</span><br><span class="line">                h = (g - b) / difference + (g &amp;lt; b ? <span class="number">6</span> : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> g:</span><br><span class="line">                h = <span class="number">2.0</span> + (b - r) / difference;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> b:</span><br><span class="line">                h = <span class="number">4.0</span> + (r - g) / difference;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        h = <span class="built_in">Math</span>.round(h * <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="number">1</span> - min / max;</span><br><span class="line">        &#125;</span><br><span class="line">    s = <span class="built_in">Math</span>.round(s * <span class="number">100</span>);</span><br><span class="line">    v = <span class="built_in">Math</span>.round(v * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> [h, s, v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Date对象 format</title>
    <url>/2020/11/14/js/data-format/</url>
    <content><![CDATA[<p>Date对象的内置方法以及自定义格式化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">console.log(d); // 输出：Mon Nov 04 2013 21:50:33 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(d.toDateString()); // 日期字符串，输出：Mon Nov 04 2013</span><br><span class="line">console.log(d.toGMTString()); // 格林威治时间，输出：Mon, 04 Nov 2013 14:03:05 GMT</span><br><span class="line">console.log(d.toISOString()); // 国际标准组织（ISO）格式，输出：2013-11-04T14:03:05.420Z</span><br><span class="line">console.log(d.toJSON()); // 输出：2013-11-04T14:03:05.420Z</span><br><span class="line">console.log(d.toLocaleDateString()); // 转换为本地日期格式，视环境而定，输出：2013年11月4日</span><br><span class="line">console.log(d.toLocaleString()); // 转换为本地日期和时间格式，视环境而定，输出：2013年11月4日 下午10:03:05</span><br><span class="line">console.log(d.toLocaleTimeString()); // 转换为本地时间格式，视环境而定，输出：下午10:03:05</span><br><span class="line">console.log(d.toString()); // 转换为字符串，输出：Mon Nov 04 2013 22:03:05 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(d.toTimeString()); // 转换为时间字符串，输出：22:03:05 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(d.toUTCString()); // 转换为世界时间，输出：Mon, 04 Nov 2013 14:03:05 GMT</span><br></pre></td></tr></table></figure>
<p>或者自定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">formatDate(date: Date | null, format?: string): string &#123;</span><br><span class="line">    const d = date || new Date();</span><br><span class="line">    <span class="built_in">let</span> f = format || <span class="string">&#x27;yyyy-MM-dd mm:ss&#x27;</span>;</span><br><span class="line">    const mapping = &#123;</span><br><span class="line">        <span class="string">&#x27;M+&#x27;</span>: d.getMonth() + 1,</span><br><span class="line">        <span class="string">&#x27;d+&#x27;</span>: d.getDate(),</span><br><span class="line">        <span class="string">&#x27;h+&#x27;</span>: d.getHours(),</span><br><span class="line">        <span class="string">&#x27;m+&#x27;</span>: d.getMinutes(),</span><br><span class="line">        <span class="string">&#x27;s+&#x27;</span>: d.getSeconds(),</span><br><span class="line">        <span class="string">&#x27;q+&#x27;</span>: Math.floor((d.getMonth() + 3) / 3),</span><br><span class="line">        <span class="string">&#x27;S+&#x27;</span>: d.getMilliseconds(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (/(y+)/i.test(f)) &#123;</span><br><span class="line">            f = f.replace(RegExp.<span class="variable">$1</span>, d.getFullYear().toString().substr(4 - RegExp.<span class="variable">$1</span>.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (const k <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">            <span class="keyword">if</span> (new RegExp(`(<span class="variable">$&#123;k&#125;</span>)`).<span class="built_in">test</span>(f)) &#123;</span><br><span class="line">                const n = RegExp.<span class="variable">$1</span>.length === 1 ? mapping[k] : (<span class="string">&#x27;00&#x27;</span> + mapping[k]).substr(mapping[k].toString().length);</span><br><span class="line">            f = f.replace(RegExp.<span class="variable">$1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>种草 ES2020 新特性</title>
    <url>/2020/11/14/js/es2020/</url>
    <content><![CDATA[<p><a href="https://prop-tc39.now.sh/" target="_blank">查看标准</a></p>
<h2 id="一：Promise-allSettled"><a href="#一：Promise-allSettled" class="headerlink" title="一：Promise.allSettled"></a>一：Promise.allSettled</h2><p>并发任务中，无论一个任务正常或者异常，都会返回对应的的状态（fulfilled 或者 rejected）与结果（业务value 或者 拒因 reason），在 then 里面通过 filter 来过滤出想要的业务逻辑结果，这就能最大限度的保障业务当前状态的可访问性，而 Promise.allSettled 就是解决这问题的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(&#123;<span class="attr">code</span>: <span class="number">500</span>, <span class="attr">msg</span>: <span class="string">&#x27;服务异常&#x27;</span>&#125;),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: []&#125;),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(&#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: []&#125;)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0: &#123;status: &quot;rejected&quot;, reason: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">        1: &#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">        2: &#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span></span><br><span class="line">    RenderContent(ret.filter(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> el.status !== <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="二：可选链（Optional-chaining）"><a href="#二：可选链（Optional-chaining）" class="headerlink" title="二：可选链（Optional chaining）"></a>二：可选链（Optional chaining）</h2><p>可选链 可让我们在查询具有多层级的对象时，不再需要进行冗余的各种前置校验。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = user &amp;&amp; user.info &amp;&amp; user.info.name;</span><br><span class="line"><span class="keyword">var</span> age = user &amp;&amp; user.info &amp;&amp; user.info.getAge &amp;&amp; user.info.getAge();</span><br><span class="line"><span class="comment">// 之后：</span></span><br><span class="line"><span class="keyword">var</span> name = user?.info?.name;</span><br><span class="line"><span class="keyword">var</span> age = user?.info?.getAge?.();</span><br></pre></td></tr></table></figure>


<h2 id="三：空值合并运算符"><a href="#三：空值合并运算符" class="headerlink" title="三：空值合并运算符"></a>三：空值合并运算符</h2><p>只有值为undefined 或者 null  的时候，才会取默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> level = user.data?.level ?? <span class="string">&#x27;暂无等级&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="四：dynamic-import"><a href="#四：dynamic-import" class="headerlink" title="四：dynamic-import"></a>四：dynamic-import</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">el.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">`/path/current-logic.js`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">module</span>.doSomthing();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// load error;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五：globalThis"><a href="#五：globalThis" class="headerlink" title="五：globalThis"></a>五：globalThis</h2><p>而 globalThis 目的就是提供一种标准化方式访问全局对象，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> self; &#125; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">global</span>; &#125; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;unable to locate global object&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globals = getGlobal(); </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis" target="_blank">MDN</a></p>
<h2 id="六：BigInt"><a href="#六：BigInt" class="headerlink" title="六：BigInt"></a>六：BigInt</h2><p>BigInt 是一种新的数据原始（primitive）类型</p>
<p>我们可以用 BigInt 对象表示大于  的整数。可以通过常规操作（例如算术运算符）进行加、减、乘、除、余数和幂等运算。它可以由数字和十六进制或二进制字符串构造。此外它还支持 AND、OR、NOT 和 XOR 之类的按位运算。唯一无效的位运算是零填充右移运算符（&gt;&gt;&gt;）。</p>
<p>使用 BigInt 有两种方式：</p>
<p>1、在整数字面量后面加n。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bigIntNum = <span class="number">9007199254740993n</span>;</span><br></pre></td></tr></table></figure>
<p>2、使用 BigInt 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bigIntNum = BigInt(<span class="number">9007199254740</span>);</span><br></pre></td></tr></table></figure>


<h2 id="七：String-prototype-matchAll"><a href="#七：String-prototype-matchAll" class="headerlink" title="七：String.prototype.matchAll"></a>七：String.prototype.matchAll</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;\\w+&gt;(.*?)&lt;\\/</span>\\w+&gt;/g;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">// -&gt; [&quot;&lt;text&gt;JS&lt;/text&gt;&quot;, &quot;&lt;text&gt;正则&lt;/text&gt;&quot;]</span></span><br></pre></td></tr></table></figure>



<p>ES2020提供了一种简易的方式：String.prototype.matchAll, 该方法会返回一个迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> allMatchs = str.matchAll(<span class="regexp">/&lt;\\w+&gt;(.*?)&lt;\\/</span>\\w+&gt;/g);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> allMatchs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次迭代返回：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &quot;&lt;text&gt;JS&lt;/text&gt;&quot;, </span></span><br><span class="line"><span class="comment">//     &quot;JS&quot;, </span></span><br><span class="line"><span class="comment">//     index: 0, </span></span><br><span class="line"><span class="comment">//     input: &quot;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&quot;, </span></span><br><span class="line"><span class="comment">//     groups: undefined</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代返回：</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &quot;&lt;text&gt;正则&lt;/text&gt;&quot;, </span></span><br><span class="line"><span class="comment">//     &quot;正则&quot;, </span></span><br><span class="line"><span class="comment">//     index: 15, </span></span><br><span class="line"><span class="comment">//     input: &quot;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&quot;, </span></span><br><span class="line"><span class="comment">//     groups: undefined</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>能看出每次迭代中可获取所有的匹配，以及本次匹配的成功的一些其他元信息。</p>
<h2 id="八、for-in-结构"><a href="#八、for-in-结构" class="headerlink" title="八、for-in 结构"></a>八、for-in 结构</h2><p>ECMA-262 几乎全部未指明 for (a in b) 顺序 ，但真正的引擎至少在某些情况下是一致的。</p>
<p>历史上为获得完整的 for-in 顺序规范的一致意见所做的努力一再失败，部分原因是所有的引擎都有自己独特的实现，这是大量工作的结果，而且它们并不想重新讨论。</p>
<p>总之，当使用 for (a in b) 控制结构时，不同的引擎已就如何迭代属性达成一致，从而使行为标准化。</p>
<p>参考：<br><span style="font-size: large;"></p>
<p><a href="https://learnku.com/f2e/t/39536?order_by=created_at&" target="_blank" style="font-weight: normal; font-size: large;">JavaScript ES2020 新特性的实例</a></p>
<p><a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank">tc39-Github</a></p>
<p><a href="https://dev.to/carlillo/es2020-features-in-simple-examples-1513" target="_blank"><i></i></a><br><a href="https://zhuanlan.zhihu.com/p/100251213" target="_blank">种草 ES2020 新特性</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTML DOM (文档对象模型)</title>
    <url>/2020/11/14/js/dom/</url>
    <content><![CDATA[<blockquote>
<p>文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容</p>
</blockquote>
<p>DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。<br>说白了DOM就是浏览器为JavaScript提供的一系列接口（通过window.documnet提供的），通过这些接口我们可以操作web页面。 但DOM并不是编程语言，它是文档对象的模型，该模型是独立于编程语言的。</p>
<h2 id="DOM-创建"><a href="#DOM-创建" class="headerlink" title="DOM 创建"></a>DOM 创建</h2><p>DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数：<ol><li>Element，元素 ——1</li><li>Attribute，属性 ——–2</li><li>Text，文本 ——3</li><li>comment 节点 ——8</li><li>Document 节点 ——9</li><li>DocumentFrament节点 ——11</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType" target="_blank">其他的参见这</a></p>
</li></ol>
DOM节点创建最常用的便是<a href="http://www.w3school.com.cn/xmldom/met_document_createelement.asp">document.createElement</a>和document.createTextNode方法：


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el1 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;hello world!&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h2><p>元素查询的API返回的的结果是DOM节点或者DOM节点的列表。document提供了两种Query方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前文档中第一个类名为 &quot;myclass&quot; 的元素</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个文档中所有的class为&quot;note&quot;或者 &quot;alert&quot;的div元素</span></span><br><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div.note, div.alert&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;highlight&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// name属性</span></span><br></pre></td></tr></table></figure>

<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><ol>
<li>element.<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank">addEventListener</a>(type, listener, [, options])<br>给元素添加指定事件type以及响应该事件的回调函数listener。options也可以为Boolean值表示捕获阶段还是冒泡阶段执行默认为false，冒泡阶段执行</li>
<li>element.<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener" target="_blank">removeEventListener</a>(type, listener, [, options])<br>移除元素上指定事件，如果元素上分别在捕获和冒泡阶段都注册了事件，需要分别移除。</li>
<li>document.<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createEvent" target="_blank">createEvent</a>()<br>创建一个自定义事件，随后必须使用init进行初始化。</li>
<li>element.<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent" target="_blank">dispatchEvent</a>(event)<br>对指定元素触发一个事件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件名为&#x27;build&#x27;.</span></span><br><span class="line">event.initEvent(<span class="string">&#x27;build&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// e.target matches elem</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发对象可以是任何元素或其他事件目标</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<h2 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h2><p>1、js如何操作class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">加类：   dom.classList.add(className);</span><br><span class="line">移除类： dom.classList.remove(className);</span><br><span class="line">替换类： dom.classList.replace(className1,className2);</span><br><span class="line">判断类： dom.classList.contains(className);　　　　<span class="comment">// 这个只能一次判断一个 类</span></span><br></pre></td></tr></table></figure>


<p>2、js如何操作style</p>
<p>如果属性有’-‘号，就写成驼峰的形式（如textAlign）  如果想保留 - 号，<br>就中括号的形式  element.style[‘text-align’] = ‘100px’;</p>
<p>3、设置style的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.setAttribute(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;height: 100px !important&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p>4、使用setProperty  如果要设置!important，推荐用这种方法设置第三个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.style.setProperty(<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;300px&#x27;</span>, <span class="string">&#x27;important&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>5、设置cssText</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.style.cssText += <span class="string">&#x27;height: 100px !important&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>6、insertRule()、addRule</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[sheet].insertRule([CSS样式]，指定位置)</span><br><span class="line">    </span><br><span class="line">[sheet]表示某个样式表，它可以通过<span class="built_in">document</span>.styleSheets来获得</span><br></pre></td></tr></table></figure>
<p>然后用JS获取这个样式表：</p>
<p>最后我们就可以给这个样式表中添加样式了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</span><br><span class="line">sheet.addRule(<span class="string">&#x27;.box&#x27;</span>, <span class="string">&#x27;height: 100px&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>sheet.insertRule(‘#box{width: 300px; height: 300px; background-color: #0f0;}’,0);<br>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 或者插入新样式时操作</span></span><br><span class="line">    <span class="keyword">var</span> styleEl = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>),</span><br><span class="line">        styleSheet = styleEl.sheet;</span><br><span class="line"></span><br><span class="line">    styleSheet.addRule(<span class="string">&#x27;.box&#x27;</span>, <span class="string">&#x27;height: 100px&#x27;</span>);</span><br><span class="line">    styleSheet.insertRule(<span class="string">&#x27;.box &#123;height: 100px&#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(styleEl);  </span><br></pre></td></tr></table></figure>



<h2 id="DOM元素的属性和方法"><a href="#DOM元素的属性和方法" class="headerlink" title="DOM元素的属性和方法"></a>DOM元素的属性和方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>element.id</td><td>设置或者返回元素的 id 属性</td></tr><tr><td>element.className</td><td>设置或者返回元素的 class 属性</td></tr><tr><td>element.style</td><td>设置或返回元素的 style 属性</td></tr><tr><td>element.title</td><td>设置或者返回元素的 title 属性</td></tr><tr><td>element.innerHTML</td><td>设置或返回元素的内容</td></tr><tr><td>element.tagName</td><td>返回元素的标签名</td></tr><tr><td>element.lastChiled</td><td>返回元素的最后一个子元素</td></tr><tr><td>element.nodeValue</td><td>设置或返回元素的值</td></tr><tr><td>element.nodeName</td><td>返回元素的名称</td></tr><tr><td>element.nodeType</td><td>返回元素的节点类型</td></tr><tr><td>element.toString()</td><td>把元素转为字符串</td></tr><tr><td>element.textContent</td><td>设置或者返回节点及其后代的内容</td></tr><tr><td>element.parentNode</td><td>返回元素的父节点</td></tr><tr><td>element.appendChild()</td><td>向元素添加新的子节点，作为最后一个子节点</td></tr><tr><td>element.cloneNode()</td><td>克隆元素</td></tr><tr><td>element.getAttribute()</td><td>返回元素节点的指定属性值</td></tr><tr><td>element.getAttributeNode()</td><td>返回指定的属性节点</td></tr><tr><td>element.removeAttribute()</td><td>从元素中移除指定属性</td></tr><tr><td>element.removeAttributeNode()</td><td>移除指定的属性节点，并返回被移除的节点</td></tr><tr><td>element.hasAttribute()</td><td>如果元素拥有指定属性，则返回true,否则返回false</td></tr><tr><td>element.hasAttributes()</td><td>如果元素拥有属性，则返回true,否则返回false</td></tr><tr><td>element.hasChildNodes()</td><td>如果元素拥有子节点，则返回true,否则返回false</td></tr><tr><td>element.clientWidth</td><td>返回元素的可见宽度</td></tr><tr><td>element.clientHeight</td><td>返回元素的可见高度</td></tr><tr><td>element.offsetWidth</td><td>返回元素的宽度</td></tr><tr><td>element.offsetHeight</td><td>返回元素的高度</td></tr><tr><td>element.offsetLeft</td><td>返回元素的水平偏移位置</td></tr><tr><td>element.offsetTop</td><td>返回元素的垂直偏移位置</td></tr><tr><td>element.offsetParent</td><td>返回元素的偏移容器</td></tr><tr><td>element.scrollWidth</td><td>返回元素的整体宽度</td></tr><tr><td>element.scrollHeight</td><td>返回元素的整体高度</td></tr><tr><td>element.scrollLeft</td><td>返回元素左边缘与视图之间的距离</td></tr><tr><td>element.scrollTop</td><td>返回元素上边缘与视图之间的距离</td></tr><tr><td>element.childNodes</td><td>范湖元素子节点的 NodeList 。</td></tr><tr><td>nodelist.item()</td><td>返回 NodeList 中位于指定下标的节点</td></tr><tr><td>nodelist.length</td><td>返回 NodeList 中的节点数</td></tr></tbody></table>

<h3>元素样式尺寸</h3>
1. window.getComputedStyle(elem)
获取elem所有应用了css后的属性值。返回一个实时的 CSSStyleDeclaration 对象。
2. elem.getBoundingClientRect()
返回元素的大小以及相对于视口的位置。返回一个DOMRect对象。包括元素的 left right top bottom width height x y 属性值。

<p><img src="/img/dom.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>es6相关（二）Symbol</title>
    <url>/2020/11/14/js/es6-2/</url>
    <content><![CDATA[<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，</p>
<blockquote>
<p>前六种是： undefined、 null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
</blockquote>
<p>Symbol 值通过 Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<blockquote>
<p>注意， Symbol函数前不能使用 new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
</blockquote>
<p> Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。如果 Symbol 的参数是一个对象，就会调用该对象的 toString方法，将其转为字符串，然后才生成一个 Symbol 值。<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">s1  </span><br><span class="line"><span class="comment">// Symbol(foo)   &#x27;asd&#x27; + s1 // 报错</span></span><br><span class="line"><span class="built_in">String</span>（s1）</span><br><span class="line"><span class="comment">//  &quot;Symbol(foo)&quot;  s1.toString()  </span></span><br><span class="line"><span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意， Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol函数的返回值是不相等的。</p>
</blockquote>
<blockquote>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
</blockquote>
<p>但是，Symbol 值可以显式转为字符串。</p>
<h2 id="1、作为属性名的-Symbol"><a href="#1、作为属性名的-Symbol" class="headerlink" title="1、作为属性名的 Symbol"></a>1、作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">      [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]  <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<h2 id="2、属性名的遍历"><a href="#2、属性名的遍历" class="headerlink" title="2、属性名的遍历"></a>2、属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在 for…in、 for…of循环中，也不会被 Object.keys()、 Object.getOwnPropertyNames()、 JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。<br>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols </span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<h2 id="3、Symbol-for-，Symbol-keyFor"><a href="#3、Symbol-for-，Symbol-keyFor" class="headerlink" title="3、Symbol.for()，Symbol.keyFor()"></a>3、Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值， Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p> Symbol.keyFor方法返回一个已登记的 Symbol 类型值的 key。<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1)  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4、内置的-Symbol-值"><a href="#4、内置的-Symbol-值" class="headerlink" title="4、内置的 Symbol 值"></a>4、内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<ul>
<li>1、Symbol.hasInstance<br>对象的 Symbol.hasInstance属性，指向一个内部方法。当其他对象使用 instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如， foo instanceof Foo在语言内部，实际调用的是 Foo[Symbol.hasInstance]”(foo)”。</li>
<li>2、Symbol.isConcatSpreadable<br>对象的 Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于 Array.prototype.concat()时，是否可以展开。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].concat(arr1, <span class="string">&#x27;e&#x27;</span>)  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable]  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].concat(arr2, <span class="string">&#x27;e&#x27;</span>)  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3、Symbol.species<br>对象的 Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。</li>
<li>4、Symbol.match<br>对象的 Symbol.match属性，指向一个函数。当执行 str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp) </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure></li>
<li>5、Symbol.replace<br>对象的 Symbol.replace属性，指向一个方法，当该对象被 String.prototype.replace方法调用时，会返回该方法的返回值。</li>
<li>6、Symbol.search<br>对象的 Symbol.search属性，指向一个方法，当该对象被 String.prototype.search方法调用时，会返回该方法的返回值。</li>
<li>7、Symbol.split<br>对象的 Symbol.split属性，指向一个方法，当该对象被 String.prototype.split方法调用时，会返回该方法的返回值。</li>
<li>8、Symbol.iterator<br>对象的 Symbol.iterator属性，指向该对象的默认遍历器方法。</li>
<li>9、Symbol.toPrimitive<br>对象的 Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。<br>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">      [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj  <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj  <span class="comment">// &#x27;3default&#x27;</span></span><br><span class="line">obj == <span class="string">&#x27;default&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj)  <span class="comment">// &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>10、Symbol.toStringTag<br>对象的 Symbol.toStringTag属性，指向一个方法。在该对象上面调用 Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在 toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制 [object Object]或 [object Array]中 object后面的那个字符串。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;Foo&#x27;</span>&#125;.toString()) </span><br><span class="line"><span class="comment">// &quot;[object Foo]&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">      get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x)  <span class="comment">// &quot;[object xxx]&quot;</span></span><br></pre></td></tr></table></figure>
ES6 新增内置对象的 Symbol.toStringTag属性值如下。</li>
</ul>
<ul>
<li> JSON[Symbol.toStringTag]：’JSON’</li>
<li> Math[Symbol.toStringTag]：’Math’</li>
<li>Module 对象 M[Symbol.toStringTag]：’Module’</li>
<li> ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’</li>
<li> DataView.prototype[Symbol.toStringTag]：’DataView’</li>
<li> Map.prototype[Symbol.toStringTag]：’Map’</li>
<li> Promise.prototype[Symbol.toStringTag]：’Promise’</li>
<li> Set.prototype[Symbol.toStringTag]：’Set’</li>
<li> %TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等</li>
<li> WeakMap.prototype[Symbol.toStringTag]：’WeakMap’</li>
<li> WeakSet.prototype[Symbol.toStringTag]：’WeakSet’</li>
<li> %MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’</li>
<li> %SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’</li>
<li> %StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’</li>
<li> Symbol.prototype[Symbol.toStringTag]：’Symbol’</li>
<li> Generator.prototype[Symbol.toStringTag]：’Generator’</li>
<li> GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’<h3 id="Symbol-unscopables">11、Symbol.unscopables<br>对象的 Symbol.unscopables属性，指向一个对象。该对象指定了使用 with关键字时，哪些属性会被 with环境排除。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables] </span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">     <span class="comment">//   copyWithin: true,</span></span><br><span class="line"> <span class="comment">//   entries: true,</span></span><br><span class="line"> <span class="comment">//   fill: true,</span></span><br><span class="line"> <span class="comment">//   find: true,</span></span><br><span class="line"> <span class="comment">//   findIndex: true,</span></span><br><span class="line"> <span class="comment">//   includes: true,</span></span><br><span class="line"> <span class="comment">//   keys: true</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]) </span><br><span class="line"><span class="comment">// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
上面代码说明，数组有 7 个属性，会被 with命令排除。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">      foo();  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.unscopables]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">      foo();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
上面代码通过指定 Symbol.unscopables属性，使得 with语法块不会在当前作用域寻找 foo属性，即 foo将指向外层作用域的变量。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>es6相关（四）Proxy、Reflect</title>
    <url>/2020/11/14/js/es6-4/</url>
    <content><![CDATA[<h2 id="1、Proxy"><a href="#1、Proxy" class="headerlink" title="1、Proxy"></a>1、Proxy</h2><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>作为构造函数，Proxy接受两个参数。</p>
<ul>
<li>第一个参数是所要代理的 目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；</li>
<li>第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作</li>
</ul>
<p>Proxy 支持的拦截操作一览，一共 13 种。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate">（忽略enumerate）</a></p>
<ul>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li> getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</ul></li>
</ul>
<h2 id="2、Reflect"><a href="#2、Reflect" class="headerlink" title="2、Reflect"></a>2、Reflect</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p>
<p>Reflect对象一共有 13 个静态方法。（与proxy相对应）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate">（忽略enumerate）</a></p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>es6相关（三）Set、WeakSet、Map、WeakMap</title>
    <url>/2020/11/14/js/es6-3/</url>
    <content><![CDATA[<h2 id="1、Set"><a href="#1、Set" class="headerlink" title="1、Set"></a>1、Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]); [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4  </span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// \&quot;abc\&quot; </span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><blockquote>
<p>Set 结构的实例有以下属性。 </p>
</blockquote>
<ul>
<li>Set.prototype.constructor ：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size ：返回 Set 实例的成员总数。<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 </li>
<li>add(value) ：添加某个值，返回 Set 结构本身。</li>
<li>delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>clear() ：清除所有成员，没有返回值。<blockquote>
<p>遍历操作<br>Set 结构的实例有四个遍历方法，可以用于遍历成员。 </p>
</blockquote>
</li>
<li>keys() ：返回键名的遍历器</li>
<li>values() ：返回键值的遍历器</li>
<li>entries() ：返回键值对的遍历器</li>
<li>forEach() ：使用回调函数遍历每个成员<br>需要特别指出的是， Set 的遍历顺序就是插入顺序</li>
</ul>
<p>扩展运算符（ … ）内部使用 for…of 循环，所以也可以用于 Set 结构。</p>
<p>数组的 map 和 filter 方法也可以间接用于 Set 了。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125; // 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125; </span></span><br></pre></td></tr></table></figure>

<h2 id="2、WeakSet"><a href="#2、WeakSet" class="headerlink" title="2、WeakSet"></a>2、WeakSet</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。<br>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set </span></span><br></pre></td></tr></table></figure>
<p>WeakSet 结构有以下三个方法。 </p>
<ul>
<li>WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</li>
<li>WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</li>
<li>WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。<br>WeakSet 没有 size 属性，没有办法遍历它的成员。</li>
</ul>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h2 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// \&quot;content\&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false </span></span><br></pre></td></tr></table></figure>
<p>不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作 Map 构造函数的参数。这就是说， Set 和 Map 都可以用来生成新的 Map。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">    ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">    [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>(set);</span><br><span class="line">m1.get(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>(m2);</span><br><span class="line">m3.get(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3 </span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。 </p>
<ul>
<li>（1）size 属性<br>size 属性返回 Map 结构的成员总数。 </li>
<li>（2）set(key, value)<br>set 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。 </li>
<li>（3）get(key)<br>get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。 </li>
<li>（4）has(key)<br>has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 </li>
<li>（5）delete(key)<br>delete 方法删除某个键，返回 true 。如果删除失败，返回 false 。 </li>
<li>（6）clear()<br>clear 方法清除所有成员，没有返回值。 <h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3>Map 结构原生提供三个遍历器生成函数和一个遍历方法。 </li>
<li>keys() ：返回键名的遍历器。</li>
<li>values() ：返回键值的遍历器。</li>
<li>entries() ：返回所有成员的遍历器。</li>
<li>forEach() ：遍历 Map 的所有成员。<br>需要特别注意的是，Map 的遍历顺序就是插入顺序。</li>
</ul>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p> （1）Map 转为数组<br>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（ … ）。</p>
<p> （2）数组 转为 Map<br>将数组传入 Map 构造函数，就可以转为 Map。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">    [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">]) </span><br></pre></td></tr></table></figure>
<p> （3）Map 转为对象<br>如果所有 Map 的键都是字符串，它可以无损地转为对象。<br> （4）对象转为 Map</p>
<p> （5）Map 转为 JSON<br>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。<br> （6）JSON 转为 Map<br>JSON 转为 Map，正常情况下，所有键名都是字符串。 </p>
<h2 id="4、WeakMap"><a href="#4、WeakMap" class="headerlink" title="4、WeakMap"></a>4、WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p> WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。<br> WeakMap 与 Map 的区别有两点。 </p>
<ul>
<li> WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。 </li>
<li> WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">    [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">]; </span><br></pre></td></tr></table></figure>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>WeakMap 与 Map 在 API 上的区别主要是两个， </p>
<ul>
<li>一是没有遍历操作（即没有 keys() 、 values() 和 entries() 方法），也没有 size 属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。 </li>
<li>二是无法清空，即不支持 clear 方法。因此， WeakMap 只有四个方法可用： get() 、 set() 、 has() 、 delete() 。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>es6相关（五）Promise、async、Generator</title>
    <url>/2020/11/14/js/es6-5/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>含义</p>
<p>对象有以下两个特点。</p>
<ul>
<li>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<h3 id="1、ES6-规定，Promise对象是一个构造函数，用来生成Promise实例。"><a href="#1、ES6-规定，Promise对象是一个构造函数，用来生成Promise实例。" class="headerlink" title="1、ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。"></a>1、ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 不管 Promise 对象最后状态如何，都会执行的操作</span></span><br></pre></td></tr></table></figure>
<h3 id="2、Promise-all方法用于将多个-Promise-实例，包装成一个新的-Promise-实例。"><a href="#2、Promise-all方法用于将多个-Promise-实例，包装成一个新的-Promise-实例。" class="headerlink" title="2、Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。"></a>2、Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function">(<span class="params">[p1,p2,p3]</span>) =&gt;</span> &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<blockquote>
<p>（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
</blockquote>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ul>
<li>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
<blockquote>
<p>注意，如果作为参数的 Promise 实例，自己定义了catch方法(catch之后返回的依然是promise的resolve)，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
</blockquote>
<h3 id="3、Promise-race方法同样是将多个-Promise-实例，包装成一个新的-Promise-实例。"><a href="#3、Promise-race方法同样是将多个-Promise-实例，包装成一个新的-Promise-实例。" class="headerlink" title="3、Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。"></a>3、Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。<br>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>
<h3 id="4、Promise-resolve将现有对象转为-Promise-对象"><a href="#4、Promise-resolve将现有对象转为-Promise-对象" class="headerlink" title="4、Promise.resolve将现有对象转为 Promise 对象"></a>4、Promise.resolve将现有对象转为 Promise 对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>Promise.resolve方法的参数分成四种情况。</p>
<ul>
<li>（1）参数是一个 Promise 实例<br>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li>
<li>（2）参数是一个thenable对象, thenable对象指的是具有then方法的对象，比如下面这个对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">      then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="number">33</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);  <span class="comment">// 2s后输出33</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</li>
<li>（3）参数不是具有then方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</li>
<li>（4）不带有任何参数<br>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。<br>需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。<h3 id="5、Promise-reject-reason-方法也会返回一个新的-Promise-实例，该实例的状态为rejected。"><a href="#5、Promise-reject-reason-方法也会返回一个新的-Promise-实例，该实例的状态为rejected。" class="headerlink" title="5、Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。"></a>5、Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</h3></li>
</ul>
<h2 id="ES2017-标准引入了-async-函数"><a href="#ES2017-标准引入了-async-函数" class="headerlink" title="ES2017 标准引入了 async 函数"></a>ES2017 标准引入了<a href="http://es6.ruanyifeng.com/#docs/async"> async 函数</a></h2><p>Generator 函数的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<ul>
<li><p>（1）内置执行器。</p>
</li>
<li><p>（2）更好的语义。</p>
</li>
<li><p>（3）更广的适用性。</p>
</li>
<li><p>（4）返回值是 Promise。</p>
</li>
<li><p>1、async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
</li>
<li><p>2、正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。<br>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。<br>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</p>
<ul>
<li><p>3、使用注意点</p>
<p>  第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中</p>
<p>  第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
<p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>
<p>第四点，async 函数可以保留运行堆栈。</p>
<h2 id="Generator-函数（反正我是不会用这个的）"><a href="#Generator-函数（反正我是不会用这个的）" class="headerlink" title="Generator 函数（反正我是不会用这个的）"></a>Generator 函数（反正我是不会用这个的）</h2><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>有两个特征。</p>
<ul>
<li>  一是，function关键字与函数名之间有一个星号；</li>
<li>  二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>) <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3333</span>) <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next() <span class="comment">//只有调用next函数才会执行</span></span><br><span class="line"><span class="comment">// 2222&#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// 3333&#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
]]></content>
  </entry>
  <entry>
    <title>es6相关（六）Class、Class 的继承</title>
    <url>/2020/11/14/js/es6-6/</url>
    <content><![CDATA[<p>class<br>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>1、类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
</li>
<li><p>2、constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
</li>
<li><p>3、类必须使用new调用，否则会报错。</p>
</li>
<li><p>4、存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">      Point.prototype, <span class="string">&quot;html&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;get&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;set&quot;</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>5、与函数一样，类也可以使用表达式的形式定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p>
</blockquote>
</li>
</ul>
<p>注意点：</p>
<ul>
<li>（  1、类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式</li>
<li>（  2、类不存在变量提升（hoist），这一点与 ES5 完全不同。</li>
<li>（  3、name属性总是返回紧跟在class关键字后面的类名。</li>
<li>（  4、如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</li>
<li>（  5、类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不**<em>会被实例继承**</em>，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 如果静态方法包含this关键字，这个this指的是类，而不是实例。</p>
</blockquote>
<p>如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类的静态方法，可以被子类继承。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性法的前面，加上static关键字。</p>
<h2 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h2><ul>
<li>1、Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&#x27; &#x27;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
子类必须在constructor方法中调用super方法，否则新建实例时会报错</li>
</ul>
<p>子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p>
<ul>
<li><p>2、判断，一个类是否继承了另一个类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>3、super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<ul>
<li><p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
</blockquote>
<ul>
<li>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。</p>
</blockquote>
<h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<ul>
<li>(1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</li>
<li>(2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
这样的结果是因为，类的继承是按照下面的模式实现的。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
<h2 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 __proto__属性"></a>实例的 __proto__属性</h2>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型，是父类的原型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>深入理解 ES6 模块机制</title>
    <url>/2020/11/14/js/es6-module/</url>
    <content><![CDATA[<blockquote>
<p>在 ES6 中，我们知道 import、export 取代了 require、module.exports 用来引入和导出模块，但是如果不了解 ES6 模块特性的话，代码可能就会运行出一些匪夷所思的结果</p>
</blockquote>
<p><a href="https://juejin.im/entry/5a879e28f265da4e82635152" target="_blank">原文地址</a></p>
<h1 id="ES6-模块特性"><a href="#ES6-模块特性" class="headerlink" title="ES6 模块特性"></a>ES6 模块特性</h1><p>基础的 ES6 模块用法我就不介绍了，如果你还没使用过 ES6 模块的话，推荐看：<a href="https://link.juejin.im/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fes6.ruanyifeng.com%2F%2523docs%2Fmodule" target="_blank" rel="nofollow noopener noreferrer">ECMAScript 6 入门 - Module 的语法</a><br>说起 ES6 模块特性，那么就先说说 ES6 模块跟 CommonJS 模块的不同之处。<br>ES6 模块跟 CommonJS 模块的不同，主要有以下两个方面：<li>ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝</li><li>ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载</li><br>这个怎么理解呢？我们一步步来看：</p>
<p>CommonJS 输出值的拷贝（浅拷贝）<br>首先第一点，在 CommonJS 模块中，如果你 require 了一个模块，那就相当于你执行了该文件的代码并最终获取到模块输出的 module.exports 对象的一份拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b.foo);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>).foo);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        foo = <span class="number">2</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        foo: foo,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// 执行：node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，你获取的只是模块输出对象的一个拷贝， b 中的 foo 已经和 a 中的 foo 已经不相干了，所以如果你想要在 CommonJS 中动态获取模块中的值，那么就需要借助于函数延时执行的特性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.foo());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b.foo());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>).foo());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        foo = <span class="number">2</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行：node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们可以总结一下：<li>CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝</li><li>CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的拷贝（指向同一个obj）</li><br>ES6 输出值的引用<br>然而在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">        <span class="keyword">import</span>(<span class="string">&#x27;./b&#x27;</span>).then(<span class="function">(<span class="params">&#123; foo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        foo = <span class="number">2</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line"><span class="comment">// 执行：babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES6 静态编译，CommonJS 运行时加载<br>关于第二点，ES6 模块编译时执行会导致有以下两个特点：<li>import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。</li><li>export 命令会有变量声明提前的效果。</li><br>import 优先执行:<br>从第一条来看，在文件中的任何位置引入 import 模块都会被提前到文件顶部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 先执行&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="comment">// b.js 先执行</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从执行结果我们可以很直观地看出，虽然 a 模块中 import 引入晚于 console.log(‘a’)，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。</p>
<p>由于 import 是静态执行，所以 import 具有提升效果即 import 命令在模块中的位置并不影响程序的输出。</p>
<p>export 变量声明提升:</p>
<p>正常的引入模块是没办法看出变量声明提升的特性，需要通过循环依赖加载才能看出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;bar2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;bar3&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="comment">// &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以很直观地看出，a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明的变量也是优于模块其它内容的执行的，但是具体对变量赋值需要等到执行到相应代码的时候。(当然函数声明和表达式声明不一样，这一点跟 JS 函数性质一样，这里就不过多解释)<br>好了，讲完了 ES6 模块和 CommonJS 模块的不同点之后，接下来就讲讲相同点：</p>
<p>模块不会重复执行</p>
<p>这个很好理解，无论是 ES6 模块还是 CommonJS 模块，当你重复引入某个相同的模块时，模块只会执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;只会执行一次&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 只会执行一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合上面说的特性，我们来看一个比较经典的例子，循环依赖，当你理解了上面所讲的特性之后，下次遇到模块循环依赖代码的执行结果就很容易理解了。<br>CommonJS 模块循环依赖<br>先来看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(&#39;in a, b.done &#x3D;&#39;, b.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;a done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">console.log(&#39;in b, a.done &#x3D;&#39;, a.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;b done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; a starting</span><br><span class="line">&#x2F;&#x2F; b starting</span><br><span class="line">&#x2F;&#x2F; in b, a.done &#x3D; false</span><br><span class="line">&#x2F;&#x2F; b done</span><br><span class="line">&#x2F;&#x2F; in a, b.done &#x3D; true</span><br><span class="line">&#x2F;&#x2F; a done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合之前讲的特性很好理解，当你从 b 中想引入 a 模块的时候，因为 node 之前已经加载过 a 模块了，所以它不会再去重复执行 a 模块，而是直接去生成当前 a 模块吐出的 module.exports 对象一份拷贝，因为 a 模块引入 b 模块先于给 done 重新赋值，所以当前 a 模块中输出的 module.exports 中 done 的值仍为 false。而当 a 模块中输出 b 模块的 done 值的时候 b 模块已经执行完毕，所以 b 模块中的 done 值为 true。</p>
<p>从上面的执行过程中，我们可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。虽然这种模块加载机制可以避免出现循环依赖时报错的情况，但稍不注意就很可能使得代码并不是像我们想象的那样去执行。因此在写代码时还是需要仔细的规划，以保证循环模块的依赖能正确工作。</p>
<p>所以有什么办法可以出现循环依赖的时候避免自己出现混乱呢？一种解决方式便是将每个模块先写 exports 语法，再写 requre 语句，利用 CommonJS 的缓存机制，在 require() 其他模块之前先把自身要导出的内容导出，这样就能保证其他模块在使用时可以取到正确的值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.done)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.done)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种写法简单明了，缺点是要改变每个模块的写法，而且大部分同学都习惯了在文件开头先写 require 语句。</p>
<p>ES6 模块循环依赖</p>
<p>跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a starting&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in b, foo:&#x27;</span>, foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a done&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b starting&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in a, bar:&#x27;</span>, bar);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;in a, setTimeout bar:&#x27;</span>, bar);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b done&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in a, bar: undefined</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// in b, foo: foo</span></span><br><span class="line"><span class="comment">// a done</span></span><br><span class="line"><span class="comment">// in a, setTimeout bar: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没看懂执行结果的话，那说明没理解前面说的 ES6 模块特性，麻烦重新再看一遍吧！</p>
<h1 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import()"></a>动态 import()</h1><p>ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="params">some condition</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> (str + <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入 import() 应运而生。</p>
<p>import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。<ul><li>require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话 require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。</li><li>而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()</li></ul><br>我们先来看下它的用法：<li>动态的 import() 提供一个基于 Promise 的 API</li><li>动态的import() 可以在脚本的任何地方使用</li><li>import() 接受字符串文字，你可以根据你的需要构造说明符</li></p>
<p>举个简单的使用例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">flag</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">import</span>(<span class="string">&#x27;./b&#x27;</span>).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span>(str).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。</p>
<p>因为是基于 Promise 的，所以如果你想要同时加载多个模块的话，可以是 Promise.all 进行并行异步加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./a.js&#x27;</span>),</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./b.js&#x27;</span>),</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./c.js&#x27;</span>),</span><br><span class="line">]).then(<span class="function">(<span class="params">[a, &#123;<span class="keyword">default</span>: b&#125;, &#123;c&#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a.js is loaded dynamically&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b.js is loaded dynamically&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c.js is loaded dynamically&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有 Promise.race 方法，它检查哪个 Promise 被首先 resolved 或 reject。我们可以使用import()来检查哪个CDN速度更快：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CDNs = [</span><br><span class="line">    &#123;</span><br><span class="line">    name: <span class="string">&#x27;jQuery.com&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;https://code.jquery.com/jquery-3.1.1.min.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    name: <span class="string">&#x27;googleapis.com&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`------`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`jQuery is: <span class="subst">$&#123;<span class="built_in">window</span>.jQuery&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">        <span class="keyword">import</span>(CDNs[<span class="number">0</span>].url).then(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(CDNs[<span class="number">0</span>].name, <span class="string">&#x27;loaded&#x27;</span>)),</span><br><span class="line">    <span class="keyword">import</span>(CDNs[<span class="number">1</span>].url).then(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(CDNs[<span class="number">1</span>].name, <span class="string">&#x27;loaded&#x27;</span>))</span><br><span class="line">]).then(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`jQuery version: <span class="subst">$&#123;<span class="built_in">window</span>.jQuery.fn.jquery&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果你觉得这样写还不够优雅，也可以结合 async/await 语法糖来使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">        <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">        <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态 import() 为我们提供了以异步方式使用 ES 模块的额外功能。 根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。</p>
]]></content>
  </entry>
  <entry>
    <title>es6相关（七）Module 的语法、ArrayBuffer</title>
    <url>/2020/11/14/js/es6-7/</url>
    <content><![CDATA[<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用arguments.callee</li>
<li>不能使用arguments.caller</li>
<li>禁止this指向全局对象</li>
<li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
<li>增加了保留字（比如protected、static和interface）</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6<br>其中，尤其需要注意this的限制。</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</p>
<h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><p>模块功能主要由两个命令构成：export和import。</p>
<ul>
<li>export命令用于规定模块的对外接口，</li>
<li>import命令用于输入其他模块提供的功能。</li>
</ul>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法：</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的，function和class的输出，也必须遵守这样的写法。</p>
<h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a1, a2, a3&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//import * as a from &#x27;./a.js&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取是用a.a1、a.a2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = a1 + <span class="string">&#x27; &#x27;</span> + a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><blockquote>
<p>注意： 上面报错的导出方式如果加上default，就不会报错</p>
</blockquote>
<p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。</p>
<p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// d.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fn <span class="keyword">from</span> <span class="string">&#x27;./c&#x27;</span>;<span class="comment">//这个fn指向c的默认导出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于ArrayBuffer，直接看这"><a href="#关于ArrayBuffer，直接看这" class="headerlink" title="关于ArrayBuffer，直接看这"></a><a href="http://es6.ruanyifeng.com/#docs/arraybuffer">关于ArrayBuffer，直接看这</a></h2>]]></content>
  </entry>
  <entry>
    <title>fetch方法</title>
    <url>/2020/11/14/js/fetch/</url>
    <content><![CDATA[<blockquote>
<p>fetch方法返回一个Promise对象, 根据 Promise Api 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch. 一但then中的语句出现错误, 也将跳到catch中.</p>
</blockquote>
<p>fetch() 必须接受一个参数——资源的路径。无论请求成功与否，它都返回一个 Promise 对象，resolve 对应请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" title="Fetch API 的Response接口呈现了对一次请求的响应数据">Response</a>。你也可以传一个可选的第二个参数init（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request" title="你可以使用  Request.Request() ?构造函数创建一个Request 对象，但是你可能会遇到一个 Request 对象作为其它 API 的操作被返回，比如一个 service worker的FetchEvent.request。">Request</a>）。</p>
<h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p>fetch可以设置不同的模式使得请求有效. 模式可在fetch方法的第二个参数对象中定义.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(url, &#123;<span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可定义的模式如下:<ul><li>same-origin: 表示同域下可请求成功; 反之, 浏览器将拒绝发送本次fetch, 同时抛出错误 “TypeError: Failed to fetch(…)”.</li><li>cors: 表示同域和带有CORS响应头的跨域下可请求成功. 其他请求将被拒绝.</li><li>cors-with-forced-preflight: 表示在发出请求前, 将执行preflight检查.</li><li>no-cors: 常用于跨域请求不带CORS响应头场景, 此时响应类型为 “opaque”.</li></ul><br>除此之外, 还有两种不太常用的mode类型, 分别是 navigate , websocket , 它们是 <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="external">HTML标准</a> 中特殊的值, 这里不做详细介绍.</p>
<h2 id="header"><a href="#header" class="headerlink" title="header"></a><a href="http://louiszhai.github.io/2016/11/02/fetch/#header" title="header"></a>header</h2><p>fetch获取http响应头非常easy. 如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(response.headers.get(<span class="string">&#x27;Content-Type&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>设置http请求头也一样简单.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">fetch(url,&#123;</span><br><span class="line">    headers: headers</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>header的内容也是可以被检索的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(header.has(<span class="string">&quot;Content-Type&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(header.has(<span class="string">&quot;Content-Length&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a><a href="http://louiszhai.github.io/2016/11/02/fetch/#post" title="post">post</a></h3><p>在fetch中发送post请求, 同样可以在fetch方法的第二个参数对象中设置.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        headers: headers,</span><br><span class="line">        body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        date: <span class="string">&#x27;2016-10-08&#x27;</span>,</span><br><span class="line">        time: <span class="string">&#x27;15:16:00&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a><a href="http://louiszhai.github.io/2016/11/02/fetch/#credentials" title="credentials">credentials</a></h3><p>跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(url,&#123;</span><br><span class="line">    credentials: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除此之外, credentials 还可以取以下值:<ul><li>omit: 缺省值, 默认为该值.</li><li>same-origin: 同源, 表示同域请求才发送cookie.</li></ul><h4 id="catch"><a href="http://louiszhai.github.io/2016/11/02/fetch/#catch" title="catch"></a>catch</p>
<p>同 XMLHttpRequest 一样, 无论服务器返回什么样的状态码(chrome中除407之外的其他状态码), 它们都不会进入到错误捕获里. 也就是说, 此时, XMLHttpRequest 实例不会触发 onerror 事件回调, fetch 不会触发 reject. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时, 它们才会进入到相应的错误捕获里. (其中, 请求返回状态码为407时, chrome浏览器会触发onerror或者reject掉fetch.)<h4 id="cache"><a href="http://louiszhai.github.io/2016/11/02/fetch/#cache" title="cache"></a>cache</p>
<p>cache表示如何处理缓存, 遵守http规范, 拥有如下几种值:<ul><li>default: 表示fetch请求之前将检查下http的缓存.</li><li>no-store: 表示fetch请求将完全忽略http缓存的存在. 这意味着请求之前将不再检查下http的缓存, 拿到响应后, 它也不会更新http缓存.</li><li>no-cache: 如果存在缓存, 那么fetch将发送一个条件查询request和一个正常的request, 拿到响应后, 它会更新http缓存.</li><li>reload: 表示fetch请求之前将忽略http缓存的存在, 但是请求拿到响应后, 它将主动更新http缓存.</li><li>force-cache: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request.</li><li>only-if-cached: 表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在mode为”same-origin”时有效).</li></ul><br>如果fetch请求的header里包含 If-Modified-Since, If-None-Match, If-Unmodified-Since, If-Match, 或者 If-Range 之一, 且cache的值为 default , 那么fetch将自动把 cache的值设置为 “no-store” .</p>
<h2 id="async-await语法"><a href="#async-await语法" class="headerlink" title="async/await语法"></a>async/await语法</h2><p>async 用于声明一个异步函数, 该函数需返回一个 Promise 对象. 而 await 通常后接一个 Promise对象, 需等待该 Promise 对象的 resolve() 方法执行并且返回值后才能继续执行. (如果await后接的是其他对象(非promise), 便会立即执行)</p>
<p>await 返回promise里面 resolve的值<br>var word = ‘123’,<br>    url = ‘…’;<br>(async ()=&gt;{<br>    try {<br>            let res = await fetch(url, {mode: ‘no-cors’});//等待fetch被resolve()后才能继续执行</p>
<pre><code>                    console.log(res);
&#125; catch(e) &#123;

    console.log(e);
    &#125;</code></pre>
<p>})();</p>
<p>使用await后, 可以直接得到返回值, 不必写 .then(callback) , 也不必写 .catch(error) 了, 更可以使用 try catch 标准语法捕获错误.<br>由于await采用的是同步的写法, 看起来它就和alert函数一样, 可以自动阻塞上下文. 因此它可以重复执行多次, 就像上述代码②一样.<br>可以看到, await/async 同步阻塞式的写法解决了完全使用 Promise 的一大痛点——不同Promise之间共享数据问题. Promise 需要设置上层变量从而实现数据共享, 而 await/async 就不存在这样的问题, 只需要像写alert一样书写就可以了.<br>值得注意的是, await 只能用于 async 声明的函数上下文中. 如下 forEach 中, 是不能直接使用await的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);<span class="comment">//这是错误的写法, 因await不在async声明的函数上下文中</span></span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>如果是试图将async声明的函数作为回调传给forEach，该回调将同时触发多次，回调内部await依然有效，只是多次的await随着回调一起同步执行了，这便不符合我们阻塞循环的初衷。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> (item)=&gt;&#123;</span><br><span class="line">        <span class="keyword">await</span> wait(<span class="number">1000</span>); <span class="comment">// 循环中的多个await同时执行，因此等待1s后将同时输出数组各个元素</span></span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;;</span><br><span class="line">array.forEach(fn);</span><br></pre></td></tr></table></figure>

<p>正确的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">0</span>,len=array.length;i&lt;len;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<h3 id="如何弥补Fetch的不足">如何弥补Fetch的不足</h3>

<p>fetch基于Promise, Promise受限, fetch也难幸免. ES6的Promise基于 <a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a> 规范 (对规范感兴趣的同学可选读 <a href="http://www.cnblogs.com/fsjohnhuang/p/4135149.html" target="_blank" rel="external">剖析源码理解Promises/A规范</a> ), 它只提供极简的api, 没有 timeout 机制, 没有 progress 提示, 没有 deferred 处理 (这个可以被async/await替代).<h4 id="fetch-jsonp"><a href="http://louiszhai.github.io/2016/11/02/fetch/#fetch-jsonp" title="fetch-jsonp"></a>fetch-jsonp</p>
<p>除此之外, fetch还不支持jsonp请求. 不过办法总比问题多, 万能的开源作者提供了 <a href="https://github.com/camsong/fetch-jsonp" target="_blank" rel="external">fetch-jsonp</a> 库, 解决了这个问题.<br>fetch-jsonp 使用起来非常简单. 如下是安装:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>

<p>如下是使用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetchJsonp(url, &#123;</span><br><span class="line">    timeout: <span class="number">3000</span>,</span><br><span class="line">    jsonpCallback: <span class="string">&#x27;callback&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.json());</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="abort"><a href="#abort" class="headerlink" title="abort"></a><a href="http://louiszhai.github.io/2016/11/02/fetch/#abort" title="abort">abort</a></h2><p>由于Promise的限制, fetch 并不支持原生的abort机制, 但这并不妨碍我们使用 Promise.race() 实现一个.</p>
<blockquote>
<p>Promise.race(iterable) 方法返回一个Promise对象, 只要 iterable 中任意一个Promise 被 resolve 或者 reject 后, 外部的Promise 就会以相同的值被 resolve 或者 reject.</p>
</blockquote>
<p>支持性: 从 chrome33, Firefox29, Safari7.1, Opera20, EdgeHTML12(并非Edge版本) 起, Promise就被完整的支持. Promise.race()也随之可用. 下面我们来看下实现.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> abort = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            abort = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;abort.&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info(<span class="string">&#x27;abort done.&#x27;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</span><br><span class="line">            fetch(url,options),</span><br><span class="line">            abort_promise</span><br><span class="line">        ]);</span><br><span class="line">    promise.abort = abort;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(fetch);</span><br></pre></td></tr></table></figure>

<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = _fetch(<span class="string">&#x27;https://www.baidu.com&#x27;</span>,&#123;<span class="attr">mode</span>:<span class="string">&#x27;no-cors&#x27;</span>&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;response:&#x27;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line">p.abort();</span><br><span class="line"><span class="comment">//&quot;abort done.&quot;</span></span><br><span class="line"><span class="comment">//&quot;error: abort.&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上, fetch请求后, 立即调用abort方法, 该promise被拒绝, 符合预期. 细心的同学可能已经注意到了, “p.abort();” 该语句我是单独写一行的, 没有链式写在then方法之后. 为什么这么干呢? 这是因为then方法调用后, 返回的是新的promise对象. 该对象不具有abort方法, 因此使用时要注意绕开这个坑.<h4 id="timeout"><a href="http://louiszhai.github.io/2016/11/02/fetch/#timeout" title="timeout"></a>timeout</p>
<p>同上, 由于Promise的限制, fetch 并不支持原生的timeout机制, 但这并不妨碍我们使用 Promise.race() 实现一个.<br>下面是一个简易的版本.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">setTimeout</span>(resolve, t))</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = fetch(<span class="string">&#x27;https://www.baidu.com&#x27;</span>,&#123;<span class="attr">mode</span>:<span class="string">&#x27;no-cors&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p, timer(<span class="number">1000</span>)]);</span><br><span class="line"><span class="comment">//&quot;timeout&quot;</span></span><br></pre></td></tr></table></figure>

<p>实际上, 无论超时时间设置为多长, 控制台都将输出log “timeout”. 这是因为, 即使fetch执行成功, 外部的promise执行完毕, 此时 setTimeout 所在的那个promise也不会reject.<br>下面我们来看一个类似xhr版本的timeout.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _fetch = (<span class="function"><span class="keyword">function</span>(<span class="params">fetch</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url,options</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> abort = <span class="literal">null</span>,</span><br><span class="line">                timeout = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> abort_promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">                abort = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&#x27;timeout.&#x27;</span>);</span><br><span class="line">                <span class="built_in">console</span>.info(<span class="string">&#x27;abort done.&#x27;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.race([</span><br><span class="line">            fetch(url,options),</span><br><span class="line">            abort_promise</span><br><span class="line">        ]);</span><br><span class="line">        promise.abort = abort;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(promise, <span class="string">&#x27;timeout&#x27;</span>,&#123;</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span>(<span class="params">ts</span>)</span>&#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params">(ts=+ts)</span>)</span>&#123;</span><br><span class="line">                    timeout = ts;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(abort,ts);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> timeout;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(fetch);</span><br></pre></td></tr></table></figure>

<p>然后, 使用如下方法测试新的fetch.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = _fetch(<span class="string">&#x27;https://www.baidu.com&#x27;</span>,&#123;<span class="attr">mode</span>:<span class="string">&#x27;no-cors&#x27;</span>&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;response:&#x27;</span>, res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line">p.timeout = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//&quot;abort done.&quot;</span></span><br><span class="line"><span class="comment">//&quot;error: timeout.&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="progress"><a href="http://louiszhai.github.io/2016/11/02/fetch/#progress" title="progress"></a>progress

<p>xhr的 onprogress 让我们可以掌控下载进度, fetch显然没有提供原生api 做类似的事情. 不过 Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取, 直到body下载完成. 因此我们完全可以模拟fetch的progress.</p>
<p>以下是 stackoverflow 上的一段代码, 用于模拟fetch的progress事件. 为了方便测试, 请求url已改为本地服务.(<a href="https://stackoverflow.com/questions/35711724/upload-progress-indicators-for-fetch" target="_blank">原文请戳 javascript - Progress indicators for fetch? - Stack Overflow</a>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consume</span>(<span class="params">reader</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        reader.read().then(<span class="function">(<span class="params">&#123;done, value&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            resolve();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    total += value.byteLength;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`received</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;value.byteLength&#125;</span> bytes</span></span><br><span class="line"><span class="string">        (<span class="subst">$&#123;total&#125;</span> bytes in total)`</span></span><br><span class="line">    );</span><br><span class="line">    pump();</span><br><span class="line">    &#125;).catch(reject)</span><br><span class="line">    &#125;</span><br><span class="line">    pump();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">&#x27;http://localhost:10101/notification/&#x27;</span>,&#123;<span class="attr">mode</span>:<span class="string">&#x27;no-cors&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> consume(res.body.getReader()))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(</span><br><span class="line"><span class="string">&quot;consumed the entire body </span></span><br><span class="line"><span class="string">without keeping the whole thing in memory!&quot;</span></span><br><span class="line">    ))</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;something went wrong: &quot;</span> + e));</span><br></pre></td></tr></table></figure>

<p>以下是日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">received 32768 bytes (32768 bytes in total)</span><br><span class="line">received 32768 bytes (32768*2 bytes in total)</span><br><span class="line">received 32768 bytes (32768*3 bytes in total)</span><br><span class="line">received 32768 bytes (32768*4 bytes in total)</span><br><span class="line">received 32768 bytes (32768*5 bytes in total)</span><br><span class="line">received 32768 bytes (32768*6 bytes in total)</span><br><span class="line">received 32768 bytes (32768*7 bytes in total)</span><br><span class="line">received 32768 bytes (32768*8 bytes in total)</span><br><span class="line">received 32768 bytes (32768*9 bytes in total)</span><br><span class="line">...</span><br><span class="line">received 919 bytes (532480 bytes in total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumed the entire body without keeping the whole thing in memory!</span><br></pre></td></tr></table></figure>
<p>我们不妨来对比下, 使用xhr的onprogress事件回调, 输出如下:</p>
<p>received 32768 bytes (32768 bytes in total)</p>
<p>received 499712 bytes (532480 bytes in total)</p>
<p>适当增加响应body的size, 发现xhr的onprogress事件回调依然只执行两次. 通过多次测试发现其执行频率比较低, 远不及fetch progress.</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 柯里化</title>
    <url>/2020/11/14/js/fun-currying/</url>
    <content><![CDATA[<blockquote>
<p>柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p>
</blockquote>
<p>实现一个函数，运算结果可以满足如下预期结果：</p>
<p>add(1)(2) // 3</p>
<p>add(1, 2, 3)(10) // 16</p>
<p>add(1)(2)(3)(4)(5) // 15</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arg_fn = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(arg_fn));</span><br><span class="line">    &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用返回的都是fn函数，下一次的调用会吧上一次的参数和这一次的参数拼接起来传给add函数、并调用返回fn函数，最后通过隐式数据类型转换调用fn的valueOf方法取出所有参数的和</p>
<h2 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h2><p>JavaScript调用valueOf方法将对象转换为原始值。当遇到要预期的原始值的对象时，JavaScript会自动调用它。</p>
<p>默认情况下，valueOf方法由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" title="Object 构造函数创建一个对象包装器。">Object</a>后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则valueOf将返回对象本身。<br>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。<table><tbody><tr><td>Array</td><td>返回数组对象本身。</td></tr><tr><td>Boolean</td><td>布尔值。</td></tr><tr><td>Date</td><td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td>Function</td><td>函数本身。</td></tr><tr><td>Number</td><td>数字值。</td></tr><tr><td>Object</td><td>对象本身。这是默认情况。</td></tr><tr><td>String</td><td>字符串值。</td></tr><tr><td> </td><td></p>
</td></tr></tbody></table>


<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h2><p>toString() 方法返回一个表示该对象的字符串。</p>
<p>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。</p>
<p>每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>



<p>3 种主要的原始类型 Boolean 值、数字和字符串(伪对象)都有 toString() 方法，可以把它们的值转换成字符串</p>
<table><tbody><tr><td>Array</td><td>[1,2] >'1,2'</td></tr><tr><td>Boolean</td><td>false > 'false'</td></tr><tr><td>Date</td><td>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Sat Mar <span class="number">0</span>9 <span class="number">2019</span> <span class="number">21</span>:<span class="number">11</span>:<span class="number">16</span> GMT+<span class="number">0</span>800 (中国标准时间)</span><br></pre></td></tr></table></figure>
</td></tr><tr><td>Function</td><td>
"function Object() { [native code] }"</td></tr><tr><td>Number</td><td>默认模式和基模式
</td></tr><tr><td>Object</td><td>"function Object() { [native code] }"
</td></tr><tr><td>String</td><td>字符串值。</td></tr><tr><td> </td><td>
</td></tr></tbody></table>Number 类型的 toString() 方法比较特殊，它有两种模式，即<默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）

<p>注释：在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的。</p>
<p>采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。</p>
<p>基只是要转换成的基数的另一种加法而已，它是 toString() 方法的参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">alert(iNum.toString(<span class="number">2</span>));\t<span class="comment">//输出 &quot;1010&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">8</span>));\t<span class="comment">//输出 &quot;12&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">16</span>));\t<span class="comment">//输出 &quot;A&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，以 3 种不同的形式输出了数字 10，即二进制形式、八进制形式和十六进制形式。HTML 采用十六进制表示每种颜色，在 HTML 中处理数字时这种功能非常有用。</p>
<p>注释：对数字调用 toString(10) 与调用 toString() 相同，它们返回的都是该数字的十进制形式。<br>产生随机字符串：</p>
<p>Math.random().toString(36)</p>
<p>“0.562buo5yjjy””</p>
]]></content>
  </entry>
  <entry>
    <title>柯里化通用式以及Arrary方法实现</title>
    <url>/2020/11/14/js/fun-currying2/</url>
    <content><![CDATA[<blockquote>
<p>JS属于解释型语言，在执行过程中顺序执行，但是会分块先预编译然后才执行。因此在JS中存在一种变量提升的现象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用闭包把所有参数存起来var currying = function(fn) &#123;</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 主要还是收集所有需要的参数到一个数组中，便于统一计算</span></span><br><span class="line">        <span class="keyword">var</span> _args = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">10</span>));  <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">5</span>));   <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>补充：<br>一：map</p>
<p>注：以下全部省略callback前面的function </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="title">callback</span>(<span class="params">value,index,arrary</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,[ options]);</span><br></pre></td></tr></table></figure>

<p>callback: 回调支持3个参数，第1个是遍历的数组内容；第2个是对应的数组索引，第3个是数组本身。</p>
<p>options: 如果这第2个可选参数不指定，则使用全局对象代替（在浏览器是为window），严格模式下是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 回调函数中有三个参数</span></span><br><span class="line"><span class="comment">// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值</span></span><br><span class="line"><span class="comment">// 第三个表示数组本身</span></span><br><span class="line"><span class="comment">// 除此之外，回调函数中的this，</span></span><br><span class="line"><span class="comment">//当map不存在第二参数时，this指向丢失，</span></span><br><span class="line"><span class="comment">//当存在第二个参数时，指向改参数所设定的对象</span></span><br><span class="line"><span class="keyword">var</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">item, i, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, i, arr, <span class="built_in">this</span>);<span class="comment">//this为&#123;a:1&#125;</span></span><br><span class="line"><span class="keyword">return</span> item + <span class="number">1</span>;  <span class="comment">// 每一项加1</span></span><br><span class="line">&#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> fn == <span class="string">&#x27;function&#x27;</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> len = <span class="built_in">this</span>.length;</span><br><span class="line">        <span class="comment">// 封装for循环过程</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params">; k &amp;lt; len; k++</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数</span></span><br><span class="line">            temp.push(fn.call(context, <span class="built_in">this</span>[k], k, <span class="built_in">this</span>))</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;TypeError:&#x27;</span>+fn+<span class="string">&#x27;is not a function.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回每一项运算结果组成的新数组</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="二：filter"><a href="#二：filter" class="headerlink" title="二：filter"></a>二：filter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="title">callback</span>(<span class="params">value,index,arrary</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;,[ options]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">同上；</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.filter != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>,len=<span class="built_in">this</span>.length;k&amp;lt;len; k++) &#123;</span><br><span class="line">            fn.call(context, <span class="built_in">this</span>[k], k, <span class="built_in">this</span>)</span><br><span class="line">            &amp;amp;&amp;amp; arr.push(<span class="built_in">this</span>[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三：forEach"><a href="#三：forEach" class="headerlink" title="三：forEach"></a>三：forEach</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="title">callback</span>(<span class="params">value,index,arrary</span>)</span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125;,[ options ])</span><br></pre></td></tr></table></figure>

<p>同上；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="string">``</span><span class="string">` javascript</span></span><br><span class="line"><span class="string">delete array[1]; // 移除 2</span></span><br><span class="line"><span class="string">alert(array); // &quot;1,,3&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alert(array.length); <span class="comment">// but the length is still 3</span></span><br><span class="line"><span class="string">``</span><span class="string">` javascript</span></span><br><span class="line"><span class="string">array.forEach(alert); // 弹出的仅仅是1和3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.forEach != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, len = <span class="built_in">this</span>.length; k &amp;lt; len; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span></span><br><span class="line">        &amp;amp;&amp;amp; <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="built_in">this</span>,k)</span><br><span class="line">        ) &#123;</span><br><span class="line">            fn.call(context, <span class="built_in">this</span>[k], k, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：some"><a href="#四：some" class="headerlink" title="四：some"></a>四：some</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.some(<span class="function"><span class="title">callback</span>(<span class="params">value,index,arrary</span>)</span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125;,[ options ])</span><br></pre></td></tr></table></figure>

<p>同上；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.some != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> passed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, len=<span class="built_in">this</span>.length; k&amp;lt; len; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (passed === <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">        passed = !!fn.call(context, <span class="built_in">this</span>[k], k,<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> passed;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五：every"><a href="#五：every" class="headerlink" title="五：every"></a>五：every</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.every(<span class="function"><span class="title">callback</span>(<span class="params">value,index,arrary</span>)</span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125;,[ options ])</span><br></pre></td></tr></table></figure>

<p>同上；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.every != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.every = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> passed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>,len = <span class="built_in">this</span>.length;k&amp;lt;len; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (passed === <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        passed =!!fn.call(context,<span class="built_in">this</span>[k],k,<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> passed;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六：indexOf"><a href="#六：indexOf" class="headerlink" title="六：indexOf"></a>六：indexOf</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.indexOf(searchElement[, fromIndex])</span><br></pre></td></tr></table></figure>

<p>返回整数索引值，如果没有匹配（严格匹配），返回-1. fromIndex可选，表示从这个位置开始搜索，若缺省或格式不合要求，使用默认值0，我在FireFox下测试，发现使用字符串数值也是可以的，例如”3”和3都可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.indexOf != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.indexOf=<span class="function"><span class="keyword">function</span>(<span class="params">search,<span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">from</span> = <span class="keyword">from</span> * <span class="number">1</span> || <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>,len=<span class="built_in">this</span>.length;k &amp;lt; len; k++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">k&gt;=<span class="keyword">from</span> &amp;amp;&amp;amp; <span class="built_in">this</span>[k]===search</span>)</span>&#123;</span><br><span class="line">                index = k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><p>lastIndexOf方法与indexOf方法类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.lastIndexOf(searchElement[, fromIndex])</span><br></pre></td></tr></table></figure>

<p>只是lastIndexOf是从字符串的末尾开始查找，而不是从开头。还有一个不同就是fromIndex的默认值是array.length - 1而不是0.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.lastIndexOf!=<span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.lastIndexOf=<span class="function"><span class="keyword">function</span>(<span class="params">search, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index = -<span class="number">1</span>, length = <span class="built_in">this</span>.length;</span><br><span class="line">        <span class="keyword">from</span> = <span class="keyword">from</span> * <span class="number">1</span> || length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = length - <span class="number">1</span>; k &gt; -<span class="number">1</span>; k-=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &amp;lt;= <span class="keyword">from</span> &amp;amp;&amp;amp; <span class="built_in">this</span>[k] === search) &#123;</span><br><span class="line">                index = k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="title">callback</span>(<span class="params">prev,value,index,arrary</span>)</span>&#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#125;,[ initialValue ])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>callback函数接受4个参数：之前值、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。若指定，则当作最初使用的prev值；如果缺省，则使用数组的第一个元素作为prev初始值，同时current往后排一位，相比有initialValue值少一次迭代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.reduce != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.reduce=<span class="function"><span class="keyword">function</span>(<span class="params">callback,init</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> prev = init, k = <span class="number">0</span>,len=<span class="built_in">this</span>.length;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> init === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">            prev = <span class="built_in">this</span>[<span class="number">0</span>];</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k; k &amp;lt; length; k++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hasOwnProperty(k)</span><br><span class="line">        &amp;amp;&amp;amp; (prev = callback(prev,<span class="built_in">this</span>[k],k,<span class="built_in">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p>reduceRight跟reduce相比，用法类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.reduceRight(callback,[ initialValue ])</span><br></pre></td></tr></table></figure>

<p>实现上差异在于reduceRight是从数组的末尾开始实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.reduceRight != <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.reduceRight=<span class="function"><span class="keyword">function</span>(<span class="params">callback,init</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> len=<span class="built_in">this</span>.length,k = len - <span class="number">1</span>, prev = init;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> init === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">            prev = <span class="built_in">this</span>[length - <span class="number">1</span>];</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback===<span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k; k &gt; -<span class="number">1</span>; k-=<span class="number">1</span>) &#123;          </span><br><span class="line">            <span class="built_in">this</span>.hasOwnProperty(k)</span><br><span class="line">        &amp;amp;&amp;amp; (prev = callback(prev,<span class="built_in">this</span>[k],k,<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>函数声明、函数表达式、匿名函数</title>
    <url>/2020/11/14/js/function/</url>
    <content><![CDATA[<blockquote>
<p>一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。</p>
</blockquote>
<h2 id="函数声明："><a href="#函数声明：" class="headerlink" title="函数声明："></a>函数声明：</h2><p>function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。</p>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式 :"></a>函数表达式 :</h2><p>var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p>
<h2 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h2><p>function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p>
<h2 id="函数声明和函数表达式不同之处在于"><a href="#函数声明和函数表达式不同之处在于" class="headerlink" title="函数声明和函数表达式不同之处在于"></a>函数声明和函数表达式不同之处在于</h2><p>一、Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式</p>
<p>二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 </p>
<p>（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p>
<pre><code>注意：</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> <span class="title">aassss</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> Vehicle2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Vehicle.name); <span class="comment">// aassss</span></span><br><span class="line"><span class="built_in">console</span>.log(Vehicle2.name); <span class="comment">// Vehicle2</span></span><br><span class="line">aassss() <span class="comment">// 会报错,aassss只能在他的函数体里面调用（函数表达式中的函数名会被忽略）</span></span><br></pre></td></tr></table></figure>

<h2 id="函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。例如："><a href="#函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。例如：" class="headerlink" title="函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。例如："></a>函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。例如：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// throws an error</span></span><br><span class="line">却可以这样</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="使用用-‘new-Function’定义的函数没有函数名。a"><a href="#使用用-‘new-Function’定义的函数没有函数名。a" class="headerlink" title="使用用 ‘new Function’定义的函数没有函数名。a"></a>使用用 ‘new Function’定义的函数没有函数名。a</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Function</span>())会输出</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;alert(anonymous);&quot;</span>); </span><br><span class="line">foo(); <span class="comment">// error, anonymous is not defined</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/11/14/js/fun-set/</url>
    <content><![CDATA[<blockquote>
<p>集合的基本性质有一条: 集合中元素是不重复的。</p>
</blockquote>
<p>集合集合需要有如下方法:</p>
<ul><li>
has(value): 检测集合内是否有某个元素</li><li>
add(value): 给集合内添加某个元素</li><li>
remove(value): 移除集合中某个元素</li><li>
clear(value): 清空集合</li><li>
size(): 返回集合长度</li><li>
values(): 返回集合转换的数组</li><li>
union(otherSet): 返回两个集合的并集</li><li>
intersection(otherSet): 返回两个集合的交集</li><li>
difference(otherSet): 返回两个集合的差集</li><li>
subset(otherSet): 判断该集合是否为传入集合的子集</li></ul>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 集合的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 集合元素的容器，以对象来表示</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@type <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检测集合内是否有某个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span>  </span>value    要检测的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>       </span>如果有，返回true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// hasOwnProperty的问题在于</span></span><br><span class="line">    <span class="comment">// 它是一个方法，所以可能会被覆写</span></span><br><span class="line">        <span class="keyword">return</span> items.hasOwnProperty(value)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 给集合内添加某个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Any&#125;</span> </span>value 要被添加的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>       </span>添加成功返回True。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//先检测元素是否存在。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">            items[value] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果元素已存在则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除集合中某个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>value 要移除的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>       </span>移除成功返回True。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//先检测元素是否存在。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> items[value];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果元素不存在，则删除失败返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回集合长度，只可用于IE9及以上</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>集合长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Object.keys方法能将对象转化为数组</span></span><br><span class="line">        <span class="comment">// 只可用于IE9及以上，但很方便</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回集合长度，可用于所有浏览器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>集合长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items.hasOwnProperty(prop)) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回集合转换的数组，只可用于IE9及以上</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>转换后的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回集合转换的数组，可用于所有浏览器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>转换后的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.valuesLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> keys = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> items) &#123;</span><br><span class="line">            keys.push(key)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回两个集合的并集</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Set&#125;</span> </span>otherSet 要进行并集操作的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Set&#125;</span>          </span>两个集合的并集</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个新集合，用于表示并集。</span></span><br><span class="line">        <span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">//将当前集合转换为数组，并依次添加进unionSet</span></span><br><span class="line">        <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将其它集合转换为数组，依次添加进unionSet。</span></span><br><span class="line">        <span class="comment">//循环中的add方法保证了不会有重复元素的出现</span></span><br><span class="line">        values = otherSet.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; values.length; i++) &#123;</span><br><span class="line">            unionSet.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unionSet;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回两个集合的交集</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Set&#125;</span> </span>otherSet 要进行交集操作的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Set&#125;</span>          </span>两个集合的交集</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个新集合，用于表示交集。</span></span><br><span class="line">        <span class="keyword">var</span> interSectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">//将当前集合转换为数组</span></span><br><span class="line">        <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="comment">//遍历数组，如果另外一个集合也有该元素，则interSectionSet加入该元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; values.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (otherSet.has(values[i])) &#123;</span><br><span class="line">                interSectionSet.add(values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interSectionSet;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回两个集合的差集</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Set&#125;</span> </span>otherSet 要进行差集操作的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Set&#125;</span>          </span>两个集合的差集</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个新集合，用于表示差集。</span></span><br><span class="line">        <span class="keyword">var</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">//将当前集合转换为数组</span></span><br><span class="line">        <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="comment">//遍历数组，如果另外一个集合没有该元素，则differenceSet加入该元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; values.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class="line">                differenceSet.add(values[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> differenceSet;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断该集合是否为传入集合的子集</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Set&#125;</span> </span>otherSet 传入的集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>      </span>是则返回True</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个判定,如果该集合长度大于otherSet的长度</span></span><br><span class="line">        <span class="comment">// 则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前集合转换为数组</span></span><br><span class="line">            <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; values.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class="line">                    <span class="comment">// 第二个判定。只要有一个元素不在otherSet中</span></span><br><span class="line">                    <span class="comment">// 那么则可以直接判定不是子集，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS 原型与原型链</title>
    <url>/2020/11/14/js/js-proto/</url>
    <content><![CDATA[<p><a href="https://www.webq.top/article/828" target="_blank">上一篇：继承与原型链</a></p>
<h2 id="一：每个对象都有-proto-属性，但只有函数对象才有-prototype-属性"><a href="#一：每个对象都有-proto-属性，但只有函数对象才有-prototype-属性" class="headerlink" title="一：每个对象都有 proto 属性，但只有函数对象才有 prototype 属性"></a>一：每个对象都有 <strong>proto</strong> 属性，但只有函数对象才有 prototype 属性</h2><p>注：Function.prototype为空函数，没有prototype（箭头函数也没有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.constructor == Person</span><br><span class="line">Person.prototype.constructor == Person</span><br></pre></td></tr></table></figure>



<p>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype) <span class="comment">//Person&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype) <span class="comment">//Object</span></span><br><span class="line">&lt;span style=<span class="string">&quot;color: rgb(249, 150, 59); font-size: x-large;&quot;</span>&gt;<span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// Function，这个特殊（为空函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>Function.prototype 为什么是函数对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> <span class="built_in">Function</span> ();</span><br><span class="line"><span class="built_in">Function</span>.prototype = A;</span><br></pre></td></tr></table></figure>

<h2 id="凡是通过-new-Function-产生的对象都是函数对象。因为-A-是函数对象，所以Function-prototype-是函数对象。"><a href="#凡是通过-new-Function-产生的对象都是函数对象。因为-A-是函数对象，所以Function-prototype-是函数对象。" class="headerlink" title="凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以Function.prototype 是函数对象。"></a>凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以Function.prototype 是函数对象。</h2><p>所有函数对象proto都指向 Function.prototype，它是一个空函数（Empty function）</p>
<h2 id="所有对象的-proto-都指向其构造器的prototype"><a href="#所有对象的-proto-都指向其构造器的prototype" class="headerlink" title="所有对象的__proto__都指向其构造器的prototype"></a>所有对象的__proto__都指向其构造器的prototype</h2><p>console.log(Function.prototype.<strong>proto</strong> === Object.prototype) // true</p>
<h2 id="二：原型链"><a href="#二：原型链" class="headerlink" title="二：原型链"></a>二：原型链</h2><li>1、person1.__proto__ 是什么？</li><li>
</li>
<li>
2、Person.__proto__ 是什么？</li><li>
</li>
<li>
3、Person.prototype.__proto__ 是什么？</li><li>
</li>
<li>
4、Object.__proto__ 是什么？</li><li>
</li>
<li>
5、Object.prototype__proto__ 是什么？</li><li>
</li>

<p>答案：</p>
<p>第一题：</p>
<p>因为 person1.<strong>proto</strong> === person1 的构造函数.prototype</p>
<p>因为 person1的构造函数 === Person</p>
<p>所以 person1.<strong>proto</strong> === Person.prototype</p>
<p>第二题：</p>
<p>因为 Person.<strong>proto</strong> === Person的构造函数.prototype</p>
<p>因为 Person的构造函数 === Function</p>
<p>所以 Person.<strong>proto</strong> === Function.prototype</p>
<p>第三题：</p>
<p>Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。</p>
<p>因为一个普通对象的构造函数 === Object</p>
<p>所以 Person.prototype.<strong>proto</strong> === Object.prototype</p>
<p>第四题，参照第二题，因为 Person 和 Object 一样都是构造函数</p>
<p>第五题：</p>
<p>Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。</p>
<p>Object.prototype.<strong>proto</strong> === null</p>
<p>拓展：<br><a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank">最详尽的 JS 原型与原型链终极详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript预编译原理分析</title>
    <url>/2020/11/14/js/js-precompile/</url>
    <content><![CDATA[<p>JavaScript运行三部曲<br>脚本执行js引擎都做了什么呢？</p>
<p>1、语法分析<br>2、预编译<br>3、解释执行</p>
<p>在执行代码前，还有两个步骤<br>语法分析很简单，就是引擎检查你的代码有没有什么低级的语法错误<br>解释执行顾名思义便是执行代码了<br>预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数<br>理解了预编译对大家理解作用域同样有帮助</p>
<p>JS预编译实例<br>举例前，先来思考一下这几个概念：</p>
<p>变量声明 var…<br>函数声明 function…</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="comment">// 变量声明</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">y</span>)</span>&#123;<span class="comment">//函数声明</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> x = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;so easy&#x27;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//是变量声明而不是函数声明！！</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//...</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        b(100);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="number">0</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>让我们看看引擎对这段代码做了什么吧</p>
<p>页面产生便创建了GO全局对象（Global Object）（也就是大家熟悉的window对象）<br>第一个脚本文件加载<br>脚本加载完毕后，分析语法是否合法<br>开始预编译<br>查找变量声明，作为GO属性，值赋予undefined<br>查找函数声明，作为GO属性，值赋予函数体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">// GO</span></span><br><span class="line"><span class="built_in">window</span> = &#123;</span><br><span class="line">    <span class="comment">//页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略</span></span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">undefined</span>，</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;so easy&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释执行代码（直到执行函数b）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="comment">// GO</span></span><br><span class="line"><span class="built_in">window</span> = &#123;</span><br><span class="line">    <span class="comment">//变量随着执行流得到初始化</span></span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;so easy&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行函数b之前，发生预编译<br>创建AO活动对象（Active Object）<br>查找形参和变量声明，值赋予undefined<br>实参值赋给形参<br>查找函数声明，值赋予函数体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">AO = &#123;</span><br><span class="line">    <span class="comment">//创建AO同时，创建了arguments等等属性，此处省略</span></span><br><span class="line">    y: <span class="number">100</span>,</span><br><span class="line">    x: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解释执行函数中代码<br>第一个脚本文件执行完毕，加载第二个脚本文件<br>第二个脚本文件加载完毕后，进行语法分析<br>语法分析完毕，开始预编译<br>重复最开始的预编译步骤……<br>大家要注意，<br>预编译阶段发生变量声明和函数声明，没有初始化行为（赋值），匿名函数不参与预编译<br>只有在解释执行阶段才会进行变量初始化<br>嗯~最后收一下尾</p>
<p>总结<br>预编译(函数执行前)※ </p>
<ol>
<li>创建AO对象（Active Object） </li>
<li>查找函数形参及函数内变量声明，形参名及变量名作为AO对象的属性，值为undefined </li>
<li>实参形参相统一，实参值赋给形参 </li>
<li>查找函数声明，函数名作为AO对象的属性，值为函数引用</li>
</ol>
<p>预编译(脚本代码块script执行前) </p>
<ol>
<li>查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined </li>
<li>查找函数声明，函数名作为全局对象的属性，值为函数引用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">params</span>) </span>&#123; &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// AO activation object</span></span><br><span class="line"><span class="comment">// 1. 寻找形参和变量声明</span></span><br><span class="line"><span class="comment">// 2. 实参赋值给形参</span></span><br><span class="line"><span class="comment">// 3. 寻找函数声明，赋值</span></span><br><span class="line"><span class="comment">// 4. 执行</span></span><br><span class="line"><span class="comment">// AO = &#123;</span></span><br><span class="line">    <span class="comment">//     a: undefined -&gt;</span></span><br><span class="line">    <span class="comment">//         2 -&gt;</span></span><br><span class="line">    <span class="comment">//         function a(params) &#123; &#125; -&gt;</span></span><br><span class="line"><span class="comment">//         1</span></span><br><span class="line"><span class="comment">//     b: undefined -&gt;</span></span><br><span class="line"><span class="comment">//         function () &#123;&#125;</span></span><br><span class="line"><span class="comment">//     d: function () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/img/js-pre.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>单向链表、循环链表、双向链表</title>
    <url>/2020/11/14/js/link-list/</url>
    <content><![CDATA[<blockquote>
<p>链表是一种常见的数据结构，也属于线性表，但不会按线性的顺序来储存数据。而是在每一个节点中，储存了下一个节点的指针。</p>
</blockquote>
<h2 id="使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。"><a href="#使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。" class="headerlink" title="使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。"></a>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。</h2><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表中最简单的形式就是单向链表，链表中的节点都包含两个部分，第一部分储存着自身信息，第二部分则储存有指向下一节点的指针。最后一个节点则指向NULL，</p>
<p>单向链表需要有如下的方法:</p>
<ul><li>
append(element): 添加元素到链表尾部</li><li>
insert(position,element): 向单向链表中某个位置插入元素</li><li>
indexOf(element): 寻找某个元素在单向链表中的位置</li><li>
remove(element): 移除给定的元素</li><li>
removeAt(position): 移除单向链表中某个位置的元素</li><li>
getHead(): 获取单向链表的头部</li><li>
isAmpty(): 检查单向链表是否为空，为空则返回true</li><li>
toString(): 将链表所有内容以字符串输出</li><li>
size(): 返回单向链表长度</li></ul>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单向链表构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单向链表中节点的构造函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Any&#125;</span> </span>element 要传入链表的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单向链表的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//单向链表的头结点，初始化为NULL</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向单向链表尾部添加元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element 要加入链表的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">var</span> current;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前项等于链表头部元素.</span></span><br><span class="line">            <span class="comment">// while循环到最后一个，从而将该节点加入链表尾部。</span></span><br><span class="line">            current = head;</span><br><span class="line">            <span class="comment">// 当next为null时，判定为false。退出循环。</span></span><br><span class="line">            <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除单向链表中某一个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>position 要移除元素的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span>          </span>移除成功返回被移除的元素，不成功则返回NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">            <span class="keyword">var</span> current = head;</span><br><span class="line">            <span class="keyword">var</span> previous;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为之前head指向第一个元素，现在把head修改为指向第二个元素。</span></span><br><span class="line">            <span class="comment">// 核心概念在于链表前后全靠指针链接，而非数组一般。</span></span><br><span class="line">            <span class="comment">// 所以只需要改变head的元素。</span></span><br><span class="line">            head = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">                <span class="comment">// previous指要操作元素位置之前的那个元素，current表示之后的那个元素。</span></span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        previous.next = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向单向链表中插入某个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>position 要插入的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element  要插入的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>          </span>插入成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">var</span> current = head;</span><br><span class="line">            <span class="keyword">var</span> previous;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">            node.next = current;</span><br><span class="line">            head = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.next = node;</span><br><span class="line">                node.next = current;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将链表所有内容以字符串输出</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>要输出的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = head;</span><br><span class="line">        <span class="keyword">var</span> string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            string += current.element;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 寻找某个元素在单向链表中的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element 要寻找的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span>         </span>返回值&gt;=0则代表找到相应位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> current = head;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除给定的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element 要移除的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span>         </span>返回值&gt;=0表示移除成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="built_in">this</span>.indexOf(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断单向链表是否为空</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span> </span>为空则返回true，不为空则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.isAmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length === <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回单向链表长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>单向链表的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取单向链表的头部</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>单向链表的头部</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.getHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身，即</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表与单向链表很是相像。在单向链表中，只有指向下一个节点的链接。但在双向链表中，还有指向上一个节点的链接，是双向的。</p>
<p>双向链表需要有如下的方法:<ul><li><br>append(element): 添加元素到双向链表尾部</li><li><br>insert(position,element): 向双向链表中某个位置插入元素</li><li><br>removeAt(position): 移除双向链表中某个位置的元素</li><li><br>showHead(): 获取双向链表的头部</li><li><br>showLength(): 获取双向链表长度</li><li><br>showTail(): 获取双向链表尾部</li></ul></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 双向链表中节点的构造函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Any&#125;</span> </span>element 要传入链表的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//双向链表的头结点，初始化为NULL</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//双向链表的尾结点，初始化为NULL</span></span><br><span class="line">    <span class="keyword">var</span> tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向链表尾部添加元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element 要加入链表的节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span>         </span>加入链表的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> previous;</span><br><span class="line">            <span class="keyword">var</span> current = head;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.next = node;</span><br><span class="line">            node.prev = current;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向链表中插入某个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>position 要插入的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span>         </span>插入成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> previous;</span><br><span class="line">            <span class="keyword">var</span> current = head;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    current.prev = node;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123;</span><br><span class="line">        </span><br><span class="line">                current = tail;</span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.next = node;</span><br><span class="line">                node.prev = previous;</span><br><span class="line">                current.prev = node;</span><br><span class="line">                node.next = current;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除链表中某一个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>position 要移除元素的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span>             </span>移除成功返回被移除的元素，不成功则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">            <span class="keyword">var</span> current = head;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> previous;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">                head = current.next;</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">                    tail = <span class="literal">null</span>;</span><br><span class="line">                    head.prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123;</span><br><span class="line">                current = tail;</span><br><span class="line">                tail = current.prev;</span><br><span class="line">                tail.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">                    previous = current.prev;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                previous.next = current.next;</span><br><span class="line">                current.next.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取链表的头部</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>链表的头部</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.showHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取链表长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>链表长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.showLength = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取链表尾部</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>链表尾部</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.showTail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>```</p>
]]></content>
  </entry>
  <entry>
    <title>js工具函数</title>
    <url>/2020/11/14/js/js-utils/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">// guid</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guid</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* eslint-disable*/</span></span><br><span class="line">        out += (((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">0x10000</span>) | <span class="number">0</span>).toString(<span class="number">16</span>).substring(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* eslint-enable */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        text: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        type: <span class="string">&#x27;text/plain;charset=utf-8&#x27;</span>,</span><br><span class="line">        fileName: <span class="string">&#x27;text.txt&#x27;</span>,</span><br><span class="line">        ...o</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([obj.text], &#123; <span class="attr">type</span>: obj.type &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">    <span class="comment">// For IE</span></span><br><span class="line">        navigator.msSaveBlob(blob, obj.fileName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        link.href = <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br><span class="line">        link.download = obj.fileName</span><br><span class="line">        link.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        link.target = <span class="string">&#x27;_blank&#x27;</span></span><br><span class="line">        link.click()</span><br><span class="line">        <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            link.remove()</span><br><span class="line">            <span class="built_in">window</span>.URL.revokeObjectURL(link.href)</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">// const uploader: any = $(&#x27;&lt;input type=&quot;file&quot;&gt;&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> uploader: HTMLElement = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">uploader.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;file&#x27;</span>);</span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        uploader.click();</span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="keyword">const</span> reImport = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.readAsText(uploader[<span class="string">&#x27;files&#x27;</span>][<span class="number">0</span>]);</span><br><span class="line">        reader.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            callback(reader);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (!Utils.browser.version.trident &amp;&amp; !Utils.browser.version.edge) &#123;</span><br><span class="line">        uploader.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reImport();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// IE系的浏览器因为浏览器本身的bug无法用click()触发input元素的change事件,这里做下处理.</span></span><br><span class="line">        <span class="built_in">window</span>[<span class="string">&#x27;setTimeout&#x27;</span>](<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (uploader.getAttribute(<span class="string">&#x27;value&#x27;</span>).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                reImport();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否能使用webp图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canUseWebP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !! [].map &amp;&amp; <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>).toDataURL(<span class="string">&#x27;image/webp&#x27;</span>).indexOf(<span class="string">&#x27;data:image/webp&#x27;</span>) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cookieName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> defaultResult = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> decodeCookieName = <span class="built_in">decodeURIComponent</span>(cookieName);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [key, value] = cookies[i].trim().split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">decodeURIComponent</span>(key) === decodeCookieName) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, days = <span class="number">365</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> encodeName = <span class="built_in">encodeURIComponent</span>(name);</span><br><span class="line">    <span class="keyword">const</span> encodeValue = <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    date.setTime(date.getTime() + days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;encodeName&#125;</span>=<span class="subst">$&#123;encodeValue&#125;</span>;</span></span><br><span class="line"><span class="string">                    expires=<span class="subst">$&#123;date.toUTCString()&#125;</span>;</span></span><br><span class="line"><span class="string">                    path=/; domain=.bilibili.com`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocalSettings</span>(<span class="params">key, storage = <span class="built_in">localStorage</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>[storage] &amp;&amp; storage.getItem) &#123;</span><br><span class="line">        <span class="keyword">return</span> storage.getItem(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getCookie(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLocalSettings</span>(<span class="params">key, val, storage = <span class="built_in">localStorage</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>[storage] &amp;&amp; storage.setItem) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage.setItem(key, val);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.setCookie(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">formatDate</span>(<span class="params">date, format</span>)</span>&#123;</span><br><span class="line">    date = date || <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    format = format || <span class="string">&#x27;yyyy-MM-dd mm:ss&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> mapping = &#123;</span><br><span class="line">        <span class="string">&#x27;M+&#x27;</span>: date.getMonth() + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;d+&#x27;</span>: date.getDate(),</span><br><span class="line">        <span class="string">&#x27;h+&#x27;</span>: date.getHours(),</span><br><span class="line">        <span class="string">&#x27;m+&#x27;</span>: date.getMinutes(),</span><br><span class="line">        <span class="string">&#x27;s+&#x27;</span>: date.getSeconds(),</span><br><span class="line">        <span class="string">&#x27;q+&#x27;</span>: <span class="built_in">Math</span>.floor((date.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),</span><br><span class="line">        <span class="string">&#x27;S+&#x27;</span>: date.getMilliseconds(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(y+)/i</span>.test(format)) &#123;</span><br><span class="line">        format = format.replace(</span><br><span class="line">            <span class="built_in">RegExp</span>.$1,</span><br><span class="line">            date.getFullYear().toString().substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$1.length)</span><br><span class="line">                    );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>).test(format)) &#123;</span><br><span class="line">            <span class="keyword">const</span> n = <span class="built_in">RegExp</span>.$1.length === <span class="number">1</span></span><br><span class="line">                    ? mapping[k]</span><br><span class="line">                    : (<span class="string">&#x27;00&#x27;</span> + mapping[k]).substr(mapping[k].toString().length);</span><br><span class="line">            format = format.replace(<span class="built_in">RegExp</span>.$1, n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#x27;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/\\/</span><span class="regexp">/g, &#x27;&amp;#x2f;&#x27;)</span></span><br><span class="line"><span class="regexp">        .replace(/</span>\</span><br><span class="line">        /g, <span class="string">&#x27;</span></span><br><span class="line"><span class="string">        &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDecoder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>[<span class="string">&#x27;TextDecoder&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">window</span>[<span class="string">&#x27;TextDecoder&#x27;</span>]();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        decode: <span class="function">(<span class="params">buf: any</span>) =&gt;</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>[<span class="string">&#x27;escape&#x27;</span>](</span><br><span class="line">            <span class="built_in">String</span>.fromCharCode.apply(<span class="built_in">String</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf)))),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">decoder = getDecoder();</span><br><span class="line"></span><br><span class="line">decode(arrayBuffer.slice(<span class="number">0</span>, <span class="number">4</span>)), <span class="comment">// 4字节tag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">document</span>.documentElement</span><br><span class="line">        &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">        ) || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setScrollTop</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">        <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTo</span>(<span class="params">to, duration</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            setScrollTop(<span class="number">0</span>, to);</span><br><span class="line">                    <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> diff = to - getScrollTop();</span><br><span class="line">        <span class="keyword">if</span> (diff === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">var</span> step = diff / duration * <span class="number">10</span>;</span><br><span class="line">        requestAnimationFrame(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(step) &gt; <span class="built_in">Math</span>.abs(diff)) &#123;</span><br><span class="line">                    setScrollTop(getScrollTop() + diff);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            setScrollTop(getScrollTop() + step);</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span> &amp;&amp; getScrollTop() &gt;= to || diff &lt; <span class="number">0</span> &amp;&amp; getScrollTop() &lt;= to) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            scrollTo(to, duration - <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy;</span><br><span class="line">    <span class="comment">// Handle the 3 simple types, and null or undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == values || <span class="string">&quot;object&quot;</span> != <span class="keyword">typeof</span> values) <span class="keyword">return</span> values;</span><br><span class="line">    <span class="comment">// Handle Date</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        copy = <span class="keyword">new</span></span><br><span class="line">        <span class="built_in">Date</span>();</span><br><span class="line">        copy.setTime(values.getTime());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle Array</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            copy = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">            len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">                copy[i] = deepClone(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle Object</span></span><br><span class="line">    <span class="keyword">if</span> (values <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            copy = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> values) &#123;</span><br><span class="line">                <span class="keyword">if</span> (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Unable to copy values! Its type isn&#x27;t supported.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assign</span>(<span class="params">target, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> to = <span class="built_in">Object</span>(target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rest.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> nextSource = rest[i];</span><br><span class="line">        <span class="keyword">if</span> (nextSource != <span class="literal">null</span>) &#123; <span class="comment">// Skip over if undefined or null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> nextKey <span class="keyword">in</span> nextSource) &#123;</span><br><span class="line">                <span class="comment">// Avoid bugs when hasOwnProperty is shadowed</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;</span><br><span class="line">                    to[nextKey] = nextSource[nextKey];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防抖用于search搜索。resize</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节流用于鼠标点击。scroll</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, gapTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _lastTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _nowTime = + <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (_nowTime - _lastTime &gt; gapTime || !_lastTime) &#123;</span><br><span class="line">            fn();</span><br><span class="line">            _lastTime = _nowTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">browser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> isSafari = </span><br><span class="line">        /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.test(ua)</span><br><span class="line">        || <span class="regexp">/(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/</span>.test(ua);</span><br><span class="line">    <span class="keyword">const</span> match = <span class="regexp">/(chrome)[ \\/]([\\w.]+)/</span>.exec(ua) || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> matched = &#123;</span><br><span class="line">        browser:  match[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        version:  match[<span class="number">2</span>] || <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> version = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (matched.browser) &#123;</span><br><span class="line">        version =  <span class="built_in">parseInt</span>(matched.version, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器</span></span><br><span class="line">        browser: matched.browser,</span><br><span class="line">        version: version,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 系统</span></span><br><span class="line">        linux: <span class="regexp">/Linux/i</span>.test(ua),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内核</span></span><br><span class="line">        webKit: <span class="regexp">/AppleWebKit/i</span>.test(ua),</span><br><span class="line">        gecko: <span class="regexp">/Gecko/i</span>.test(ua) &amp;&amp; !<span class="regexp">/KHTML/i</span>.test(ua),</span><br><span class="line">        trident: <span class="regexp">/Trident/i</span>.test(ua),</span><br><span class="line">        presto: <span class="regexp">/Presto/i</span>.test(ua),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手机</span></span><br><span class="line">        mobile: <span class="regexp">/AppleWebKit.*Mobile.*/i</span>.test(ua),</span><br><span class="line">        iOS: <span class="regexp">/Mac OS X[\\s_\\-\\/](\\d+[.\\-_]\\d+[.\\-_]?\\d*)/i</span>.test(ua),</span><br><span class="line">        iPhone: <span class="regexp">/iPhone/i</span>.test(ua),</span><br><span class="line">        iPad: <span class="regexp">/iPad/i</span>.test(ua),</span><br><span class="line">        webApp: !<span class="regexp">/Safari/i</span>.test(ua),</span><br><span class="line">        android: <span class="regexp">/Android/i</span>.test(ua),</span><br><span class="line">        windowsPhone: <span class="regexp">/Windows Phone/i</span>.test(ua),</span><br><span class="line">        microMessenger: <span class="regexp">/MicroMessenger/i</span>.test(ua),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 桌面</span></span><br><span class="line">        msie: <span class="regexp">/msie [\\w.]+/i</span>.test(ua),</span><br><span class="line">        edge: <span class="regexp">/edge/i</span>.test(ua),</span><br><span class="line">        edgeBuild16299: <span class="regexp">/(\\s|^)edge\\/</span><span class="number">16.16299</span>(\\s|$)/i.test(ua),</span><br><span class="line">        safari: isSafari,</span><br><span class="line">        safariSupportMSE: isSafari &amp;&amp; (<span class="regexp">/Version\\/</span><span class="number">1</span>\\d/i).test(ua),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 暴露出这些属性和方法</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    guid,</span><br><span class="line">    download,</span><br><span class="line">    upload,</span><br><span class="line"></span><br><span class="line">    canUseWebP,</span><br><span class="line">    getCookie,</span><br><span class="line"></span><br><span class="line">    setCookie,</span><br><span class="line"></span><br><span class="line">    getLocalSettings,</span><br><span class="line">    setLocalSettings ,</span><br><span class="line">    formatDate,</span><br><span class="line">    htmlEncode，</span><br><span class="line"></span><br><span class="line">    getDecoder，</span><br><span class="line"></span><br><span class="line">    setScrollTop,</span><br><span class="line"></span><br><span class="line">    setScrollTop,</span><br><span class="line"></span><br><span class="line">    scrollTo,    </span><br><span class="line">    deepClone,</span><br><span class="line"></span><br><span class="line">    assign,</span><br><span class="line"></span><br><span class="line">    browser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS 引擎的执行机制</title>
    <url>/2020/11/14/js/micro-task/</url>
    <content><![CDATA[<p>JSJS的执行机制是：</p>
<p>首先判断JS是同步还是异步，同步就进入主进程，异步就进入event table</p>
<p>异步任务在event table中注册函数，当满足触发条件后，被推入event queue</p>
<p>同步任务进入主线程后一直执行，直到主线程空闲时，才会去event queue中查看是否有可执行的异步任务，如果有就推入主进程中<br>以上三步循环执行，这就是event loop。</p>
<p>而准确的划分方式是：</p>
<p>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval，setImmediate</p>
<p>micro-task(微任务)：Promise，process.nextTick<br><img src="/img/micro-task.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;定时器开始啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;马上执行for循环啦&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">10000</span>; i++</span>)</span>&#123;</span><br><span class="line">        i == <span class="number">99</span> &amp;amp;&amp;amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行then函数啦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>首先执行script下的宏任务，遇到setTimeout,将其放到宏任务的“队列”里</p>
<p>遇到 new Promise直接执行，打印”马上执行for循环啦”</p>
<p>遇到then方法，是微任务，将其放到微任务的“队列”里。</p>
<p>打印 “代码执行结束”</p>
<p>本轮宏任务执行完毕，查看本轮的微任务，发现有一个then方法里的函数，打印”执行then函数啦”</p>
<p>到此,本轮的event loop 全部完成。</p>
<p>下一轮的循环里，先执行一个宏任务，发现宏任务的“队列”里有一个setTimeout里的函数,执行打印”定时器开始啦”<br>所以最后的执行顺序是： 马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦</p>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>这段setTimeout代码什么意思? 我们一般说: 3秒后,会执行setTimeout里的那个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;执行了&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>但是这种说并不严谨，准确的解释是：3秒后，setTimeout里的函数被会推入event queue，而event queue(事件队列)里的任务，只有在主线程空闲时才会执行。</p>
<p>所以只有满足 (1)3秒后 (2)主线程空闲，同时满足时，才会3秒后执行该函数<br>如果主线程执行内容很多，执行时间超过3秒，比如执行了10秒，那么这个函数只能10秒后执行了。</p>
]]></content>
  </entry>
  <entry>
    <title>MSE学习日志</title>
    <url>/2020/11/14/js/mse/</url>
    <content><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource" target="_blank">MediaSource</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26374202" target="_blank">使用 MediaSource 搭建流式播放器</a></p>
<p><a href="https://juejin.im/post/5ae04c6651882567244da8eb#heading-2" target="_blank">FLV封装格式介绍及解析</a></p>
<p><a href="https://blog.csdn.net/stn_lcd/article/details/73743020" target="_blank">FLV学习（二）FLV封装原理</a></p>
<p><a href="https://www.jianshu.com/p/7ffaec7b3be6" target="_blank">flv格式详解+实例剖析</a></p>
<p><a href="https://blog.csdn.net/hejjunlin/article/details/73322063" target="_blank">H.264标准（二）FLV封装格式详解</a></p>
<p><a href="https://blog.csdn.net/yue_huang/article/details/78466537" target="_blank">DASH简介及使用方法(FFmpeg, MP4Box)</a></p>
<p><a href="https://technet.microsoft.com/zh-cn/dn551368(v=vs.95)" target="_blank">构建简单的 MPEG-DASH 流媒体播放器</a></p>
<p><a href="https://github.com/Dash-Industry-Forum/dash.js" target="_blank">Dash.js</a></p>
]]></content>
  </entry>
  <entry>
    <title>new 命令</title>
    <url>/2020/11/14/js/new/</url>
    <content><![CDATA[<h2 id="new命令的原理"><a href="#new命令的原理" class="headerlink" title="new命令的原理"></a>new命令的原理</h2><p>使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。</p>
<ul>
<li><ol>
<li>创建一个空对象，作为将要返回的对象实例</li>
</ol>
</li>
<li><ol start="2">
<li>将这个空对象的原型，指向构造函数的prototype属性</li>
</ol>
</li>
<li><ol start="3">
<li>将这个空对象赋值给函数内部的this关键字</li>
</ol>
</li>
<li><ol start="4">
<li>开始执行构造函数内部的代码</li>
</ol>
</li>
</ul>
<blockquote>
<p>注意：如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">11</span>; </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">car1 = <span class="keyword">new</span> Car()</span><br></pre></td></tr></table></figure>
<p>这样是取不到car1里面的name属性，<br>如果构造函数里面return 的为非对象，依然可以取到name</p>
<h3 id="new命令简化的内部流程"><a href="#new命令简化的内部流程" class="headerlink" title="new命令简化的内部流程"></a>new命令简化的内部流程</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">/* 构造函数 */</span> </span></span></span><br><span class="line"><span class="function"><span class="params">    constructor(<span class="comment">/* 构造函数参数 */</span> param1) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 将 <span class="built_in">arguments</span> 对象转为数组</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 取出构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">var</span> constructor = args.shift();</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 创建一个空对象，继承构造函数的 prototype 属性</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">var</span> context = <span class="built_in">Object</span>.create(constructor.prototype);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 执行构造函数</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">var</span> result = constructor.apply(context, args);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="regexp">//</span> 如果返回结果是对象，就直接返回，则返回 context 对象</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="literal">null</span>) ? result : context)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 实例</span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">actor</span> = <span class="title">_new</span>(<span class="params">Person, <span class="string">&#x27;张三&#x27;</span>, <span class="number">28</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>new.target<br>函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === f);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 数据类型转换</title>
    <url>/2020/11/14/js/num-string/</url>
    <content><![CDATA[<blockquote>
<p>JS属于解释型语言，在执行过程中顺序执行，但是会分块先预编译然后才执行。因此在JS中存在一种变量提升的现象</p>
</blockquote>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成1，false 转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>逐个解析字符，而<span class="built_in">Number</span>函数整体转换字符串的类型。</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;42 cats&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>函数会自动过滤一个字符串前导和后缀的空格。<span class="built_in">Number</span>(<span class="string">&#x27;\\t\\v\\r12.34\</span></span><br><span class="line"><span class="string">&#x27;</span>) <span class="comment">// 12.34</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>方法的参数是对象时，将返回<span class="literal">NaN</span></span><br><span class="line">除非是包含单个数值的数组</span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之所以会这样，是因为Number背后的转换规则比较复杂。</p>
<p>1、调用对象自身的valueOf方法。<br>    如果返回原始类型的值，则直接对该值使用Number函数，</p>
<pre><code>不再进行后续步骤。</code></pre>
<p>2、如果valueOf方法返回的还是对象</p>
<pre><code>则改为调用对象自身的toString方法。

如果toString方法返回原始类型的值，

则对该值使用Number函数，不再进行后续步骤。</code></pre>
<p>3、如果toString方法返回的是对象，就报错。</p>
<pre><code>使用String函数，可以将任意类型的值转化成字符串。转换规则如下。</code></pre>
<p>（1）原始类型值的转换规则</p>
<ul>
<li>数值：转为相应的字符串。</li>
<li>字符串：转换后还是原来的值。</li>
<li>布尔值：true转为”true”，false转为”false”。</li>
<li>undefined：转为”undefined”。</li>
<li>null：转为”null”。</li>
</ul>
<p>2）对象的转换规则</p>
<p>String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<p>String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序<br>先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。 </p>
<p>如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。<br>如果valueOf方法返回的是对象，就报错。</p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h2><p>使用Boolean函数，可以将任意类型的变量转为布尔值。</p>
<p>它的转换规则相对简单：除了以下六个值的转换结果为false，其他的值全部为true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">null</span><br><span class="line">-0</span><br><span class="line">0或+0</span><br><span class="line">NaN</span><br><span class="line">&#39;&#39;（空字符串）</span><br></pre></td></tr></table></figure>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>自动转换，它是以强制转换为基础的。<br>遇到以下三种情况时，JavaScript会自动转换数据类型，即转换是自动完成的，对用户不可见。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不同类型的数据互相运算</span></span><br><span class="line"><span class="number">123</span> + <span class="string">&#x27;abc&#x27;</span> <span class="comment">// &quot;123abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对非布尔值类型的数据求布尔值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对非数值类型的数据使用一元运算符</span></span><br><span class="line"><span class="comment">//（即“+”和“-”）</span></span><br><span class="line">+ &#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125; <span class="comment">// NaN</span></span><br><span class="line">- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。<br>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p>
<h2 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line">上面代码中，运算符两侧的运算子，</span><br><span class="line">都被转成了数值。</span><br><span class="line">一元运算符也会把运算子转成数值。</span><br><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Promise-Polyfill源码解析</title>
    <url>/2020/11/14/js/promise-polyfill/</url>
    <content><![CDATA[<p><a href="https://github.com/taylorhakes/promise-polyfill" target="_blank">https://github.com/taylorhakes/promise-polyfill</a></p>
<p>我们平时都是以new Promise(params)的形式使用Promise的，说明Promise是一个构造函数，那我们就从构造函数为入口来分析Promise-polyfill源码。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">Promise</span>))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Promises must be constructed via new&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;not a function&#x27;</span>);</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type <span class="type">&#123;!number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>._state = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;!boolean&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>._handled = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;Promise|undefined&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;!Array&amp;lt;!Function&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>._deferreds = [];</span><br><span class="line"></span><br><span class="line">doResolve(fn, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个if语句说明Promise必须以构造函数形式被调用，第二个if语句则说明Promise的唯一参数fn必须是函数类型。接下来是四个对象属性的定义，我们逐一来看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** <span class="doctag">@type <span class="type">&#123;!number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>._state = <span class="number">0</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>_state属性定义了Promise的状态，我们都知道Promise有pending、fulfilled、rejected三种状态，在源码里，三种状态分别对应_state值为0、1、2。此外，源码中还有_state值为3，第四种内部状态，这个我们后面遇到再讲。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;!boolean&#125;</span> </span>*/</span></span><br><span class="line">   <span class="built_in">this</span>._handled = <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_handled属性的类型为Boolean，初始值为false，其代表Promise是否被处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;Promise|undefined&#125;</span> </span>*/</span></span><br><span class="line">   <span class="built_in">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_value属性的类型为Promise或undefined，初始值为undefined，其代表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;!Array&amp;lt;!Function&gt;&#125;</span> </span>*/</span></span><br><span class="line">   <span class="built_in">this</span>._deferreds = [];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_deferreds属性的类型为Array，初始值为空数组，其作用我们后面遇到再讲，现在只要注意其数组中存放的值为Function。<br>最后是一个函数调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doResolve(fn, <span class="built_in">this</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将Promise的参数fn与代表当前对象的this作为参数，调用了deResolve函数。至此，我们可以发现整个构造函数只是在做一些必要的检查和属性定义，并没有做什么处理，那关键点应该就在最后的函数调用。我们来看看deResolve函数都做了些什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">doResolve</span>(<span class="params">fn, self</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            resolve(self, value);</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            reject(self, reason);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        reject(self, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总体上看，首先定义了一个变量done，初始值为false，接下来是一个try..catch语句，我们先来分析try部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            resolve(self, value);</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            reject(self, reason);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面讲过fn就是构造函数的参数，也就是我们new Promise时传入的回调函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们用resolve, reject替换fn中的两个参数，结果变成:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn(resolve, reject);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说try部分总共就做了一件事，就是讲我们传入的回调函数执行了，并传入了两个回调函数作为参数。这里特别注意一点，到目前为止，并没有涉及到异步之类的，所以我们可以知道Promise构造函数内的代码是同步执行的！<br>那么传入的两个回调函数是什么时候被执行的呢？其实就是在我们调用resolve(value)或reject(reason)的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// resolve(value);</span></span><br><span class="line">    reject(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们再看两个回调函数的内部逻辑，两者唯一的差别就是最后调用的函数不同，我们先看相同的部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">   done = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>done变量为true则直接退出函数，否则将done置为true，再执行下面代码。所以我们知道，done变量的作用就是为了防止resolve()和reject()被同时调用。因为Promise标准规定了，其状态只能从pending-&gt;fulfilled或pending-&gt;rejected。<br>再看不同部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve(self, value);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reject(self, reason);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个函数的参数是当前对象和我们传入的值，也就是我们所说的完成的值和拒绝的原因，由此我们可以预测，调用这两个函数会将Promsie的状态变为fulfilled或rejected。<br>最后看catch部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    reject(self, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其逻辑完全与try部分的第二个回调函数一样，其实就是说，调用Promsie构造函数如果抛出异常，则Promise就会变为rejected状态。<br>接下来分析resolve与reject函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">self, newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue === self)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;A promise cannot be resolved with itself.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            newValue &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">            <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            self._state = <span class="number">3</span>;</span><br><span class="line">            self._value = newValue;</span><br><span class="line">            finale(self);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            doResolve(bind(then, newValue), self);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        self._state = <span class="number">1</span>;</span><br><span class="line">        self._value = newValue;</span><br><span class="line">        finale(self);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(self, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个代码被try…catch包裹，先看只有一行代码的catch部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reject(self, e);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个resolve函数抛出异常，都会调用reject函数，所以我们也明白了，resolve后的状态不一定就是fulfilled，也可能是rejected，但reject后的状态一定是rejected。<br>再看try部分，我们先跳过前面二个条件判断，直接看最后的部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self._state = <span class="number">1</span>;</span><br><span class="line">   self._value = newValue;</span><br><span class="line">   finale(self);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_state属性赋值为1，前面讲过，1代表状态为fulfilled。_value保存了完成的值，最后将当前对象作为参数调用了finale函数。finale主要为then方法做准备的，与Promise构造函数关系不大，我们讲then方法时再分析。<br>然后是第一个条件检测：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newValue === self)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;A promise cannot be resolved with itself.&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>newValue是我们传入的完成的值，self是当前的Promise对象，也就是说，完成的值不能是当前对象本身。就是下面这种情况:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(promise);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用异步的原因是保证resolve(promise)时，promise已经被赋值。<br>第二个条件主要是处理特殊类型的完成值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>) ) &#123;</span><br><span class="line">        <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果newValue是对象或函数类型，就将其then属性保存在then变量中。</p>
<p>往下讲之前，我们需要知道一个概念：thenable类型，拥有then方法的对象或函数。这个定义其实是借鉴了鸭子类型：如果它看起来像一只鸭子，并且叫起来相一致鸭子，那么它一定是一只鸭子。为什么要提这个呢？因为我们需要判断一个值是否是纯粹的Promise对象，具体由来就不讲了，推荐大家去看《你不知道的JavaScript 中卷》。</p>
<p>知道thenable类型，我们就清楚下面的代码是做什么的了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    self._state = <span class="number">3</span>;</span><br><span class="line">    self._value = newValue;</span><br><span class="line">    finale(self);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么这个判断要先判断？因为Promise也有then方法，所以要先判断值是不是纯粹的Promise。以_state=3标记。再判断是否是thenable类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        doResolve(bind(then, newValue), self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中bind函数为Function.prototype.bind的polyfill：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, thisArg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(thisArg, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即将以newValue为this的函数和当前对象作为参数再次调用doResolve函数，这么做的原因，是如果Promise的完成的值是Promise或thenable类型，那么最终状态取决于Promise或thenable的状态。</p>
]]></content>
  </entry>
  <entry>
    <title>parseInt() 函数</title>
    <url>/2020/11/14/js/parseInt/</url>
    <content><![CDATA[<blockquote>
<p>parseInt(string, radix)函数可解析一个字符串，并返回一个整数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>param</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。要被解析的字符串。</td>
</tr>
<tr>
<td>radix</td>
<td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</td>
</tr>
</tbody></table>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回解析后的数字。<br>当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。<br>举例，如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。</p>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><p>只有字符串中的第一个数字会被返回。</p>
</li>
<li><p>开头和结尾的空格是允许的。</p>
</li>
<li><p>如果字符串的第一个字符不能被转换为数字，那么 parseInt() 会返回 NaN。</p>
</li>
<li><p> radix参数为n 将会把第一个参数看作是一个数的n进制表示，而返回的值则是十进制的。例如：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>, <span class="number">5</span>) </span><br><span class="line"><span class="comment">// 将&#x27;123&#x27;看作5进制数，返回十进制数38 =&amp;gt; 1*5^2 + 2*5^1 + 3*5^0 = 38</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下例子均返回15:</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0xF&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;F&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;17&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0</span>21, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;015&quot;</span>, <span class="number">10</span>);   <span class="comment">// parseInt(015, 10); 返回 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">15.99</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;15,123&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;FXX123&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1111&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;15 * 3&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;15e2&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;15px&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12&quot;</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下例子均返回 NaN:</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">8</span>); <span class="comment">// 根本就不是数值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;546&quot;</span>, <span class="number">2</span>);   <span class="comment">// 除了“0、1”外，其它数字都不是有效二进制数字</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下例子均返回 -15：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-F&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-0F&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-0XF&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(-<span class="number">15.1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot; -17&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot; -15&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-1111&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-15e1&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;-12&quot;</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下例中全部返回 4:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">4.7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">4.7</span> * <span class="number">1e22</span>, <span class="number">10</span>); <span class="comment">// 非常大的数值变成 4</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.00000000000434</span>, <span class="number">10</span>); <span class="comment">// 非常小的数值变成 4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的例子返回 224</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0e0&quot;</span>,<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<h2 id="没有指定-radix-参数时的八进制解析"><a href="#没有指定-radix-参数时的八进制解析" class="headerlink" title="没有指定 radix 参数时的八进制解析"></a>没有指定 radix 参数时的八进制解析</h2><p>尽管 ECMAScript 3 已经不赞成这种做法，且 ECMAScript 5 已经禁止了这种做法，但是仍然有很多实现环境仍然把以 0 开头的数值字符串（numeric string）解释为一个八进制数。下面的例子可能返回八进制的结果，也可能返回十进制的结果。总是指定一个基数（radix）可以避免这种不</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可靠的行为。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0e0&quot;</span>); </span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;08&quot;</span>); </span><br><span class="line"><span class="comment">// 0, &#x27;8&#x27; 不是八进制数字.&lt;span aria-hidden=&quot;true&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ECMAScript-5-移除了八进制解析"><a href="#ECMAScript-5-移除了八进制解析" class="headerlink" title="ECMAScript 5 移除了八进制解析"></a>ECMAScript 5 移除了八进制解析</h2><p>ECMAScript 5 规范不再允许parseInt函数的实现环境把以0字符开始的字符串作为八进制数值。ECMAScript 5 陈述如下：</p>
<blockquote>
<p>根据给定radix，parseInt函数产生一个由字符串参数内容解析过来的整数值。字符串中开头的空白会被忽略。如果radix没有指定或者为0，参数会被假定以10为基数来解析，如果数值以字符对0x或0X开头，会假定以16为基数来解析。</p>
</blockquote>
<p>这与ECMAScript 3有所不同，ECMAScript 3仅仅是不提倡这种做法但并没有禁止这种做法。<br>直至2013年，很多实现环境并没有采取新的规范所规定的做法, 而且由于必须兼容旧版的浏览器，所以永远都要明确给出radix参数的值.</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScipt中队列的实现</title>
    <url>/2020/11/14/js/queue/</url>
    <content><![CDATA[<blockquote>
<p>队列与栈是很相像的数据结构，不同之处在于队列是是先进先出(FIFO:First In First Out)的。</p>
</blockquote>
<ul><li>
队列需要有如下的方法:<ul><li>
enqueue(element(s)): 向队列尾部添加几个项</li><li>
dequeue(): 移除队列的第一项(也就是排在最前面的项)</li><li>
front(): 返回队列的第一个元素，也就是最新添加的那个</li><li><ul><li>
isAmpty: 检查队列是否为空，为空则返回true</li><li>
clear: 移除队列中所有元素</li><li>
size: 返回队列中元素个数。</li><li>
print: 以字符串显示队列中所有内容</li></ul></li></ul></li></ul>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 队列构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 队列构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用数组来模拟队列</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将元素推入队列</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>ele 要推入队列的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        items.push(ele);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将队列中第一个元素弹出</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>返回被弹出的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.shift()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查看队列的第一个元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>返回队列中第一个元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确定队列是否为空</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span> </span>若队列为空则返回true,不为空则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.isAmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length === <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回队列的长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>队列的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空队列中所有内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以字符串显示队列中所有内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 队列构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 击鼓传花的小游戏</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Array&#125;</span> </span>nameList 参与人员列表</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>num      在循环中要被弹出的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;String&#125;</span>          </span>返回赢家(也就是最后活下来的那个)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">            queue.enqueue(nameList[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> eliminated = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eliminated = queue.dequeue();</span><br><span class="line">        <span class="built_in">console</span>.log(eliminated + <span class="string">&quot; Get out!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue.dequeue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameList = [<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;小王&#x27;</span>, <span class="string">&#x27;小绿&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>正则表达式大全</title>
    <url>/2020/11/14/js/regex/</url>
    <content><![CDATA[<p><a href="https://c.runoob.com/front-end/854" target="_blank">测试工具</a><br></p></p>
<h2 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h2><ul><li>数字：<strong>^[0-9]*$</strong></li><li>n位的数字：<strong>^\\d{n}$</strong></li><li>至少n位的数字<strong>：^\\d{n,}$</strong></li><li>m-n位的数字：<strong>^\\d{m,n}$</strong></li><li>零和非零开头的数字：<strong>^(0|[1-9][0-9]*)$</strong></li><li>非零开头的最多带两位小数的数字：<strong>^([1-9][0-9]*)+(\\.[0-9]{1,2})?$</strong></li><li>带1-2位小数的正数或负数：<strong>^(\\-)?\\d+(\\.\\d{1,2})$</strong></li><li>正数、负数、和小数：<strong>^(\\-|\\+)?\\d+(\\.\\d+)?$</strong></li><li>有两位小数的正实数：<strong>^[0-9]+(\\.[0-9]{2})?$</strong></li><li>有1~3位小数的正实数：<strong>^[0-9]+(\\.[0-9]{1,3})?$</strong></li><li>非零的正整数：<strong>^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$</strong></li><li>非零的负整数：<strong>^\\-[1-9][]0-9"*$ 或 ^-[1-9]\\d*$</strong></li><li>非负整数：<strong>^\\d+$ 或 ^[1-9]\\d*|0$</strong></li><li>非正整数：<strong>^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$</strong></li><li>非负浮点数：<strong>^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$</strong></li><li>非正浮点数：<strong>^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$</strong></li><li>正浮点数：<strong>^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$</strong></li><li>负浮点数：<strong>^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</strong></li><li>浮点数：<strong>^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$</strong></li></ul><hr>

<h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<strong>^[\\u4e00-\\u9fa5]{0,}$</strong></li><li>英文和数字：<strong>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</strong></li><li>长度为3-20的所有字符：<strong>^.{3,20}$</strong></li><li>由26个英文字母组成的字符串：<strong>^[A-Za-z]+$</strong></li><li>由26个大写英文字母组成的字符串：<strong>^[A-Z]+$</strong></li><li>由26个小写英文字母组成的字符串：<strong>^[a-z]+$</strong></li><li>由数字和26个英文字母组成的字符串：<strong>^[A-Za-z0-9]+$</strong></li><li>由数字、26个英文字母或者下划线组成的字符串：<strong>^\\w+$ 或 ^\\w{3,20}$</strong></li><li>中文、英文、数字包括下划线：<strong>^[\\u4E00-\\u9FA5A-Za-z0-9_]+$</strong></li><li>中文、英文、数字但不包括下划线等符号：<strong>^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$</strong></li><li>可以输入含有^%&amp;',;=?$\\"等字符：<strong>[^%&amp;',;=?$\\x22]+</strong></li><li>禁止输入含有~的字符：<strong>[^~\\x22]+</strong></li></ul><hr>

<h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2><ul><li>Email地址：<strong>^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$</strong></li><li>域名：<strong>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</strong></li><li>InternetURL：<strong>[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$</strong></li><li>手机号码：<strong>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</strong></li><li>电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：<strong>^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$</strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong>\\d{3}-\\d{8}|\\d{4}-\\d{7}</strong></li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）:&nbsp;<strong>((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$)</strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：<strong>(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)</strong></li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</strong></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\\w{5,17}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</strong></li><li>日期格式：<strong>^\\d{4}-\\d{1,2}-\\d{1,2}</strong></li><li>一年的12个月(01～09和1～12)：<strong>^(0?[1-9]|1[0-2])$</strong></li><li>一个月的31天(01～09和1～31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：<strong>^[1-9][0-9]*$</strong></li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li><li>必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li><li>备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：<strong>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$</strong></li><li>中文字符的正则表达式：<strong>[\\u4e00-\\u9fa5]</strong></li><li>双字节字符：<strong>[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</strong></li><li>空白行的正则表达式：<strong>\\n\\s*\\r (可以用来删除空白行)</strong></li><li>HTML标记的正则表达式：<strong>&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</strong></li><li>腾讯QQ号：<strong>[1-9][0-9]{4,} (腾讯QQ号从10000开始)</strong></li><li>中国邮政编码：<strong>[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)</strong></li><li>IP地址：<strong>((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</strong></li></ul>


]]></content>
  </entry>
  <entry>
    <title>正则表达式基本语法</title>
    <url>/2020/11/14/js/regex2/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;^The&quot;</span>：表示所有以<span class="string">&quot;The&quot;</span>开始的字符串（<span class="string">&quot;There&quot;</span>，<span class="string">&quot;The cat&quot;</span>等）；</span><br><span class="line"><span class="string">&quot;of despair$&quot;</span>：表示所以以<span class="string">&quot;of despair&quot;</span>结尾的字符串；</span><br><span class="line"><span class="string">&quot;^abc$&quot;</span>：表示开始和结尾都是<span class="string">&quot;abc&quot;</span>的字符串——呵呵，只有<span class="string">&quot;abc&quot;</span>自己了；</span><br><span class="line"><span class="string">&quot;notice&quot;</span>：表示任何包含<span class="string">&quot;notice&quot;</span>的字符串。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;ab*&quot;</span>：表示一个字符串有一个a后面跟着零个或若干个b。</span><br><span class="line">（<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abbb&quot;</span>,……）；</span><br><span class="line"><span class="string">&quot;ab+&quot;</span>：表示一个字符串有一个a后面跟着至少一个b或者更多；</span><br><span class="line"><span class="string">&quot;ab?&quot;</span>：表示一个字符串有一个a后面跟着零个或者一个b；</span><br><span class="line"><span class="string">&quot;a?b+$&quot;</span>：表示在字符串的末尾有零个或一个a跟着一个或几个b。</span><br><span class="line"></span><br><span class="line">必须要指定下限</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;ab&#123;2&#125;&quot;</span>：表示一个字符串有一个a跟着<span class="number">2</span>个b（<span class="string">&quot;abb&quot;</span>）；</span><br><span class="line"><span class="string">&quot;ab&#123;2,&#125;&quot;</span>：表示一个字符串有一个a跟着至少<span class="number">2</span>个b；</span><br><span class="line"><span class="string">&quot;ab&#123;3,5&#125;&quot;</span>：表示一个字符串有一个a跟着<span class="number">3</span>到<span class="number">5</span>个b。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;hi|hello&quot;</span>：表示一个字符串里有<span class="string">&quot;hi&quot;</span>或者<span class="string">&quot;hello&quot;</span>；</span><br><span class="line"><span class="string">&quot;(b|cd)ef&quot;</span>：表示<span class="string">&quot;bef&quot;</span>或<span class="string">&quot;cdef&quot;</span>；</span><br><span class="line"><span class="string">&quot;(a|b)*c&quot;</span>：表示一串<span class="string">&quot;a&quot;</span><span class="string">&quot;b&quot;</span>混合的字符串后面跟一个<span class="string">&quot;c&quot;</span>；</span><br><span class="line"></span><br><span class="line">. 表示任意字符</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;a.[0-9]&quot;</span>：表示一个字符串有一个<span class="string">&quot;a&quot;</span>后面跟着一个任意字符和一个数字；</span><br><span class="line"><span class="string">&quot;^.&#123;3&#125;$&quot;</span>：表示有任意三个字符的字符串（长度为<span class="number">3</span>个字符）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方括号表示某些字符允许在一个字符串中的某一特定位置出现：</span><br><span class="line"><span class="string">&quot;[ab]&quot;</span>：表示一个字符串有一个<span class="string">&quot;a&quot;</span>或<span class="string">&quot;b&quot;</span>（相当于<span class="string">&quot;a¦b&quot;</span>）；</span><br><span class="line"><span class="string">&quot;[a-d]&quot;</span>：表示一个字符串包含小写的<span class="string">&#x27;a&#x27;</span>到<span class="string">&#x27;d&#x27;</span>中的一个（相当于<span class="string">&quot;a|b|c|d&quot;</span>或者<span class="string">&quot;[abcd]&quot;</span>）；</span><br><span class="line"><span class="string">&quot;^[a-zA-Z]&quot;</span>：表示一个以字母开头的字符串；</span><br><span class="line"><span class="string">&quot;[0-9]%&quot;</span>：表示一个百分号前有一位的数字；</span><br><span class="line"><span class="string">&quot;,[a-zA-Z0-9]$&quot;</span>：表示一个字符串以一个逗号后面跟着一个字母或数字结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>特殊字符    <a href="https://www.w3cschool.cn/tools/index?name=create_reg" target="_blank" style="font-size: 14px;">正则表达式在线生成工具</a>      <a href="https://www.w3cschool.cn/regexp/tfua1pq5.html" target="_blank" style="font-size: 14px;">W3C文档</a></h1><table cellspacing="1" cellpadding="3"><tbody><tr><td>字符</td><td>含意</td></tr><tr><td>\\</td><td>
做为转意，即通常在"\\"后面的字符不按原来意义解释，如/b/匹配字符"b"，当b前面加了反斜杆后/\\b/，转意为匹配一个单词的边界。 
-或- 
对正则表达式功能字符的还原，如"*"匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了"\\"后，/a\\*/将只匹配"a*"。</td></tr><tr><td>^</td><td>匹配一个输入或一行的开头，/^a/匹配"an A"，而不匹配"An a"</td></tr><tr><td>$</td><td>匹配一个输入或一行的结尾，/a$/匹配"An a"，而不匹配"an A"</td></tr><tr><td>*</td><td>匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa</td></tr><tr><td>+</td><td>匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa</td></tr><tr><td>?</td><td>匹配前面元字符0次或1次，/ba*/将匹配b,ba</td></tr><tr><td>(x)</td><td>匹配x保存x在名为$1...$9的变量中</td></tr><tr><td>x|y</td><td>匹配x或y</td></tr><tr><td>{n}</td><td>精确匹配n次</td></tr><tr><td>{n,}</td><td>匹配n次以上</td></tr><tr><td>{n,m}</td><td>匹配n-m次</td></tr><tr><td>[xyz]</td><td>字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</td></tr><tr><td>[^xyz]</td><td>不匹配这个集合中的任何一个字符</td></tr><tr><td>[\\b]</td><td>匹配一个退格符</td></tr><tr><td>\\b</td><td>匹配一个单词的边界</td></tr><tr><td>\\B</td><td>匹配一个单词的非边界</td></tr><tr><td>\\cX</td><td>X是一个控制符，/\\cM/匹配Ctrl-M</td></tr><tr><td>\\d</td><td>匹配一个字数字符，/\\d/ = /[0-9]/</td></tr><tr><td>\\D</td><td>匹配一个非字数字符，/\\D/ = /[^0-9]/</td></tr><tr><td>\
</td><td>匹配一个换行符</td></tr><tr><td>\\r</td><td>匹配一个回车符</td></tr><tr><td>\\s</td><td>匹配一个空白字符，包括\
,\\r,\\f,\\t,\\v等</td></tr><tr><td>\\S</td><td>匹配一个非空白字符，等于/[^\
    \\f\\r\\t\\v]/</td></tr><tr><td>\\t</td><td>匹配一个制表符</td></tr><tr><td>\\v</td><td>匹配一个重直制表符</td></tr><tr><td>\\w</td><td>匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配"$5.98"中的5，等于[a-zA-Z0-9]</td></tr><tr><td>\\W</td><td>匹配一个不可以组成单词的字符，如[\\W]匹配"$5.98"中的$，等于[^a-zA-Z0-9]。</td></tr></tbody></table><table width="100%" border="1"><tbody><tr><td>
    用re = new RegExp("pattern",["flags"]) 的方式比较好 
    pattern : 正则表达式 
    flags: g （全文查找出现的所有 pattern） 
    i （忽略大小写） 
    m （多行查找）</td><td>vaScript动态正则表达式问题
    请问正则表达式可以动态生成吗? 
    例如JavaScript中: 
    var str = "strTemp"; 
    要生成: 
    var re = /strTemp/; 
    如果是字符连接: 
    var re = "/" + str + "/"即可 
    但是要生成表达式,可以实现吗?怎样实现?</td><td> </td></tr></tbody></table>
]]></content>
  </entry>
  <entry>
    <title>各种排序实现</title>
    <url>/2020/11/14/js/sort/</url>
    <content><![CDATA[<blockquote>
<p>十大经典排序算法总结</p>
</blockquote>
<p> <a href="https://github.com/damonare/Sorts" target="_blank">详细图文解析 看这</a></p>
<h2 id="一、冒泡demo"><a href="#一、冒泡demo" class="headerlink" title="一、冒泡demo:"></a>一、冒泡demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，</span></span><br><span class="line"><span class="comment">//就好像气泡往上冒一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></span><br><span class="line">                [arr[j + <span class="number">1</span>], arr[j]] = [arr[j], arr[j + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1) 首先，在数组中选择一个中间项作为主元</span></span><br><span class="line"><span class="comment">// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，</span></span><br><span class="line"><span class="comment">// 然后交换它们。重复这个过程，直到左侧的指针超过了右侧的指针。</span></span><br><span class="line"><span class="comment">// 这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作</span></span><br><span class="line"><span class="comment">// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组，</span></span><br><span class="line"><span class="comment">// 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成</span></span><br></pre></td></tr></table></figure>
<h2 id="二、快排demo"><a href="#二、快排demo" class="headerlink" title="二、快排demo:"></a>二、快排demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> partitionIndex;</span><br><span class="line">    left = <span class="keyword">typeof</span> left !== <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left;</span><br><span class="line">    right = <span class="keyword">typeof</span> right !== <span class="string">&#x27;number&#x27;</span> ? len - <span class="number">1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;     <span class="comment">//分区操作</span></span><br><span class="line">    <span class="keyword">let</span> pivot = left;                      <span class="comment">//设定基准值（pivot）</span></span><br><span class="line">    <span class="keyword">let</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            [arr[i], arr[index]] = [arr[index], arr[i]];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[pivot], arr[index - <span class="number">1</span>]] = [arr[index - <span class="number">1</span>], arr[pivot]];</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)</span></span><br></pre></td></tr></table></figure>
<h2 id="三、选择demo"><a href="#三、选择demo" class="headerlink" title="三、选择demo:"></a>三、选择demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序：每次排一个数组项，假设数组的第一项已经排序，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，</span></span><br><span class="line"><span class="comment">// 第三项是该插入到第一项之前还是第一项之后还是第三项</span></span><br></pre></td></tr></table></figure>
<h2 id="四、插入demo"><a href="#四、插入demo" class="headerlink" title="四、插入demo:"></a>四、插入demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;amp;&amp;amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，</span></span><br></pre></td></tr></table></figure>
<p>而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)<br>// 归并排序是一种分治算法。<br>本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，<br>接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组</p>
<h2 id="五、归并demo"><a href="#五、归并demo" class="headerlink" title="五、归并demo:"></a>五、归并demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">len &lt; <span class="number">2</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">    left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;amp;&amp;amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(...left);</span><br><span class="line">    result.push(...right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序：堆排序把数组当中二叉树来排序而得名。</span></span><br><span class="line"><span class="comment">// 1）索引0是树的根节点；</span></span><br></pre></td></tr></table></figure>
<p>2）除根节点为，任意节点N的父节点是N/2；</p>
<p>3）节点L的左子节点是2*L；</p>
<p>4）节点R的右子节点为2*R + 1</p>
<p>// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，<br>然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个</p>
<h2 id="六、堆demo"><a href="#六、堆demo" class="headerlink" title="六、堆demo:"></a>六、堆demo:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len;    <span class="comment">//因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;   <span class="comment">//建立大顶堆</span></span><br><span class="line">    len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i</span>) </span>&#123;     <span class="comment">//堆调整</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;amp;&amp;amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;amp;&amp;amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">        [arr[i], arr[largest]] = [arr[largest], arr[i]];</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [arr[<span class="number">0</span>],arr[i]]=[arr[i],arr[<span class="number">0</span>]];</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、希尔排序"><a href="#七、希尔排序" class="headerlink" title="七、希尔排序:"></a>七、希尔排序:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;希尔排序耗时:&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">gap &lt; len<span class="regexp">/5) &#123;          /</span><span class="regexp">/动态定义间隔序列</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        gap =gap*5+1;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    for (gap; gap &gt; 0; gap = Math.floor(gap/</span><span class="number">5</span></span>)</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;amp;&amp;amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;希尔排序耗时:&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序:"></a>八、计数排序:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = array.length,</span><br><span class="line">        B = [],</span><br><span class="line">        C = [],</span><br><span class="line">        min = max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;计数排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">        max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</span><br><span class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</span><br><span class="line">        C[array[k]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;计数排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(countingSort(arr));</span><br><span class="line">    <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></span><br></pre></td></tr></table></figure>
<h2 id="九、桶排序"><a href="#九、桶排序" class="headerlink" title="九、桶排序:"></a>九、桶排序:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*方法说明：桶排序</span></span><br><span class="line"><span class="comment">@param  array 数组</span></span><br><span class="line"><span class="comment">@param  num   桶的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [],</span><br><span class="line">    min = max = array[<span class="number">0</span>], regex = <span class="string">&#x27;/^[1-9]+[0-9]*$/&#x27;</span>, space, n = <span class="number">0</span>;</span><br><span class="line">        num = num || ((num &gt; <span class="number">1</span> &amp;amp;&amp;amp; regex.test(num)) ? num : <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">&#x27;桶排序耗时&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">            max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        space = (max - min + <span class="number">1</span>) / num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</span><br><span class="line">            <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></span><br><span class="line">                <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;amp;&amp;amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class="line">                    buckets[index][k + <span class="number">1</span>] = buckets[index][k];</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></span><br><span class="line">                buckets[index] = [];</span><br><span class="line">                buckets[index].push(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; num) &#123;</span><br><span class="line">            result = result.concat(buckets[n]);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;桶排序耗时&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<h2 id="十、基数排序"><a href="#十、基数排序" class="headerlink" title="十、基数排序:"></a>十、基数排序:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基数排序适用于：</span></span><br><span class="line"><span class="comment">    *  (1)数据范围较小，建议在小于1000</span></span><br><span class="line"><span class="comment">    *  (2)每个数值都要大于等于0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author <span class="variable">xiazdong</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  </span>arr 待排序数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  </span>maxDigit 最大位数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//LSD Radix Sort</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> counter = [];</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;基数排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">counter[bucket]== <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">        counter[bucket].push(arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">counter[j]!=<span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;基数排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>));</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JavaScipt中栈的实现</title>
    <url>/2020/11/14/js/stack/</url>
    <content><![CDATA[<blockquote>
<p>栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。</p>
</blockquote>
<p>栈需要有如下的方法:</p>
<ul><li>
push(element(s)): 添加几个元素到栈顶</li><li>
pop(): 移除并返回栈顶元素</li><li>
peek(): 返回栈顶元素</li><li>
isAmpty: 检查栈是否为空，为空则返回true</li><li>
clear: 移除栈中所有元素</li><li>
size: 返回栈中元素个数。</li><li>
print: 以字符串显示栈中所有内容</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 栈的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用数组来模拟栈</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将元素送入栈，放置于数组的最后一位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;Any&#125;</span> </span>element 接受的元素，不限制类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        items.push(element);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>返回被弹出的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查看栈顶元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Any&#125;</span> </span>返回栈顶元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确定栈是否为空</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span> </span>若栈为空则返回true,不为空则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.isAmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length === <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空栈中所有内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回栈的长度</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return <span class="type">&#123;Number&#125;</span> </span>栈的长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以字符串显示栈中所有内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将10进制数字转为2进制数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>decNumber 要转换的10进制数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;Number&#125;</span>           </span>转换后的2进制数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divideBy2</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> remStack = <span class="keyword">new</span> Stack(),</span><br><span class="line">    rem,</span><br><span class="line">    binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rem = <span class="built_in">Math</span>.floor(decNumber % <span class="number">2</span>);</span><br><span class="line">        remStack.push(rem);</span><br><span class="line">        decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!remStack.isAmpty()) &#123;</span><br><span class="line">        binaryString += remStack.pop().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>toString方法和valueOf方法以及Symbol.toPrimitive</title>
    <url>/2020/11/14/js/tostring/</url>
    <content><![CDATA[<blockquote>
<p>每个对象都有一个toString()方法和valueOf方法，其中toString()方法返回一个表示该对象的字符串，valueOf方法返回该对象的原始值。</p>
</blockquote>
<h2 id="对于值类型数据-又叫基本类型-场景下，toString及valueOf方法的使用"><a href="#对于值类型数据-又叫基本类型-场景下，toString及valueOf方法的使用" class="headerlink" title="对于值类型数据(又叫基本类型)场景下，toString及valueOf方法的使用"></a>对于值类型数据(又叫基本类型)场景下，toString及valueOf方法的使用</h2><p>toString方法对于值类型数据使用而言，其效果相当于类型转换，将原类型转为字符串。</p>
<p>valueOf方法对于值类型数据使用而言，其效果将相当于返回原数据。 </p>
<h2 id="复合对象类型数据使用toString及valueOf方法"><a href="#复合对象类型数据使用toString及valueOf方法" class="headerlink" title="复合对象类型数据使用toString及valueOf方法"></a>复合对象类型数据使用toString及valueOf方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123; </span><br><span class="line">    i: <span class="number">10</span>, </span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.i; </span><br><span class="line">    &#125;, </span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;valueOf&#x27;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.i; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">alert(test);<span class="comment">// 10 toString </span></span><br><span class="line">alert(+test); <span class="comment">// 10 valueOf </span></span><br><span class="line">alert(<span class="string">&#x27;&#x27;</span>+test); <span class="comment">// 10 valueOf </span></span><br><span class="line">alert(<span class="built_in">String</span>(test)); <span class="comment">// 10 toString </span></span><br><span class="line">alert(<span class="built_in">Number</span>(test)); <span class="comment">// 10 valueOf </span></span><br><span class="line">alert(test == <span class="string">&#x27;10&#x27;</span>); <span class="comment">// true valueOf </span></span><br><span class="line">alert(test === <span class="string">&#x27;10&#x27;</span>); <span class="comment">// false  不会隐式转换</span></span><br></pre></td></tr></table></figure>
<p>总结： </p>
<ul>
<li>在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。</li>
<li>在有运算操作符的情况下，valueOf的优先级高于toString。</li>
</ul>
<p>这两个方法一般是交由js去隐式调用，以满足不同的运算情况。 </p>
<blockquote>
<p>在数值运算里，会优先调用valueOf()，如 a + b; </p>
</blockquote>
<blockquote>
<p>在字符串运算里，会优先调用toString(),如alert(c).</p>
</blockquote>
<p>null和undefined不是伪对象,null和undefined调用toString()方法会报错</p>
<p>但是String()可以将null和undefined转换为字符串</p>
<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p>对象的Symbol.toPrimitive属性。这是定义在Symbol对象上的一个属性,ES6把这个属性暴露出来，可以在对象上自定义。该对象被转化为原始类型的值时，<code>会调用这个办法，返回该对象对应的原始类型值。</code></p>
<p>Symbol.toPrimitive被调用时,会接受一个字符串参数，表示当前运算的模式，有三种模式。</p>
<ul>
<li>number:该场合需要转成数值</li>
<li>string:该场合需要转成字符串</li>
<li>default:该场合可以转成数值，也可以转成字符串。</li>
</ul>
<p>当对象发生到基本类型值的转换时，会按照下面的逻辑调用对象上的方法：</p>
<ul>
<li><p>如果存在，调用 <code>obj[Symbol.toPrimitive](hint)</code>；</p>
</li>
<li><p>否则，如果 hint 取值是 “string”：</p>
<p>无论是否存在，调用 obj.toString() 和 obj.valueOf()。</p>
</li>
<li><p>否则（也就是 hint 取值是 “number” 或 “default” 的情况）：<br>无论是否存在，调用 obj.valueOf() 和 obj.toString()。</p>
</li>
</ul>
<h3 id="确定-hint"><a href="#确定-hint" class="headerlink" title="确定 hint"></a>确定 hint</h3><p>我们提到了 ToPrimitive 算法中用到的 hint 参数，那怎样确定一次运算场景下的 hint 取值是什么呢？很简单—-新建一个对象，打印各个运算场景下的 hint 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hint: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user) <span class="comment">// hint: string </span></span><br><span class="line"><span class="number">2</span>*user <span class="comment">// hint: number</span></span><br><span class="line">+user <span class="comment">// hint: number</span></span><br><span class="line">user + <span class="number">500</span> <span class="comment">// hint: default</span></span><br><span class="line"><span class="built_in">String</span>(user) <span class="comment">// hint: string</span></span><br></pre></td></tr></table></figure>


<p>注意：</p>
<ul>
<li>Symbol.toPrimitive 和 toString 方法的返回值必须是基本类型值。</li>
<li>valueOf 方法除了可以返回基本类型值，也可以返回其他类型值。</li>
</ul>
<p>当我们创建一个普通对象时（{} 或 new Object() 的方式等），对象上是不具备 [Symbol.toPrimitive] （方法）属性的。所以，对于普通对象的到基本类型值的运算，一般按照具体场景：</p>
<blockquote>
<p>hint 值为 “string” 时，先调用 toString，toString 如果返回一个基本类型值了，则返回、终止运算；否则接着调用 valueOf 方法。</p>
</blockquote>
<blockquote>
<p>否则，先调用 valueOf，valueOf 如果返回一个基本类型值了，则返回、终止运算；否则接着调用 toString 方法。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>new 命令</title>
    <url>/2020/11/14/js/video-demuxing-muxing/</url>
    <content><![CDATA[<blockquote>
<p>Mux 是 Multiplex 的缩写，意为“多路传输”，其实就是“混流”、“封装”的意思，与“合成”的意思相似就是指把视频素材和音频素材封装到一个单独的文件中。</p>
</blockquote>
<p>muxing 是在mux 后面加了 -ing 构成的动名词形式。<br>Demux是在 mux 前面加了个表示否定的 De- 前缀，意思是进行与 muxing 相反的“分解复用”操作，也就是我们平时说的“分离”一个文件中的视频部分或是音频部分。<br>同样，也可以在 demux 后面加 -ing 构成动名词 demuxing。<br>意义：<br>通过 muxing（混流），可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，作为一个信号进行传输，等传输完毕，就可以通过 demuxing（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。<br>要点：<br>在 muxing 与 demuxing 的整个过程，都不对原来的视频、音频或字幕重新编码。混流（封装、打包）后的文件，可以通过分离（分解、解包）操作，获得与原始素材一模一样的独立的视频、音频和字幕文件。</p>
<p>视频的分离与合成，编码和解码</p>
<p>对媒体流的处理分为两种：“编码（encoding）”和“解码（decoding）”。编码指的是通过一定协议或规则把一段声音或图像转化成计算机数字文件的过程。而解码恰恰是编码的反面——把编码过的媒体文件重新转化成声音或图像。</p>
<p>用来执行编码工作的软件叫“编码器”（Coder 或 Encoder）;<br>用来执行解码工作的软件叫“解码器”（Decoder）<br>“编码器”与“解码器”合称“编解码器”（“Codec”）。</p>
<p>声音与图像是两种不同的媒体，它们分别对应人的两种不同感官。作为不同的媒体，我们只能用专门针对声音的软件或是专门针对视频的软件去分别分析处理音频流（Audio Stream）与视频流（Video Stream）。</p>
<p>用来编码音频流的软件叫作“音频编码器”（Audio Encoder）<br>用来编码视频流的软件叫作“视频编码器”（Video Encoder）</p>
<p>音频流与视频流的处理必须分别进行，即：<br>“音频编码器”编码出单个音频文件，<br>“视频编码器”编码出单个视频文件，<br>“音频解码器”单独对音频文件进行解码还原，<br>“视频解码器”单独对视频文件进行解码还原。</p>
<p>既然音频处理和视频处理必须单独运行，那为什么我们平时看的RMVB、AVI格式的电影都是既包含声音又包含图像的单个文件呢？那是因为我们在通过摄像机获得单独的音频流和视频流后不仅对它们进行了“编码”，还对它们进行了“合成”（Synthesis）。通过合成，音频与视频就打包到一起，生成一个单独的文件。可以说，所有既有声音又有图像的视频文件，100%都是通过某种合成器（Synthesizer）合成过的。（注意：“合成”与“合并”不同，见最后的参考帖子。）</p>
<p>然而必须知道的是：尽管通过合成器可以把音频流和视频流打包成一个文件，但是正如人的眼睛不可能听、人的耳朵不可能看，音频流和视频流是不可能完全地混杂到一起的，是注定“分离”的。因此，所谓“合成”，只是把音频流和视频流用一个容器文件（Container）封装起来，其实里面还是各自独立的。我们在播放视频文件的时候总是先调用分离器（Splitter），将封装合成的视频“分离”成独立的音频和视频码流，然后才调用解码器对这些独立的音频流和视频流进行解码输出。</p>
<p>举个例子应该比较好懂一些：</p>
<p>比如我们有一个音频文件 Sample.mp2 和一个视频文件 Sample.m1v，用编码软件如小日本4通过 MPEG-1 编码方式合成为一个独立文件 Sample.mpg，然后把这个.mpg文件拿到媒体播放器里面播放，直接就可以听到声音看到画面。表面上看播放器只是简单地“播放”了这个文件，实际上这个“播放”包含了更多我们看不到的步骤。这个步骤是这样的：</p>
<p>播放器打开视频源文件<br>播放器调用分离器将视频文件分解为单独的音频流和视频流<br>播放器调用音频解码器对音频流进行解码，同时调用视频解码器对视频流进行解码<br>播放器依据同样的时间线将解码后的音频流和视频流输出到播放窗口并使之保持同步。</p>
<p>我们经常听到滤镜（Filter）的名称，实际上就是指的各种分离器或解码器。</p>
<p>Filter（滤镜）</p>
<p>什么是HDTV”中已经描述了HDTV的几个要素，相应地，要播放HDTV，就首先要正确地解开封装，然后进行视频音频解码。所以我们需要分离器，视频解码器和音频解码器，俗称HDTV的“三件套”，又统称滤镜。</p>
<p>一、分离器：<br>要正确地播放多媒体文件，首先是正确地调用分离器，把视频轨和音频轨分离出来。分离器相应分为三大类。<br>1、MPEG2 TS分离器:<br>月光（全称Moonlight-Elecard MPEG2 Demultiplexer），兼容性非常好，是首选的MPEG2分离器。<br>Gabest（就是Mpeg Splitter），MPC的作者Gabest编写的分离器。<br>NVIDIA Transport Demux（nVidia自家的分离器），是PureVideo家族成员之一，只能配合自家族的视频音频解码器，配合N卡比较好。<br>2、H264的分离器:<br>常见的有Gabest MP4分离器，就是MP4splitter，也是Gabest编写的，Halli的分离器和NDigital分离器等。<br>3、HD-WMV的分离器:<br>微软封闭技术，WMP9以上都自带了，XP用户都不需要装。</p>
<p>二、视频解码器</p>
<p>各大公司不断研发新版本，提升画质，改善兼容性，加强显卡硬件加速作用。</p>
<p>1、MPEG2视频解码器:</p>
<p>winDVD的视频解码器InterVideo Video Decoder。</p>
<p>PowerDVD的MPEG2视频解码器，有CyberLink DTV Video/SP Filter和CyberLink Video/SP Filter<br>月光视频解码器，Moonlight-Elecard MPEG2 Video Decoder为3.X版本和4.0X版本，名为Elecard MPEG-2 Video Decoder。</p>
<p>低端电脑推荐使用Sonic CinemasterVideo，画质一般，强项是能打开硬件加速。</p>
<p>PureVideo家族中的MPEG2视频解码器NVIDIA Video Decoder，只能用于N卡6、7系列的显卡上。</p>
<p>Dscaler5以上所说的PowerDVD、WinDVD、月光、Sonic等的视频解码器都可以打开显卡硬件加速，降低CPU的负担。</p>
<p>2、H264的视频解码器：</p>
<p>CoreAVC的H264视频解码器CoreAVC DirectShow Video Decoder。</p>
<p>月光的H264解码器，全称为Moonlight H264 Video Decoder，ffdshow的解码器，全称为ffdshow MPEG-4 Video Decoder，能打开N卡显卡硬件加速的CyberLink H.264/AVC Decoder(PDVD7)。</p>
<p>3、HD-WMV</p>
<p>只能用上微软自家的解码器，N卡6、7系以上能打开加速。</p>
<p>HDTV视频解码cpu占用很高，目前最强的cpu也难以完成，而且cpu作为通用处理器，用于视频解码则效率很低，所以HDTV播放的关键是显示卡的解码加速。视频解码器能否支持显示卡硬件加速，是能否播放HDTV的关键。</p>
<p>三、音频解码器：<br>ffdsshow，月光音频解码器、WinDVD的音频解码器、PowerDVD的音频解码器、AC3Filter音频解码器。</p>
<p>如果播放HDTV时碰到有声无画或者有画无声，就应该自己从解码器着手，替换一个试试。</p>
]]></content>
  </entry>
  <entry>
    <title>TypeScript 3.7、TypeScript 3.8 Beta</title>
    <url>/2020/11/14/js/ts-3.7/</url>
    <content><![CDATA[<p>原文链接： <a href="https://link.zhihu.com/?target=http%3A//www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" target="_blank" rel="nofollow noreferrer">TypeScript 3.7</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/90871356?from_voters_page=true" target="_blank">翻译地址</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1575422" target="_blank">TypeScript 3.8 Beta</a></p>
<h2 id="1、可选链-2、空值联合"><a href="#1、可选链-2、空值联合" class="headerlink" title="1、可选链## 2、空值联合"></a><ul><li>1、可选链</li></ul>## <ul><li>2、空值联合</li></ul></h2><pre><code>&lt;a href=&quot;https://www.webq.top/article/926&quot; target=&quot;_blank&quot; style=&quot;font-size: 14px;&quot;&gt;参照上文：es2020&lt;/a&gt;</code></pre>
<h2 id="3、断言函数"><a href="#3、断言函数" class="headerlink" title="3、断言函数"></a><ul><li>3、断言函数</li></ul></h2><p><span style="font-weight: normal;">      <span style="font-size: large;">它们是一些特殊函数的集合。当一些非预期的事情发生的时候它们将抛出 error。它们被称为断言函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">val: any</span>): <span class="title">val</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yell</span>(<span class="params">str: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isString(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.toUppercase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Oops!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul><li>4、对返回never的函数更好的支持</li></ul>



<ul><li>5、（更多）递归类型别名</li></ul>



<ul><li>6、--declaration和--allowJs</li></ul>



<ul><li>
7、useDefineForClassFields标志和declare属性修饰符</li></ul>

<ul><li>8、基于项目引用的免构建编辑</li></ul>

</li><li>9、未调用函数检查</li></ul>

<ul><li>10、TypeScript 文件中的// @ts-nocheck</li></ul>

<ul><li>11、关于分号的格式化选项</li></ul>

<ul><li>12、3.7 中破坏性的改动</li><ul><li>DOM 类型库的更新</li><li>类字段</li><li>函数存在性检查</li><li>本地和导入的类型声明发生冲突</li><li>API 变动</li></ul></ul>]]></content>
  </entry>
  <entry>
    <title>TS声明文件</title>
    <url>/2020/11/14/js/ts-dts/</url>
    <content><![CDATA[<blockquote>
<p>当使用外部JavaScript库或新的宿主API时，需要一个自定义声明文件（.d.ts）</p>
</blockquote>
<p><a href="https://www.tslang.cn/docs/handbook/writing-declaration-files.html" target="_blank">原文地址</a></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>最好从程序库的文档而不是代码开始写.d.ts文件。 这样保证不会被具体实现所干扰，而且相比于JS代码更易读。 下面的例子会假设你正在参照文档写声明文件。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>当定义接口（例如：“options”对象），你会选择是否将这些类型放进命名空间里。 这主要是靠主观判断 – 如果使用的人主要是用这些类型来声明变量和参数，并且类型命名不会引起命名冲突，则放在全局命名空间里更好。 如果类型不是被直接使用，或者没法起一个唯一的名字的话，就使用命名空间来避免与其它类型发生冲突。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>许多JavaScript库接收一个函数做为参数，之后传入已知的参数来调用它。 当用这些类型为函数签名的时候，不要把这些参数标记成可选参数。 正确的思考方式是“(调用者)会提供什么样的参数？”，不是“(函数)会使用到什么样的参数？”。</p>
<p> TypeScript 0.9.7+不会强制这种可选参数的使用，参数可选的双向协变可以被外部的linter强制执行。</p>
<h2 id="扩展与声明合并"><a href="#扩展与声明合并" class="headerlink" title="扩展与声明合并"></a>扩展与声明合并</h2><p>写声明文件的时候，要记住TypeScript扩展现有对象的方式。 你可以选择用匿名类型或接口类型的方式声明一个变量：### 匿名类型var</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare <span class="keyword">let</span> MyPoint: &#123; <span class="attr">x</span>: number; y: number; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="接口类型var"><a href="#接口类型var" class="headerlink" title="接口类型var"></a>接口类型var</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SomePoint &#123; <span class="attr">x</span>: number; y: number; &#125;</span><br><span class="line">declare <span class="keyword">let</span> MyPoint: SomePoint;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从使用者角度来讲，它们是相同的，但是SomePoint类型能够通过接口合并来扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SomePoint &#123; <span class="attr">z</span>: number; &#125;</span><br><span class="line">MyPoint.z = <span class="number">4</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否想让你的声明是可扩展的取决于主观判断。 通常来讲，尽量符合library的意图。</p>
<h2 id="类的分解"><a href="#类的分解" class="headerlink" title="类的分解"></a>类的分解</h2><p>TypeScript的类会创建出两个类型：实例类型，定义了类型的实例具有哪些成员；构造函数类型，定义了类构造函数具有哪些类型。 构造函数类型也被称做类的静态部分类型，因为它包含了类的静态成员。</p>
<p>你可以使用typeof关键字来拿到类静态部分类型，在写声明文件时，想要把类明确的分解成实例类型和静态类型时是有用且必要的。</p>
<p>下面是一个例子，从使用者的角度来看，这两个声明是等同的：### 标准版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> st: string;</span><br><span class="line">    inst: number;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">m: any</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分解版"><a href="#分解版" class="headerlink" title="分解版"></a>分解版</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface A_Static &#123;</span><br><span class="line">    <span class="keyword">new</span>(m: any): A_Instance;</span><br><span class="line">    st: string;</span><br><span class="line">&#125;</span><br><span class="line">interface A_Instance &#123;</span><br><span class="line">    inst: number;</span><br><span class="line">&#125;</span><br><span class="line">declare <span class="keyword">let</span> A: A_Static;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的利弊如下：<ul><li>标准方式可以使用extends来继承；分解的类不能。也可能会在未来版本的TypeScript里做出改变：是否允许任意extends表达式</li><li>都允许之后为类添加静态成员(通过合并声明的方式)</li><li>分解的类允许增加实例成员，标准版不允许</li><li>使用分解类的时候，需要为多类型成员起合理的名字</li></ul>## 命名规则<br>一般来讲，不要给接口加I前缀（比如：IColor）。 因为TypeScript的接口类型概念比C#或Java里的意义更为广泛，IFoo命名不利于这个特点。## 例子<br>下面进行例子部分。对于每个例子，首先使用应用示例，然后是类型声明。 如果有多个好的声明表示方法，会列出多个。## 参数对象### 应用示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">animalFactory.create(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">animalFactory.create(<span class="string">&quot;giraffe&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;ronald&quot;</span> &#125;);</span><br><span class="line">animalFactory.create(<span class="string">&quot;panda&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;bob&quot;</span>, <span class="attr">height</span>: <span class="number">400</span> &#125;);</span><br><span class="line"><span class="comment">// Invalid: name must be provided if options is given</span></span><br><span class="line">animalFactory.create(<span class="string">&quot;cat&quot;</span>, &#123; <span class="attr">height</span>: <span class="number">32</span> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">namespace animalFactory &#123;</span><br><span class="line">    interface AnimalOptions &#123;</span><br><span class="line">        name: string;</span><br><span class="line">        height?: number;</span><br><span class="line">        weight?: number;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">name: string, animalOptions?: AnimalOptions</span>): <span class="title">Animal</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="带属性的函数-应用示例"><a href="#带属性的函数-应用示例" class="headerlink" title="带属性的函数### 应用示例"></a>带属性的函数### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">zooKeeper.workSchedule = <span class="string">&quot;morning&quot;</span>;</span><br><span class="line">zooKeeper(giraffeCage);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-1"><a href="#类型声明-1" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note: Function must precede namespace</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zooKeeper</span>(<span class="params">cage: AnimalCage</span>)</span>;</span><br><span class="line">namespace zooKeeper &#123;</span><br><span class="line">    <span class="keyword">let</span> workSchedule: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="可以用new调用也可以直接调用的方法-应用示例"><a href="#可以用new调用也可以直接调用的方法-应用示例" class="headerlink" title="可以用new调用也可以直接调用的方法### 应用示例"></a>可以用new调用也可以直接调用的方法### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> w = widget(<span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> widget(<span class="string">&quot;sprocket&quot;</span>);</span><br><span class="line"><span class="comment">// w and y are both widgets</span></span><br><span class="line">w.sprock();</span><br><span class="line">y.sprock();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-2"><a href="#类型声明-2" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Widget &#123;</span><br><span class="line">    sprock(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface WidgetFactory &#123;</span><br><span class="line">    <span class="keyword">new</span>(name: string): Widget;</span><br><span class="line">    (width: number, <span class="attr">height</span>: number): Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">let</span> widget: WidgetFactory;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="全局或外部的未知代码库-应用示例"><a href="#全局或外部的未知代码库-应用示例" class="headerlink" title="全局或外部的未知代码库### 应用示例"></a>全局或外部的未知代码库### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Either</span></span><br><span class="line"><span class="keyword">import</span> x = <span class="built_in">require</span>(<span class="string">&#x27;zoo&#x27;</span>);</span><br><span class="line">x.open();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">zoo.open();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-3"><a href="#类型声明-3" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare namespace zoo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&quot;zoo&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> = zoo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模块里的单一复杂对象-应用示例"><a href="#模块里的单一复杂对象-应用示例" class="headerlink" title="模块里的单一复杂对象### 应用示例"></a>模块里的单一复杂对象### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Super-chainable library for eagles</span></span><br><span class="line"><span class="keyword">import</span> Eagle = <span class="built_in">require</span>(<span class="string">&#x27;./eagle&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call directly</span></span><br><span class="line">Eagle(<span class="string">&#x27;bald&#x27;</span>).fly();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke with new</span></span><br><span class="line"><span class="keyword">var</span> eddie = <span class="keyword">new</span> Eagle(<span class="string">&#x27;Mille&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set properties</span></span><br><span class="line">eddie.kind = <span class="string">&#x27;golden&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-4"><a href="#类型声明-4" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Eagle &#123;</span><br><span class="line">    (kind: string): Eagle;</span><br><span class="line">    <span class="keyword">new</span> (kind: string): Eagle;</span><br><span class="line"></span><br><span class="line">    kind: string;</span><br><span class="line">    fly(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> Eagle: Eagle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = Eagle;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将模块做为函数-应用示例"><a href="#将模块做为函数-应用示例" class="headerlink" title="将模块做为函数### 应用示例"></a>将模块做为函数### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Common pattern for node modules (e.g. rimraf, debug, request, etc.)</span></span><br><span class="line"><span class="keyword">import</span> sayHello = <span class="built_in">require</span>(<span class="string">&#x27;say-hello&#x27;</span>);</span><br><span class="line">sayHello(<span class="string">&#x27;Travis&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-5"><a href="#类型声明-5" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;say-hello&#x27;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name: string</span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">export</span> = sayHello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="回调函数-应用示例"><a href="#回调函数-应用示例" class="headerlink" title="回调函数### 应用示例"></a>回调函数### 应用示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addLater(<span class="number">3</span>, <span class="number">4</span>, <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型声明-6"><a href="#类型声明-6" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note: &#x27;void&#x27; return type is preferred here</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLater</span>(<span class="params">x: number, y: number, (sum: number) =&gt; <span class="keyword">void</span></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>centos7 常用命令【systemctl替换service】</title>
    <url>/2020/11/14/linux/centos-cmd/</url>
    <content><![CDATA[<p>centos7 上面启动服务以及关闭服务已经不是以前的service stop/start xxxx了</p>
<p>而是systemctl命令，不过用service他会有一个提醒你用systemctl”,</p>
<ul>
<li>“content”: ‘ ‘ 看所有网卡IP地址——ip addr</li>
<li>启动防火墙——systemctl start firewalld.service</li>
<li>停止防火墙——systemctl stop firewalld.service</li>
<li>查看firewalld防火墙状态——firewall-cmd –state</li>
<li>禁止防火墙开机启动——systemctl disable firewalld.service</li>
<li>列出正在运行的服务状态——systemctl</li>
<li>启动一个服务—— systemctl start postfix.service</li>
<li>关闭一个服务—— systemctl stop postfix.servic</li>
<li>重启一个服务：—— systemctl restart postfix.service</li>
<li>显示一个服务的状态—— systemctl status postfix.service</li>
<li>在开机时启用一个服务—— systemctl enable postfix.service</li>
<li>在开机时禁用一个服务—— systemctl disable postfix.service</li>
<li>查看服务是否开机启动—— systemctl is-enabled postfix.service;echo $?</li>
<li>查看已启动的服务列表—— systemctl list-unit-files|grep enabled</li>
<li>设置系统默认启动运行级别3—— ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target</li>
<li>设置系统默认启动运行级别5—— ln -sf/lib/systemd/system/graphical.target/etc/systemd/system/default.target</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>centos7 常用命令【systemctl替换service】</title>
    <url>/2020/11/14/linux/crontab-1/</url>
    <content><![CDATA[<blockquote>
<p>service crond status</p>
</blockquote>
<p>1、先手动执行定时任务以此来判断脚本是否有问题。</p>
<p>2、确认服务器是否开启定时任务计划服务</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service crond status</span><br><span class="line"></span><br><span class="line">service crond start</span><br></pre></td></tr></table></figure>

<p>3、查看crontab执行记录</p>
<p>如果出现了crontab定时任务不执行的情况，首先需要定位问题，那么就需要通过日志来确定问题所在。</p>
<p>crontab的日志位置一般位于/var/log/cron，利用下面的语句即可查看日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/cron</span><br></pre></td></tr></table></figure>
<p>上面的/var/log/cron只会记录是否执行了某些计划的脚本，但是具体执行是否正确以及脚本执行过程中的一些信息linux</p>
<p>会通过邮件形式发送到给该用户。对于root用户该邮件记录位于/var/spool/mail/root，通过以下命令可以查看最近的crontab执行情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f /var/spool/mail/root</span><br></pre></td></tr></table></figure>
<p>mail邮件一般只会记录脚本执行成功与否，如果执行失败，无法给出进一步的错误信息，这时需要我们将语句执行的错误信息</p>
<p>重定向至文件中，这样可以很方便的查看错误信息</p>
]]></content>
  </entry>
  <entry>
    <title>Linux定时任务 + mongodb自动备份</title>
    <url>/2020/11/14/linux/crontab-mongo/</url>
    <content><![CDATA[<blockquote>
<p>mongodump -d k-blog -c articles -o ./</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/0f1e009beb84" target="_blank">原文地址</a></p>
<p><a href="https://brickyang.github.io/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/" target="_blank">Linux 自动定时备份 MongoDB</a></p>
<h2 id="mongodb自动整库备份脚本"><a href="#mongodb自动整库备份脚本" class="headerlink" title="mongodb自动整库备份脚本"></a>mongodb自动整库备份脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">DB_HOST=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">DB_NAME=<span class="string">&quot;node_user&quot;</span></span><br><span class="line"></span><br><span class="line">OUT_DIR=<span class="string">&quot;/data/backup/mongod_bak/mongod_bak_now&quot;</span> <span class="comment">#临时备份目录</span></span><br><span class="line"></span><br><span class="line">TAR_DIR=<span class="string">&quot;/data/backup/mongod_bak/mongod_bak_list&quot;</span> <span class="comment">#备份存放路径</span></span><br><span class="line"></span><br><span class="line">DATE=$(date +%Y_%m_%d) <span class="comment">#获取当前系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----当前时间为<span class="variable">$DATE</span>-----&quot;</span></span><br><span class="line"></span><br><span class="line">DAYS=7 <span class="comment">#DAYS=7代表删除7天前的备份，即只保留最近7天的备份</span></span><br><span class="line"></span><br><span class="line">TAR_BAK=<span class="string">&quot;mongod_bak_<span class="variable">$DATE</span>.tar.gz&quot;</span> <span class="comment">#最终保存的数据库备份文件名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OUT_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----删除原有备份文件-----&quot;</span></span><br><span class="line"></span><br><span class="line">find <span class="variable">$OUT_DIR</span>/ -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">rm -rf <span class="variable">$OUT_DIR</span>/*</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----开始备份全部数据库-----&quot;</span></span><br><span class="line"></span><br><span class="line">mongodump -h <span class="variable">$DB_HOST</span> -o <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span> <span class="comment">#备份全部数据库，具体可以参照：  mongodump --help</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----开始压缩备份文件-----&quot;</span></span><br><span class="line"></span><br><span class="line">tar -zcvf <span class="variable">$TAR_DIR</span>/<span class="variable">$TAR_BAK</span> <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span> <span class="comment">#压缩为.tar.gz格式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-----删除7天前的备份文件-----&quot;</span></span><br><span class="line"></span><br><span class="line">find <span class="variable">$TAR_DIR</span>/ -mtime +<span class="variable">$DAYS</span> -delete <span class="comment">#删除7天前的备份文件</span></span><br></pre></td></tr></table></figure>

<h2 id="Mongodb整库还原-—–-mongorestore"><a href="#Mongodb整库还原-—–-mongorestore" class="headerlink" title="Mongodb整库还原 —– mongorestore"></a>Mongodb整库还原 —– mongorestore</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongorestore -h dbhost -d dbname –directoryperdb dbdirectory</span><br><span class="line">-h：MongoDB所在服务器地址</span><br><span class="line">-d：需要恢复的数据库实例，例如：<span class="built_in">test</span>，当然这个名称也可以和备份时候的不一样，比如test2</span><br><span class="line">–directoryperdb：备份数据所在位置，例如：c:\\data\\dump\\<span class="built_in">test</span>，这里为什么要多加一个<span class="built_in">test</span>，而不是备份时候的dump，读者自己查看提示吧！</span><br><span class="line">–-drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，备份后添加修改的数据都会被删除，慎用哦！</span><br></pre></td></tr></table></figure>

<h2 id="单个collection备份："><a href="#单个collection备份：" class="headerlink" title="单个collection备份："></a>单个collection备份：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongoexport -h dbhost -d dbname -c collectionname -f collectionKey -o dbdirectory</span><br><span class="line">-h: MongoDB所在服务器地址</span><br><span class="line">-d: 需要恢复的数据库实例</span><br><span class="line">-c: 需要恢复的集合</span><br><span class="line">-f: 需要导出的字段(省略为所有字段)</span><br><span class="line">-o: 表示导出的文件名</span><br></pre></td></tr></table></figure>

<h2 id="单个collection恢复："><a href="#单个collection恢复：" class="headerlink" title="单个collection恢复："></a>单个collection恢复：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongoimport -d dbhost -c collectionname –<span class="built_in">type</span> csv –headerline –file</span><br><span class="line">-<span class="built_in">type</span>: 指明要导入的文件格式</span><br><span class="line">-headerline: 批明不导入第一行，因为第一行是列名</span><br><span class="line">-file: 指明要导入的文件路径</span><br></pre></td></tr></table></figure>

<h2 id="Linux-定时任务-crond"><a href="#Linux-定时任务-crond" class="headerlink" title="Linux 定时任务   crond"></a>Linux 定时任务   crond</h2><p>1、默认crontab 的邮件位置为： /var/spool/mail/root</p>
<h2 id="crond简介："><a href="#crond简介：" class="headerlink" title="crond简介："></a>crond简介：</h2><p>1）、crond是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">　　/sbin/service crond start    //启动服务</span><br><span class="line"></span><br><span class="line">　　/sbin/service crond stop     //关闭服务</span><br><span class="line"></span><br><span class="line">　　/sbin/service crond restart  //重启服务</span><br><span class="line"></span><br><span class="line">　　/sbin/service crond reload   //重新载入配置</span><br><span class="line"></span><br><span class="line">　　/sbin/service crond status   //查看服务状态</span><br></pre></td></tr></table></figure>

<p>2)、/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</p>
<p>3）、脚本实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##每天早上6点 </span></span><br><span class="line">0 6 * * * <span class="built_in">echo</span> <span class="string">&quot;Good morning.&quot;</span> &amp;gt;&amp;gt; /tmp/test.txt //注意单纯<span class="built_in">echo</span>，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</span><br><span class="line"></span><br><span class="line"><span class="comment">##每两个小时 </span></span><br><span class="line">0 */2 * * * <span class="built_in">echo</span> <span class="string">&quot;Have a break now.&quot;</span> &amp;gt;&amp;gt; /tmp/test.txt  </span><br><span class="line"></span><br><span class="line"><span class="comment">##晚上11点到早上8点之间每两个小时和早上八点 </span></span><br><span class="line">0 23-7/2，8 * * * <span class="built_in">echo</span> <span class="string">&quot;Have a good dream&quot;</span> &amp;gt;&amp;gt; /tmp/test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 </span></span><br><span class="line">0 11 4 * 1-3 <span class="built_in">command</span> line</span><br><span class="line"></span><br><span class="line"><span class="comment">##1月1日早上4点 </span></span><br><span class="line">0 4 1 1 * <span class="built_in">command</span> line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root //如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ </span><br><span class="line"></span><br><span class="line"><span class="comment">##每小时执行/etc/cron.hourly内的脚本</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line"></span><br><span class="line"><span class="comment">##每天执行/etc/cron.daily内的脚本</span></span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily </span><br><span class="line"></span><br><span class="line"><span class="comment">##每星期执行/etc/cron.weekly内的脚本</span></span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly </span><br><span class="line"></span><br><span class="line"><span class="comment">##每月去执行/etc/cron.monthly内的脚本 </span></span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly </span><br><span class="line"></span><br><span class="line">注意: <span class="string">&quot;run-parts&quot;</span>这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。 　 </span><br><span class="line"></span><br><span class="line"><span class="comment">##每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。 </span></span><br><span class="line">5，15，25，35，45，55 16，17，18 * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##每周一，三，五的下午3：00系统进入维护状态，重新启动系统。</span></span><br><span class="line">00 15 * * 1，3，5 shutdown -r +5</span><br><span class="line"></span><br><span class="line"><span class="comment">##每小时的10分，40分执行用户目录下的innd/bbslin这个指令： </span></span><br><span class="line">10，40 * * * * innd/bbslink </span><br><span class="line"></span><br><span class="line"><span class="comment">##每小时的1分执行用户目录下的bin/account这个指令： </span></span><br><span class="line">1 * * * * bin/account</span><br><span class="line"></span><br><span class="line"><span class="comment">##每天早晨三点二十分执行用户目录下如下所示的两个指令（每个指令以;分隔）： </span></span><br><span class="line">20 3 * * * （/bin/rm -f expire.ls logins.bad;bin/expire<span class="variable">$#</span>@62;expire.1st）　　</span><br><span class="line"></span><br><span class="line"><span class="comment">##每年的一月和四月，4号到9号的3点12分和3点55分执行/bin/rm -f expire.1st这个指令，并把结果添加在mm.txt这个文件之后（mm.txt文件位于用户自己的目录位置）。 </span></span><br><span class="line">12,55 3 4-9 1,4 * /bin/rm -f expire.1st<span class="variable">$#</span>@62;<span class="variable">$#</span>@62;mm.txt </span><br></pre></td></tr></table></figure>
<h3 id="对于时间的定义，一共分为6部分："><a href="#对于时间的定义，一共分为6部分：" class="headerlink" title="对于时间的定义，一共分为6部分："></a>对于时间的定义，一共分为6部分：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">      minute hour day-of-month month-of-year day-of-week commands </span><br><span class="line">合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday) </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">除了数字还有几个个特殊的符号就是  * 、/ 、- 、,  </span><br></pre></td></tr></table></figure>

<p>“*” 代表所有的取值范围内的数字，</p>
<p>“/“代表每的意思,”/5”表示每5个单位，</p>
<p>“-“代表从某个数字到某个数字,</p>
<p>“,”分开几个离散的数字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l   /  -r  /  -e</span><br><span class="line">    -l 在标准输出上显示当前的crontab。 </span><br><span class="line">　　-r 删除当前的crontab文件。 </span><br><span class="line">　　-e 使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件。当结束编辑离开时，编辑后的文件将自动安装。</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Node.textContent</title>
    <url>/2020/11/14/js/textContent/</url>
    <content><![CDATA[<blockquote>
<p>Node.textContent 属性表示一个节点及其后代的文本内容。</p>
</blockquote>
<ul><li>1、如果 element 是 Document，DocumentType 或者 Notation 类型节点，则 textContent 返回 null。如果你要获取整个文档的文本以及CDATA数据，可以使用<a rel="nofollow" href="https://developer.mozilla.org/zh-CN/docs/DOM/document.documentElement" title="DOM/document.documentElement">document.documentElement</a>.textContent。</li></ul><ul><li>2、如果节点是个CDATA片段，注释，ProcessingInstruction节点或一个文本节点，textContent 返回节点内部的文本内容（即 <a href="https://developer.mozilla.org/zh-CN/docs/DOM/Node.nodeValue" title="DOM/Node/NodeValue/Node.nodeValue">nodeValue</a>）。</li></ul><ul><li>3、对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释、ProcessingInstruction节点。如果该节点没有子节点的话，返回一个空字符串。</li></ul><ul><li>4、在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。</li></ul>

<h2 id="与innerText的区别"><a href="#与innerText的区别" class="headerlink" title="与innerText的区别"></a>与innerText的区别</h2><p>IE引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/innerText" title="Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。">node.innerText</a>。意图类似，但有以下区别：</p>
<p>1、textContent 会获取所有元素的内容，包括script 和style 元素，然而 innerText 不会。</p>
<p>2、innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本，而textContent会。</p>
<p>3、由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会。</p>
<p>4、与 extContent 不同的是, 在 IE (对于小于等于 IE11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点（所以不可能再次将节点再次插入到任何其他元素或同一元素中）。</p>
<h2 id="与innerHTML的区别"><a href="#与innerHTML的区别" class="headerlink" title="与innerHTML的区别"></a>与innerHTML的区别</h2><p>innerHTML 返回 HTML 文本。通常，为了在元素中检索或写入文本，人们使用innerHTML。但是，textContent通常具有更好的性能，因为文本不会被解析为HTML。此外，使用textContent可以防止  <abbr title="cross-site scripting">XSS</abbr> 攻击。</p>
<h2 id="innerHTML与outerHTML的区别？"><a href="#innerHTML与outerHTML的区别？" class="headerlink" title="innerHTML与outerHTML的区别？"></a>innerHTML与outerHTML的区别？</h2><ul><li><span style="font-size: large;">innerHTML 设置或获取位于对象起始和结束标签内的 HTML</li><li><span style="font-size: large;">outerHTML 设置或获取对象及其内容的 HTML 形式</li><li><span style="font-size: large;">innerText 设置或获取位于对象起始和结束标签内的文本</li><li><span style="font-size: large;"><span style="text-decoration-line: line-through;">outerText <span style="color: rgb(194, 79, 74);">是一个非标准的属性。作为一个获得器，它返回与<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/innerText" title="Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。">Node.innerText</a>一致的值。 作为一个设置器，它将删除当前节点并将其替换为给定的文本。</li></ul>


<p> 比如对于这样一个HTML元素：<br> content<br> 。<br> <ul><li>innerHTML：内部HTML，content<br> ；</li><li>outerHTML：外部HTML，<br> content<br> ；</li><li>innerText：内部文本，content；</li></ul></p>
]]></content>
  </entry>
  <entry>
    <title>Centos7 安装nvm、node</title>
    <url>/2020/11/14/linux/centos-node/</url>
    <content><![CDATA[<p>首先：<br>安装nvm</p>
<h2 id="下载命令"><a href="#下载命令" class="headerlink" title="下载命令"></a>下载命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure>

<h2 id="下载完成后加入系统环境"><a href="#下载完成后加入系统环境" class="headerlink" title="下载完成后加入系统环境"></a>下载完成后加入系统环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>   ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>查看 NVM 版本list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list-romote</span><br></pre></td></tr></table></figure>



<p>4、安装需要的node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install  v11.9.0</span><br></pre></td></tr></table></figure>
<p>查看当前机器已安装版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure>
<p>切换node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm use v11.9.0</span><br></pre></td></tr></table></figure>
<p>7、设置默认的node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default v11.9.0</span><br></pre></td></tr></table></figure>

<p>n是Node的一个模块，作者是<a href="https://github.com/visionmedia" style="font-family: &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;">TJ Holowaychuk</a>（<a href="http://expressjs.com/" style="font-family: &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;">Express</a>框架作者）</p>
<p>n与nvm的区别</p>
<ul>
<li><p>n是 npm 的一个全局模块，安装n之前需要先安装node。<br>nvm是一个独立软件包。</p>
</li>
<li><p>在安装的时候，n会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径/usr/local/bin，非常简单明了。当然由于n会操作到非用户目录，所以需要加sudo来执行命令。</p>
<p>  在安装的时候，nvm将不同的 node 版本存储到~/.nvm/&lt;version&gt;/下，然后修改$PATH，将指定版本的 node 路径加入，这样我们调用的 node 命令即是使用指定版本的 node。</p>
</li>
</ul>
<p>所以，对于 node 路径，n永远是/usr/local/bin；nvm需要手动指定路径。</p>
<p>n对全局模块毫无作为，因此有可能在切换了 node 版本后发生全局模块执行出错的问题；nvm的全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突。</p>
<blockquote>
<p>从上面两点可以看出，nvm的使用比n要复杂一些。但是从安全角度，还是用nvm</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>crontab 定时任务</title>
    <url>/2020/11/14/linux/crontab/</url>
    <content><![CDATA[<blockquote>
<p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合</p>
</blockquote>
<h2 id="crontab-定时任务"><a href="#crontab-定时任务" class="headerlink" title="crontab 定时任务"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank">crontab 定时任务</a></h2><p><a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank">每天一个linux命令（50）：crontab命令</a></p>
<p><a href="https://segmentfault.com/a/1190000002628040" target="_blank">Linux 下执行定时任务 crontab 命令详解</a></p>
<p><a href="http://www.cnblogs.com/peida/tag/linux%E5%91%BD%E4%BB%A4/default.html?page=1" target="_blank">linux命令</a></p>
<p><a href="http://www.cnblogs.com/jianqingwang/p/6726589.html" target="_blank">Centos7:利用crontab定时执行任务</a></p>
<h2 id="19、crontab-定时任务"><a href="#19、crontab-定时任务" class="headerlink" title="19、crontab 定时任务"></a>19、crontab 定时任务</h2><h2 id="19-1-命令格式"><a href="#19-1-命令格式" class="headerlink" title="19.1. 命令格式"></a>19.1. 命令格式<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id2" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>
<h2 id="19-2-命令参数"><a href="#19-2-命令参数" class="headerlink" title="19.2. 命令参数"></a>19.2. 命令参数<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id3" title="永久链接至标题"></a></h2><ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h2 id="19-3-crontab的文件格式"><a href="#19-3-crontab的文件格式" class="headerlink" title="19.3. crontab的文件格式"></a>19.3. crontab的文件格式<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id4" title="永久链接至标题"></a></h2><p>分 时 日 月 星期 要运行的命令<br>第1列分钟0～59<br>第2列小时0～23（0表示子夜）<br>第3列日1～31<br>第4列月1～12<br>第5列星期0～7（0和7表示星期天）<br>第6列要运行的命令</p>
<h2 id="19-4-常用方法"><a href="#19-4-常用方法" class="headerlink" title="19.4. 常用方法"></a>19.4. 常用方法<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id5" title="永久链接至标题"></a></h2><h2 id="创建一个新的crontab文件"><a href="#创建一个新的crontab文件" class="headerlink" title="创建一个新的crontab文件"></a>创建一个新的crontab文件<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id6" title="永久链接至标题"></a></h2><p>向cron进程提交一个crontab文件之前，首先要设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$HOME目录下的. profile文件，在其中加入这样一行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EDITOR=vi; <span class="built_in">export</span> EDITOR</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后保存并退出。不妨创建一个名为&lt;user&gt; cron的文件，其中&lt;user&gt;是用户名，例如， davecron。在该文件中加入如下的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (put your own initials here)echo the date to the console every</span></span><br><span class="line"><span class="comment"># 15minutes between 6pm and 6am</span></span><br><span class="line">0,15,30,45 18-06 * * * /bin/<span class="built_in">echo</span> <span class="string">&#x27;date&#x27;</span> &gt; /dev/console</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存并退出。注意前面5个域用空格分隔。<br>在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab davecron</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p>
<h2 id="列出crontab文件"><a href="#列出crontab文件" class="headerlink" title="列出crontab文件"></a>列出crontab文件<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id7" title="永久链接至标题"></a></h2><p>使用-l参数列出crontab文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line">0,15,30,45 18-06 * * * /bin/<span class="built_in">echo</span> `date` &gt; dev/tty1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用这种方法在$HOME目录中对crontab文件做一备份:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab -l &gt; <span class="variable">$HOME</span>/mycron</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p>
<h2 id="编辑crontab文件"><a href="#编辑crontab文件" class="headerlink" title="编辑crontab文件"></a>编辑crontab文件<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id8" title="永久链接至标题"></a></h2><p>如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span></span><br><span class="line">30 3 1,7,14,21,26 * * /bin/find -name <span class="string">&#x27;core&#x27;</span> -<span class="built_in">exec</span> rm &#123;&#125; \\;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存并退出。</p>
<p>注解<br>最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。</p>
<h2 id="删除crontab文件"><a href="#删除crontab文件" class="headerlink" title="删除crontab文件"></a>删除crontab文件<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id9" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$crontab</span> -r</span><br></pre></td></tr></table></figure>

<h2 id="19-5-使用实例"><a href="#19-5-使用实例" class="headerlink" title="19.5. 使用实例"></a>19.5. 使用实例<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id10" title="永久链接至标题"></a></h2><h2 id="实例1：每1分钟执行一次myCommand"><a href="#实例1：每1分钟执行一次myCommand" class="headerlink" title="实例1：每1分钟执行一次myCommand"></a>实例1：每1分钟执行一次myCommand<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#mycommand" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure>

<h2 id="实例2：每小时的第3和第15分钟执行"><a href="#实例2：每小时的第3和第15分钟执行" class="headerlink" title="实例2：每小时的第3和第15分钟执行"></a>实例2：每小时的第3和第15分钟执行<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id11" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure>

<h2 id="实例3-在上午8点到11点的第3和第15分钟执行"><a href="#实例3-在上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例3 在上午8点到11点的第3和第15分钟执行"></a>实例3 在上午8点到11点的第3和第15分钟执行<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id12" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实例4：每隔两天的上午8点到11点的第3和第15分钟执行"><a href="#实例4：每隔两天的上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例4：每隔两天的上午8点到11点的第3和第15分钟执行"></a>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id13" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实例5：每周一上午8点到11点的第3和第15分钟执行"><a href="#实例5：每周一上午8点到11点的第3和第15分钟执行" class="headerlink" title="实例5：每周一上午8点到11点的第3和第15分钟执行"></a>实例5：每周一上午8点到11点的第3和第15分钟执行<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id14" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例6：每晚的21-30重启smb"><a href="#实例6：每晚的21-30重启smb" class="headerlink" title="实例6：每晚的21:30重启smb"></a>实例6：每晚的21:30重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#smb" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例7：每月1、10、22日的4-45重启smb"><a href="#实例7：每月1、10、22日的4-45重启smb" class="headerlink" title="实例7：每月1、10、22日的4 : 45重启smb"></a>实例7：每月1、10、22日的4 : 45重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id15" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例8：每周六、周日的1-10重启smb"><a href="#实例8：每周六、周日的1-10重启smb" class="headerlink" title="实例8：每周六、周日的1 : 10重启smb"></a>实例8：每周六、周日的1 : 10重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id16" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例9：每天18-00至23-00之间每隔30分钟重启smb"><a href="#实例9：每天18-00至23-00之间每隔30分钟重启smb" class="headerlink" title="实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb"></a>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id17" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例10：每星期六的晚上11-00-pm重启smb"><a href="#实例10：每星期六的晚上11-00-pm重启smb" class="headerlink" title="实例10：每星期六的晚上11 : 00 pm重启smb"></a>实例10：每星期六的晚上11 : 00 pm重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#pmsmb" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例11：每一小时重启smb"><a href="#实例11：每一小时重启smb" class="headerlink" title="实例11：每一小时重启smb"></a>实例11：每一小时重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id18" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实例12：晚上11点到早上7点之间，每隔一小时重启smb"><a href="#实例12：晚上11点到早上7点之间，每隔一小时重启smb" class="headerlink" title="实例12：晚上11点到早上7点之间，每隔一小时重启smb"></a>实例12：晚上11点到早上7点之间，每隔一小时重启smb<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id19" title="永久链接至标题"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 23-7 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="19-6-使用注意事项"><a href="#19-6-使用注意事项" class="headerlink" title="19.6. 使用注意事项"></a>19.6. 使用注意事项<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id20" title="永久链接至标题"></a></h2><p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p>
<p>在crontab文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p>
<ul>
<li><p>脚本中涉及文件路径时写全局路径；</p>
</li>
<li><p>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line">!/bin/sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意清理系统用户的邮件日志"><a href="#注意清理系统用户的邮件日志" class="headerlink" title="注意清理系统用户的邮件日志"></a>注意清理系统用户的邮件日志<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id22" title="永久链接至标题"></a></h2><p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 */3 * * * /usr/<span class="built_in">local</span>/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<h2 id="系统级任务调度与用户级任务调度"><a href="#系统级任务调度与用户级任务调度" class="headerlink" title="系统级任务调度与用户级任务调度"></a>系统级任务调度与用户级任务调度<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id23" title="永久链接至标题"></a></h2><p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html#id24" title="永久链接至标题"></a></h2><p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>当crontab失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p>
<p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p>
<p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</p>
<p>更新系统时间时区后需要重启cron,在ubuntu中服务名为cron:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$service</span> cron restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ubuntu下启动、停止与重启cron:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> /etc/init.d/cron start</span><br><span class="line"><span class="variable">$sudo</span> /etc/init.d/cron stop</span><br><span class="line"><span class="variable">$sudo</span> /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>XSS和CSRF</title>
    <url>/2020/11/14/js/xss-csrf/</url>
    <content><![CDATA[<blockquote>
<p>跨站脚本攻击(Cross Site Scripting)、跨站请求伪造(Cross Site Request Forgery)</p>
</blockquote>
<p>XSS，(cross site scripting),跨站脚本注入，指攻击者利用一些技巧向页面注入脚本代码并让其执行，从而达成攻击效果。</p>
<h2 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h2><p>攻击者利用页面输入和输出的功能，在输入时使用闭标签再加脚本代码等技巧，当服务器输出这些输入信息到页面时，就会插入并执行脚本代码。解决方法是可以在服务端对客户端的输入进行过滤或转义。注意：这里不一定只用script标签，还可以用img等其他标签，或者用onclick等事件方法达到执行脚本代码。简单例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Web 请求如下所示：</span></span><br><span class="line">GET http:<span class="comment">//www.somesite.com/page.asppageid=10&amp;lang=en&amp;title=Section%20Title</span></span><br><span class="line"><span class="comment">//在发出请求后，服务器返回的 HTML 内容包括：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section Title</span></span><br><span class="line"><span class="comment">// 攻击者可以通过摆脱 </span></span><br><span class="line"><span class="comment">//  标记来注入代码：</span></span><br><span class="line"><span class="comment">// http://www.somesite.com/page.asp?pageid=10&amp;lang=en&amp;title=Section%20Title</span></span><br><span class="line"><span class="comment">// &lt;script&gt;alert(‘XSS%20attack’)&lt;/script&gt;</span></span><br><span class="line"><span class="comment">//最终这个请求的 HTML 输出将为：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Section Title&lt;script&gt;alert(‘XSS attack’)&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="XSS危害与防范"><a href="#XSS危害与防范" class="headerlink" title="XSS危害与防范"></a>XSS危害与防范</h2><p>攻击者可以使用 XSS 漏洞搞恶作剧，窃取 Cookie，劫持帐户，执行 ActiveX，执行 Flash 内容，强迫您下载软件，官网挂钓鱼网站，或者是对硬盘和数据采取操作。防范的方法就是服务端对能被攻击的输入进行过滤或转义。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。<br>CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户</p>
<h2 id="CSRF-并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的-处理者。"><a href="#CSRF-并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的-处理者。" class="headerlink" title="CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的 处理者。"></a>CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的 处理者。</h2><p><img src="/img/xss.png"></p>
<h2 id="CSRF攻击的防御"><a href="#CSRF攻击的防御" class="headerlink" title="CSRF攻击的防御"></a>CSRF攻击的防御</h2><p>目前业界服务器端防御CSRF攻击主要有三种策略：验证HTTP Referer字段，在请求地址中添加token并验证，在HTTP头中自定义属性并验证。下面分别对这三种策略进行简要介绍。</p>
<h2 id="1、-验证HTTP-Referer字段"><a href="#1、-验证HTTP-Referer字段" class="headerlink" title="1、 验证HTTP Referer字段"></a>1、 验证HTTP Referer字段</h2><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问<a href="http://bank.test/test?page=10&amp;userID=101&amp;money=10000%E9%A1%B5%E9%9D%A2%E5%AE%8C%E6%88%90%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E5%BD%95bank">http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank</a>. test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank. test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</p>
<h2 id="2、-在请求地址中添加token并验证"><a href="#2、-在请求地址中添加token并验证" class="headerlink" title="2、 在请求地址中添加token并验证"></a>2、 在请求地址中添加token并验证</h2><p>CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上，这样就把 token 以参数的形式加入请求了。</p>
<h2 id="3、-在HTTP头中自定义属性并验证"><a href="#3、-在HTTP头中自定义属性并验证" class="headerlink" title="3、 在HTTP头中自定义属性并验证"></a>3、 在HTTP头中自定义属性并验证</h2><p>自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。</p>
]]></content>
  </entry>
  <entry>
    <title>centos7安装防火墙firewalld</title>
    <url>/2020/11/14/linux/firewalld/</url>
    <content><![CDATA[<p>默认情况下CentOS 7可能已经安装了firewalld服务，若确实没有安装直接使用yum命令安装即可：</p>
<h2 id="先来安装"><a href="#先来安装" class="headerlink" title="先来安装"></a>先来安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># yum install -y firewalld</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>安装完成后firewalld并没有运行，有必要先来熟悉下基本的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看运行状态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="comment">#启动firewall</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment">#设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br><span class="line"><span class="comment">#删除开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">#停止firewall</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>注：elasticsearch需要开放9200,9300两个端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># firewall-cmd --add-port=9200/tcp --permanent  #永久开放9200端口</span></span><br><span class="line"><span class="comment"># firewall-cmd --add-port=9300/tcp --permanent  #永久开放9300端口</span></span><br><span class="line"><span class="comment"># firewall-cmd --reload  #重新加载</span></span><br><span class="line"><span class="comment"># firewall-cmd --list-all #查看防火墙配置</span></span><br><span class="line">public (default)</span><br><span class="line">  interfaces:</span><br><span class="line">  sources:</span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: 9200/tcp 9300/tcp</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>


<h2 id="也可以直接修改配置文件"><a href="#也可以直接修改配置文件" class="headerlink" title="也可以直接修改配置文件"></a>也可以直接修改配置文件</h2><p>比如您将SSH端口修改为了2018，可尝试直接编辑firewalld的配置文件vi /etc/firewalld/zones/public.xml，里面加入一条规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;port protocol=<span class="string">&quot;tcp&quot;</span> port=<span class="string">&quot;2018&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>接着输入命令：systemctl start firewalld来启动firewalld，这样就不会阻挡在外啦。</p>
<h2 id="一些常用的列子"><a href="#一些常用的列子" class="headerlink" title="一些常用的列子"></a>一些常用的列子</h2><p>放行某个指定的TCP端口，如放行80端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>放行端口范围（8000-9000）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8000-9000/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>查看已经放行的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<p>删除某个已经放行的端口（6022）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=6022/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>阻止某个IP（123.57.22.204）连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&quot;rule family=ipv4 source address=123.57.22.204 reject&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意上面的所有列子都需要输入： firewall-cmd –reload重载firewall使其生效。</p>
]]></content>
  </entry>
  <entry>
    <title>SSR开启Google的BBR内核脚本加速TCP</title>
    <url>/2020/11/14/linux/google-bbr/</url>
    <content><![CDATA[<blockquote>
<p>Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。</p>
</blockquote>
<p>BBR 这个特性其实是在 Linux 内核 4.9 才计划加入的。所以，要开启BBR，需要内核版本在Linux kernel 4.9以上，根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。下面纪录一下如何升级Linux内核，并且开启BBR：</p>
<p>下载bbr 安装脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>

<p>安装成功后重启服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>

<p>查看内核版本，如果返回值含有4.13或以上版本, 就表示安装成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control </span><br></pre></td></tr></table></figure>

<p> 返回：net.ipv4.tcp_available_congestion_control = bbr cubic reno</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回：net.ipv4.tcp_congestion_control = bbr</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>

<p>返回：net.core.default_qdisc = fq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p>返回：tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>
<h3>内核升级方法： </h3>
如果是 CentOS 系统，执行如下命令即可升级内核： 
 yum --enablerepo=elrepo-kernel -y install kernel-ml kernel-ml-devel 


<p>CentOS 6 的话，执行命令：<br> sed -i ‘s/^default=.*/default=0/g’ /boot/grub/grub.conf </p>
<p>CentOS 7 的话，执行命令：<br> grub2-set-default 0 </p>
<p>如果是 Debian/Ubuntu 系统，则需要手动下载最新版内核来安装升级。<br>去<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank">这里下载</a>最新版的内核 deb 安装包。</p>
<p>如果系统是 64 位，则下载 amd64 的 linux-image 中含有 generic 这个 deb 包； </p>
<p>如果系统是 32 位，则下载 i386 的 linux-image 中含有 generic 这个 deb 包； </p>
<p>安装的命令如下（以最新版的 64 位 4.12.4 举例而已，请替换为下载好的 deb 包）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb </span><br></pre></td></tr></table></figure>

<p>安装完成后，再执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/update-grub </span><br></pre></td></tr></table></figure>

<p>最后，重启 VPS 即可。</p>
]]></content>
  </entry>
  <entry>
    <title>CentOS7下yum安装Java</title>
    <url>/2020/11/14/linux/java/</url>
    <content><![CDATA[<h2 id="一：查看yum包含的jdk版本"><a href="#一：查看yum包含的jdk版本" class="headerlink" title="一：查看yum包含的jdk版本"></a>一：查看yum包含的jdk版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search java 或者 yum list java*</span><br></pre></td></tr></table></figure>


<table><thead><tr><th>版本</th><th align="center">jre</th><th align="right">jdk</th></tr></thead><tbody><tr><td>1.8</td><td align="center">java-1.8.0-openjdk.x86_64</td><td align="right">java-1.8.0-openjdk-devel.x86_64</td></tr><tr><td>1.7</td><td align="center">java-1.7.0-openjdk.x86_64</td><td align="right">java-1.7.0-openjdk-devel.x86_64</td></tr><tr><td>1.6</td><td align="center">java-1.6.0-openjdk.x86_64</td><td align="right">java-1.6.0-openjdk-devel.x86_64</td></tr></tbody></table>

<h2 id="二、安装jdk"><a href="#二、安装jdk" class="headerlink" title="二、安装jdk"></a>二、安装jdk</h2><p>此次选择java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="注：也可以安装1-8-0的所有文件"><a href="#注：也可以安装1-8-0的所有文件" class="headerlink" title="注：也可以安装1.8.0的所有文件"></a>注：也可以安装1.8.0的所有文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure>

<h2 id="三：-使用命令检查是否安装成功"><a href="#三：-使用命令检查是否安装成功" class="headerlink" title="三： 使用命令检查是否安装成功"></a>三： 使用命令检查是否安装成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Linux安装jdk的三种方法</title>
    <url>/2020/11/14/linux/jdk/</url>
    <content><![CDATA[<p>环境：</p>
<p>Linux版本：CentOS 6.5</p>
<p>JDK版本：JDK 1.7</p>
<p>方法：<br>方法一：手动解压JDK的压缩包，然后设置环境变量<br>方法二：用yum安装JDK<br>方法三：用rpm安装JDK</p>
<p>方法一：手动解压JDK的压缩包，然后设置环境变量</p>
<p>`1.在/usr/目录下创建java目录 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir/usr/java</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd /usr/java</span></span><br></pre></td></tr></table></figure>
<p><code>2.下载，然后解压 ``` bash</code><br>[root@localhost java]# curl -O <a href="http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz">http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz</a><br>[root@localhost java]# tar -zxvf jdk-7u79-linux-x64.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;3.设置环境变量</span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line">[root@localhost java]# vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">JRE_HOME=/usr/java/jdk1.7.0_79/jre</span><br><span class="line">CLASS_PATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure>
<p>让修改生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost java]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>4.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost java]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.7.0_79&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_79-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</span><br></pre></td></tr></table></figure>


<p>方法二：用yum安装JDK(CentOS)</p>
<p>1.查看yum库中都有哪些jdk版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum search java|grep jdk</span></span><br><span class="line">ldapjdk-javadoc.x86_64 : Javadoc <span class="keyword">for</span> ldapjdk</span><br><span class="line">java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.6.0-openjdk-demo.x86_64 : OpenJDK Demos</span><br><span class="line">java-1.6.0-openjdk-devel.x86_64 : OpenJDK Development Environment</span><br><span class="line">java-1.6.0-openjdk-javadoc.x86_64 : OpenJDK API Documentation</span><br><span class="line">java-1.6.0-openjdk-src.x86_64 : OpenJDK Source Bundle</span><br><span class="line">java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.7.0-openjdk-demo.x86_64 : OpenJDK Demos</span><br><span class="line">java-1.7.0-openjdk-devel.x86_64 : OpenJDK Development Environment</span><br></pre></td></tr></table></figure>

<p>2.选择版本，进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost ~]# yum install java-1.7.0-openjdk</span><br></pre></td></tr></table></figure>
<p>安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64<br>3.设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/profile</span></span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64</span><br><span class="line">JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">CLASS_PATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure>

<p>让修改生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost java]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>

<p>3.验证</p>
<p>同上。<br>注：因为采用yum安装jdk，系统考虑到多版本的问题，会用alternatives进行版本控制。开始，相应版本的jdk安装在/usr/lib/jvm/之后，会在alternatives中注册，在/etc/alternatives目录下会产生一些链接到/usr/lib/jvm/中刚安装好的jdk版本。</p>
<p>在/usr/bin下面会有链接到/etc/alternatives的相应的文件。比如，/usr/bin下面会有一个链接文件java的映射关系</p>
<p>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/java-&gt;/etc/alternatives/java</span><br><span class="line">/etc/alternatives/java-&gt; /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java</span><br></pre></td></tr></table></figure>

<p>这样，java命令不用设置环境变量，就可以正常运行了。但如果对于tomcat或其他软件来说还是要设置环境变量。<br>同样，如果安装新的版本jdk，就会重新链接到最新安装的jdk版本。当然，也可以使用alternatives修改所要使用的版本。</p>
<p>具体方法可参照：<a href="http://www.linuxidc.com/Linux/2011-02/31856.htm" target="_blank">《使用Linux的alternatives管理多版本的软件》</a></p>
<p>1.下载<br>方法三：用rpm安装JDK</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[hadoop@localhost ~]$ curl -O http://download.oracle.com/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.rpm</span><br></pre></td></tr></table></figure>

<p>2.使用rpm命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost  ~]<span class="comment"># rpm -ivh jdk-7u79-linux-x64.rpm</span></span><br><span class="line">Preparing...               <span class="comment">########################################### [100%]</span></span><br><span class="line">  1:jdk                    <span class="comment">###########################################[100%]</span></span><br><span class="line">Unpacking JAR files...</span><br><span class="line">       rt.jar...</span><br><span class="line">       jsse.jar...</span><br><span class="line">       charsets.jar...</span><br><span class="line">       tools.jar...</span><br><span class="line">       localedata.jar...</span><br><span class="line">       jfxrt.jar...</span><br></pre></td></tr></table></figure>
<p>3.设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost java]<span class="comment"># vi /etc/profile</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_79</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_79&#x2F;jre</span><br><span class="line">CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>4.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost java]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.7.0_79&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_79-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</span><br></pre></td></tr></table></figure>
<p>和yum安装类似，不用设置环境变量就可以，运行java命令。rpm安装方式默认会把jdk安装到/usr/java/jdk1.7.0_79，然后通过三层链接，链接到/usr/bin,具体链接如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /bin</span></span><br><span class="line">[root@localhost bin]<span class="comment"># ll|grep java</span></span><br><span class="line">lrwxrwxrwx. 1 root root     25 Mar 28 11:24 jar -&gt;/usr/java/default/bin/jar</span><br><span class="line">lrwxrwxrwx. 1 root root     26 Mar 28 11:24 java -&gt; /usr/java/default/bin/java</span><br><span class="line">lrwxrwxrwx. 1 root root     27 Mar 28 11:24 javac -&gt;/usr/java/default/bin/javac</span><br><span class="line">lrwxrwxrwx. 1 root root     29 Mar 28 11:24 javadoc -&gt;/usr/java/default/bin/javadoc</span><br><span class="line">lrwxrwxrwx. 1 root root     28 Mar 28 11:24 javaws -&gt;/usr/java/default/bin/javaws</span><br><span class="line">lrwxrwxrwx. 1 root root     30 Mar 28 11:24 jcontrol -&gt;/usr/java/default/bin/jcontrol</span><br><span class="line">[root@localhost bin]<span class="comment"># cd /usr/java/</span></span><br><span class="line">[root@localhost java]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx. 1 root root   16 Mar 28 11:24 default-&gt; /usr/java/latest</span><br><span class="line">drwxr-xr-x. 8 root root 4096 Mar 28 11:24 jdk1.7.0_79</span><br><span class="line">lrwxrwxrwx. 1 root root   21 Mar 28 11:24 latest -&gt; /usr/java/jdk1.7.0_79</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CentOS7下yum安装Jenkins</title>
    <url>/2020/11/14/linux/jenkins/</url>
    <content><![CDATA[<h2 id="准备条件：安装Java（CentOS下安装Java1-8）"><a href="#准备条件：安装Java（CentOS下安装Java1-8）" class="headerlink" title="准备条件：安装Java（CentOS下安装Java1.8）"></a>准备条件：安装Java（<a href="https://www.webq.top/article/900" target="_blank" style="font-size: 14px;">CentOS下安装Java</a>1.8）</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1、Yum安装"><a href="#1、Yum安装" class="headerlink" title="1、Yum安装"></a>1、Yum安装</h2><p>yum源导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加Yum源</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y jenkins</span><br></pre></td></tr></table></figure>
<h2 id="2、开放端口"><a href="#2、开放端口" class="headerlink" title="2、开放端口"></a>2、开放端口</h2><p>Jenkins站点的默认监听端口是8080(<a href="https://www.webq.top/article/899" target="_blank">防火墙安装看这</a>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="3、安装完成后启动Jenkins："><a href="#3、安装完成后启动Jenkins：" class="headerlink" title="3、安装完成后启动Jenkins："></a>3、安装完成后启动Jenkins：</h2><ul>
<li>检查Jenkins服务状态<br>sudo systemctl status jenkins</li>
<li>设置为开机自启动<br>sudo systemctl enable jenkins</li>
<li>启动Jenkins服务<br>sudo systemctl start jenkins</li>
<li>停止Jenkins服务<br>sudo service jenkins stop</li>
</ul>
<p>（查看Jenkins开启成功「Active：active （running）」，就可以在浏览器里面查看：<a href="https://link.jianshu.com/?t=http://IP:Port" target="_blank" rel="nofollow">http://服务器IP:Jenkins启动的端口号Port</a>）## 4、相关配置<br>Jenkins配置文件地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure>

<p>这就是Jenkins的配置文件，可以在这里查看Jenkins默认的配置。<br>cat jenkins<br>这里介绍下三个比较重要的配置：</p>
<p>JENKINS_HOME</p>
<p>JENKINS_USER</p>
<p>JENKINS_PORT<br>JENKINS_HOME是Jenkins的主目录，Jenkins工作的目录都放在这里,Jenkins储存文件的地址,Jenkins的插件，生成的文件都在这个目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Path:        Development/Jenkins</span></span><br><span class="line"><span class="comment">## Description: Jenkins Continuous Integration Server</span></span><br><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;/var/lib/jenkins&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Directory where Jenkins store its configuration and working</span></span><br><span class="line"><span class="comment"># files (checkouts, build reports, artifacts, ...).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_HOME=<span class="string">&quot;/var/lib/jenkins&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JENKINS_USER 是Jenkins的用户，拥有$JENKINS_HOME和/var/log/jenkins的权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Type:        string</span></span><br><span class="line"><span class="comment">## Default:     &quot;jenkins&quot;</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unix user account that runs the Jenkins daemon</span></span><br><span class="line"><span class="comment"># Be careful when you change this, as you need to update</span></span><br><span class="line"><span class="comment"># permissions of $JENKINS_HOME and /var/log/jenkins.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_USER=<span class="string">&quot;jenkins&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JENKINS_PORT 是Jenkins的端口，默认端口是8080。</p>
<h2 id="Default-8080"><a href="#Default-8080" class="headerlink" title="Default:     8080"></a>Default:     8080</h2><p>ServiceRestart: jenkins</p>
<p>Port Jenkins is listening on.</p>
<p>Set to -1 to disable</p>
<p>JENKINS_PORT=”8080”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Type:        integer(0:65535)  </span></span><br><span class="line"><span class="comment">## Default:     8080</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Port Jenkins is listening on.</span></span><br><span class="line"><span class="comment"># Set to -1 to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;8080&quot;</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>使用kcptun加速shadowsocks</title>
    <url>/2020/11/14/linux/kcptun/</url>
    <content><![CDATA[<blockquote>
<p>Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为 KCP+UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP 浪费100%-200%的带宽的代价（理想状态下），换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p>
</blockquote>
<p><a href="https://www.bilibili.com/blackboard/diagnostics.html" target="_blank">网络诊断地址</a></p>
<p>工作原理：<br><img src="/img/kcp.png"></p>
<h2 id="服务端安装-KCPTun"><a href="#服务端安装-KCPTun" class="headerlink" title="服务端安装 KCPTun"></a>服务端安装 KCPTun</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh &amp;&amp; chmod +x ./kcptun.sh &amp;&amp; ./kcptun.sh</span><br></pre></td></tr></table></figure>

<p>接下来会依次提醒设置以下参数（这里是最终的结果</p>
<ul>
<li>1、端口：默认29900，即为KCPTUN与其客户端连接使用的端口，默认即可。</li>
<li>2、要加速的地址：默认127.0.0.1。</li>
<li>3、要加速的端口：设置为你的SS/SSR使用的端口。</li>
<li>4、密码：自己设置，用于KCPTUN客户端连接使用，不要使用默认密码。</li>
<li>5、加密方式选择：较强的加密方式会影响网速，建议默认aes或不加密。</li>
<li>6、加速模式：推荐fast2即可。随后可以手动修改为其它模式，测试加速效果。</li>
<li>7、MTU：默认1350即可。</li>
<li>8、sndwnd：发送窗口大小，与服务器的上传带宽大小有关，这项与rcvwnd的比例会影响加速效果，可以暂时设置为默认的512。</li>
<li>9、rcvwnd：接收窗口大小，与服务器的下载带宽大小有关，也可以暂设置为默认的512，或者1024也可以。</li>
<li>10、以下几项中，除了数据压缩外，其它保持默认参数即可。建议关闭数据压缩，可以在一定程度上提升传输效率。</li>
<li>11、其余各项设置，保持默认即可，设置完成后，按任意键开始安装过程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;localaddr&quot;</span>: <span class="string">&quot;:17926&quot;</span>, // 服务器ssr的端口</span><br><span class="line">  <span class="string">&quot;remoteaddr&quot;</span>: <span class="string">&quot;106.54.102.141:29900&quot;</span>, // 加速地址以及 kcptun 使用的端口</span><br><span class="line">  <span class="string">&quot;key&quot;</span>: <span class="string">&quot;hongye123&quot;</span>, //  kcptun 的密码</span><br><span class="line">  <span class="string">&quot;crypt&quot;</span>: <span class="string">&quot;none&quot;</span>, // 加密方式</span><br><span class="line">  <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;fast2&quot;</span>, // </span><br><span class="line">  <span class="string">&quot;mtu&quot;</span>: 1350, // </span><br><span class="line">  <span class="string">&quot;sndwnd&quot;</span>: 512, // </span><br><span class="line">  <span class="string">&quot;rcvwnd&quot;</span>: 512, // </span><br><span class="line">  <span class="string">&quot;datashard&quot;</span>: 10, // </span><br><span class="line">  <span class="string">&quot;parityshard&quot;</span>: 3, // </span><br><span class="line">  <span class="string">&quot;dscp&quot;</span>: 0, // </span><br><span class="line">  <span class="string">&quot;nocomp&quot;</span>: <span class="literal">true</span>, // </span><br><span class="line">  <span class="string">&quot;quiet&quot;</span>: <span class="literal">false</span>, // </span><br><span class="line">  <span class="string">&quot;tcp&quot;</span>: <span class="literal">false</span> // </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下面的参数配置将是之后在客户端中填写的重要参数"><a href="#下面的参数配置将是之后在客户端中填写的重要参数" class="headerlink" title="下面的参数配置将是之后在客户端中填写的重要参数"></a>下面的参数配置将是之后在客户端中填写的重要参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">key=hongye123;crypt=none;mode=fast2;mtu=1350;sndwnd=512;rcvwnd=512;datashard=10;parityshard=3;dscp=0;nocomp</span><br></pre></td></tr></table></figure>

<ul>
<li>KCPTUN安装目录：/usr/local/kcptun</li>
<li>KCPTUN的参数配置文件：/usr/local/kcptun/server-config.json</li>
<li>启动：supervisorctl start kcptun</li>
<li>停止：supervisorctl stop kcptun</li>
<li>重启：supervisorctl restart kcptun</li>
<li>状态：supervisorctl status kcptun</li>
<li>卸载：./kcptun.sh uninstall</li>
</ul>
<h2 id="客户端配置（这里只介绍mac"><a href="#客户端配置（这里只介绍mac" class="headerlink" title="客户端配置（这里只介绍mac"></a>客户端配置（这里只介绍mac</h2><p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank">点击下载最新的ShadowsocksX-NG</a>（我这里下载的是1.9.2版本<br>具体配置如下：<br><img src="/img/ssr.png"></p>
<p>注： 端口号要填写kcptun的端口号，参数选项即为上述，服务端安装好之后返回的一串数据</p>
<p>Windows：<a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">https://github.com/xtaci/kcptun/releases</a></p>
<p>iOS：没有对应的客户端，可以在路由器上安装，间接使用kcptun加速<br>Android：<a href="https://github.com/shadowsocks/kcptun-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/kcptun-android/releases</a></p>
<p><a href="https://ssr.tools/588" target="_blank">详细讲解看这</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端开发者必备的Nginx知识</title>
    <url>/2020/11/14/linux/nginx-n/</url>
    <content><![CDATA[<blockquote>
<p>nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写</p>
</blockquote>
<p>nginx在应用程序中的作用<ul><li>解决跨域</li><li>请求过滤</li><li>配置gzip</li><li>负载均衡</li><li>静态资源服务器</li><li>…</li></ul></p>
<p>nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。</p>
<p>下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。</p>
<p>为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？<br><a href="https://www.webq.top/article/5ca0e011bc22ce6603871671" target="_blank">正反向代理看这</a></p>
<h1 id="基本配置配置结构"><a href="#基本配置配置结构" class="headerlink" title="基本配置配置结构"></a>基本配置<h4>配置结构</h1><p>下面是一个nginx配置文件的基本结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">events &#123; &#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123; </span><br><span class="line">        location path</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location path</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul><li>main:nginx的全局配置，对全局生效。</li><li>events:配置影响nginx服务器或与用户的网络连接。</li><li>http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。</li><li>server：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>location：配置请求的路由，以及各种页面的处理情况。</li><li>upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。</li></ul><h4>内置变量
下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。<table><thead><tr><th>变量名</th><th>功能</th></tr></thead><tbody><tr><td>$host</td><td>请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名</td></tr><tr><td>$request_method</td><td>客户端请求类型，如GET、POST</td></tr><tr><td>$remote_addr</td><td>客户端的IP地址</td></tr><tr><td>$args</td><td>请求中的参数</td></tr><tr><td>$content_length</td><td>请求头中的Content-length字段</td></tr><tr><td>$http_user_agent</td><td>客户端agent信息</td></tr><tr><td>$http_cookie</td><td>客户端cookie信息</td></tr><tr><td>$remote_port</td><td>客户端的端口</td></tr><tr><td>$server_protocol</td><td>请求使用的协议，如HTTP/1.0、·HTTP/1.1`</td></tr><tr><td>$server_addr</td><td>服务器地址</td></tr><tr><td>$server_name</td><td>服务器名称</td></tr><tr><td>$server_port</td><td>服务器的端口号</td></tr></tbody></table>
# 解决跨域
先追本溯源以下，跨域究竟是怎么回事。<h4>跨域的定义
同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。<h4>同源的定义
如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源
<h4>nginx解决跨域的原理
例如：<ul><li>前端server的域名为：fe.server.com</li><li>后端服务的域名为：dev.server.com</li></ul>
现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。

<p>现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  fe.server.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">            proxy_pass dev.server.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。</p>
<h1 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h1><p>根据状态码过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error_page 500 501 502 503 504 506 &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        #将跟路径改编为存放html的路径。</span><br><span class="line">        root &#x2F;root&#x2F;static&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    rewrite  ^.*$ &#x2F;index.html  redirect;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>根据请求类型过滤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="配置gzip"><a href="#配置gzip" class="headerlink" title="配置gzip"></a>配置gzip</h1><p>GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。<br>对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。<br>并不是每个浏览器都支持gzip的，如何知道客户端是否支持gzip呢，请求头中的Accept-Encoding来标识对压缩的支持。</p>
<p>启用gzip同时需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了,我们可以通过nginx的配置来让服务端支持gzip。下面的respone中content-encoding:gzip，指服务端开启了gzip的压缩方式。</p>
<figure><img src="https://user-gold-cdn.xitu.io/2019/3/11/1696a1190112985c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<figcaption></figcaption></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip                    on;</span><br><span class="line">gzip_http_version       1.1;        </span><br><span class="line">gzip_comp_level         5;</span><br><span class="line">gzip_min_length         1000;</span><br><span class="line">gzip_types             text&#x2F;csv text&#x2F;xml text&#x2F;css text&#x2F;plain text&#x2F;javascript </span><br><span class="line">                        application&#x2F;javascript application&#x2F;x-javascript </span><br><span class="line">                        application&#x2F;json application&#x2F;xml;</span><br><span class="line">                        </span><br></pre></td></tr></table></figure>
<h4>gzip<ul><li>开启或者关闭gzip模块</li><li>默认值为off</li><li>可配置为on / off</li></ul><h4>gzip_http_version<ul><li>启用 GZip 所需的HTTP 最低版本</li><li>默认值为HTTP/1.1</li></ul>
这里为什么默认版本不是1.0呢？
HTTP 运行在TCP 连接之上，自然也有着跟TCP 一样的三次握手、慢启动等特性。
启用持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。

<p>为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。<br>HTTP/1.1默认支持TCP持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于TCP持久连接上的HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有Content-Length。而在HTTP/1.1中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。<br>nginx同样有着配置chunked的属性chunked_transfer_encoding，这个属性是默认开启的。<br>Nginx在启用了GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出Content-Length这个响应头部。<br>所以，在HTTP1.0中如果利用Nginx启用了GZip，是无法获得Content-Length的，这导致HTTP1.0中开启持久链接和使用GZip只能二选一，所以在这里gzip_http_version默认设置为1.1。<h4>gzip_comp_level<ul><li>压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。</li><li>默认值为 1</li><li>压缩级别取值为1-9</li></ul><h4>gzip_min_length<ul><li>设置允许压缩的页面最小字节数，Content-Length小于该值的请求将不会被压缩</li><li>默认值:0</li><li>当设置的值较小时，压缩后的长度可能比原文件大，建议设置1000以上</li></ul><h4>gzip_types<ul><li>要采用gzip压缩的文件类型(MIME类型)</li><li>默认值:text/html(默认不压缩js/css)</li></ul></p>
<h1 id="负载均衡nginx如何实现负载均衡"><a href="#负载均衡nginx如何实现负载均衡" class="headerlink" title="负载均衡nginx如何实现负载均衡"></a>负载均衡<h4>nginx如何实现负载均衡</h1><p>Upstream指定后端服务器地址列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">    server 10.1.22.33:12345;</span><br><span class="line">    server 10.1.22.34:12345;</span><br><span class="line">    server 10.1.22.35:12345;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  fe.server.com;</span><br><span class="line">    listen 80;</span><br><span class="line">    location &#x2F;api &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;balanceServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。<h4>nginx实现负载均衡的策略</p>
<p>轮询策略<br>默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">    server 10.1.22.33:12345;</span><br><span class="line">    server 10.1.22.34:12345;</span><br><span class="line">    server 10.1.22.35:12345;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>最小连接数策略<br>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 10.1.22.33:12345;</span><br><span class="line">    server 10.1.22.34:12345;</span><br><span class="line">    server 10.1.22.35:12345;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>最快响应时间策略<br>依赖于NGINX Plus，优先分配给响应时间最短的服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server 10.1.22.33:12345;</span><br><span class="line">    server 10.1.22.34:12345;</span><br><span class="line">    server 10.1.22.35:12345;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>客户端ip绑定<br>来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 10.1.22.33:12345;</span><br><span class="line">    server 10.1.22.34:12345;</span><br><span class="line">    server 10.1.22.35:12345;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~* \\.(png|gif|jpg|jpeg)$ &#123;</span><br><span class="line">    root    &#x2F;root&#x2F;static&#x2F;;  </span><br><span class="line">    autoindex on;</span><br><span class="line">    access_log  off;</span><br><span class="line">    expires     10h;# 设置过期时间为10小时          </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。</p>
]]></content>
  </entry>
  <entry>
    <title>Nginx 反向代理与负载均衡</title>
    <url>/2020/11/14/linux/nginx-proxy/</url>
    <content><![CDATA[<h2 id="nginx负载均衡的5种策略"><a href="#nginx负载均衡的5种策略" class="headerlink" title="nginx负载均衡的5种策略"></a>nginx负载均衡的5种策略</h2><p><a href="https://www.jianshu.com/p/e98e84a3322f" target="_blank">Nginx入门Nginx 配置反向代理服务器</a></p>
<p>用户访问网站的时候首先会访问nginx服务器，然后nginx服务器再从服务器集群中选择压力较小的服务器，将该访问请求引向该服务器</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>下面修改配置方面我就从mac系统下来进行简单的演示，如何安装的话也暂以mac为主了，windows系统直接去Nginx官网下载安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装nginx</span><br><span class="line">    1-进到homebrew官网，然后复制命令，预安装需要的东西</span><br><span class="line">    2-brew install nginx    安装nginx</span><br><span class="line">    3-nginx -v  显示版本号</span><br><span class="line">进入nginx</span><br><span class="line">    <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/etc/nginx</span><br></pre></td></tr></table></figure>
<h2 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h2><ul><li>
一、启动nginx</li><li>
nginx</li></ul>
    访问localhost:8080(默认)即可
<ul><li>
二、关闭nginx</li><li>
如果出现下图情况，不要惊慌，是因为之前nginx被启动过了</li><li>
只需nginx -s stop，停止nginx服务</li><li>
然后再次启动nginx即可</li></ul><ul><li>
三、重启nginx</li><li>
nginx -s reload</li><li>
每次修改完.conf文件就需要重启nginx</li><li>
四、检查配置</li><li>
检查修改的nginx.conf配置是否正确</li><li>
nginx -t</li><li>
如果出现下面ok和successfull就代表正确了，其他的都不对</li></ul>

<p>nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful</p>
<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>nginx反向代理主要通过proxy_pass来配置，将你项目的开发机地址填写到proxy_pass后面，正常的格式为proxy_pass URL即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http://10.10.10.10:20186;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Upstream模块实现负载均衡"><a href="#Upstream模块实现负载均衡" class="headerlink" title="Upstream模块实现负载均衡"></a>Upstream模块实现负载均衡</h2><ul><li>
ip_hash指令</li><li>
server指令</li><li>
upstream指令及相关变量</li></ul>
上面写的三个指令，我们直接通过代码来一一分析

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 修改nginx.conf</span><br><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">        upstream firstdemo &#123;</span><br><span class="line">            server 39.106.145.33;</span><br><span class="line">        server 47.93.6.93;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">            listen 8080;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://firstdemo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面修改的nginx.conf就是上图中花圈的那个文件，nginx配置的主要修改就在这里。化繁为简，把原本nginx.conf里的内容直接替换为上面的不到20行的代码了<br>既然不到20行，那就把里面对应的内容统统解释一下吧，有个了解就好<ul><li><br>worker_processes</li><li><br>工作进程数，和CPU核数相同</li><li><br>worker_connections</li><li><br>每个进程允许的最大连接数</li><li><br>upstream模块</li><li><br>负载均衡就靠它</li><li><br>语法格式：upstream name {}</li><li><br>里面写的两个server分别对应着不同的服务器</li><li><br>server模块</li><li><br>实现反向代理</li><li><br>listen监督端口号</li><li><br>location / {}访问根路径</li><li><br>proxy_pass <a href="http://firstdemo,代理到firstdemo里两个服务器上/">http://firstdemo，代理到firstdemo里两个服务器上</a></li></ul><br>上面修改了nginx.conf之后，别忘了最重要的一步重启nginx<br>那么再次访问localhost:8080（打开多个页面会发现访问的服务器内容不同）<br>每次刷新都会访问不同的服务器，这样就做到了负载均衡处理<br>不过，更应该做到的是当用户第一次访问到其中一台服务器后，下次再访问的时候就直接访问该台服务器就好了，不用总变化了。那么就发挥了ip_hash的威力了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 省略...</span><br><span class="line">    upstream firstdemo &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 39.106.145.33;</span><br><span class="line">        server 47.93.6.93;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ip_hash它的作用是如果第一次访问该服务器后就记录，之后再访问都是该服务器了，这样比如第一次访问是33服务器，那之后再访问也会分配为33服务器访问了</p>
<h2 id="工作中的简单使用"><a href="#工作中的简单使用" class="headerlink" title="工作中的简单使用"></a>工作中的简单使用</h2><p>在公司开发项目的时候，遇到设计，产品走查环节的时候，不能每次都让他们去配一个host，毕竟这样不友好，走查起来有麻烦。所以更应该给他们直观的感受，既给一个访问地址就可以看到样子<br>下面给大家看一下，我正常在公司时nginx做的反向代理配置，和咱们上面的如出一辙，只是加了一个server_name，用指定的域名去访问即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.demo.com ;</span><br><span class="line">    auth_basic off;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass    http://10.10.10.10:20186;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_connect_timeout 60;</span><br><span class="line">        proxy_read_timeout 600;</span><br><span class="line">        proxy_send_timeout 600;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次修改完nginx配置后不要忘记重启nginx才能生效，这样只需要访问<a href="http://www.demo.com这个地址就可以查看我的开发环境,进行走查了./">www.demo.com这个地址就可以查看我的开发环境，进行走查了。</a></p>
<h2 id="nginx负载均衡的5种策略-1"><a href="#nginx负载均衡的5种策略-1" class="headerlink" title="nginx负载均衡的5种策略"></a><a href="https://segmentfault.com/a/1190000014483200">nginx负载均衡的5种策略</a></h1></h2><h3 id="1、轮询（默认）"><a href="#1、轮询（默认）" class="headerlink" title="1、轮询（默认）"></a>1、轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2、weight"><a href="#2、weight" class="headerlink" title="2、weight"></a>2、weight</h2><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的<br>情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14 weight=3;</span><br><span class="line">    server 192.168.0.15 weight=7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>权重越高，在被访问的概率越大，如上例，分别是30%，70%。</p>
<h3 id="3、ip-hash"><a href="#3、ip-hash" class="headerlink" title="3、ip_hash"></a>3、ip_hash</h3><p>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么<code>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的</code>。</p>
<p>我们可以采用<code>ip_hash</code>指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<code>哈希算法，自动定位到该服务器</code>。</p>
<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决<code>session的问题</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.14:88;</span><br><span class="line">    server 192.168.0.15:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4、fair（第三方）"><a href="#4、fair（第三方）" class="headerlink" title="4、fair（第三方）"></a>4、fair（第三方）</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">        server server1;</span><br><span class="line">    server server2;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5、url-hash（第三方）"><a href="#5、url-hash（第三方）" class="headerlink" title="5、url_hash（第三方）"></a>5、url_hash（第三方）</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server squid1:3128;</span><br><span class="line">    server squid2:3128;</span><br><span class="line">    <span class="built_in">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在需要使用负载均衡的server中增加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_pass http://backserver/; </span><br><span class="line">upstream backserver&#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) </span><br><span class="line">    server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大) </span><br><span class="line">    server 127.0.0.1:6060; </span><br><span class="line">    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>fail_timeout:max_fails次失败后，暂停的时间<br>配置实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">worker_processes  4;</span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment"># 最大并发数</span></span><br><span class="line">worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">        <span class="comment"># 待选服务器列表</span></span><br><span class="line">    upstream myproject&#123;</span><br><span class="line">         <span class="comment"># ip_hash指令，将同一用户引入同一服务器。</span></span><br><span class="line">        ip_hash;</span><br><span class="line">        server 125.219.42.4 fail_timeout=60s;</span><br><span class="line">        server 172.31.2.183;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">            <span class="comment"># 监听端口</span></span><br><span class="line">        listen 80;</span><br><span class="line">        <span class="comment"># 根目录下</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 选择哪个服务器列表</span></span><br><span class="line">            proxy_pass http://myproject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"></span><br><span class="line">worker_processes  4;</span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment"># 最大并发数</span></span><br><span class="line">worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">        <span class="comment"># 待选服务器列表</span></span><br><span class="line">    upstream myproject&#123;</span><br><span class="line">            <span class="comment"># ip_hash指令，将同一用户引入同一服务器。</span></span><br><span class="line">        ip_hash;</span><br><span class="line">        server 125.219.42.4 fail_timeout=60s;</span><br><span class="line">        server 172.31.2.183;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">            <span class="comment"># 监听端口</span></span><br><span class="line">        listen 80;</span><br><span class="line">        <span class="comment"># 根目录下</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 选择哪个服务器列表</span></span><br><span class="line">            proxy_pass http://myproject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>详解root和alias指令</title>
    <url>/2020/11/14/linux/nginx-root-alias/</url>
    <content><![CDATA[<blockquote>
<p>配置nginx的静态文件有两个指令，一个 root 和一个 alias</p>
</blockquote>
<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>Nginx以其高性能著称，常用与做前端反向代理服务器。同时nginx也是一个高性能的静态文件服务器。通常都会把应用的静态文件使用nginx处理。</p>
<p>对于这两个指令，是否需要在路径的后面加上斜杠，经常容易让人犯晕，本文通过尝试不同的匹配规则，归纳了一个比较通用的配置方式。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>与<a href="https://www.jianshu.com/p/e154c2ef002f" target="_blank">简明 Nginx Location Url 配置笔记</a>一文关于location url配置的实验一样，本文也使用vagrant虚拟机里的nginx。其基本配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/sites-enabled/pro.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen 80 default_server;</span><br><span class="line"></span><br><span class="line">   server_name localhost;</span><br><span class="line"></span><br><span class="line">   access_log /var/<span class="built_in">log</span>/nginx/pro/access.log;</span><br><span class="line">   error_log /var/<span class="built_in">log</span>/nginx/pro/error.log;</span><br><span class="line"></span><br><span class="line">   error_page 404 /404.html;</span><br><span class="line"></span><br><span class="line">   root /vagrant/pro;</span><br><span class="line">   index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目的目录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">☁  pro  tree</span><br><span class="line">.</span><br><span class="line">├── 403.html</span><br><span class="line">├── 404.html</span><br><span class="line">├── index.html</span><br><span class="line">├── static</span><br><span class="line">│   ├── flask</span><br><span class="line">│   │   └── m.png</span><br><span class="line">│   └── stc.jpg</span><br><span class="line">└── upload</span><br><span class="line">    └── up.png</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>分别有两个静态文件夹，一个是static，另外一个是upload。</p>
<h2 id="初识root"><a href="#初识root" class="headerlink" title="初识root"></a>初识root</h2><p>root 是指定项目的根目录，适用与server和location。可以指定多个，如果locaiton没有指定，会往其外层的server或http中寻找继承。</p>
<blockquote>
<p>访问<a href="http://192.168.33.10/static/stc.jpg">http://192.168.33.10/static/stc.jpg</a> 会发现图片已经返回。我们还尚未配置 location，为啥会正确的找到文件？学习root或者alias指令的时候，最好的办法是给文件拓展名加上一个字符，使得该文件在硬盘中不存在，那么就能从nginx的error.log中看到nginx寻找文件的方式。</p>
</blockquote>
<p>访问 <a href="http://192.168.33.10/static/stc.jpgx%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9F%A5%E7%9C%8B">http://192.168.33.10/static/stc.jpgx，然后查看</a> /var/log/nginx/pro/error.log文件，可以看到如下的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 07:41:48 [error] 4416<span class="comment">#0: *70 open()</span></span><br><span class="line"> <span class="string">&quot;/vagrant/pro/static/stc.jpgx&quot;</span> failed </span><br><span class="line"></span><br><span class="line">(2: No such file or directory), </span><br><span class="line">client: 192.168.33.1, server: localhost,</span><br><span class="line"> request: <span class="string">&quot;GET /static/stc.jpgx HTTP/1.1&quot;</span>, </span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>即/vagrant/pro/static/stc.jpgx 文件不存在。的确我们没有这个文件。如果文件名正确，就能访问，原因是由于在server中指定了root /vagrant/pro，此时的nginx就在该目录下寻找文件，而url上的地址，正好和文件的路径一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.33.10  /static/stc.jpg </span><br><span class="line">/vagrant/pro          /static/stc.jpg</span><br></pre></td></tr></table></figure>

<p>由此可以猜想，nginx中root指令的地址，其实是替换了匹配后的url中的host。</p>
<h2 id="root指令"><a href="#root指令" class="headerlink" title="root指令"></a>root指令</h2><p>为了验证上面的猜想，需要多写几个location做实验。添加一个location配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /static &#123;</span><br><span class="line">        root /vagrant/pro/static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次访问<a href="http://192.168.33.10/static/stc.jpg%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%B9%B6%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E4%BA%86%EF%BC%8C%E6%9F%A5%E7%9C%8Berror.log">http://192.168.33.10/static/stc.jpg，发现并不能显示图片了，查看error.log</a> 返回如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 07:48:57 [error] 5978<span class="comment">#0: *71 open() </span></span><br><span class="line"><span class="string">&quot;/vagrant/pro/static/static/stc.jpg&quot;</span> failed </span><br><span class="line"></span><br><span class="line">(2: No such file or directory),</span><br><span class="line">client: 192.168.33.1, </span><br><span class="line">server: localhost, request: </span><br><span class="line"><span class="string">&quot;GET /static/stc.jpg HTTP/1.1&quot;</span>, </span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>nginx把地址识别成/vargrant/pro/static/static/stc.jpg多了一个static，套用上面的规则，其组合为192.168.33.10 == /vagrant/pro/static ，url是/static/stc.jpg。置换可以得到/vagrant/pro/static + /static/stc.jpg。与错误的error一致。解决方案就是把root中的static去掉，马上就能访问图片了。</p>
<p>既然是那么把文件夹static命名为stc，其结果又会怎样？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /static &#123;</span><br><span class="line">        root /vagrant/pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://192.168.33.10/static/stc.jpg">http://192.168.33.10/static/stc.jpg</a> 得到错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 07:54:46 [error] 5992<span class="comment">#0: *73 open() </span></span><br><span class="line"><span class="string">&quot;/vagrant/pro/static/stc.jpg&quot;</span> </span><br><span class="line">failed (2: No such file or directory),</span><br><span class="line">client: 192.168.33.1, server: localhost,</span><br><span class="line">request: <span class="string">&quot;GET /static/stc.jpg HTTP/1.1&quot;</span>,</span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>计算路径/vagrant/pro + /static/stc.jpg， 找不到/vagrant/pro/static/stc.jpg文件，符合之前所说的规则，尝试修改location：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /stc &#123;</span><br><span class="line">        root /vagrant/pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为url变了，访问<a href="http://192.168.33.10/stc/stc.jpg%EF%BC%8C%E6%89%8D%E8%83%BD%E5%A4%9F%E6%89%BE%E5%88%B0%E5%9B%BE%E7%89%87%E3%80%82%E7%8E%B0%E5%9C%A8%E6%8A%8Astc%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%98%E5%9B%9Estatic%E3%80%82">http://192.168.33.10/stc/stc.jpg，才能够找到图片。现在把stc文件夹变回static。</a></p>
<h2 id="root-与-斜杠"><a href="#root-与-斜杠" class="headerlink" title="root 与 斜杠"></a>root 与 斜杠</h2><p>很多人会疑惑，路径最后的斜杠/是否要加呢？location中的static后面的斜杠，和匹配后的url有关，不再赘述。root中的路径的斜杠/可以再通过实验确定。把location配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /static/ &#123;</span><br><span class="line">       root /vagrant/pro/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://192.168.33.10/static/stc.jpg">http://192.168.33.10/static/stc.jpg</a> 一切正常，访问<a href="http://192.168.33.10/static/stc.jpg%EF%BC%8Cerror%E4%B8%BA%E6%89%BE%E4%B8%8D%E5%88%B0&quot;/vagrant/pro/static/stc.jpgs&quot;%E6%96%87%E4%BB%B6%E3%80%82">http://192.168.33.10/static/stc.jpg，error为找不到&quot;/vagrant/pro/static/stc.jpgs&quot;文件。</a></p>
<p>如果按照root替换host的规则，那么替换过程为</p>
<p>/vagrant/pro/ + /static/stc.jpg == /vagrant/pro//static/stc.jpg。在*nix系统中， 多个斜杠和一个斜杠是等价的，也就是 /vagrant/pro//static/stc.jpg 与/vagrant/pro/static/stc.jpg一样。</p>
<p>这样一来，root路径后面的斜杠，加与不加效果都一样。既然如此，肯定有人会想到这么配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ static/ &#123;</span><br><span class="line">        root /vagrant/pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果安照之前上面的即算法，那么应该是 /vagrant/pro + static/stc.jpg，相加的应该是/vagrant/prostatic/stc.jpg，按理说应该是错误，可是实际上却能访问图片。咄咄怪事？</p>
<p>如果对前文nginx location的url匹配规则了解的话，应该看出来了其实 ^~ static/并不能匹配。修改 location</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ static/ &#123;</span><br><span class="line">        rewrite ^ http://google.com;</span><br><span class="line">   <span class="comment"># root /vagrant/pro;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://192.168.33.10/static/stc.jpg%E4%BE%9D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%9B%BE%E7%89%87%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%B7%B3%E8%BD%ACgoogle%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%8C%B9%E9%85%8D^">http://192.168.33.10/static/stc.jpg依然可以得到图片，没有跳转google，说明并没有匹配^</a>~ static/。</p>
<p>其实原理也很简单，还记得我们第一次实验，当时尚未配置location，也同样可以返回图片。没错，尽管^~ static/没有匹配，而外层的server定义了root为/vagrant/pro，因此搜索图片正常返回，再注释外层的root，再一次访问。此时会得到一个404，查看error如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 08:18:15 [error] 6227<span class="comment">#0: *82 open() </span></span><br><span class="line"><span class="string">&quot;/usr/share/nginx/html/static/stc.jpg&quot;</span> </span><br><span class="line">failed (2: No such file or directory),</span><br><span class="line"> client: 192.168.33.1, server: localhost, </span><br><span class="line">request: <span class="string">&quot;GET /static/stc.jpg HTTP/1.1&quot;</span>,</span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>/usr/share/nginx/html/static/stc.jpg，说明即使没有指定root，nginx默认也有一个root，/usr/share/nginx/html。当然，这个配置和 ^~ static/没有关系。</p>
<p>如果~ static/stc.jpgs? 那么就能命中，此时访问图片，依然能够正确的解析，因此，并不存在 /vagrant/pro + static/stc.jpg这种情况。理解这里的关键是 root替换host，并加上匹配后的url，匹配后的url当然包括前面的斜杠，匹配部分的url则不会。</p>
<p>对于 ~ static/stc.jpgs?模式，访问url<a href="http://192.168.33.10/static/stc.jpg">http://192.168.33.10/static/stc.jpg</a></p>
<ul>
<li><p>匹配后的url为 /static/stc.jpg</p>
</li>
<li><p>匹配部分的url为  static/stc.jpg</p>
</li>
</ul>
<p>掌握这个很重要，直接关系到后面alias指令与斜杠的关系。</p>
<p>对于root指令，我们可以归纳。</p>
<ul>
<li><p>对于匹配后的url地址，将匹配的location中的root路径替换访问url的host即得到文件的真实地址。（多个斜杠其实等价于一个斜杠）</p>
</li>
<li><p>如果不匹配location，则寻找更外层的root做替换。</p>
</li>
<li><p>root指令最后的斜杠可加可不加。</p>
</li>
</ul>
<h2 id="alias指令"><a href="#alias指令" class="headerlink" title="alias指令"></a>alias指令</h2><p>对于root，操作上很简单，只要把root地址替换host后就是文件在硬盘路径（真实地址）。对于alise，它并不是替换匹配后的url地址，而是替换匹配部分的url。alias指令也可以有多个。</p>
<p>添加一个location，和root的方式几乎一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /upload &#123;</span><br><span class="line">       <span class="built_in">alias</span> /vagrant/pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://192.168.33.10/upload/up.png%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%9B%BE%E7%89%87%EF%BC%8C%E6%9F%A5%E7%9C%8Berror%E5%BE%97%E5%88%B0%EF%BC%9A">http://192.168.33.10/upload/up.png并没有图片，查看error得到：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 08:36:18 [error] </span><br><span class="line">6312<span class="comment">#0: *90 open() &quot;/vagrant/pro/up.png&quot; </span></span><br><span class="line">failed (2: No such file or directory), </span><br><span class="line">client: 192.168.33.1, server: localhost,</span><br><span class="line">request: <span class="string">&quot;GET /upload/up.png HTTP/1.1&quot;</span>,</span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见 alias的模式并不是/vagrant/pro + /upload/up.png，而是 /vagrant/pro + /up.png。</p>
<p>alias这个词在计算机里很常用，字面意思是“别名”，顾名思议就是换一个名字啦。实际替换规则就是把匹配的url地址，换成alias中的路径即可。例如上述的例子替换过程可以模拟如下：</p>
<table>
<thead>
<tr>
<th>过程</th>
<th>模式或url</th>
</tr>
</thead>
<tbody>
<tr>
<td>url模式</td>
<td>^~ /upload</td>
</tr>
<tr>
<td>alias路径</td>
<td>/vagrant/pro</td>
</tr>
<tr>
<td>访问地址</td>
<td><a href="https://link.jianshu.com?t=http://192.168.33.10/upload/up.png" target="_blank" rel="nofollow">http://192.168.33.10/upload/up.png</a></td>
</tr>
<tr>
<td>匹配部分的地址</td>
<td>/upload + /up.png</td>
</tr>
<tr>
<td>替换</td>
<td>/upload == /vagrant/pro</td>
</tr>
<tr>
<td>结果</td>
<td>/vagrant/pro + /up.png</td>
</tr>
</tbody>
</table>

<p>为了修改图片的访问，修改locaton如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /upload &#123;</span><br><span class="line">      <span class="built_in">alias</span> /vagrant/pro/upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问<a href="http://192.168.33.10/upload/up.png%E5%B0%B1%E8%83%BD%E5%BE%97%E5%88%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9B%BE%E7%89%87%E5%95%A6%EF%BC%8C%E4%BB%BF%E9%80%A0%E4%B8%8A%E9%9D%A2%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E4%B8%BA%EF%BC%9A">http://192.168.33.10/upload/up.png就能得到正确的图片啦，仿造上面的计算过程为：</a></p>
<table>
<thead>
<tr>
<th>过程</th>
<th>模式或url</th>
</tr>
</thead>
<tbody>
<tr>
<td>url模式</td>
<td>^~ /upload</td>
</tr>
<tr>
<td>alias路径</td>
<td>/vagrant/pro/upload</td>
</tr>
<tr>
<td>访问地址</td>
<td><a href="https://link.jianshu.com?t=http://192.168.33.10/upload/up.png" target="_blank" rel="nofollow">http://192.168.33.10/upload/up.png</a></td>
</tr>
<tr>
<td>匹配部分的地址</td>
<td>/upload + /up.png</td>
</tr>
<tr>
<td>替换</td>
<td>/upload == /vagrant/pro/upload</td>
</tr>
<tr>
<td>结果</td>
<td>/vagrant/pro/upload + /up.png</td>
</tr>
</tbody>
</table>

<p>从结果可以看出，正确的找到了文件路径，如果alias指令路径加上斜杠，那么计算处理的文件路径为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/upload == /vagrant/pro/upload</span><br><span class="line">/vagrant/pro/upload/ + /up.png</span><br></pre></td></tr></table></figure>

<p>多个斜杠是合法的。等价于一个斜杠的情况。</p>
<p>下面修改locaiton如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /upload/ &#123;</span><br><span class="line">       <span class="built_in">alias</span> /vagrant/pro/upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时匹配时的url则变成  /upload/ + up.jpg, 那么置换的结果为 /vagrant/pro/upload + up.png，而/vagrant/pro/uploadup.png的路径是非法的，从error中也能看到置换的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2016/09/28 08:52:44 [error] 6452<span class="comment">#0: *92 </span></span><br><span class="line">open() <span class="string">&quot;/vagrant/pro/uploadup.png&quot;</span> </span><br><span class="line">failed (2: No such file or directory), </span><br><span class="line">client: 192.168.33.1, server: localhost, </span><br><span class="line">request: <span class="string">&quot;GET /upload/up.png HTTP/1.1&quot;</span>, </span><br><span class="line">host: <span class="string">&quot;192.168.33.10&quot;</span></span><br></pre></td></tr></table></figure>

<p>解决办法也很简单，把/vagrant/pro/upload 改成 /vagrant/pro/upload/即可。由此可见，alias最后的斜杠并不像root指令那样可有可无，是否需要，取决于配合loacation的url匹配模式。</p>
<p>前文root模式中，考虑了没有根的斜杠（~ static/stc.jpgs?）这种情况，alias情况下会很难捕捉错误。如果locaion配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ upload/ &#123;</span><br><span class="line">       <span class="built_in">alias</span> /vagrant/pro/upload/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换置换的文件路径应该为 /vagrant/pro/upload/up.png，可是实际测试中，这样配置alias，会一直导致一个301的重定向，如果alias目录没有打开autoindex，则会抛出一个403错误。具体情况尚未知晓，不知道是不是nginx的bug。为了避免这种情况，使用alias的时候，尽量不要配置location为 ^~ upload/的模式，并且不从根指定url，还是显得不伦不类。</p>
<p>alise作为别名，比起root的一大好处就是不一定要url上的路径和文件路径一样，因为alise并不是替换host，而是替换匹配部分的host。修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ^~ /upload/ &#123;</span><br><span class="line">      <span class="built_in">alias</span> /vagrant/pro/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://192.168.33.10/upload/stc.jpg%E6%88%96%E8%80%85">http://192.168.33.10/upload/stc.jpg或者</a> <a href="http://192.168.33.10/upload/flask/m.png%E9%83%BD%E8%83%BD%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E5%88%B0static%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B0%BD%E7%AE%A1url%E4%B8%8A%E6%98%AFupload%E3%80%82">http://192.168.33.10/upload/flask/m.png都能正确的访问到static目录下的文件，尽管url上是upload。</a></p>
<p>替换规则也很简单，/upload/ == /vagrant/pro/static/ 得到 /vagrant/pro/static/ + stc.jpg 或 /vagrant/pro/static/ + flask/m.png。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nginx的静态文件配置中，root和alias指令都能实现。为了避免混淆，尽量不要写没有根路径的url模式，即避免  static/这样的开头，根路径的斜杠需要保留，没有根路径其实也很奇怪。</p>
<p>root和alias的区别主要在于替换的部分，root模式中，会把root配置的路径替换匹配后的url中的host。alias则把他指定的路径，替换url中匹配的部分。指令中的斜杠对于root指令没有影响，对于alise则按照替换规则匹配即可。</p>
<p>root 指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /dir/ </span><br><span class="line">root root_path</span><br><span class="line">-&gt;http://host/dir/file.txt</span><br><span class="line">-&gt; root_path/dir/file.txt</span><br></pre></td></tr></table></figure>

<p>alias 指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /dir</span><br><span class="line"><span class="built_in">alias</span> alias_path </span><br><span class="line">-&gt;http://host /dir /file.txt</span><br><span class="line">-&gt; alias_path/file.txt</span><br><span class="line"></span><br><span class="line">location /dir/ </span><br><span class="line"><span class="built_in">alias</span> alias_path/</span><br><span class="line">-&gt;http://host/dir/ file.txt</span><br><span class="line">-&gt;alias_path/file.txt</span><br></pre></td></tr></table></figure>

<p>了解了root和alise之后，通常最佳实际是配置一个项目的根root，其他的文件夹则使用alias，毕竟alias更加灵活。</div><br><br><a href="https://www.jianshu.com/p/4be0d5882ec5" target="_blank">原文地址</a><br></p>
]]></content>
  </entry>
  <entry>
    <title>Nginx代理ssl转发https和wss请求</title>
    <url>/2020/11/14/linux/nginx-wss/</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>什么情况下需要这种操作？</p>
<p>比如，后台多台服务器做反向代理；</p>
<p>比如，微信小程序，建立微信小程序的websocket连接，必须要使用wss，但是目前不支持自定义端口，在调用的时候会使用默认端口，这个时候就需要做个代理。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Nginx配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443; <span class="comment">#https和wss协议默认端口</span></span><br><span class="line">    <span class="comment"># ssl的相关配置</span></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /usr/<span class="built_in">local</span>/a.pem; // ssl pem文件</span><br><span class="line">    ssl_certificate_key /usr/<span class="built_in">local</span>/a.key; // ssl key文件</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_buffer_size 1400;</span><br><span class="line">    add_header Strict-Transport-Security max-age=15768000;</span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">    ssl_stapling on;</span><br><span class="line">    ssl_stapling_verify on;</span><br><span class="line">    server_name www.webq.top;</span><br><span class="line">    <span class="comment"># 转发wss协议</span></span><br><span class="line">    location /wss &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:2346;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 转发https协议</span></span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:2345;</span><br><span class="line">        proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="comment"># add_header Access-Control-Allow-Origin *;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们访问 <a href="https://swoole.app/">https://</a><a href="http://www.webq.top/">www.webq.top</a> 的时候实际上就转发到了内部的2345端口的http服务，而不需要 <a href="https://swoole.app:9502/">https://www.webq.top:2</a>345 。建立websocket连接时直接与 wss://<a href="http://www.webq.top/wss">www.webq.top/wss</a> 建立连接，会转发到内部2346端口的服务。</p>
<p>参考：<br><a href="https://www.goozp.com/article/69.html" target="_blank">Nginx代理ssl转发https和wss请求</a></p>
]]></content>
  </entry>
  <entry>
    <title>基本的 WebSocket 的 Nginx 配置</title>
    <url>/2020/11/14/linux/nginx-ws/</url>
    <content><![CDATA[<p><a href="https://siriux.net/2013/06/nginx-and-websockets/" target="_blank">nginx and WebSockets</a></p>
<p>先用 ws 模块写一个简单的 WebSocket 服务器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Server = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server</span><br><span class="line"></span><br><span class="line">wss = <span class="keyword">new</span> Server port: <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">wss.on (<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log <span class="string">&#x27;a connection&#x27;</span></span><br><span class="line">    ws.send <span class="string">&#x27;started&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log <span class="string">&#x27;server started&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后修改 Hosts, 添加, 比如 ws.repo, 指向 127.0.0.1<br>然后是 Nginx 配置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name ws.repo;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//127.0.0.1:3000/;</span></span><br><span class="line">        proxy_redirect off;</span><br><span class="line"></span><br><span class="line">        proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Reload Nginx 然后从浏览器控制台尝试链接, OK</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://ws.repo/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者通过 Upstream 的写法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">upstream ws_server &#123;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name ws.repo;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//ws_server/;</span></span><br><span class="line">        proxy_redirect off;</span><br><span class="line"></span><br><span class="line">        proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WebSocket 先是通过 HTTP 建立连接,<br>然后通过 101 状态码, 表示切换协议,, 在配置里是 Upgrade# nginx配置websocket支持wss</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    <span class="keyword">default</span> upgrade;  </span><br><span class="line">    <span class="string">&#x27;&#x27;</span> close;  </span><br><span class="line">&#125;  </span><br><span class="line">upstream websocket &#123;  </span><br><span class="line">    server <span class="number">128.190</span><span class="number">.82</span><span class="number">.105</span>:<span class="number">8888</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;  </span><br><span class="line">    listen <span class="number">8888</span>;  </span><br><span class="line">    server_name proxy.hello.com;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /etc/nginx/ssl/hello.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/hello.com.key;</span><br><span class="line">    ssl_session_timeout <span class="number">20</span>m;</span><br><span class="line">    ssl_verify_client off;</span><br><span class="line">    location / &#123;  </span><br><span class="line">        proxy_pass http:<span class="comment">//websocket;  </span></span><br><span class="line">        proxy_http_version <span class="number">1.1</span>;  </span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;Upgrade&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>128.190.82.105:8888是真正的服务端地址，nginx所在域名是proxy.hello.com，代理的端口号是8888，所以前端访问的时候这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WEBSOCKET_URL: &#39;wss:&#x2F;&#x2F;proxy.hello.com:8888&#39;,  </span><br></pre></td></tr></table></figure>

<p><img src="/img/ws.webp"></p>
]]></content>
  </entry>
  <entry>
    <title>正向代理与反向代理的区别</title>
    <url>/2020/11/14/linux/proxy-reproxy/</url>
    <content><![CDATA[<blockquote>
<p>正向代理代理的对象是客户端，反向代理代理的对象是服务端</p>
</blockquote>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。</p>
<p>  反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p>
<p><img src="/img/proxy.webp"></p>
<h2 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h2><p>  正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。</p>
<p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。</p>
<p>从上面的描述也能看得出来正向代理和反向代理最关键的两点区别：<ul><li>是否指定目标服务器</li><li><br>客户端是否要做设置</li></ul></p>
<p>  正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。</p>
<p>  从用途上来区分：<ul><li>正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率</li><li>反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能</li></ul></p>
<p>  从安全性来讲：<ul><li>正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务</li><li>反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器</li></ul></p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>  正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</p>
<h3 id="3-1-正向代理"><a href="#3-1-正向代理" class="headerlink" title="3.1 正向代理"></a>3.1 正向代理</h3><p>它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，知名的科学上网工具shadowsocks 扮演的就是典型的正向代理角色。</p>
<p>  从上面的介绍也就可以猜出来正向代理的至少一个功能（俗称翻墙），也即：</p>
<p>  用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。</p>
<h3 id="3-2-反向代理"><a href="#3-2-反向代理" class="headerlink" title="3.2 反向代理"></a>3.2 反向代理</h3><p>反向代理隐藏了真实的服务端</p>
<p>从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即：</p>
<p>假设用户A访问 <a href="https://link.jianshu.com/?t=http://www.somesite.com/something.html" target="_blank" rel="nofollow">http://www.somesite.com/something.html</a>，但<a href="https://link.jianshu.com/?t=http://www.somesite.com" target="_blank" rel="nofollow">www.somesite.com</a>上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。</p>
<p>反向代理的作用就比较多了，这里简单列举一下：<ul><li>保护和隐藏原始资源服务器</li><li>加密和SSL加速</li><li>负载均衡</li><li>缓存静态内容</li><li>压缩</li><li>减速上传</li><li>安全</li><li>外网发布</li></ul></p>
]]></content>
  </entry>
  <entry>
    <title>Linux vi/vim</title>
    <url>/2020/11/14/linux/vi/</url>
    <content><![CDATA[<blockquote>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。<br><img src="/img/vi-cmd.gif"><br><img src="/img/vim-vi.png"></p>
</blockquote>
<p><a href="http://www.runoob.com/linux/linux-vim.html" target="_blank">原文地址</a></p>
<p>vi/vim 共分为三种模式，分别是<code>命令模式（Command mode）</code>，<code>输入模式（Insert mode）</code>和<code>底线命令模式（Last line mode）</code>。 这三种模式的作用分别是：</p>
<h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><p>用户刚刚启动 vi/vim，便进入了命令模式。<br>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>以下是常用的几个命令：</p>
<ul>
<li><code>i</code>&nbsp;切换到输入模式，以输入字符。</li>
<li><code>x</code>&nbsp;删除当前光标所在处的字符。</li>
<li><code>:</code>&nbsp;切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。<br>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>在命令模式下按下i就进入了输入模式。<br>在输入模式中，可以使用以下按键：</p>
<ul>
<li><code>字符按键以及Shift组合</code>，输入字符</li>
<li><code>ENTER</code>，回车键，换行</li>
<li><code>BACK SPACE</code>，退格键，删除光标前一个字符</li>
<li><code>DEL</code>，删除键，删除光标后一个字符</li>
<li><code>方向键</code>，在文本中移动光标</li>
<li><code>HOME</code>/<code>END</code>，移动光标到行首/行尾</li>
<li><code>Page Up</code>/<code>Page Down</code>，上/下翻页</li>
<li><code>Insert</code>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><code>ESC</code>，退出输入模式，切换到命令模式</li>
</ul>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。<br>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
]]></content>
  </entry>
  <entry>
    <title>使用Node 开发命令行程序</title>
    <url>/2020/11/14/node/cmd/</url>
    <content><![CDATA[<h2 id="一、可执行脚本"><a href="#一、可执行脚本" class="headerlink" title="一、可执行脚本"></a>一、可执行脚本</h2><p>1.demo文件头添加这一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line">console.log(hello world)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在package.json中添加<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;./demo.js&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>在命令行执行：（下篇文章介绍）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm  link</span><br></pre></td></tr></table></figure>
然后就可以执行 hello 命令 运行demo里面的内容。</li>
</ol>
<h2 id="二、yargs-模块"><a href="#二、yargs-模块" class="headerlink" title="二、yargs 模块"></a>二、yargs 模块</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -save yargs</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">&#x27;yargs&#x27;</span>)</span><br><span class="line">.option(<span class="string">&#x27;v&#x27;</span>, &#123;</span><br><span class="line">    alias : <span class="string">&#x27;version&#x27;</span>,</span><br><span class="line">    demand: <span class="literal">true</span>,     <span class="comment">// 后面的参数是否可以省略</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;0.0.0&#x27;</span>,</span><br><span class="line">    describe: <span class="string">&#x27;版本号&#x27;</span>,</span><br><span class="line">    type: string,    </span><br><span class="line">    boolean：<span class="literal">true</span>,  <span class="comment">// 是否强制转换成布尔值</span></span><br><span class="line">&#125;)</span><br><span class="line">.option(<span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    alias : <span class="string">&#x27;branch&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.usage(<span class="string">&#x27;Usage: kwe-cli [options]&#x27;</span>)  <span class="comment">// 用法格式</span></span><br><span class="line">.example(<span class="string">&#x27;kwe-cli&#x27;</span>, <span class="string">&#x27;init zero&#x27;</span>)       <span class="comment">// 举个例子</span></span><br><span class="line">.help(<span class="string">&#x27;h&#x27;</span>)    <span class="comment">// 显示帮助信息</span></span><br><span class="line">.alias(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;help&#x27;</span>)</span><br><span class="line">.argv;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello，argv.v)</span><br><span class="line"><span class="built_in">console</span>.log(hello，argv._)</span><br><span class="line"><span class="comment">// 就可以获取-v /-b 后的参数：</span></span><br><span class="line">hello -v wzw</span><br><span class="line"><span class="comment">// 打印  hello wzw(当没wzw的时候 会打印true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以argv._来获取非连词线开头的参数</span></span><br><span class="line">hello -v wzw w s y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：[&#x27;w&#x27;, &#x27;s&#x27;, &#x27;y&#x27;]</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Express中间件</title>
    <url>/2020/11/14/node/express-middle/</url>
    <content><![CDATA[<blockquote>
<p>Express 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。</p>
</blockquote>
<p>中间件函数能够访问<a href="https://expressjs.com/zh-cn/4x/api.html#req">请求对象</a> (req)、<a href="https://expressjs.com/zh-cn/4x/api.html#res">响应对象</a> (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示。</p>
<p>中间件函数可以执行以下任务：<ul><li>&lt;执行任何代码。</li><li>&lt;对请求和响应对象进行更改。</li><li>&lt;结束请求/响应循环。</li><li>&lt;调用堆栈中的下一个中间件函数。</li></ul><br>如果当前中间件函数没有结束请求/响应循环，那么它必须调用 next()，以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。</p>
<p>Express 应用程序可以使用以下类型的中间件：<ul><li><a href="https://expressjs.com/zh-cn/guide/using-middleware.html#middleware.application" style="color: rgb(70, 172, 200); font-size: large;">应用层中间件</a></li><li><a href="https://expressjs.com/zh-cn/guide/using-middleware.html#middleware.router" style="color: rgb(70, 172, 200); font-size: large;">路由器层中间件</a></li><li><a href="https://expressjs.com/zh-cn/guide/using-middleware.html#middleware.error-handling" style="color: rgb(70, 172, 200); font-size: large;">错误处理中间件</a></li><li><a href="https://expressjs.com/zh-cn/guide/using-middleware.html#middleware.built-in" style="color: rgb(70, 172, 200); font-size: large;">内置中间件</a></li><li><a href="https://expressjs.com/zh-cn/guide/using-middleware.html#middleware.third-party" style="color: rgb(70, 172, 200); font-size: large;">第三方中间件</a></li></ul></p>
<h2 id="应用层中间件"><a href="#应用层中间件" class="headerlink" title="应用层中间件:"></a>应用层中间件:</h2><p>此示例显示没有安装路径的中间件函数。应用程序每次收到请求时执行该函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此示例显示安装在 /user/:id 路径中的中间件函数。在 /user/:id 路径中为任何类型的 HTTP 请求执行此函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request Type:&#x27;</span>, req.method);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此示例显示一个路由及其处理程序函数（中间件系统）。此函数处理针对 /user/:id 路径的 GET 请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;USER&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是在安装点使用安装路径装入一系列中间件函数的示例。 它演示一个中间件子堆栈，用于显示针对 /user/:id 路径的任何类型 HTTP 请求的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request URL:&#x27;</span>, req.originalUrl);</span><br><span class="line">    next();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request Type:&#x27;</span>, req.method);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="路由器层中间件"><a href="#路由器层中间件" class="headerlink" title="路由器层中间件"></a>路由器层中间件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// a middleware function with no mount path. This code is executed for every request to the router</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path</span></span><br><span class="line">    router.use(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Request URL:&#x27;</span>, req.originalUrl);</span><br><span class="line">        next();</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Request Type:&#x27;</span>, req.method);</span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a middleware sub-stack that handles GET requests to the /user/:id path</span></span><br><span class="line">    router.get(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// if the user ID is 0, skip to the next router</span></span><br><span class="line">        <span class="keyword">if</span> (req.params.id == <span class="number">0</span>) next(<span class="string">&#x27;route&#x27;</span>);</span><br><span class="line">        <span class="comment">// otherwise pass control to the next middleware function in this stack</span></span><br><span class="line">        <span class="keyword">else</span> next();<span class="comment">//</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// render a regular page</span></span><br><span class="line">        res.render(<span class="string">&#x27;regular&#x27;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><p>错误处理中间件函数的定义方式与其他中间件函数基本相同，差别在于错误处理函数有四个自变量而不是三个，专门具有特征符 (err, req, res, next)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">app.use(function(err, req, res, next) &#123;</span><br><span class="line">        console.error(err.stack);</span><br><span class="line">        res.status(500).send(&#39;Something broke!&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h2><h3 id="express-static-root-options"><a href="#express-static-root-options" class="headerlink" title="express.static(root, [options])"></a>express.static(root, [options])</h3><p>Express 中唯一内置的中间件函数是 express.static。此函数基于 <a href="https://github.com/expressjs/serve-static">serve-static</a>，负责提供 Express 应用程序的静态资源。<br>root 自变量指定从其中提供静态资源的根目录。<br>可选的 options 对象可以具有以下属性：<table><thead><tr><th>属性</th><th>描述</th><th>类型</th><th>缺省值</th></tr></thead><tbody><tr><td>dotfiles</td><td>是否对外输出文件名以点（.）开头的文件。有效值包括“allow”、“deny”和“ignore”</td><td>字符串</td><td>“ignore”</td></tr><tr><td>etag</td><td>启用或禁用 etag 生成</td><td>布尔</td><td>true</td></tr><tr><td>extensions</td><td>用于设置后备文件扩展名。</td><td>数组</td><td>[]</td></tr><tr><td>index</td><td>发送目录索引文件。设置为 false 可禁用建立目录索引。</td><td>混合</td><td>“index.html”</td></tr><tr><td>lastModified</td><td>将 Last-Modified 的头设置为操作系统上该文件的上次修改日期。有效值包括 true 或 false。</td><td>布尔</td><td>true</td></tr><tr><td>maxAge</td><td>设置 Cache-Control 头的 max-age 属性（以毫秒或者 <a href="https://www.npmjs.org/package/ms">ms 格式</a>中的字符串为单位）</td><td>数字</td><td>0</td></tr><tr><td>redirect</td><td>当路径名是目录时重定向到结尾的“/”。</td><td>布尔</td><td>true</td></tr><tr><td>setHeaders</td><td>用于设置随文件一起提供的 HTTP 头的函数。</td><td>函数</td><td> </td></tr></tbody></table></p>
<h2 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h2><p>使用第三方中间件向 Express 应用程序添加功能。<br>安装具有所需功能的 Node.js 模块，然后在应用层或路由器层的应用程序中将其加装入。<br>以下示例演示如何安装和装入 cookie 解析中间件函数 cookie-parser。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ npm install cookie-parser</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">var cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; load the cookie-parsing middleware</span><br><span class="line">app.use(cookieParser());</span><br></pre></td></tr></table></figure>



<h1 id="Express中间件的原理"><a href="#Express中间件的原理" class="headerlink" title="Express中间件的原理"></a>Express中间件的原理</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仿照express实现中间件的功能</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Created by BadWaka on 2017/3/6.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仿express实现中间件机制</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;app&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">express</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = []; <span class="comment">// 待执行的函数数组</span></span><br><span class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> task = funcs[i++];  <span class="comment">// 取出函数数组里的下一个函数</span></span><br><span class="line">            <span class="keyword">if</span> (!task) &#123;    <span class="comment">// 如果函数不存在,return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        task(req, res, next);   <span class="comment">// 否则,执行下一个函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* use方法就是把函数添加到函数数组中</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">task</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span> (<span class="params">task</span>) </span>&#123;</span><br><span class="line">    funcs.push(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> app;    <span class="comment">// 返回实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是测试case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">http.createServer(app).listen(<span class="string">&#x27;3000&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;listening 3000....&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareA</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareA after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareB</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareB after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middlewareC</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC before next()&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middlewareC after next()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(middlewareA);</span><br><span class="line">app.use(middlewareB);</span><br><span class="line">app.use(middlewareC);</span><br></pre></td></tr></table></figure>

<p>middlewareA before next()</p>
<p>middlewareB before next()</p>
<p>middlewareC before next()</p>
<p>middlewareC after next()</p>
<p>middlewareB after next()</p>
<p>middlewareA after next()</p>
]]></content>
  </entry>
  <entry>
    <title>linux下安装软件--yum命令</title>
    <url>/2020/11/14/linux/yum/</url>
    <content><![CDATA[<blockquote>
<p>在安装yum的时候，yum会建立它的软件仓库，可以通过yum repolist来查看有哪些，yum库的定义目录为/etc/yum.repos.d,一般情况下，这些预装的库能满足我们的需要,如果自己添加repository需要相应URL和密钥。</p>
</blockquote>
<h2 id="1-准备："><a href="#1-准备：" class="headerlink" title="1.准备："></a>1.准备：</h2><p>centos7 修改yum源为阿里源,某下网络下速度比较快 首先是到yum源设置文件夹里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br></pre></td></tr></table></figure>
<p>接着备份旧的配置文件<br>   sudo mv CentOS-Base.repo CentOS-Base.repo.bak<br>下载阿里源的文件,也可以是其他的源如（<a href="https://blog.csdn.net/inslow/article/details/54177191" target="_blank">修改CentOS默认yum源为国内yum镜像源</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>
<p>清理缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure>
<p>重新生成缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache </span><br></pre></td></tr></table></figure>

<h2 id="2-列出已经安装的软件包"><a href="#2-列出已经安装的软件包" class="headerlink" title="2.列出已经安装的软件包"></a>2.列出已经安装的软件包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed 列出所有已经安装的软件包</span><br><span class="line">yum list packageName 在线查看软件包</span><br><span class="line">yum list installed packageName 在已经安装的软件包中查看packageName软件包，可以通过此命令来查看是否安装此软件包</span><br></pre></td></tr></table></figure>
<p>3.安装软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install packageName 在线安装软件包</span><br><span class="line"></span><br><span class="line">yum localinstall packageName 安装本地rpm软件包</span><br></pre></td></tr></table></figure>
<p>4.升级软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list updates 列出需要更新的软件包</span><br><span class="line"></span><br><span class="line">yum update packageName 更新此软件包</span><br><span class="line"></span><br><span class="line">yum update 更新所有列在yum list updates更新列表中的软件包</span><br></pre></td></tr></table></figure>
<p>5.卸载软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove packageName</span><br><span class="line"></span><br><span class="line">yum erase packageName</span><br></pre></td></tr></table></figure>
<p>其中remove是只卸载软件，保留配置文件和数据文件，erase是卸载软件并删除其相关的文件。</p>
<p>6.查看包依赖关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum deplist packageName</span><br></pre></td></tr></table></figure>
<p>7.查看系统中的某个文件是由哪个软件提供的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum provides  fileName</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JSON Web Token</title>
    <url>/2020/11/14/node/jwt/</url>
    <content><![CDATA[<blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。</p>
</blockquote>
<h2 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p>
<ul>
<li>1、用户向服务器发送用户名和密码。</li>
<li>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ul>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
<h2 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">    <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h2 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br><span class="line">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br><span class="line">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。<br>JWT 的三个部分依次如下。<ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><br>写成一行，就是下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Header.Payload.Signature</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面依次介绍这三个部分。<h3>3.1 Header</h3><br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。<h3>3.2 Payload</h3><br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<ul><li></p>
<li>iss: jwt签发者</li>
<li>
sub: jwt所面向的用户</li>
<li>
aud: 接收jwt的一方</li>
<li>
exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>
nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>
iat: jwt的签发时间</li>
<li>
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li></li></ul>
除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">    <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload),</span><br><span class="line">secret)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<blockquote>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
</blockquote>
<h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p>
<h2 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h2 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<h2 id="六：在node中使用"><a href="#六：在node中使用" class="headerlink" title="六：在node中使用"></a>六：在node中使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../../config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="comment">// 生成</span></span><br><span class="line"><span class="built_in">exports</span>.sign = <span class="function"><span class="keyword">function</span> <span class="title">token</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        secret,</span><br><span class="line">        expiresIn</span><br><span class="line">        &#125; = config.jwt</span><br><span class="line">    <span class="keyword">const</span> token = jwt.sign(&#123;</span><br><span class="line">        username: user.username,</span><br><span class="line">        userID: user._id</span><br><span class="line">    &#125;, secret, &#123;</span><br><span class="line">        expiresIn: expiresIn</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="built_in">exports</span>.verify = <span class="function"><span class="keyword">function</span> (<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> decoded = jwt.verify(token, config.jwt.secret)</span><br><span class="line">    <span class="keyword">return</span> decoded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Nodejs定时任务（node-schedule)</title>
    <url>/2020/11/14/node/node-schedule/</url>
    <content><![CDATA[<blockquote>
<p>定时导出某些数据、定时发送消息或邮件给用户、定时备份什么类型的文件等等</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install node-schedule --save 或者 yarn add node-schedule</span><br></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h2 id="1、Cron风格定时器"><a href="#1、Cron风格定时器" class="headerlink" title="1、Cron风格定时器"></a>1、Cron风格定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  scheduleCronstyle = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//每分钟的第30秒定时执行一次:</span></span><br><span class="line">    schedule.scheduleJob(<span class="string">&#x27;30 * * * * *&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;scheduleCronstyle:&#x27;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scheduleCronstyle();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>schedule.scheduleJob的回调函数中写入要执行的任务代码，一个定时器就完成了！</p>
<h2 id="规则参数讲解-代表通配符"><a href="#规则参数讲解-代表通配符" class="headerlink" title="规则参数讲解    *代表通配符"></a>规则参数讲解    *代表通配符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">*  *  *  *  *  *</span><br><span class="line">┬ ┬ ┬ ┬ ┬ ┬</span><br><span class="line">│ │ │ │ │  |</span><br><span class="line">│ │ │ │ │ └ day <span class="keyword">of</span> week (<span class="number">0</span> - <span class="number">7</span>) (<span class="number">0</span> or <span class="number">7</span> is Sun)</span><br><span class="line">│ │ │ │ └───── month (<span class="number">1</span> - <span class="number">12</span>)</span><br><span class="line">│ │ │ └────────── day <span class="keyword">of</span> month (<span class="number">1</span> - <span class="number">31</span>)</span><br><span class="line">│ │ └─────────────── hour (<span class="number">0</span> - <span class="number">23</span>)</span><br><span class="line">│ └──────────────────── minute (<span class="number">0</span> - <span class="number">59</span>)</span><br><span class="line">└───────────────────────── second (<span class="number">0</span> - <span class="number">59</span>, OPTIONAL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>6个占位符从左到右分别代表：秒、分、时、日、月、周几</p>
<p><em>表示通配符，匹配任意，当秒是</em>时，表示任意秒数都触发，其它类推</p>
<p>下面可以看看以下传入参数分别代表的意思</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">每分钟的第<span class="number">30</span>秒触发： <span class="string">&#x27;30 * * * * *&#x27;</span></span><br><span class="line"></span><br><span class="line">每小时的<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">&#x27;30 1 * * * *&#x27;</span></span><br><span class="line"></span><br><span class="line">每天的凌晨<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">&#x27;30 1 1 * * *&#x27;</span></span><br><span class="line"></span><br><span class="line">每月的<span class="number">1</span>日<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">&#x27;30 1 1 1 * *&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2016</span>年的<span class="number">1</span>月<span class="number">1</span>日<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">&#x27;30 1 1 1 2016 *&#x27;</span></span><br><span class="line"></span><br><span class="line">每周<span class="number">1</span>的<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">&#x27;30 1 1 * * 1&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>每个参数还可以传入数值范围:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task1 = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//每分钟的1-10秒都会触发，其它通配符依次类推</span></span><br><span class="line">    schedule.scheduleJob(<span class="string">&#x27;1-10 * * * * *&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;scheduleCronstyle:&#x27;</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>每五分钟执行一个cron任务 = */5 * * * *不支持的cron特性<br>一般的, W (最近的工作日), L (一个月/星期的最后一天), 以及 # (月的第n个星期) 是不支持的. 大多数流行的cron特性应该都能工作。<br><a href="https://github.com/harrisiirak/cron-parser" target="_blank">cron-parser 用来解析crontab指令</a>## 2、基于日期的调度<br>就是说你特别想要一个函数在 2012年12月12日早上5:30执行。 记住在JavaScript中- 0 - 星期一, 11 - 十二月.（意思就是星期数和月份数都是从0开始计数的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(date, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;世界将在今天走向 结束.&#x27;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>要在未来使用当前数据，你可以使用绑定:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;Tada!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(date, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;.bind(<span class="literal">null</span>,x));</span><br><span class="line">x = <span class="string">&#x27;Changing Data&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当调度的任务运行时，这个将会打印出’Tada!’，而不是 ‘Changing Data’， 这个x会在调度后立即更改.</p>
<h2 id="3、递归循环规则调度"><a href="#3、递归循环规则调度" class="headerlink" title="3、递归循环规则调度"></a>3、递归循环规则调度</h2><p>你可以创建递归规则来指定任务在何时重新调用。举个例子，考虑这个规则，将在每个小时的第42分钟执行函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule = <span class="keyword">new</span> schedule.RecurrenceRule();</span><br><span class="line">rule.minute = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(rule, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;生命，宇宙，一切的答案。。。!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>你也可以使用数组来指定一个允许值的列表,Range</p>
<p>对象来指定一个系列的开始值和结束值，带有可选的步骤参数。举个例子，这个将在星期4，星期5，星期6和星期天的下午五点答应一个信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rule = <span class="keyword">new</span> schedule.RecurrenceRule();</span><br><span class="line">rule.dayOfWeek = [<span class="number">0</span>, <span class="keyword">new</span> schedule.Range(<span class="number">4</span>, <span class="number">6</span>)];</span><br><span class="line">rule.hour = <span class="number">17</span>;</span><br><span class="line">rule.minute = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(rule, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;今天我碰到klren了!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归规则的属性"><a href="#递归规则的属性" class="headerlink" title="递归规则的属性"></a>递归规则的属性</h3><ul>
<li>second</li>
<li>minute</li>
<li>hour</li>
<li>date</li>
<li>month</li>
<li>year</li>
<li>dayOfWeek</li>
</ul>


<p>注意: 值得注意的时递归规则的默认的第一个属性是null (除了第二个,对于熟悉cron，知道默认为0). 如果我们之前没有明确地设定minute为0, 信息将会在下面时间打印 5:00pm, 5:01pm, 5:02pm, …, 5:59pm. 或许这不是你想要的.</p>
<h3 id="对象字面化语法"><a href="#对象字面化语法" class="headerlink" title="对象字面化语法"></a>对象字面化语法</h3><p>让事情变得简单一点，一个对象字面化语法也是支持的，就像这个例子，将会在每个星期天的下午两点半打印信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(&#123;<span class="attr">hour</span>: <span class="number">14</span>, <span class="attr">minute</span>: <span class="number">30</span>, <span class="attr">dayOfWeek</span>: <span class="number">0</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;到了喝茶的时间!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置开始时间和结束时间"><a href="#设置开始时间和结束时间" class="headerlink" title="设置开始时间和结束时间"></a>设置开始时间和结束时间</h3><p>这个例子中，它将在五秒后开始，然后十秒后结束.和之前一样支持规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>(startTime.getTime() + <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">var</span> j = schedule.scheduleJob(&#123; <span class="attr">start</span>: startTime, <span class="attr">end</span>: endTime, <span class="attr">rule</span>: <span class="string">&#x27;*/1 * * * * *&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;到了喝茶时间!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="处理任务和任务调度"><a href="#处理任务和任务调度" class="headerlink" title="处理任务和任务调度"></a>处理任务和任务调度</h2><p>这儿有一些函数来从一个任务中获取信息以及处理任务和调度</p>
<h3 id="job-cancel-reshedule"><a href="#job-cancel-reshedule" class="headerlink" title="job.cancel(reshedule)"></a>job.cancel(reshedule)</h3><p>你可以让任何任务失效，使用 cancel() 方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">j.cancel();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>所有的计划调用将会被取消。当你设置 reschedule 参数为true，然后任务将在之后重新排列。</p>
<h3 id="job-cancelNext-reshedule"><a href="#job-cancelNext-reshedule" class="headerlink" title="job.cancelNext(reshedule)"></a>job.cancelNext(reshedule)</h3><p>这个方法将取消下一个计划的调度或者任务.</p>
<p>当你设置 reschedule 参数为true，然后任务将在之后重新排列。</p>
<h3 id="job-reschedule-spec"><a href="#job-reschedule-spec" class="headerlink" title="job.reschedule(spec)"></a>job.reschedule(spec)</h3><p>这个方法将取消所有挂起的调度，然后使用给定的规则重新注册任务.</p>
<p>将返回 true/false 来说明成功/失败.</p>
<h3 id="job-nextInvocation"><a href="#job-nextInvocation" class="headerlink" title="job.nextInvocation()"></a>job.nextInvocation()</h3><p>这个方法返回一个日期对象为这个任务的下一次调用计划，如果没有调度安排，则返回null.</p>
]]></content>
  </entry>
  <entry>
    <title>node ws模块</title>
    <url>/2020/11/14/node/node-wss/</url>
    <content><![CDATA[<ul><li>认识 TCP
TCP 协议可以总结几个特点：<ul><li>有状态的长连接：客户端发起连接请求，服务端响应并建立连接，连接会一直保持直到一方主动断开。</li><li>主动性：建立起与客户端的连接后，服务端可主动向客户端发起调用。</li><li>信息安全性：同样可以使用 SSL 证书进行信息加密，访问时用 WSS 。</li><li>跨域：默认支持跨域。</li></ul>
</li><li><a href="https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/ws/ws-with-koa" target="_blank">编写聊天室源码ws-with-koa</a>
</li><li>服务端 API</li><li>安装第三方模块 ws：npm install ws</li><li>开启一个 WebSocket 的服务器，端口为 8080</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socketServer = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> socketServer(&#123;</span><br><span class="line">    port: <span class="number">8080</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul><li>也可以利用 Express 来开启 WebSocket 的服务器</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).Server(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socketServer = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> socketServer(&#123;<span class="attr">server</span>: server, <span class="attr">port</span>: <span class="number">8080</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul><li>用 on 来进行事件监听</li><li>connection：连接监听，当客户端连接到服务端时触发该事件</li><li>close：连接断开监听，当客户端断开与服务器的连接时触发</li><li>message：消息接受监听，当客户端向服务端发送信息时触发该事件</li><li>send: 向客户端推送信息</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">    client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">_message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _messageObj = <span class="built_in">JSON</span>.parse(_message);</span><br><span class="line">        <span class="comment">//status = 1 表示正常聊天</span></span><br><span class="line">        _messageObj.status = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.message = _messageObj;</span><br><span class="line">        <span class="comment">//把客户端的消息广播给所有在线的用户</span></span><br><span class="line">        wss.broadcast(_messageObj);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出聊天  </span></span><br><span class="line">    client.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.message = <span class="built_in">this</span>.message || &#123;&#125;;</span><br><span class="line">            <span class="comment">// status = 0 表示退出聊天</span></span><br><span class="line">            <span class="built_in">this</span>.message.status = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//把客户端的消息广播给所有在线的用户</span></span><br><span class="line">            wss.broadcast(<span class="built_in">this</span>.message);  </span><br><span class="line">        &#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;刷新页面了&#x27;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义广播方法</span></span><br><span class="line">wss.broadcast = <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">_messageObj</span>) </span>&#123;  </span><br><span class="line">    wss.clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123; </span><br><span class="line">        client.send(<span class="built_in">JSON</span>.stringify(_messageObj))</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>


<h2 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h2><ul><li>在支持 WebSocket 的浏览器下实例化 WebSocket ，参数为 WebSocket 服务器地址，建立与服务器的连接</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="params">!WebSocket</span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.connState&#x27;</span>).text(<span class="string">&quot;您的浏览器不支持WebSocket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//连接 socket 服务器</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul><li>onopen：当网络连接建立时触发该事件</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听 socket 的连接</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.connState&#x27;</span>).text(<span class="string">&quot;服务已连接 ws://localhost:8080&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul><li>onclose：当服务端关闭时触发该事件</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听服务端断开</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.connState&#x27;</span>).text(<span class="string">&quot;服务已断开&quot;</span>);</span><br><span class="line">    socket = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul><li>close: 在客户端断开与服务端的连接 socket.close();</li><li>onerror：当网络发生错误时触发该事件</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听服务端异常</span></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.connState&#x27;</span>).text(<span class="string">&quot;服务错误&quot;</span>);</span><br><span class="line">    socket = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul><li>onmessage：当接收到服务器发来的消息的时触发的事件，也是通信中最重要的一个监听事件</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听服务端广播过来的消息</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msgObj = <span class="built_in">JSON</span>.parse(msg.data);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">msgObj.status == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;&lt;p&gt;&#x27;</span> </span><br><span class="line">        + msgObj.nickname </span><br><span class="line">        + <span class="string">&#x27;[&#x27;</span> + msgObj.time </span><br><span class="line">        + <span class="string">&#x27;]退出聊天&lt;/p&gt;&#x27;</span>).appendTo(<span class="string">&#x27;.msgList&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;&lt;p&gt;&#x27;</span> </span><br><span class="line">        + msgObj.nickname </span><br><span class="line">        + <span class="string">&#x27;[&#x27;</span> + msgObj.time </span><br><span class="line">        + <span class="string">&#x27;]：&#x27;</span> + msgObj.message </span><br><span class="line">        + <span class="string">&#x27;&lt;/p&gt;&#x27;</span>).appendTo(<span class="string">&#x27;.msgList&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul><li>send：向服务端推送消息</li></ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sendMessage = <span class="function"><span class="keyword">function</span>(<span class="params">_mess</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> now = myDate.getMonth() </span><br><span class="line">        + <span class="string">&#x27;-&#x27;</span> + myDate.getDate() </span><br><span class="line">        + <span class="string">&#x27; &#x27;</span> + myDate.getHours() </span><br><span class="line">        + <span class="string">&#x27;:&#x27;</span> + myDate.getMinutes() + <span class="string">&#x27;:&#x27;</span> + myDate.getSeconds();                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> mesObj = &#123;</span><br><span class="line">            nickname: $(<span class="string">&#x27;#nickName&#x27;</span>).val(),</span><br><span class="line">            message: _mess || $(<span class="string">&#x27;#mesBox&#x27;</span>).val(),</span><br><span class="line">            time: now</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向服务端发送消息</span></span><br><span class="line">        socket.send(<span class="built_in">JSON</span>.stringify(mesObj));</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>基于Node.js的WebSocket通信</title>
    <url>/2020/11/14/node/node-ws/</url>
    <content><![CDATA[<blockquote>
<p> 假如A,B,C,D用户均通过客户端连接到Websocket服务，其中每个人发的消息都需要将其通过Websocket转发给其他人，此场景类似于服务端将A的消息广播给组内其他用户。</p>
</blockquote>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>首先来看服务端程序，具体的工作流程分以下几步：<li>创建一个WebSocketServer的服务，同时监听8080端口的连接请求。</li><li>每当有新的客户端连接该WebSocket成功时，便将该连接push到连接池的数组中。</li><li>监听message事件，当该事件发生时，遍历连接池，以连接为单位将该消息转发到对应的客户端</li><li>监听close事件，当该事件发生时，将该连接移出连接池</li></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 服务端代码</span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server,</span><br><span class="line">wss = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">8080</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">var</span> clients = [];</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将该连接加入连接池</span></span><br><span class="line">        clients.push(ws);</span><br><span class="line">        ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 广播消息</span></span><br><span class="line">            clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ws1</span>)</span>&#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params">ws1 !== ws</span>)</span> &#123;</span><br><span class="line">                    ws1.send(message);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 连接关闭时，将其移出连接池</span></span><br><span class="line">            clients = clients.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ws1</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ws1 !== ws</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMessage()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;online&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;Connection to server opened&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;Client received a message&#x27;</span>, event); </span></span><br><span class="line">        &#125;; </span><br><span class="line"><span class="javascript">    ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;connection closed.&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            ws.send(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="如何发现用户？"><a href="#如何发现用户？" class="headerlink" title="如何发现用户？"></a>如何发现用户？</h1><p>通过上述的demo可以看到，WebSocket都是基于连接的，也就是说我们知道data是从那个connection发过来，但并不知道使用客户端的是A或者B,如果A只想给B发消息，此时我们就需要在Server端能够标识用户身份和连接的对应关系。<br>于是，需要在客户端连接到WebSocket之后，紧接着再发一次请求，告诉Server我的user_id是多少，Server将此user_id与connection之间的关系存储在hashmap中，至此就建立了user_id与connection的对应关系。当需要发送消息给对应的客户端，从此hashmap中取出对应用户的connection信息，调用其send方法发出消息即可。<br>依赖包<br>npm install hashmap</blockquote></p>
<h2 id="服务端实现-1"><a href="#服务端实现-1" class="headerlink" title="服务端实现"></a>服务端实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>).Server, webSocketServer = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">8080</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> HashMap = <span class="built_in">require</span>(<span class="string">&#x27;hashmap&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// record the client</span></span><br><span class="line"><span class="keyword">var</span> userConnectionMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">var</span> connectNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection</span></span><br><span class="line">webSocketServer.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    ++connectNum;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A client has connected. current connect num is : &#x27;</span> + connectNum);</span><br><span class="line">    ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> objMessage = <span class="built_in">JSON</span>.parse(message);</span><br><span class="line">        <span class="keyword">var</span> strType  = objMessage[<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">switch</span>(<span class="params">strType</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;online&#x27;</span> : </span><br><span class="line">                userConnectionMap.set(objMessage[<span class="string">&#x27;from&#x27;</span>], ws);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">var</span> targetConnection = userConnectionMap.get(objMessage[<span class="string">&#x27;to&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (targetConnection) &#123;</span><br><span class="line">                    targetConnection.send(message);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objMessage = <span class="built_in">JSON</span>.parse(message);</span><br><span class="line">    userConnectionMap.remove(objMessage[<span class="string">&#x27;from&#x27;</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>npm包开发调试</title>
    <url>/2020/11/14/node/npm-link/</url>
    <content><![CDATA[<p>开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候， </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;myModule&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的 node_modules 目录之中。对于开发中的模块，解决方法就是在全局的 node_modules 目录之中，生成一个符号链接，指向模块的本地目录。 </p>
<blockquote>
<p>npm link 就能起到这个作用，会自动建立这个符号链接。 </p>
</blockquote>
<p>请设想这样一个场景，你开发了一个模块 myModule ，目录为 src/myModule ，你自己的项目 myProject 要用到这个模块，项目目录为 src/myProject </p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ul>
<li>在模块目录（ src/myModule ）下运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/myModule$ npm link  </span></span><br><span class="line">    npm link</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是<br>package.json 文件中指定的模块名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/path/to/global/node_modules/myModule -&gt; src/myModule</span><br></pre></td></tr></table></figure>
<p>这个时候，已经可以全局调用 myModule 模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。 </p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><ul>
<li>切换到项目目录，再次运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm link 命令，并指定模块名。 </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/myProject$ npm link myModule</span><br></pre></td></tr></table></figure>
上面命令等同于生成了本地模块的符号链接。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule</span><br><span class="line">```  </span><br><span class="line">然后，就可以在你的项目中，加载该模块了。 </span><br><span class="line">``` javascript</span><br><span class="line">var myModule = require(<span class="string">&#x27;myModule&#x27;</span>);</span><br></pre></td></tr></table></figure>
这样一来， myModule 的任何变化，都可以直接反映在 myProject 项目之中。但是，这样也出现了风险，任何在 myProject 目录中对 myModule 的修改，都会反映到模块的源码中。 如果你的项目不再需要该模块，可以在项目目录内使用 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm unlink 命令，删除符号链接。 </span><br><span class="line"></span><br><span class="line">src/myProject$ npm unlink myModule</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>npm 包发布流程</title>
    <url>/2020/11/14/node/npm-deploy/</url>
    <content><![CDATA[<h2 id="【npm】利用npm安装-删除-发布-更新-撤销发布包"><a href="#【npm】利用npm安装-删除-发布-更新-撤销发布包" class="headerlink" title="【npm】利用npm安装/删除/发布/更新/撤销发布包"></a><a href="https://www.cnblogs.com/penghuwan/p/6973702.html">【npm】利用npm安装/删除/发布/更新/撤销发布包</a></h2><ul>
<li>npm adduser用于在<a href="http://npmjs.com/">npmjs.com</a>注册一个用户。</li>
<li> 已注册  npm login</li>
<li> npm publish</li>
</ul>
<blockquote>
<p>注意：登录时报错：e409 Conflict</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registry returned 409 <span class="keyword">for</span> PUT on http://registry.npm.taobao.org/-/user/org.couchdb.user:666: conflict</span><br></pre></td></tr></table></figure>

<p>出现这个错误最大的可能性是我们把registry选项替换成了淘宝的镜像</p>
<p>登录前确保npm源为官方源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm  ls</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><a href="http://zccbbg.top/2018/12/24/npm-adduser-%E6%8A%A5%E9%94%99e409-Conflict/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm login --registry http://registry.npmjs.org</span><br><span class="line"></span><br><span class="line">npm publish --registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ul>
<li><p>发布一个beta版，默认为latest</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish --tag beta</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想废弃某个版本的模块，可以使用npm deprecate命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm deprecate my-thing@<span class="string">&quot;&lt;  0.2.3&quot;</span> <span class="string">&quot;critical bug fixed in v0.2.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行上面的命令以后，小于0.2.3版本的模块的package.json都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出指定模块的维护者</span></span><br><span class="line">$ npm owner ls &lt; package name &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增维护者</span></span><br><span class="line">$ npm owner add &lt; user &gt; &lt; package name &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除维护者</span></span><br><span class="line">$ npm owner rm &lt; user &gt; &lt; package name &gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>cookie-parser 和 express-session</title>
    <url>/2020/11/14/network/cookie-parser/</url>
    <content><![CDATA[<blockquote>
<p>cookie-parser 在用 express 生成器构建项目时自动安装的，它的作用就是设置，获取和删除 cookie。express-session 依赖于它。</p>
</blockquote>
<h2 id="cookie-parser"><a href="#cookie-parser" class="headerlink" title="cookie-parser"></a>cookie-parser</h2><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">var cookieParser = require(&#x27;cookie-parser&#x27;);    #引入模块</span><br><span class="line">app.use(cookieParser());        #挂载中间件，可以理解为实例化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两行代码默认在app.js中写好了，表示现在可以直接使用 cookie 了。</p>
<h2 id="2-创建cookie"><a href="#2-创建cookie" class="headerlink" title="2. 创建cookie"></a>2. 创建cookie</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.cookie(name, value [, options]);</span><br></pre></td></tr></table></figure>

<p>name 是 cookie 名，value 是 cookie 值，可以是 json 对象或字符串。options 是选项，详细请阅<a href="http://www.expressjs.com.cn/4x/api.html#res.cookie" rel="nofollow noreferrer" target="_blank">这里</a>，常用选项有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#39;maxAge&#39;: 90000,    # 有效时长，即90000毫秒后过期，String</span><br><span class="line">    &#39;signed&#39;: false     # 默认为false，表示是否签名，Boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 cookie 会在 http 响应头中添加Set-Cookie，从而在浏览器中设置 cookie<h3 id="articleHeader3">3. 获取cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cookies &#x3D; req.cookies      # 获取cookie集合</span><br><span class="line">var value &#x3D; req.cookies.key    # 获取名称为key的cookie的值</span><br></pre></td></tr></table></figure>
<h2 id="4-删除cookie"><a href="#4-删除cookie" class="headerlink" title="4. 删除cookie"></a>4. 删除cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.clearCookie(name [, options])</span><br></pre></td></tr></table></figure>

<p>name 是 cookie 名，options 与创建 cookie 时所传一致</p>
<h2 id="5-签名"><a href="#5-签名" class="headerlink" title="5. 签名"></a>5. 签名</h2><p>上文所写 cookie 的各种操作，都是没有经过签名的。签名可以提高安全性。下面是使用签名生成 cookie的方法，大同小异，修改上文即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(cookieParser(<span class="string">&#x27;ruidoc&#x27;</span>)); </span><br><span class="line"><span class="comment">//  需要传一个自定义字符串作为secret</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # 创建cookie的options中，必填 signed: true</span></span><br><span class="line">res.cookie(name, value, &#123;    </span><br><span class="line">        <span class="string">&#x27;signed&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">var cookies = req.signedCookies      # 获取cookie集合</span><br><span class="line">var value = req.signedCookies.key    # 获取名称为key的cookie的值</span><br></pre></td></tr></table></figure>

<p>提示：使用签名时这三处必须一起修改，只改一处是无效的！</p>
<h2 id="6-栗子"><a href="#6-栗子" class="headerlink" title="6. 栗子"></a>6. 栗子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置cookie名为user，值为对象，90000ms过期，无签名</span></span><br><span class="line">res.cookie(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">&#x27;ruidoc&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        maxAge: <span class="number">900000</span> </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设置的cookie</span></span><br><span class="line"><span class="keyword">var</span> user = req.cookies.user</span><br><span class="line"><span class="comment">// 设置cookie名为admin，值为对象，无过期时间，有签名</span></span><br><span class="line">res.cookie(<span class="string">&#x27;admin&#x27;</span>, &#123; <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span> &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;signed&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设置的cookie</span></span><br><span class="line"><span class="keyword">var</span> admin = req.signedCookies.admin</span><br></pre></td></tr></table></figure>

<p>options 中没有设置过期时间的话，默认关闭浏览器即过期清除</p>
<h2 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h2><p>express-session 才是真正在服务端保存数据的中间件，它需要独立安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express-session --save</span><br></pre></td></tr></table></figure>

<p>然后在app.js中引入，在app.use(cookieParser()) 之后挂载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line">app.use(session([options]));</span><br></pre></td></tr></table></figure>

<p>同样说几个常用的options</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;secret&#x27;: &#x27;ruidoc&#x27;,     # 签名，与上文中cookie设置的签名字符串一致，</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;maxAge&#x27;</span>: <span class="number">90000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;name&#x27;: &#x27;session_id&#x27;    # 在浏览器中生成cookie的名称key，默认是connect.sid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为创建 session 的同时会创建 cookie 来保存 sessionId，所以options 中的 cookie.maxAge 可看作是 session 的有效时长。</p>
<h2 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 创建一个session</span><br><span class="line">req.session.key = value</span><br><span class="line"></span><br><span class="line"># 创建多个session</span><br><span class="line">req.session = &#123;</span><br><span class="line">    key1: value1,</span><br><span class="line">    key2: value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取session"><a href="#获取session" class="headerlink" title="获取session"></a>获取session</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">var session = req.session      # 获取session集合</span><br><span class="line">var value = req.session.key    # 获取名称为key的session的值</span><br></pre></td></tr></table></figure>
<h2 id="销毁session"><a href="#销毁session" class="headerlink" title="销毁session"></a>销毁session</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空所有session</span></span><br><span class="line">req.session.key.destroy()    # 销毁名称为key的session的值&quot; title=&quot;&quot;&gt;</span><br><span class="line">req.session.destroy()      # 清空所有session</span><br><span class="line">req.session.key.destroy()    # 销毁名称为key的session的值</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000009663833" target="_blank">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>cookie 和 session</title>
    <url>/2020/11/14/network/cookie-session/</url>
    <content><![CDATA[<blockquote>
<p>HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据</p>
</blockquote>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：<ul><li>1、服务器向客户端发送 cookie。<ul><li>通常使用 HTTP 协议规定的 set-cookie 头操作。</li><li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。</li></ul></li><li>2、浏览器将 cookie 保存。</li><li>3、每次请求浏览器都会将 cookie 发向服务器。</li></ul><br>其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：<ul><li>path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。</li><li>expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间(单位：s)。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。</li><li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li><li><br>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</li></ul></p>
<h2 id="express-中的-cookie"><a href="#express-中的-cookie" class="headerlink" title="express 中的 cookie"></a>express 中的 cookie</h2><p>express4 中操作 cookie 使用 cookie-parser 模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先引入 cookie-parser 这个模块</span></span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cookieParser中间件，cookieParser(secret, options)</span></span><br><span class="line"><span class="comment">// 其中secret用来加密 cookie 字符串（下面会提到 signedCookies）</span></span><br><span class="line"><span class="comment">// options 传入上面介绍的 cookie 可选参数</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果请求中的 cookie 存在 isVisit, 则输出 cookie</span></span><br><span class="line">        <span class="comment">// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟</span></span><br><span class="line">        <span class="keyword">if</span> (req.cookies.isVisit) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(req.cookies);</span><br><span class="line">        res.send(<span class="string">&quot;再次欢迎访问&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.cookie(<span class="string">&#x27;isVisit&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span>&#125;);</span><br><span class="line">    res.send(<span class="string">&quot;欢迎第一次访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。</p>
<p>session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。</p>
<p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p>
<p>session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中。线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到。</p>
<p>express 中操作 session 要用到 express-session (&lt;a rel=”nofollow” href=”<a href="https://github.com/expressjs/session&quot;">https://github.com/expressjs/session&quot;</a> “=””&gt;<a href="https://github.com/expressjs/session">https://github.com/expressjs/session</a></a> ) 这个模块，主要的方法就是 session(options)，其中 options 中包含可选参数，主要有：<ul><li>name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。</li><li>store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。</li><li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。</li><li>cookie: 设置存放 session id 的 cookie 的相关选项，默认为<ul><li>(default: { path: ‘/‘, httpOnly: true, secure: false, maxAge: null })</li></ul></li><li>genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。</li><li>rolling: 每个请求都重新设置一个 cookie，默认为 false。</li><li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true。</li></ul></p>
<p>1） 在内存中存储 session<br>express-session 默认使用内存来存 session，对于开发调试来说很方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先引入 express-session 这个模块</span></span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照上面的解释，设置 session 的可选参数</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 建议使用 128 个字符的随机字符串  secret: &#x27;recommand 128 bytes random string&#x27;,</span></span><br><span class="line">    cookie: &#123; <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span> &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 session 中的 isVisit 字段</span></span><br><span class="line">    <span class="comment">// 如果存在则增加一次，否则为session设置isVisit字段，并初始化为 1。</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">req.session.isVisit</span>)</span> &#123;</span><br><span class="line">        req.session.isVisit++;</span><br><span class="line">        res.send(<span class="string">&#x27;&amp;lt;p&gt;第&#x27;</span>+req.session.isVisit+<span class="string">&#x27;次来此页面&amp;lt;/p&gt;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">        res.send(<span class="string">&quot;欢迎第一次来这里&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(req.session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>2） 在 redis 中存储 session</p>
<p>session 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session。</p>
<p>假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中。而下一次访问时，他被负载均衡到了进程2，则此时进程2的内存中没有他的信息，认为他是个新用户。这就会导致用户在我们服务中的状态不一致。</p>
<p>使用 redis 作为缓存，可以使用 connect-redis 模块(&lt;a rel=”nofollow” href=”<a href="https://github.com/tj/connect-redis&quot;">https://github.com/tj/connect-redis&quot;</a> “=””&gt;<a href="https://github.com/tj/connect-redis">https://github.com/tj/connect-redis</a></a> )来得到 redis 连接实例，然后在 session 中设置存储方式为该实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> redisStore = <span class="built_in">require</span>(<span class="string">&#x27;connect-redis&#x27;</span>)(session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    <span class="comment">// 假如你不想使用 redis 而想要使用 memcached 的话</span></span><br><span class="line">    <span class="comment">// 代码改动也不会超过 5 行。</span></span><br><span class="line">    <span class="comment">// 这些 store 都遵循着统一的接口，</span></span><br><span class="line">    <span class="comment">// 凡是实现了那些接口的库，都可以作为 session 的 store 使用</span></span><br><span class="line">    <span class="comment">// 比如都需要实现.get(keyString)和.set(keyString, value) 方法。</span></span><br><span class="line">    <span class="comment">// 编写自己的 store 也很简单</span></span><br><span class="line">        store: <span class="keyword">new</span> redisStore(),</span><br><span class="line">        secret: <span class="string">&#x27;somesecrettoken&#x27;</span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">req.session.isVisit</span>)</span> &#123;</span><br><span class="line">        req.session.isVisit++;</span><br><span class="line">        res.send(<span class="string">&#x27;&amp;lt;p&gt;第&#x27;</span>+req.session.isVisit+<span class="string">&#x27;次来到此页面&amp;lt;/p&gt;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">        res.send(<span class="string">&#x27;欢迎第一次来这里&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>我们可以运行 redis-cli 查看结果，如图可以看到 redis 中缓存结果。</code></pre>
<p><img src="/img.net0.png"></p>
<h2 id="各种存储的利弊"><a href="#各种存储的利弊" class="headerlink" title="各种存储的利弊"></a>各种存储的利弊</h2><p>上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库<br>其中，开发环境存内存就好了。一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题。但内存 session 除了省事之外，没有别的好处。</p>
<p>cookie session 我们下面会提到，现在说说利弊。用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息。当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的。它的弊端是增大了数据量传输，利端是方便。</p>
<p>缓存方式是最常用的方式了，即快，又能共享状态。相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输。推荐使用。</p>
<p>数据库 session。除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧。</p>
<h2 id="signedCookie"><a href="#signedCookie" class="headerlink" title="signedCookie"></a>signedCookie</h2><p>上面都是讲基础，现在讲一些专业点的。<br>上面有提到cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造其实不是这样的，那只是为了方便理解才那么写。要知道，计算机领域有个名词叫 签名，专业点说，叫 信息摘要算法。</p>
<p>比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证。相应的 cookie 长这样：<br>dotcom_user=alsotang，它说明现在的用户是 alsotang 这个用户。如果我在浏览器中装个插件，把它改成 dotcom_user=ricardo，服务器一读取，就会误认为我是 ricardo。然后我就可以进行 ricardo 才能进行的操作了。之前 web 开发不成熟的时候，用这招甚至可以黑个网站下来，把 cookie 改成 dotcom_user=admin 就行了，唉，那是个玩黑客的黄金年代啊。</p>
<p>OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名。<br>假设我的服务器有个秘密字符串，是 this_is_my_secret_and_fuck_you_all，我为用户 cookie 的 dotcom_user 字段设置了个值 alsotang。cookie 本应是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">dotcom_user</span>: <span class="string">&#x27;alsotang&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的。<br>而如果我们签个名，比如把 dotcom_user 的值跟我的 secret_string 做个 sha1<br>sha1(‘secret’ + ‘alsotang’) === ‘4850a42e3…’<br>然后把 cookie 变成这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dotcom_user: <span class="string">&#x27;alsotang&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dotcom_user.sig&#x27;</span>: <span class="string">&#x27;4850a42e3...&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，用户就没法伪造信息了。一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致。<br>毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高。</p>
<h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie-session"></a>cookie-session</h2><p>上面一直提到 session 可以存在 cookie 中，现在来讲讲具体的思路。这里所涉及的专业名词叫做 对称加密。<br>假设我们想在用户的 cookie 中存 session data，使用一个名为 session_data 的字段。<br>存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sessionData = &#123;</span><br><span class="line">    username: <span class="string">&#x27;alsotang&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    company:<span class="string">&#x27;alibaba&#x27;</span>,</span><br><span class="line">    location: <span class="string">&#x27;hangzhou&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这段信息的话，可以将 sessionData 与我们的 secret_string 一起做个对称加密，存到 cookie 的 session_data字段中，只要你的 secret_string 足够长，那么攻击者也是无法获取实际 session 内容的。对称加密之后的内容对于攻击者来说相当于一段乱码。</p>
<p>而当用户下次访问时，我们就可以用 secret_string 来解密 sessionData，得到我们需要的 session data。<br>signedCookies 跟 cookie-session 还是有区别的：</p>
<p>1）是前者信息可见不可篡改，后者不可见也不可篡改</p>
<p>2）是前者一般是长期保存，而后者是 session cookie</p>
<p>cookie-session 的实现跟 signedCookies 差不多。</p>
<p>不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险。</p>
<p>回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中。他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了。而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分。</p>
<p>如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中。这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了。如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中。</p>
<h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session cookie"></a>session cookie</h2><p>初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。</p>
<p>常见的场景就是在开发用户登陆状态保持时。</p>
<p>假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。</p>
<p>比如有这样一个用户</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    username: <span class="string">&#x27;alsotang&#x27;</span>, </span><br><span class="line">    age: <span class="number">22</span>, </span><br><span class="line">    company: <span class="string">&#x27;alibaba&#x27;</span>, </span><br><span class="line">    location: <span class="string">&#x27;hangzhou&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username。<br>登陆的检验过程伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">        <span class="comment">// 获取 user 并进行下一步</span></span><br><span class="line">        next()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.signedCookies[<span class="string">&#x27;username&#x27;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 如果存在则从数据库中获取这个username 的信息,并保存到 session 中</span></span><br><span class="line">        getuser(<span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">        req.session.user = user;</span><br><span class="line">        next();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当做为登陆用户处理</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://wiki.jikexueyuan.com/project/node-lessons/cookie-session.html" target="_blank">原文地址</a>“</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 状态消息</title>
    <url>/2020/11/14/network/dns/</url>
    <content><![CDATA[<p>以Chrome 浏览器为例：（访问： <a href="http://www.google.com/">www.google.com</a></p>
<p>1、 Chrome 浏览器 会首先搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存），看自身的缓存中是否有 <a href="http://www.google.com/">www.google.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p>
<blockquote>
<p>注：我们怎么查看Chrome自身的缓存？可以使用 <a href="chrome://net-internals/#dns" target="_blank">chrome://net-internals/#dns</a> 来进行查看</p>
</blockquote>
<p>2、如果浏览器自身的缓存里面没有找到对应的条目，那么 Chrome 会搜索操作系统自身的 DNS 缓存,如果找到且没有过期则停止搜索解析到此结束.</p>
<blockquote>
<p>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p>
</blockquote>
<p>3、如果在 Windows 系统的 DNS 缓存也没有找到，那么尝试读取 hosts 文件（位于 C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的 IP 地址，如果有则解析成功。</p>
<p>4、如果在 hosts 文件中也没有找到对应的条目，浏览器就会发起一个 DNS 的系统调用，就会向本地配置的首选 DNS 服务器发起域名解析请求。<br>（递归，通过的是UDP协议向DNS的53端口发起请求</p>
<p>4.1、运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功</p>
<p>4.2、如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求</p>
<p>4.2.1、找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），并发起请求，返回com域的IP地址</p>
<p>4.2.2、向com域的IP地址发起请求,返回google.com这个域的DNS地址</p>
<p>4.2.3、向google.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求，返回<a href="http://www.google.com这个域名对应的ip地址,并返回给windows系统内核,内核又把结果返回给浏览器,终于浏览器拿到了www.google.com/">www.google.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.google.com</a>  对应的IP地址</p>
<p>一图胜千言：<br><img src="/img/dns.jpg"></p>
<p>资料：<br><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank">DNS 原理入门</a></p>
<p><a href="http://www.178linux.com/49376" target="_blank">DNS详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>Http 206 文件断点续传下载原理</title>
    <url>/2020/11/14/network/http-206/</url>
    <content><![CDATA[<blockquote>
<p>断点续传下载需要重视2对头信息Accept-Ranges/Range与If-Range/tag</p>
</blockquote>
<h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a><a href="http://www.cnblogs.com/phpstudy2015-6/p/6821478.html" target="_blank">断点续传</a></h2><h2 id="检测服务器端是否支持范围请求"><a href="#检测服务器端是否支持范围请求" class="headerlink" title="检测服务器端是否支持范围请求"></a>检测服务器端是否支持范围请求</h2><p>假如在响应中存在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges" title="服务器使用 HTTP 响应头 Accept-Range 标识自身支持范围请求(partial requests)。字段的具体值用于定义范围请求的单位。">Accept-Ranges</a> 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。例如，你可以使用 cURL 发送一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" title="HTTP HEAD 方法 请求资源的首部信息, 并且这些首部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.">HEAD</a> 请求来进行检测。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -I http:<span class="comment">//i.imgur.com/z4d4kWk.jpg</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: <span class="number">146515</span></span><br></pre></td></tr></table></figure>

<p>在上面的响应中， Accept-Ranges: bytes 表示界定范围的单位是 bytes 。这里  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length" title="Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。">Content-Length</a> 也是有效信息，因为它提供了要检索的图片的完整大小。</p>
<p>如果站点未发送 Accept-Ranges 首部，那么它们有可能不支持范围请求。一些站点会明确将其值设置为 “none”，以此来表明不支持。在这种情况下，某些应用的下载管理器会将暂停按钮禁用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -I https:<span class="comment">//www.youtube.com/watch?v=EwTZ2xpQwpA</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure>
<h2 id="从服务器端请求特定的范围"><a href="#从服务器端请求特定的范围" class="headerlink" title="从服务器端请求特定的范围"></a>从服务器端请求特定的范围</h2><p>假如服务器支持范围请求的话，你可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range" title="The Range 是一个请求首部，告知服务器返回文件的哪一部分。在一个  Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码。假如所请求的范围不合法，那么服务器会返回  416 Range Not Satisfiable 状态码，表示客户端错误。服务器允许忽略  Range  首部，从而返回整个文件，状态码用 200 。">Range</a> 首部来生成该类请求。该首部指示服务器应该返回文件的哪一或哪几部分。</p>
<h3 id="单一范围"><a href="#单一范围" class="headerlink" title="单一范围"></a>单一范围</h3><p>我们可以请求资源的某一部分。这次我们依然用 cURL 来进行测试。”-H” 选项可以在请求中追加一个首部行，在这个例子中，是用 Range 首部来请求图片文件的前 1024 个字节。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl http:<span class="comment">//i.imgur.com/z4d4kWk.jpg -i -H &quot;Range: bytes=0-1023&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样生成的请求如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=<span class="number">0</span>-<span class="number">1023</span></span><br></pre></td></tr></table></figure>

<p>服务器端会返回状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206" title="HTTP 206 Partial Content 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。">206</a> Partial Content 的响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">1023</span>/<span class="number">146515</span></span><br><span class="line">Content-Length: <span class="number">1024</span></span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure>

<p>在这里，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length" title="Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。">Content-Length</a> 首部现在用来表示先前请求范围的大小（而不是整张图片的大小）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Range" title="在HTTP协议中，响应首部 Content-Range 显示的是一个数据片段在整个文件中的位置。">Content-Range</a> 响应首部则表示这一部分内容在整个资源中所处的位置。<h3 id="多重范围">多重范围<br>Range头部也支持一次请求文档的多个部分。请求范围用一个逗号分隔开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl http:<span class="comment">//www.example.com -i -H &quot;Range: bytes=0-50, 100-150&quot;</span></span><br></pre></td></tr></table></figure>

<p>服务器返回206 Partial Content状态码和Content-Type：multipart/byteranges; boundary=3d6b6a416f9b5头部，Content-Type：multipart/byteranges表示这个响应有多个byterange。每一部分byterange都有他自己的Centen-type头部和Content-Range，并且使用boundary参数对body进行划分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=<span class="number">3</span>d6b6a416f9b5</span><br><span class="line">Content-Length: <span class="number">282</span></span><br><span class="line"></span><br><span class="line">--<span class="number">3</span>d6b6a416f9b5</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">50</span>/<span class="number">1270</span></span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Do</span><br><span class="line">--<span class="number">3</span>d6b6a416f9b5</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Range: bytes <span class="number">100</span>-<span class="number">150</span>/<span class="number">1270</span></span><br><span class="line"></span><br><span class="line">eta http-equiv=<span class="string">&quot;Content-type&quot;</span> content=<span class="string">&quot;text/html; c</span></span><br><span class="line"><span class="string">--3d6b6a416f9b5--</span></span><br></pre></td></tr></table></figure>
<h3 id="条件式范围请求"><a href="#条件式范围请求" class="headerlink" title="条件式范围请求"></a>条件式范围请求</h3><p>当（中断之后）重新开始请求更多资源片段的时候，必须确保自从上一个片段被接收之后该资源没有进行过修改。<br>The <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" title="If-Range HTTP 请求头字段用来使得 Range 头字段在一定条件下起作用：当字段值中的条件得到满足时，Range 头字段才会起作用，同时服务器回复206 部分内容状态码，以及Range 头字段请求的相应部分；如果字段值中的条件没有得到满足，服务器将会返回 200 OK 状态码，并返回完整的请求资源。">If-Range</a> 请求首部可以用来生成条件式范围请求：假如条件满足的话，条件请求就会生效，服务器会返回状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206" title="HTTP 206 Partial Content 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。">206</a> Partial 的响应，以及相应的消息主体。假如条件未能得到满足，那么就会返回状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" title="状态码 200 OK 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。">200</a> OK 的响应，同时返回整个资源。该首部可以与  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" title="The Last-Modified  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。包含有  If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。">Last-Modified</a> 验证器或者  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" title="ETagHTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。">ETag</a> 一起使用，但是二者不能同时使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">If-Range: Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">0</span>7:<span class="number">28</span>:<span class="number">0</span>0 GMT</span><br></pre></td></tr></table></figure>
<h2 id="范围请求的响应"><a href="#范围请求的响应" class="headerlink" title="范围请求的响应"></a>范围请求的响应</h2><p>与范围请求相关的有三种状态：<ul><li>在请求成功的情况下，服务器会返回  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206" title="HTTP 206 Partial Content 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。">206</a> Partial Content 状态码。</li><li>在请求的范围越界的情况下（范围值超过了资源的大小），服务器会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/416" title="HTTP 416 Range Not Satisfiable 错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。">416</a>Requested Range Not Satisfiable （请求的范围无法满足） 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" title="状态码 200 OK 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。">200</a> OK 状态码。</li></ul></p>
<h2 id="与分块传输编码的对比"><a href="#与分块传输编码的对比" class="headerlink" title="与分块传输编码的对比"></a>与分块传输编码的对比</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" title="Transfer-Encoding 消息首部指明了将 entity 安全传递给用户所采用的编码形式。">Transfer-Encoding</a> 首部允许分块编码，这在数据量很大，并且在请求未能完全处理完成之前无法知晓响应的体积大小的情况下非常有用。服务器会直接把数据发送给客户端而无需进行缓冲或确定响应的精确大小——后者会增加延迟。范围请求与分块传输是兼容的，可以单独或搭配使用。</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 状态消息</title>
    <url>/2020/11/14/network/http-code/</url>
    <content><![CDATA[<h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx: 信息"></a>1xx: 信息</h2><p>该状态码属于临时响应类型，代表请求已被接受，需要继续处理。</p>
<p>该类状态码只包含状态行和某些可选的响应头信息，并以空行结束。</p>
<table><tbody><tr><th align="left" width="40%">消息：</th><th align="left" width="60%">描述：</th></tr><tr><td>100 Continue</td><td>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td>101 Switching Protocols</td><td>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr><tr><td>103 Checkpoint</td><td>用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。</td></tr></tbody></table>

<h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx: 成功"></a>2xx: 成功</h2><p>该类型的状态码，表示请求已成功被服务器接收、理解、并接受。</p>
<table><tbody><tr><th align="left" width="40%">消息：</th><th align="left" width="60%">描述：</th></tr><tr><td>200 OK</td><td>请求成功（这是对HTTP请求成功的标准应答。）</td></tr><tr><td>201 Created</td><td>请求被创建完成，同时新的资源被创建。</td></tr><tr><td>202 Accepted</td><td>供处理的请求已被接受，但是处理未完成。</td></tr><tr><td>203 Non-Authoritative Information</td><td>请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。</td></tr><tr><td>204 No Content</td><td>请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td>205 Reset Content</td><td>请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td>206 Partial Content</td><td>客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table>

<h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><p>该类状态码完成请求的要求是需要客户端采取进一步的操作。它通常用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p>
<table><tbody><tr><th align="left" width="40%">消息：</th><th align="left" width="60%">描述：</th></tr><tr><td>300 Multiple Choices</td><td>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td>301 Moved Permanently</td><td>所请求的页面已经转移至新的 URL 。</td></tr><tr><td>302 Found</td><td>所请求的页面已经临时转移至新的 URL 。</td></tr><tr><td>303 See Other</td><td>所请求的页面可在别的 URL 下被找到。</td></tr><tr><td>304 Not Modified</td><td>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td>305 Use Proxy</td><td>客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td>306 Switch Proxy</td><td><i>目前已不再使用，但是代码依然被保留。</i></td></tr><tr><td>307 Temporary Redirect</td><td>被请求的页面已经临时移至新的 URL 。</td></tr><tr><td>308 Resume Incomplete</td><td>用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。</td></tr></tbody></table>

<h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><p>该类的状态码表示客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
<table><tbody><tr><th align="left" width="40%">消息：</th><th align="left" width="60%">描述：</th></tr><tr><td>400 Bad Request</td><td>因为语法错误，服务器未能理解请求。</td></tr><tr><td>401 Unauthorized</td><td>合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。</td></tr><tr><td>402 Payment Required</td><td><i>此代码尚无法使用。</i></td></tr><tr><td>403 Forbidden</td><td>合法请求，但对被请求页面的访问被禁止。</td></tr><tr><td>404 Not Found</td><td>服务器无法找到被请求的页面。</td></tr><tr><td>405 Method Not Allowed</td><td>请求中指定的方法不被允许。</td></tr><tr><td>406 Not Acceptable</td><td>服务器生成的响应无法被客户端所接受。</td></tr><tr><td>407 Proxy Authentication Required</td><td>用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td>408 Request Timeout</td><td>请求超出了服务器的等待时间。</td></tr><tr><td>409 Conflict</td><td>由于冲突，请求无法被完成。</td></tr><tr><td>410 Gone</td><td>被请求的页面不可用。</td></tr><tr><td>411 Length Required</td><td>"Content-Length" 未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td>412 Precondition Failed</td><td>请求中的前提条件被服务器评估为失败。</td></tr><tr><td>413 Request Entity Too Large</td><td>由于所请求的实体太大，服务器不会接受请求。</td></tr><tr><td>414 Request-URI Too Long</td><td>由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。</td></tr><tr><td>415 Unsupported Media Type</td><td>由于媒介类型不被支持，服务器不会接受请求。</td></tr><tr><td>416 Requested Range Not Satisfiable</td><td>客户端请求部分文档，但是服务器不能提供被请求的部分。</td></tr><tr><td>417 Expectation Failed</td><td>服务器不能满足客户在请求中指定的请求头。</td></tr></tbody></table>

<h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx: 服务器错误"></a>5xx: 服务器错误</h2><p>该类状态码表示服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器无法使用当前的软硬件资源完成对请求的处理。</p>
<table><tbody><tr><th align="left" width="40%">消息：</th><th align="left" width="60%">描述：</th></tr><tr><td>500 Internal Server Error</td><td>请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td>501 Not Implemented</td><td>请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。</td></tr><tr><td>502 Bad Gateway</td><td>请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。</td></tr><tr><td>503 Service Unavailable</td><td>服务器当前不可用（过载或者当机）。</td></tr><tr><td>504 Gateway Timeout</td><td>网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。</td></tr><tr><td>505 HTTP Version Not Supported</td><td>服务器不支持请求中指明的HTTP协议版本。</td></tr><tr><td>511 Network Authentication Required</td><td>用户需要提供身份验证来获取网络访问入口。</td></tr></tbody></table>]]></content>
  </entry>
  <entry>
    <title>跨域资源共享 CORS 详解</title>
    <url>/2020/11/14/network/http-cors/</url>
    <content><![CDATA[<blockquote>
<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。  它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
</blockquote>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h1 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h1><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：<ul><li>HEAD</li><li>GET</li><li>POST</li></ul><br>（2）HTTP的头信息不超出以下几种字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><br>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p>
<h1 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h1><h2 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h2><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;api.bob.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;api.bob.com&lt;&#x2F;a&gt;</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;api.bob.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;api.bob.com&lt;&#x2F;a&gt;</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。<br>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
<h2 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h2><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">xhr.withCredentials &#x3D; false;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<h1 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h1><h2 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;&lt;a href=&quot;http://api.alice.com/cors&quot;&gt;http://api.alice.com/cors&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。<br>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://api.bob.com/&quot;</span>&gt;</span>http://api.bob.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。<br>（1）Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。<br>（2）Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>
<h2 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h2><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">0</span>1 Dec <span class="number">2008</span> <span class="number">0</span>1:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-Origin: <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://api.bob.com/&quot;</span>&gt;</span>http://api.bob.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据.该字段也可以设为星号,表示同意任意跨源请求./">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">XMLHttpRequest cannot load http:&#x2F;&#x2F;api.alice.com.</span><br><span class="line">Origin http:&#x2F;&#x2F;api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器回应的其他CORS相关字段如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（1）Access-Control-Allow-Methods</p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p>（2）Access-Control-Allow-Headers</p>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p>（3）Access-Control-Allow-Credentials</p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）Access-Control-Max-Age</p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h2 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h2><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。<br>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PUT /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://api.bob.com/&quot;</span>&gt;</span>http://api.bob.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面头信息的Origin字段是浏览器自动添加的。<br>下面是服务器正常的回应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;api.bob.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;api.bob.com&lt;&#x2F;a&gt;</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
<h1 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h1><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 请求方法：GET 和 POST</title>
    <url>/2020/11/14/network/http-get-post/</url>
    <content><![CDATA[<ul><li>GET - 从指定的资源请求数据。</li><li>POST - 向指定的资源提交要被处理的数据。</li></ul><ul><li>

<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p>
<p>/test/demo_form.php?name1=value1&amp;name2=value2<br>有关 GET 请求的其他一些注释：</li><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul></ul></p>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><pre><code>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：

POST /test/demo_form.php HTTP/1.1
Host: w3cschool.cn
name1=value1&amp;amp;name2=value2
有关 POST 请求的其他一些注释：</code></pre>
<ul><li>    POST 请求不会被缓存</li><li>    POST 请求不会保留在浏览器历史记录中</li><li>    POST 不能被收藏为书签</li><li>    POST 请求对数据长度没有要求</li></ul>

<h2 id="比较-GET-与-POST"><a href="#比较-GET-与-POST" class="headerlink" title="比较 GET 与 POST"></a>比较 GET 与 POST</h2><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。<table><tbody><tr><th align="left" width="30%"> </th><th align="left" width="35%">GET</th><th align="left" width="35%">POST</th></tr><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>.</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签<br>.</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存<br>.</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded or multipart/form-data。为二进制数据使用多重编码。<br>.</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。<br>.</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。<br>.</td><td>无限制。</p>
</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。
.</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。

<p>在发送密码或其他敏感信息时绝不要使用 GET ！<br>.</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table></p>
<hr>## 其他 HTTP 请求方法
下面的表格列出了其他一些 HTTP 请求方法：<table id="table1"><tbody><tr><th align="left" width="15%">方法</th><th align="left" width="85%">描述</th></tr><tr><td>HEAD</td><td>与 GET 相同，但只返回 HTTP 报头，不返回文档主体。
.</td></tr><tr><td>PUT</td><td>上传指定的 URI 表示。
.</td></tr><tr><td>DELETE</td><td>删除指定资源。
.</td></tr><tr><td>OPTIONS</td><td>返回服务器支持的 HTTP 方法。
.</td></tr><tr><td>CONNECT</td><td>把请求连接转换到透明的 TCP/IP 通道。</td></tr></tbody></table>]]></content>
  </entry>
  <entry>
    <title>HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</title>
    <url>/2020/11/14/network/http-differ/</url>
    <content><![CDATA[<p>一、HTTP的基本优化</p>
<p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</p>
<ul><li>
带宽：忽略。</li><li>
延迟：</li><ul><li>
浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>

</li><li>
DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>

</li><li>
建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul></ul>


<p>二、HTTP1.0和HTTP1.1的一些区别<li><br>缓存处理：</li><li><br>HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，</li><li><br>HTTP1.1则引入了更多的缓存控制策略例如<h5>Last-Modified / If-Modified-Since</h5><br>Etag / If-None-Match</p>
</li><li><h5>Cache-Control</h5></li><li>

</li><li>

</li><li>
带宽优化及网络连接的使用：</li><li>
HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，</li><li>
HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>

</li><li>
错误通知的管理：</li><li>
在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>

</li><li>
Host头处理</li><li>
在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li><li>
HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li>

</li><li>
长连接</li><li>
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li><li>

</li>
三、SPDY：HTTP1.x的优化
2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：

<li>
降低延迟</li><li>
针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li>

</li><li>
请求优先级（request prioritization）</li><li>
多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li>

</li><li>
header压缩</li><li>
前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li>

</li><li>
基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</li><li>

</li><li>
服务端推送（server push）</li><li>
采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了</li><li>

</li>
SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。


<p>四、HTTP2.0<br><a href="https://link.zhihu.com/?target=https://http2.akamai.com/demo" target="_blank">https://link.zhihu.com/?target=https://http2.akamai.com/demo</a></p>
<p>是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p>
<p>五、HTTP2.0：SPDY的升级版</p>
<p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p>
<p>HTTP2.0和SPDY的区别：</p>
<li>
HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>
HTTP2.0 消息头的压缩算法采用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank">HPACK</a>，而非 SPDY 采用的 <a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank">DEFLATE</a></li><li>

</li>
六、HTTP2.0和HTTP1.X相比的新特性

<ul><li>
新的二进制格式（Binary Format）</li><li>
HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>

</li><li>
多路复用（MultiPlexing）</li><li>
即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li>

</li><li>
header压缩</li><li>
如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>

</li><li>
服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li><li>

</li></ul>
七、HTTP2.0的升级改造<ul><li>
HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</li><li>

</li><li>
当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<strong>NGINX白皮书，<a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank">NGINX配置HTTP2.0官方指南</a> 。</li><li>

</li><li>
使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li><li>

</li></ul>
八、附注
HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

<ul><li>
HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li>
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>

</li><li>
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li><li>

</li></ul>
<a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank">服务器推送到底是什么？</a>

<p>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</p>
<p>为什么需要头部压缩？<br>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：<a href="https://imququ.com/post/header-compression-in-http2.html" target="_blank">HTTP/2 头部压缩技术介绍</a></p>
<p>HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<p>参考文档：<br><a href="https://www.nihaoshijie.com.cn/index.php/archives/698/" target="_blank">多路复用与keep-alive</a></p>
<p><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650995461&amp;idx=1&amp;sn=ff45463bbf862517761c17887ef3fd2d" target="_blank">腾讯HTTPS性能优化实践</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank">传输层安全性协议</a> TLS/SSL</p>
<p><a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank">HTTP严格传输安全</a> HSTS</p>
<p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/" target="_blank">HTTP2.0的奇妙日常</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 与 HTTPS</title>
    <url>/2020/11/14/network/http-https/</url>
    <content><![CDATA[<blockquote>
<p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
</blockquote>
<p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p>
<p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p>
<p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</p>
<ul><li>1、TCP 三次同步握手</li><li>2、客户端验证服务器数字证书</li><li>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>4、SSL 安全加密隧道协商完成</li><li>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li><li>
</li></ul>

<h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2><ul><li><span style="font-size: large;">1、HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li><span style="font-size: large;">
</li><li><span style="font-size: large;">2、使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li><span style="font-size: large;">
</li><li><span style="font-size: large;">3、HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li><span style="font-size: large;">
</li><li><span style="font-size: large;">4、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li><span style="font-size: large;">HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li><li><span style="font-size: large;">
</li></ul>

<h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><img src="http://www.runoob.com/wp-content/uploads/2018/09/https-intro.png" style="max-width:100%;">

<p>1、客户端发起 HTTPS 请求</p>
<p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p>
<p>2、服务端的配置</p>
<p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p>
<p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>
<p>3、传送证书</p>
<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>
<p>4、客户端解析证书</p>
<p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<p>5、传送加密信息</p>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p>6、服务段解密信息</p>
<p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p>7、传输加密后的信息</p>
<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<p>8、客户端解密信息</p>
<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>
<h1 id="https处理的一个过程，对称加密和非对称加密"><a href="#https处理的一个过程，对称加密和非对称加密" class="headerlink" title="https处理的一个过程，对称加密和非对称加密"></a><a href="https://blog.csdn.net/qq_16681169/article/details/50933958" target="_blank">https处理的一个过程，对称加密和非对称加密</a></h1><p>SSL协议通信过程</p>
<p>(1) 浏览器发送一个连接请求给服务器;服务器将自己的证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息返回客户端;</p>
<p>(2) 客户端浏览器检查服务器传送到CA证书是否由自己信赖的CA中心签发。若是，执行4步;否则，给客户一个警告信息：询问是否继续访问。</p>
<p>(3) 客户端浏览器比较证书里的信息，如证书有效期、服务器域名和公钥S_PK，与服务器传回的信息是否一致，如果一致，则浏览器完成对服务器的身份认证。</p>
<p>(4) 服务器要求客户端发送客户端证书(包含客户端公钥C_PuKey)、支持的对称加密方案及其他相关信息。收到后，服务器进行相同的身份认证，若没有通过验证，则拒绝连接;</p>
<p>(5) 服务器根据客户端浏览器发送到密码种类，选择一种加密程度最高的方案，用客户端公钥C_PuKey加密后通知到浏览器;</p>
<p>(6) 客户端通过私钥C_PrKey解密后，得知服务器选择的加密方案，并选择一个通话密钥key，接着用服务器公钥S_PuKey加密后发送给服务器;</p>
<p>(7) 服务器接收到的浏览器传送到消息，用私钥S_PrKey解密，获得通话密钥key。</p>
<p>(8) 接下来的数据传输都使用该对称密钥key进行加密。</p>
<p>上面所述的是双向认证 SSL 协议的具体通讯过程，服务器和用户双方必须都有证书。由此可见，SSL协议是通过非对称密钥机制保证双方身份认证，并完成建立连接，在实际数据通信时通过对称密钥机制保障数据安全性</p>
<p>.<br><a href="https://blog.51cto.com/11883699/2160032" target="_blank">HTTPS原理和CA证书申请</a></p>
<p>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p>
<h1 id="DV-SSL"><a href="#DV-SSL" class="headerlink" title="DV SSL"></a>DV SSL</h1><p>DV SSL证书是只验证网站域名所有权的简易型（Class 1级）SSL证书，可10分钟快速颁发，能起到加密传输的作用，但无法向用户证明网站的真实身份。</p>
<p>目前市面上的免费证书都是这个类型的，只是提供了对数据的加密，但是对提供证书的个人和机构的身份不做验证。</p>
<h1 id="OV-SSL"><a href="#OV-SSL" class="headerlink" title="OV SSL"></a>OV SSL</h1><p>OV SSL,提供加密功能,对申请者做严格的身份审核验证,提供可信×××明。<br>和DV SSL的区别在于，OV SSL 提供了对个人或者机构的审核，能确认对方的身份，安全性更高。<br>所以这部分的证书申请是收费的~</p>
<h1 id="EV-SSL"><a href="#EV-SSL" class="headerlink" title="EV SSL"></a>EV SSL</h1><p>超安=EV=最安全、最严格 超安EV SSL证书遵循全球统一的严格身份验证标准，是目前业界安全级别最高的顶级 (Class 4级)SSL证书。<br>金融证券、银行、第三方支付、网上商城等，重点强调网站安全、企业可信形象的网站，涉及交易支付、客户隐私信息和账号密码的传输。<br>这部分的验证要求最高，申请费用也是最贵的。</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP的神秘面纱</title>
    <url>/2020/11/14/network/http-histroy/</url>
    <content><![CDATA[<blockquote>
<p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p>
</blockquote>
<p><img src="/img/http0.png"></p>
<h2 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h2><p><img src="/img/http1.png"></p>
<p>1.物理层：</p>
<p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </p>
<p>　　<br>2.数据链路层：</p>
<p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 　
　</p>
<p>3.网络层：</p>
<p>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p>　　<br>4.传输层：</p>
<p>定义了一些传输数据的协议和端口号（WWW端口80等），如： </p>
<p>TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）<br>UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 </p>
<p>5.会话层：</p>
<p>通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名</p>
<p>6.表示层</p>
<p>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换</p>
<p>7.应用层：</p>
<p>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</p>
<h2 id="HTTP-发展历史HTTP-0-9"><a href="#HTTP-发展历史HTTP-0-9" class="headerlink" title="HTTP 发展历史HTTP/0.9"></a>HTTP 发展历史HTTP/0.9</h2><ul><li>只有一个命令GET</li><li>响应类型: 仅 超文本</li><li>没有header等描述数据的信息</li><li>服务器发送完毕，就关闭TCP连接</li><li>
</li></ul>HTTP/1.0<ul><li>增加了很多命令（post HESD ）</li><li>增加status code 和 header</li><li>多字符集支持、多部分发送、权限、缓存等</li><li>响应：不再只限于超文本 (Content-Type 头部提供了传输 HTML 之外文件的能力 — 如脚本、样式或媒体文件)</li><li>
</li></ul>HTTP/1.1<ul><li>持久连接。TCP三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）</li><li>
</li><li>支持的方法: GET , HEAD , POST , PUT , DELETE , TRACE , OPTIONS</li><li>进行了重大的性能优化和特性增强，分块传输、压缩/解压、内容缓存磋商、虚拟主机（有单个IP地址的主机具有多个域名）、更快的响应，以及通过增加缓存节省了更多的带宽</li><li>
</li></ul>HTTP2<ul><li>所有数据以二进制传输。HTTP1.x是基于文本的，无法保证健壮性，HTTP2.0绝对使用新的二进制格式，方便且健壮</li><li>同一个连接里面发送多个请求不再需要按照顺序来</li><li>头信息压缩以及推送等提高效率的功能</li><li>
</li></ul>URI、URL、URNURI: Uniform Resource Identifier/统一资源标识符
URL: Uniform Resource Locator/统一资源定位器
URN: Uniform Resource Name/永久统一资源定位符
web上的各种资源（html、图片、视频、音频等）都由一个URI标识定位。URI相当于它们的详细“家庭住址”。
URI包含了URL和URN。

<p><img src="/img/http3.jpg"></p>
<p>URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。</p>
<p>URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是一个URI</span><br><span class="line">http:&#x2F;&#x2F;bitpoetry.io&#x2F;posts&#x2F;hello.html#intro</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 资源访问方式</span><br><span class="line">http:&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 资源存储位置</span><br><span class="line">bitpoetry.io&#x2F;posts&#x2F;hello.html</span><br><span class="line"></span><br><span class="line">#intro &#x2F;&#x2F; 资源</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; URL</span><br><span class="line">http:&#x2F;&#x2F;bitpoetry.io&#x2F;posts&#x2F;hello.html</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; URN</span><br><span class="line">bitpoetry.io&#x2F;posts&#x2F;hello.html#intro</span><br></pre></td></tr></table></figure>

<p>#HTTP报文<br>请求报文：<br><img src="/img/http4.jpg"></p>
<p>响应报文：<br><img src="/img/http5.jpg"></p>
<h2 id="HTTP-各种特性-curl"><a href="#HTTP-各种特性-curl" class="headerlink" title="HTTP 各种特性## curl"></a>HTTP 各种特性## curl</h2><p>curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>
<p><a href="http://man.linuxde.net/curl" target="_blank">curl命令</a></p>
<h2 id="CORS跨域请求的限制与解决"><a href="#CORS跨域请求的限制与解决" class="headerlink" title="CORS跨域请求的限制与解决"></a>CORS跨域请求的限制与解决</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前端： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    fetch(url,&#123;</span><br><span class="line"><span class="javascript">        method: <span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line">        headers: &#123;</span><br><span class="line"><span class="javascript">            <span class="string">&#x27;X-Test-Cors&#x27;</span>: <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务端要加个请求头 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line"><span class="comment">// 加上这个设置</span></span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;X-Test-Cors&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 缓存Cache-Control</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Cache-Control&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;public&lt;/td&gt;&lt;td&gt;所有内容都将被缓存(客户端和代理服务器都可缓存)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;private&lt;/td&gt;&lt;td&gt;内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;no-cache&lt;/td&gt;&lt;td&gt;必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;no-store&lt;/td&gt;&lt;td&gt;所有内容都不会被缓存到缓存或 Internet 临时文件中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;must-revalidation/proxy-revalidation&lt;/td&gt;&lt;td&gt;如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;max-age=xxx (xxx is numeric)&lt;/td&gt;&lt;td&gt;缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="comment">// 服务端设置响应头</span></span><br><span class="line">response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span>,</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 缓存20s 多个值用逗号分开  &#x27;Cache-Control&#x27;: &#x27;max-age=20,public&#x27; </span></span><br><span class="line">&#125;)</span><br><span class="line">response.end(<span class="string">&#x27;console.log(&quot;script loaded&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>参考文献：<br><a href="https://finget.github.io/2018/07/03/http/" target="_blank">前端工程师，揭开HTTP的神秘面纱</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank">互联网协议入门（一）</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank">互联网协议入门（二）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/45136487" target="_blank">HTTP协议基础及发展历史</a>“</p>
]]></content>
  </entry>
  <entry>
    <title>http连接优化与浏览器允许的并发请求资源数</title>
    <url>/2020/11/14/network/http-len/</url>
    <content><![CDATA[<blockquote>
<p>前端技术的逐渐成熟，还衍生了domain hash, cookie free, css sprites, js/css combine, max expires time, loading images on demand等等技术。这些技术的出现和大量使用都和并发资源数有关</p>
</blockquote>
<li><a href="https://www.cnblogs.com/hubing/p/4922508.html" target="_blank">原文地址</a></li><li></li><li>1、按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 解决方案是启用和主站不同的域名来放置静态资源，也就是cookie free。</li><li>

</li><li>2、将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 这也就衍生了domain hash技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。</li><li>
</li><li>再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是css sprites的由来。</li><li>
</li><li>3、全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 由于cs/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，js/css combine也就自然衍生了，同时也是minify、compress等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。</li><li>
</li><li>4、随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。</li><li>
</li><li>5、即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。</li>

<h2 id="配置nginx实现通过cookie-free域名发送静态资源"><a href="#配置nginx实现通过cookie-free域名发送静态资源" class="headerlink" title="配置nginx实现通过cookie-free域名发送静态资源"></a>配置nginx实现通过cookie-free域名发送静态资源</h2><h2 id="使用-cookie-free-域名的好处"><a href="#使用-cookie-free-域名的好处" class="headerlink" title="使用 cookie-free 域名的好处"></a>使用 cookie-free 域名的好处</h2><p>当浏览器加载 HTML 文件中引用的静态资源 —— 如图片、外部 CSS、外部 JS 等 —— 时，若该资源所属域与当前页面相同，则会在 HTTP 头请求中加载当前域的 cookie 信息。</p>
<p>你的网站为 <a href="http://www.whatever.com,启用了/">http://www.whatever.com，启用了</a> Google Analytics 或百度统计或任意第三方统计代码。用户访问你的网站首页，首页 html 代码引用了 10 个图片文件，图片地址是 <code>http://www.whatever.com/images/[0-9].jpg</code> （此处有正则）。</p>
<p>因为 Google Analytics 在 <a href="http://www.whatever.com/">http://www.whatever.com</a> 这个域下设置了 cookie，浏览器在加载这些图片时，会把 Google Analytics 设置的 cookie 放在头信息里发过去。</p>
<p>本来一个 cookie 也没多大，顶多 1KB，但是如果你要加载 50 个图片（或其它静态文件），这样发送的 cookie 总量就多达 50KB 了。对于静态资源来说，发送这些 cookie 完全没有意义，所以我们不想让浏览器请求这些静态资源时发送 cookie。</p>
<p>下图是苹果教程网未设置 cookie-free 域名前请求某静态资源时 HTTP 请求头中包含 cookie 内容的惨状</p>
<h2 id="配置nginx实现cookie-free域名"><a href="#配置nginx实现cookie-free域名" class="headerlink" title="配置nginx实现cookie-free域名"></a>配置nginx实现cookie-free域名</h2><p>其实单独把 cookie-free 域名这个事儿单独拎出来说是一件很伤感的事情，因为有钱淫一般都会同时选择 VIP 套餐：CDN。使用 CDN，将静态资源分发在多台服务器上，用户在请求资源时智能判断哪个节点速度最快并返回，同时再启用一个 cookie-free 域名用来指向静态资源。</p>
<p>对于没有能力搞 CDN 的人，只能单独配置一下 cookie-free 域名了。没关系，等咱有了钱，服务器买 20 个，什么联通、电信、铁通、长宽、移动、电信通，通通给接上，带宽怎么着也得 20M，还得上下行速率对等。</p>
<p>好了不废话了，下面使用专业的语言描述一下要干的事：</p>
<p>前提条件：一台自己的服务器（VPS），安装了 nginx，已经有可用的 nginx 配置文件（假定 server_name 为 <a href="http://www.whatever.com),网站运转正常./">www.whatever.com），网站运转正常。</a><br>待办事项：修改 nginx 的配置文件，让 nginx 监听 cdn.whatever.com，并修改部分对静态文件的处理规则。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>首先你要增加一个子域名（cdn.whatever.com）指向你的服务器，这个不用多说了吧……<br>然后需要编辑你的 nginx 配置文件，它原来大概可能长这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen      <span class="number">80</span>;</span><br><span class="line">        server_name www.whatever.com whatever.com;</span><br><span class="line">        root        /root/to/your/site;</span><br><span class="line">    </span><br><span class="line">        location / &#123;</span><br><span class="line">            index   index.html index.php;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \\.(gif|jpg|png)$ &#123;</span><br><span class="line">            expires <span class="number">30</span>d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*此处略去若干*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你需要做的是首先修改 server_name 字段，让 nginx 同时监听 cdn.whatever.com。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server_name www.whatever.com whatever.com cdn.whatever.com;</span><br></pre></td></tr></table></figure>



<p>然后新增一个 location 块，写如下内容，并确保这个 location 块处于所有已存在的 location 块之前，即 nginx 需要优先处理这个 location 中的内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location ~* \\.(?:js|css|png|jpg|jpeg|gif|ico)$ &#123;</span><br><span class="line">        expires max;</span><br><span class="line">        add_header Pragma public;</span><br><span class="line">        add_header Cache-Control <span class="string">&quot;public, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">        access_log off;</span><br><span class="line">        log_not_found off;</span><br><span class="line">        tcp_nodelay off;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>搞定后保存 nginx 配置文件，然后重启 nginx。</p>
<p>最后一步，将网页中引用的所有 <a href="http://www.whatver.com/">www.whatver.com</a> 域下的静态文件通通改为 cdn.whatever.com。以上文所说的那个首页为例，新的图片地址为 <a href="http://cdn.whatver.com/images/[0-9].jpg%E3%80%82">http://cdn.whatver.com/images/[0-9].jpg。</a></p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p>其实要实现 cookie-free，只需要换一个域名并保证当前页面没有给根域名设置 cookie 即可。比如我们虽然启用了 cdn.whatever.com，但是由于 Google Analytics（以下简称 GA） 设置 cookie 的域为 .whatever.com 而不是 .<a href="http://www.ppios.com,会导致请求/">www.ppios.com，会导致请求</a> cdn.whatever.com 中的内容时依然会发送 cookie。具体 cookie 的设置情况请自行打开开发者工具查看。</p>
<p>这里再提一下关于限制 GA 设置 cookie 的内容，原则上 GA 应该是默认只设置当前域名的，比如你的页面 URL 是 <a href="http://www.whatever.com,则/">http://www.whatever.com，则</a> GA 设置 cookie 的域就是 <a href="http://www.whatever.com;同理如果你的/">www.whatever.com；同理如果你的</a> URL 是 <a href="http://whatever.com,则/">http://whatever.com，则</a> GA 会把 cookie 设置为 .whatever.com，这样你所有的子域名都会被这个 cookie 影响了。</p>
<p>解决方法就是修改 GA 统计代码，在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_gaq.push([<span class="string">&#x27;_setAccount&#x27;</span>, <span class="string">&#x27;UA-123456788-1&#x27;</span>]);</span><br><span class="line">_gaq.push([<span class="string">&#x27;_trackPageview&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>这两行之前新增一行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_gaq.push([<span class="string">&#x27;_setDomainName&#x27;</span>, <span class="string">&#x27;www.whatever.com&#x27;</span>]);</span><br></pre></td></tr></table></figure>



<p>这样就是告诉 GA 只准在 <a href="http://www.whatever.com/">www.whatever.com</a> 域下设置 cookie，关于这个设置顺序折腾了小半个晚上，大家一定要注意啊。</p>
]]></content>
  </entry>
  <entry>
    <title>从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</title>
    <url>/2020/11/14/network/http-url/</url>
    <content><![CDATA[<p>主要过程是：</p>
<p>浏览器解析-&gt;查询缓存-&gt;dns 查询</p>
<p>-&gt;建立链接-&gt;服务器处理请求-&gt;服务器发送响应-&gt;客户端收到页面</p>
<p>-&gt;解析 HTML-&gt;构建渲染树-&gt;开始显示内容(白屏时间)-&gt;首屏内容加载完成(首屏时间)</p>
<p>-&gt;用户可交户(DOMContentLoaded)-&gt;加载完成(load)</p>
<ul>
<li><p>1、在浏览器地址栏输入URL</p>
</li>
<li><p>2、<a href="//www.webq.top/article/788" target="_blank">浏览器查看 缓存</a>，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>
<ul>
<li>如果资源未缓存，发起新请求</li>
<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>
<li>检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control：</li>
<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li>
<li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
</ul>
</li>
<li><p>3、浏览器解析URL获取协议，主机，端口，path</p>
</li>
<li><p>4、浏览器组装一个HTTP（GET）请求报文</p>
</li>
<li><p>5、<a href="//www.webq.top/article/919" target="_blank">浏览器获取主机ip地址，过程如下：</a></p>
<ul>
<li>浏览器缓存</li>
<li>本机缓存</li>
<li>hosts文件</li>
<li>路由器缓存</li>
<li>ISP DNS缓存</li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
</ul>
</li>
</ul>
<ul>
<li><p>6、<a href="//www.webq.top/article/920" target="_blank">打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：</a></p>
</li>
<li><p>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口</p>
</li>
<li><p>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包</p>
</li>
<li><p>客户端发送ACK=Y+1， Seq=Z</p>
</li>
<li><p>7、TCP链接建立后发送HTTP请求</p>
</li>
<li><p>8、服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
</li>
<li><p>9、服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</p>
</li>
<li><p>10、处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p>
</li>
<li><p>11、服务器将响应报文通过TCP连接发送回浏览器</p>
</li>
<li><p>12、浏览器接收HTTP响应，然后根据情况选择 关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：</p>
<ul>
<li>主动方发送Fin=1， Ack=Z， Seq= X报文</li>
<li>被动方发送ACK=X+1， Seq=Z报文</li>
<li>被动方发送Fin=1， ACK=X， Seq=Y报文</li>
<li>主动方发送ACK=Y， Seq=X报文</li>
</ul>
</li>
<li><p>13、浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p>
</li>
<li></li>
<li><p>14、如果资源可缓存，进行缓存</p>
</li>
<li><p>15、对响应进行解码（例如gzip压缩）</p>
</li>
<li><p>16、根据资源类型决定如何处理（假设资源为HTML文档）</p>
</li>
<li><p>17、解析HTML文档，构建DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释</p>
<ul>
<li><p>17-1、构建DOM树：</p>
<ul>
<li>Tokenizing：根据HTML规范将字符流解析为标记</li>
<li>Lexing：词法分析将标记转换为对象并定义属性和规则</li>
<li>DOM construction：根据HTML标记关系将对象组成DOM树</li>
</ul>
</li>
<li><p>17-2、解析过程中遇到图片、样式表、js文件，启动下载</p>
</li>
<li><p>17-3、构建CSSOM树：</p>
<ul>
<li>Tokenizing：字符流转换为标记流</li>
<li>Node：根据标记创建节点</li>
<li>CSSOM：节点创建CSSOM树</li>
</ul>
</li>
<li><p>17-4、<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="nofollow">根据DOM树和CSSOM树构建渲染树</a>:</p>
<ul>
<li>从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    * 对每一个可见节点，找到恰当的CSSOM规则并应用
    * 发布可视节点的内容和计算样式

* 17-5、js解析如下：

    * 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
    * HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。

    * 这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。

    * 同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容

    * 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素

    * 当文档完成解析，document.readState变成interactive

    * 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()

    * 浏览器在Document对象上触发DOMContentLoaded事件

    * 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，
    * document.readState变为complete,window触发load事件

* 17-6、显示页面（HTML解析过程中会逐步显示页面）</code></pre>
]]></content>
  </entry>
  <entry>
    <title>对称加密、非对称加密、RSA(总结)</title>
    <url>/2020/11/14/network/symmetric-key/</url>
    <content><![CDATA[<blockquote>
<p>对称加密算法(Symmetric-key algorithm)和非对称加密算法(asymmetric key encryption algorithm)只不过就是密码学(cryptography)中的两种加密算法</p>
</blockquote>
<p>对称加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一</p>
<p>常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。</p>
<p>公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography）</p>
<p>一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。</p>
<p>要想使用非对称加密算法，首先要有一对key，一个被称为private key私钥，一个成为public key公钥，然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密，也就是说，只要你自己保存好你的private key，就能确保，别人想给你发的密文不被破解，所以你不用担心别人的密钥被盗，没关系。</p>
<p>这种加密算法应用非常广泛，RSA，SSH，电子证书，电子签名，电子身份证等等。</p>
<p>对称加密优缺点：</p>
<p>对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。</p>
<p>非对称加密优缺点：</p>
<p>1，不存在密钥分发的问题，解码方可以自己生成密钥对，一个做私钥存起来，另外一个作为公钥进行发布。</p>
<p>2，解决了密钥管理的复杂度问题，多个加密方都可以使用一个已知的公钥进行加密，但只有拥有私钥的一方才能解密。</p>
<p>3，安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。</p>
<p>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p>https是由非对称加密获取一个通话密钥key，再由这个key来进行对称加密</p>
<p>总结一下吧：</p>
<p>安全肯定是非对称加密安全，但是效率比较慢，对称加密效率高，但是不安全。<br>严谨一点的做法是混合起来使用，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
<p>参考链接：</p>
<p><a href="https://segmentfault.com/a/1190000004461428" target="_blank">白话解释 对称加密算法 VS 非对称加密算法</a></p>
<p><a href="https://blog.csdn.net/qq_16681169/article/details/50933958" target="_blank">https处理的一个过程，对称加密和非对称加密</a></p>
]]></content>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/11/14/network/webSocket/</url>
    <content><![CDATA[<blockquote>
<p>WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p>
</blockquote>
<h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。</p>
<p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET ws:<span class="comment">//localhost:3000/ws/chat HTTP/1.1</span></span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http:<span class="comment">//localhost:3000</span></span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该请求和普通的HTTP请求有几点不同：<li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li><li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li><li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li><li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li><br>随后，服务器如果接受该请求，就会返回如下响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。</p>
<p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。</p>
<p>现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p>
<p>为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</p>
<p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：<ul><li>Chrome</li><li>Firefox</li><li>IE &gt;= 10</li><li>Sarafi &gt;= 6</li><li>Android &gt;= 4.4</li><li>iOS &gt;= 8</li></ul></p>
<h1 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h1><h2 id=""><a href="#" class="headerlink" title=""></a><a name="#-E6-9C-8D-E5-8A-A1-E5-99-A8"></a></h2><p>WebSocket 的用法相当简单。<br>下面是一个网页脚本的例子（点击<a href="http://jsbin.com/muqamiqimu/edit?js,console" target="_blank">这里</a>看运行结果），基本上一眼就能明白。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;&lt;a href=&quot;</span>wss:<span class="comment">//echo.websocket.org/&quot;&gt;wss://echo.websocket.org&lt;/a&gt;&quot;);</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">    ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="客户端的-API"><a href="#客户端的-API" class="headerlink" title="客户端的 API"></a>客户端的 API</h1><p>WebSocket 客户端的 API 如下。</p>
<h2 id="1、-WebSocket-构造函数"><a href="#1、-WebSocket-构造函数" class="headerlink" title="1、 WebSocket 构造函数"></a>1、 WebSocket 构造函数</h2><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行上面语句之后，客户端就会与服务器进行连接。<br>实例对象的所有属性和方法清单，参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank">这里</a>。</p>
<h2 id="2、-webSocket-readyState"><a href="#2、-webSocket-readyState" class="headerlink" title="2、 webSocket.readyState"></a>2、 webSocket.readyState</h2><p>readyState属性返回实例对象的当前状态，共有四种。<ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></blockquote><br>下面是一个示例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">        <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// this never happens</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、webSocket-onopen"><a href="#3、webSocket-onopen" class="headerlink" title="3、webSocket.onopen"></a>3、webSocket.onopen</h2><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ws.addEventListener(&#39;open&#39;, function (event) &#123;</span><br><span class="line">    ws.send(&#39;Hello Server!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、-webSocket-onclose"><a href="#4、-webSocket-onclose" class="headerlink" title="4、 webSocket.onclose"></a>4、 webSocket.onclose</h2><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code = event.code;</span><br><span class="line">    <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">    <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">    <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code = event.code;</span><br><span class="line">    <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">    <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">    <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5、-webSocket-onmessage"><a href="#5、-webSocket-onmessage" class="headerlink" title="5、 webSocket.onmessage"></a>5、 webSocket.onmessage</h2><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> event.data === <span class="built_in">String</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received data string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received arraybuffer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6、-webSocket-send"><a href="#6、-webSocket-send" class="headerlink" title="6、 webSocket.send()"></a>6、 webSocket.send()</h2><p>实例对象的send()方法用于向服务器发送数据。<br>发送文本的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ws.send(<span class="string">&#x27;your message&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发送 Blob 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">    .querySelector(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class="line">    .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发送 ArrayBuffer 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; img.data.length; i++) &#123;</span><br><span class="line">    binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>

<h2 id="7、-webSocket-bufferedAmount"><a href="#7、-webSocket-bufferedAmount" class="headerlink" title="7、 webSocket.bufferedAmount"></a>7、 webSocket.bufferedAmount</h2><p>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、-webSocket-onerror"><a href="#8、-webSocket-onerror" class="headerlink" title="8、 webSocket.onerror"></a>8、 webSocket.onerror</h2><p>实例对象的onerror属性，用于指定报错时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>WebSocket 服务器的实现，可以查看维基百科的<a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations" target="_blank">列表</a>。<br>常用的 Node 实现。<ul><li><a href="https://github.com/uNetworking/uWebSockets" target="_blank">µWebSockets</a></p>
</li><li><a href="https://socket.io/" target="_blank">Socket.IO</a>
</li><li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank">WebSocket-Node</a>
</li><li><a href="https://github.com/websockets/ws" target="_blank">WS</a>
</li></ul>]]></content>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/2020/11/14/js/web-worker/</url>
    <content><![CDATA[<blockquote>
<p>为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给Worker 线程</p>
</blockquote>
<p>Web Worker 有以下几个使用注意点。</p>
<ul>
<li><p>同源限制</p>
<p>  分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
</li>
<li><p>DOM 限制</p>
<p>  Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>
</li>
<li><p>通信联系</p>
<p>  Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
</li>
<li><p>脚本限制</p>
<p>  Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
</li>
<li><p>文件限制</p>
<p>  Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
</li>
</ul>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Worker()构造函数的参数是一个脚本文件，（之后会介绍行内的写法以及基于webpack的配置）该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">worker.postMessage(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">worker.postMessage(&#123;<span class="attr">method</span>: <span class="string">&#x27;echo&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;Work&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure>

<p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。<br>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received message &#x27;</span> + event.data);</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，事件对象的data属性可以获取 Worker 发来的数据。<br>Worker 完成任务以后，主线程就可以把它关掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>


<h2 id="Worker-线程"><a href="#Worker-线程" class="headerlink" title="Worker 线程"></a>Worker 线程</h2><p>Worker 线程内部需要有一个监听函数，监听message事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    self.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = e.data;</span><br><span class="line">    <span class="keyword">switch</span> (data.cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            self.postMessage(<span class="string">&#x27;WORKER STARTED: &#x27;</span> + data.msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;stop&#x27;</span>:</span><br><span class="line">            self.postMessage(<span class="string">&#x27;WORKER STOPPED: &#x27;</span> + data.msg);</span><br><span class="line">            self.close(); <span class="comment">// Terminates the worker.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            self.postMessage(<span class="string">&#x27;Unknown command: &#x27;</span> + data.msg);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，self.close()用于在 Worker 内部关闭自身。</p>
<h2 id="Worker-加载脚本"><a href="#Worker-加载脚本" class="headerlink" title="Worker 加载脚本"></a>Worker 加载脚本</h2><p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法可以同时加载多个脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">&#x27;script1.js&#x27;</span>, <span class="string">&#x27;script2.js&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">worker.onerror(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([</span><br><span class="line">    <span class="string">&#x27;ERROR: Line &#x27;</span>, e.lineno, <span class="string">&#x27; in &#x27;</span>, e.filename, <span class="string">&#x27;: &#x27;</span>, e.message</span><br><span class="line">    ].join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">worker.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Worker 内部也可以监听error事件。</p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p>主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class="line">    uInt8Array[i] = i * <span class="number">2</span>; <span class="comment">// [0, 2, 4, 6, 8,...]</span></span><br><span class="line">&#125;</span><br><span class="line">worker.postMessage(uInt8Array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uInt8Array = e.data;</span><br><span class="line">    postMessage(<span class="string">&#x27;Inside worker.js: uInt8Array.toString() = &#x27;</span> + uInt8Array.toString());</span><br><span class="line">    postMessage(<span class="string">&#x27;Inside worker.js: uInt8Array.byteLength = &#x27;</span> + uInt8Array.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects" target="_blank">Transferable Objects</a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transferable Objects 格式</span></span><br><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure>



<h2 id="Web-Worker行内写法"><a href="#Web-Worker行内写法" class="headerlink" title="Web Worker行内写法"></a>Web Worker行内写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorker</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">&#x27;(&#x27;</span> + f.toString() +<span class="string">&#x27;)()&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</span><br><span class="line">    <span class="keyword">return</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pollingWorker = createWorker(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params"><span class="keyword">new</span>, old</span>) </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        fetch(<span class="string">&#x27;/my-api-endpoint&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = res.json();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (!compare(data, cache)) &#123;</span><br><span class="line">            cache = data;</span><br><span class="line">            self.postMessage(data);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// render data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.postMessage(<span class="string">&#x27;init&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="基于webpack的worker-loader"><a href="#基于webpack的worker-loader" class="headerlink" title="基于webpack的worker-loader"></a>基于webpack的worker-loader</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D worker-loader</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js：</span></span><br><span class="line">    <span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">&#x27;./worker.js&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">    worker.postMessage(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;;</span><br><span class="line">    worker.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>// worker.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    self.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>


<p>// webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\\.worker\\.js$/</span>,</span><br><span class="line">            use: &#123; </span><br><span class="line">                loader: <span class="string">&#x27;worker-loader&#x27;</span> </span><br><span class="line">                options: &#123;</span><br><span class="line">                    name: string,<span class="comment">//默认‘[hash].worker.js 输出js文件名</span></span><br><span class="line">                    inline: boolean, <span class="comment">// 默认false，是否将 worker 内联为一个 BLOB</span></span><br><span class="line">                    fallback: boolean, <span class="comment">// 默认false，是否需要支持非 worker 环境的回退</span></span><br><span class="line">                    publicPath: string, <span class="comment">// 默认值：null,重写 worker 脚本的下载路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="集成-TypeScript"><a href="#集成-TypeScript" class="headerlink" title="集成 TypeScript"></a>集成 TypeScript</h2><h2 id=""><a href="#" class="headerlink" title=""></a><a aria-label="集成 TypeScript" href="https://webpack.docschina.org/loaders/worker-loader/#%E9%9B%86%E6%88%90-typescript"></a></h2><p>集成 TypeScript，在导出 worker 时，需要声明一个自定义模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typings/custom.d.ts</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&quot;worker-loader!*&quot;</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebpackWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="title">constructor</span>(<span class="params"></span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> WebpackWorker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker.ts</span></span><br><span class="line"><span class="keyword">const</span> ctx: Worker = self <span class="keyword">as</span> any;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据到父线程</span></span><br><span class="line">ctx.postMessage(&#123; <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应父线程的消息</span></span><br><span class="line">ctx.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(event));</span><br><span class="line"><span class="comment">// App.ts</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">&quot;worker-loader!./Worker&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">worker.postMessage(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line">worker.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Webpack文档地址"><a href="#Webpack文档地址" class="headerlink" title="Webpack文档地址"></a><a href="https://webpack.docschina.org/loaders/worker-loader/" target="_blank">Webpack文档地址</a></h2><p>这么用： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Workers <span class="keyword">from</span> <span class="string">&#x27;worker-loader?inline=true&amp;fallback=false!./danmaku-worker.rev&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>TCP详解</title>
    <url>/2020/11/14/network/tcp/</url>
    <content><![CDATA[<blockquote>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
</blockquote>
<p>首先来看看OSI的七层模型：<br><img src="/img/osi.gif"></p>
<p>我们需要知道：</p>
<p>一：TCP工作在网络OSI的七层模型中的第四层——Transport层，第四层的数据叫Segment。</p>
<p>二：IP在第三层——Network层，在第三层上的数据叫Packet。</p>
<p>三：ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame。</p>
<p>同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。</p>
<h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>其中 ACK SYN 序号 这三个部分在以下会用到，它们的介绍也在下面。<br><img src="/img/tcp.png"></p>
<p>上面就是TCP协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详细的说明一下。</p>
<ul><li>
1、Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li><li>

</li><li>
2、Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li><li>

</li><li>
3、Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li><li>

</li><li>
4、Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li><li>

</li><li>
5、TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</li><li>

</li></ul>
        5.1、URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层   设备要尽快处理这些数据；


<pre><code>    5.2、ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；


    5.3、PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；


    5.4、RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；


    5.5、SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，</code></pre>
<p>SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</p>
<pre><code>    5.6、FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。


6、Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；这个比较复杂？</code></pre>
<p>暂时需要的信息有：</p>
<p>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</p>
<p>SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p>
<p>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。<h4></p>
<h4>三次握手的过程：



<img src="//api.webq.top/static/img/tcp3.png" style="max-width:100%;">
<ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>
</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>
</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li><li>
</li></ol>
实例:
IP 192.168.1.116.3337 > 192.168.1.123.7788: S 3626544836:3626544836
IP 192.168.1.123.7788 > 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837
IP 192.168.1.116.3337 > 192.168.1.123.7788: ack 1739326487,ack 1


<p>第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;</p>
<p>第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;</p>
<p>第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。</p>
<h4>那四次挥手呢？



<p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<ol><li>第一次挥手：主机1（<span style="color: rgb(139, 170, 74);">可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>
</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>
</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>
</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li><li>
</li></ol><h4>为什么要四次挥手



<p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p>
<p>TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；</p>
<p>但是，这个时候主机1还是可以接受来自主机2的数据；<br>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；</p>
<p>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<p>如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul><li>FIN_WAIT_1: </li><li>这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：</li><li>
</li><li>FIN_WAIT_1状态:</li><li>是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li>
</li><li>FIN_WAIT_2：</li><li>上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li>
</li><li>CLOSE_WAIT：</li><li>这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。</li><li>
</li><li>接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li>
</li><li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li>
</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。</li><li>
</li><li>如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li><li>CLOSED: 表示连接中断。</li></ul>


<p><img src="/img/tcp4.png"></p>
]]></content>
  </entry>
  <entry>
    <title>红小豆语录</title>
    <url>/2020/11/14/other/hy/</url>
    <content><![CDATA[<h2 id="一、术语"><a href="#一、术语" class="headerlink" title="一、术语"></a>一、术语</h2><p>1、音名：</p>
<table border="0" width="100%" cellpadding="0" cellspacing="0" ><tbody><tr><th>C   </th><th>D </th><th> E</th><th> F</th><th> G</th><th>A </th><th> B</th></tr></tbody></table><p >

<p>2、唱名：</p>
<table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><th>1 </th><th>2 </th><th>3 </th><th>4 </th><th>5 </th><th>6 </th><th> 7</th></tr><tr><td > do </td><td > re</td><td > mi</td><td > fa</td><td >sol</td><td > la</td><td > si</td></tr></tbody></table>
注：若是C调，则是1（do）对应这C，若是D调，则是1（do）对应这D；（一脸无辜，这是什么啊？


<p>3、<a href="https://www.jitashe.org/tool/yinjie/" target="_blank">吉他常用音阶模式图</a>（吉他中相邻品格为半音关系，也就是，E与F、B和C之间只差半音，其他都是全音）</p>
<p><img src="/img/guitar1.png"></p>
<p>注： 这咋那么多啊（外面下雪了，可大了o(╥﹏╥)o</p>
<p>4、<a href="https://www.webq.top/upload?edit=1" target="_blank">十二平均律：</a></p>
<p>将do、re、mi、sol、la、si、do这个八度音程平均分成12份（可以看做对应吉他的0到12品，12品的E正好比空弦升一个八度</p>
<p>用钢琴的键比较易懂一点（正好一个八度十二个键，相邻键为半音关系（不知道能不能这么解释？</p>
<p><img src="/img/piano.png"></p>
<p>以下为钢琴88键从左到右对应的绝对中心频率：（中央C 对应： 261.626，<a href="https://zh.wikipedia.org/wiki/%E9%8B%BC%E7%90%B4%E9%8D%B5%E9%A0%BB%E7%8E%87" target="_blank">摘自维基百科</a></p>
<table border="0" width="100%" cellpadding="0" cellspacing="0"><tbody><tr><th> 12键</th><th>C</th><th>C#</th><th>D</th><th> D#</th><th>E </th><th>F </th><th> F#</th><th>G </th><th>G# </th><th> A</th><th>A# </th><th> B</th></tr><tr><td> 大字二组</td><td></td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> <b>27.5000</b></td><td> 29.1352</td><td> 30.8677</td></tr><tr><td >大字一组</td><td >32.7032</td><td > 34.6478</td><td > 36.7081</td><td > 38.8909</td><td > 41.2034</td><td >43.6535 </td><td > 46.2493</td><td > 48.9994</td><td >51.9131
</td><td > <b>55.0000</b></td><td > 58.2705</td><td > 61.7354</td></tr><tr><td >大字组</td><td >65.4064</td><td > 69.2957</td><td > 73.4162</td><td > 77.7817</td><td > 82.4069</td><td > 87.3071</td><td > 92.4986</td><td >97.9989</td><td > 103.826</td><td ><b>110.000</b></td><td > 116.541</td><td >123.471 </td></tr><tr><td >小字组</td><td >130.813</td><td >138.591</td><td > 146.832</td><td > 155.563</td><td > 164.814</td><td > 174.614</td><td > 184.997</td><td > 195.998</td><td > 207.652</td><td > <b>220.000</b></td><td > 233.082</td><td > 246.942</td></tr><tr><td > 小字一组</td><td >261.626</td><td > 277.183</td><td > 293.665</td><td > 311.127</td><td > 329.628</td><td > 349.228</td><td > 369.994</td><td > 391.995</td><td > 415.305</td><td > <b>440.000</b></td><td > 466.164</td><td > 493.883</td></tr><tr><td > 小字二组</td><td >523.251</td><td > 554.365</td><td > 587.330</td><td > 622.254</td><td > 659.255</td><td > 698.456</td><td > 739.989</td><td > 783.991</td><td > 830.609</td><td > <b>880.000</b></td><td > 932.328</td><td > 987.767</td></tr><tr><td > 小字三组</td><td >1046.50</td><td > 1108.73</td><td > 1174.66</td><td > 1244.51</td><td > 1318.51</td><td > 1396.91</td><td > 1479.98</td><td > 1567.98</td><td > 1661.22</td><td > <b>1760.00</b></td><td > 1864.66</td><td > 1975.53</td></tr><tr><td > 小字四组</td><td >2093.00</td><td > 2217.46</td><td > 2349.32</td><td > 2489.02</td><td > 2637.02</td><td > 2793.83</td><td > 2959.96</td><td >3135.96</td><td > 3322.44</td><td > <b>3520.00</b></td><td > 3729.31</td><td > 3951.07</td></tr><tr><td > 小字五组</td><td > 4186.01</td><td > </td><td > </td><td > </td><td > </td><td > </td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></tbody></table>


<p>注： 每升八度，声音的频率就会翻一倍</p>
<p>5、<a target="_blank" href="https://baike.baidu.com/item/%E9%87%87%E6%A0%B7%E9%A2%91%E7%8E%87">采样频率</a></p>
<p>指录音设备在一秒钟内对声音信号的采样次数，采样频率越高声音的还原就越真实越自然。</p>
<p>在当今的主流采集卡上，采样频率一般共分为22.05KHz、44.1KHz、48KHz三个等级<br>22.05 KHz只能达到FM广播的声音品质<br>44.1KHz则是理论上的CD音质界限<br>48KHz则更加精确一些<br>对于高于48KHz的采样频率人耳已无法辨别出来了</p>
<p>注： 浏览器输入如下代码，检测当前音频设备输出的采样率（前提要有音频输出设备：耳机、音箱…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)().sampleRate</span><br></pre></td></tr></table></figure>



<p>6、音速与采样时间</p>
<p>通常的节拍每分钟对应120个四分之一音符，即每个1/4音符的时长是0.5秒，由此可得1/2音符是1秒，1/8音符是0.25秒，1/16音符是0.125秒。</p>
<p>7、乐器音色（这是什么鬼啊</p>
<p>不同的乐器演奏出的音色不同，主要是因为发声时不但有中心频率的振动，还有谐波甚至和频波。</p>
<p>频率：将声音波形FFT变换到频域，发现除中心频率，还有2阶到6阶的谐波，各阶的谐波也有对应的强度。<br>时域：是一个近似的指数衰减，可以通过拟合曲线得到包络参数。</p>
<p>最终可以将基频与谐波的采样曲线线性叠加并乘以时域的包络曲线得到单个钢琴按键的声音。</p>
<p>注： 去除谐波，时域，结合节拍数，就可以找到单个音的频率（对应的音阶：1234567；好麻烦啊 o(╥﹏╥)o</p>
<h2 id="二、吉他谱中的常见符号"><a href="#二、吉他谱中的常见符号" class="headerlink" title="二、吉他谱中的常见符号"></a>二、吉他谱中的常见符号</h2><p>1、升记号（#）表示将基本音级升高半音<br>2、 降记号（b）表示将基本音级降低半音。<br>3、重升记号（×）表示将基本音级升高两个半音（一个全音）<br>4、重降记号（bb）表示将基本音级降低两个半音（一个全音）<br>5、还原记号(ヰ)表示将已经升高或降低的音还原<br>.<br>.<br>.</p>
<p>注： <a href="http://www.798com.com/article-11806-1.html" target="_blank">太多了</a>（我想堆雪人，o(╥﹏╥)o</p>
<h2 id="三、吉他演奏技巧"><a href="#三、吉他演奏技巧" class="headerlink" title="三、吉他演奏技巧"></a>三、吉他演奏技巧</h2><p>1、<a href="https://www.bilibili.com/video/av49877527?p=31" target="_blank">滑音(Slide)</a></p>
<p>2、<a href="https://www.bilibili.com/video/av49877527?p=32" target="_blank">搥弦(Hammer-On)</a></p>
<p>3、勾弦(Pull-Off)</p>
<p>4、<a href="https://www.bilibili.com/video/av12122543?from=search&seid=14911589215526421631" target="_blank">点弦(Tapping)</a></p>
<p>5、推弦(Bending)</p>
<p>6、揉弦吉他常用技巧</p>
<p>7、扫拨(Sweep Picking）：多用于电吉他演奏，常见于重金属摇滚乐。</p>
<p>8、打弦(Slap）：多用于低音吉他（Bass）。</p>
<p>9、琵音</p>
<p>10、颤音</p>
<p>11、泛音</p>
<h2 id="四、？？？（我在哪、我在干什么"><a href="#四、？？？（我在哪、我在干什么" class="headerlink" title="四、？？？（我在哪、我在干什么"></a>四、？？？（我在哪、我在干什么</h2><p><span style="font-size: large;">1、大调和小调的区别</p>
<p><b>大调式：1 - 2 - 3 - 4 - 5 - 6 - 7 - 1</b></p>
<b>
</b>
凡是音阶排列符合全、全、半、全、全、全、半结构的音阶，就是自然大调<b>
</b>
    一般来说，一首音乐作品的开始音符是使用1、3或5的，而结束在1上的就是大调音乐<b>
</b>


<p><b>小调式：</b><b> 6 - 7  - </b><b>1 - 2 - 3 - 4 - 5 - 6</b><br><b><br></b></p>
<pre><code>a：自然小调：凡是音阶符合全、半、全、全、半、全、全结构的音阶，叫自然小调

b：和声小调：升高自然小调音阶的第VII级，叫和声小调

c：旋律小调：在自然小调音阶上行时升高它的4、5，而小行时还原5、4叫旋律小调</code></pre>
<p><span style="font-size: large;">2、F大调为何降B（？？？</p>
<p><a href="https://zh.wikipedia.org/wiki/F%E5%A4%A7%E8%AA%BF" target="_blank">维基上这么说</a>（完全不知道说的什么o(╥﹏╥)o</p>
<p><b>F大调</b>是一个基于F音的<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E8%AA%BF" title="大调">大调</a>，由F、G、A、B♭、C、D、E和F组成，<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%8F%B7" title="调号">调号</a>有一个<a href="https://zh.wikipedia.org/wiki/%E9%99%8D%E8%99%9F" title="降号">降号</a></p>
]]></content>
  </entry>
  <entry>
    <title>python中的装饰器</title>
    <url>/2020/11/14/python/decorators/</url>
    <content><![CDATA[<ul>
<li>函数外可以访问函数内的变量<h2 id="写个简单的装饰器"><a href="#写个简单的装饰器" class="headerlink" title="写个简单的装饰器"></a>写个简单的装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warp</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;haha warp&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">&#x27;result:&#x27;</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_result</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;func add:&#x27;</span>, a + b)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">haha warp</span><br><span class="line">func add: <span class="number">3</span></span><br><span class="line">result: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>add会作为参数func传给get_result函数,然后get_result返回warp函数。</li>
<li>执行add.__name__会输出wrap</li>
<li>其实这是python解释器在背后吧warp赋值给了add，然后add就保存了warp的索引，每次调用add(a, b)都是在执行warp(a, b)<h2 id="解决name属性被修改的问题"><a href="#解决name属性被修改的问题" class="headerlink" title="解决name属性被修改的问题"></a>解决name属性被修改的问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warp</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;haha warp&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">&#x27;result:&#x27;</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_result</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">print(<span class="string">&#x27;func add:&#x27;</span>, a + b)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">a = add</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;name:&#x27;</span>, a.__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">a = add</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(a.__name__)</span><br></pre></td></tr></table></figure>
释执行结果：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">haha warp</span><br><span class="line">func add: <span class="number">3</span></span><br><span class="line">result: <span class="number">3</span></span><br><span class="line">name: add</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>解释：</p>
<ul>
<li>functools.warps是为了在装饰器中方便的拷贝被装饰函数的签名</li>
</ul>
<h2 id="怎么生成传参装饰器"><a href="#怎么生成传参装饰器" class="headerlink" title="怎么生成传参装饰器"></a>怎么生成传参装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_auth</span>(<span class="params">has_token=<span class="literal">True</span></span>):</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warp</span>(<span class="params">self, data, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> has_token:</span><br><span class="line">            token = data.get(<span class="string">&#x27;token&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uid = data.get(<span class="string">&#x27;uid&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">                passwd = data.get(<span class="string">&#x27;passwd&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">bool</span>(uid) <span class="keyword">and</span> <span class="built_in">bool</span>(passwd)) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> func(self, data, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"> <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_auth(has_token=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># data: 调用方传递的用户的凭证信息包括token</span></span><br><span class="line">info = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_auth(has_token=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        data: 登录信息</span><br><span class="line">info = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">user_info = UserInfo()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;-------------login------------&#x27;</span>)</span><br><span class="line">data = &#123;<span class="string">&#x27;uid&#x27;</span>: <span class="string">&#x27;uid1&#x27;</span>, <span class="string">&#x27;passwd&#x27;</span>: <span class="string">&#x27;sss&#x27;</span>&#125;</span><br><span class="line">print(<span class="string">&#x27;has uid passwd:&#x27;</span>, user_info.login(data))</span><br><span class="line">print(<span class="string">&#x27;no uid passwd:&#x27;</span>, user_info.login(&#123;&#125;))</span><br><span class="line">print(<span class="string">&#x27;-------------get_info------------&#x27;</span>)</span><br><span class="line">data = &#123;<span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;token&#x27;</span>&#125;</span><br><span class="line">print(<span class="string">&#x27;has token:&#x27;</span>, user_info.get_info(data))</span><br><span class="line">print(<span class="string">&#x27;no token:&#x27;</span>, user_info.get_info(&#123;&#125;))</span><br></pre></td></tr></table></figure>
<p>执行结果及解释<br>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -------------login------------</span></span><br><span class="line">has uid passwd: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">no uid passwd: &#123;&#125;</span><br><span class="line"><span class="comment"># -------------get_info------------</span></span><br><span class="line">has token: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">no token: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>这个用户鉴权装饰器应对于登陆和登陆后的鉴权,如参数has_token,当为False时,说明
是登陆,反之说明已经登陆成功,应携带token参数请求接口,其他的逻辑应该很简单.</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Django配置Ajax跨域调用/设置Cookie</title>
    <url>/2020/11/14/python/django-cors/</url>
    <content><![CDATA[<h2 id="django-cors-headers"><a href="#django-cors-headers" class="headerlink" title="django-cors-headers"></a>django-cors-headers</h2><h2 id="一、跨域调用"><a href="#一、跨域调用" class="headerlink" title="一、跨域调用"></a>一、跨域调用</h3></h2><p>首先下载这个插件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>
<p>然后在你的Django项目中的settings.py中做如下配置(install app和middleware)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [ <span class="comment"># Or MIDDLEWARE_CLASSES on Django &amp;lt; 1.10</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>要注意的是，CorsMiddleware最好放的尽可能的往上，比如要 在CommonMiddleware和WhiteNoiseMiddleware的上边，要不然设置的跨域响应头可能起不了什么作用。</p>
<p>最后配置一下你允许的跨域请求主机</p>
<p>允许所有主机请求你的API，这种设置下不能设置cookie，下文会说解决方案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>或者指定白名单。这里注意有个坑，当前后端联机调试的时候，前端在浏览器写localhost或127.0.0.1和本机的具体IP地址在白名单里是不一样的，推荐调试的时候写具体IP地址，白名单里也写具体IP地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    <span class="string">&#x27;172.30.203.52:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;localhost:80&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="二、携带cookie"><a href="#二、携带cookie" class="headerlink" title="二、携带cookie"></a>二、携带cookie</h2><p>要跨域设置cookie，需要前后端的共同努力，首先看后端：</p>
<p>前提是插件下载好了，并且install_app和middleware都配置了。如上边提到的，将CORS_ORIGIN_ALLOW_ALL设为false，通过白名单的方式设定允许跨域请求的请求源，然后再设置CORS_ALLOW_CREDENTIALS配置项为True，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If True, cookies will be allowed to be included in cross-site HTTP requests. Defaults to False.</span></span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>前端只需要在发起请求时设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">withCredentials: true</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>django2.2版本中pymysql报错</title>
    <url>/2020/11/14/python/django-sql-error/</url>
    <content><![CDATA[<p>ImproperlyConfigured: mysqlclient 1.3.13 or newer is required</p>
<h2 id="1、问题背景：已经安装好了-pymysql，但是在命令行执行-python3-manage-py-migrate-进行数据迁移时报如下错误："><a href="#1、问题背景：已经安装好了-pymysql，但是在命令行执行-python3-manage-py-migrate-进行数据迁移时报如下错误：" class="headerlink" title="1、问题背景：已经安装好了 pymysql，但是在命令行执行 python3 manage.py migrate 进行数据迁移时报如下错误："></a>1、问题背景：已经安装好了 pymysql，但是在命令行执行 python3 manage.py migrate 进行数据迁移时报如下错误：</h2><p>（当然，你也可能是在执行其它操作时遇到类似错误）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#x2F;lib&#x2F;python3.7&#x2F;importlib&#x2F;__init__.py&quot;, line 127, in import_module</span><br><span class="line">    return _bootstrap._gcd_import(name[level:], package, level)</span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;mysql&#x2F;base.py&quot;, line 36, in &gt;module&gt;</span><br><span class="line">    raise ImproperlyConfigured(&#39;mysqlclient 1.3.13 or newer is required; you have %s.&#39; % Database.__version__)</span><br><span class="line">django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3.</span><br></pre></td></tr></table></figure>
<p>根据最后两行的提示，mysqlclient 版本不够新，但是我已经都安装的最新版本了呀。</p>
<h2 id="2、解决方案一："><a href="#2、解决方案一：" class="headerlink" title="2、解决方案一："></a>2、解决方案一：</h2><p>安装mysqlclient</p>
<p>mysqlclient==1.3.14</p>
<h3 id="pip-安装-mysqlclient-报错"><a href="#pip-安装-mysqlclient-报错" class="headerlink" title="pip 安装 mysqlclient 报错"></a>pip 安装 mysqlclient 报错</h3><p><a href="https://pypi.org/project/mysqlclient/">https://pypi.org/project/mysqlclient/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-devel -y</span><br><span class="line"></span><br><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>

<h2 id="3、解决方案二："><a href="#3、解决方案二：" class="headerlink" title="3、解决方案二："></a>3、解决方案二：</h2><p>虽然本地已安装了 PyMySQL 驱动，但 Django 连接 MySQL 时仍默认使用 MySQLdb 驱动，但 MySQLdb 并不支持 Python3，所以需要手动在项目中进行配置。</p>
<p>在项目根目录下的 <code>__init__.py</code> 文件中添加如下代码即可：</p>
<p>import pymysql<br>pymysql.install_as_MySQLdb()</p>
<p>再次执行命令时，还是会报错，没关系，仔细看下报错的倒数第三行，已经告诉你是在 base.py 第 36 行报的错，根据你的提示路径打开 base.py，把 35、36 行前面加 # 注释掉就好了，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">34 version &#x3D; Database.version_info</span><br><span class="line">35 #if version &gt; (1, 3, 13):</span><br><span class="line">36 #    raise ImproperlyConfigured(&#39;mysqlclient 1.3.13 or newer is required; you     have %s.&#39; % Database.__version__)</span><br></pre></td></tr></table></figure>
<p>现在再次执行命令，上面的报错已经没有了，但是又有了新的错误，看下面怎么解决吧。</p>
<p>AttributeError: ‘str’ object has no attribute ‘decode’<br>解决了上面的问题后，又遇到下面这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;mysql&#x2F;operations.py&quot;, line 146, in last_executed_query</span><br><span class="line">    query &#x3D; query.decode(errors&#x3D;&#39;replace&#39;)</span><br><span class="line">AttributeError: &#39;str&#39; object has no attribute &#39;decode&#39;</span><br></pre></td></tr></table></figure>
<p>提示属性错误:“str”对象没有属性“decode”。</p>
<p>问题的原因是，在 Python3 里：</p>
<p>str 通过 encode() 转换成 bytes<br>bytes 通过 decode() 转换成 str<br>也就是说：str 只有 encode() 方法，bytes 只有 decode() 方法！<br>这个估计是 django 的 bug 了。</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>根据提示打开报错的文件 operations.py<br>找到 146 行，把 decode 改成 encode 即可，类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">140     def last_executed_query(self, cursor, sql, params):</span><br><span class="line">141         # With MySQLdb, cursor objects have an (undocumented) &quot;_executed&quot;</span><br><span class="line">142         # attribute where the exact query sent to the database is saved.</span><br><span class="line">143         # See MySQLdb&#x2F;cursors.py in the source distribution.</span><br><span class="line">144         query &#x3D; getattr(cursor, &#39;_executed&#39;, None)</span><br><span class="line">145         if query is not None:</span><br><span class="line">146             query &#x3D; query.encode(errors&#x3D;&#39;replace&#39;)\t# 这里把 decode 改为 encode</span><br><span class="line">147         return query</span><br></pre></td></tr></table></figure>
<p>此时，再次执行命令就不报错了，大功告成！</p>
<p>tips：</p>
<ul>
<li>str通过encode()方法可以编码为指定的bytes。</li>
<li>反过来，当从网络或磁盘上读取了字节流，那么读到的数据就是bytes。</li>
<li>要把bytes变为str，就需要用decode()方法。</li>
<li>反之，则使用encode()方法即可！</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>django2.2版本中pymysql报错</title>
    <url>/2020/11/14/python/middleware/</url>
    <content><![CDATA[<p>我们从浏览器发出一个请求 Request，得到一个响应后的内容 HttpResponse ，这个请求传递到 Django的过程如下：</p>
<p><img src="/img/middleware.jpg"></p>
<p>也就是说，每一个请求都是先通过中间件中的 process_request 函数，这个函数返回 None 或者 HttpResponse 对象，如果返回前者，继续处理其它中间件，如果返回一个 HttpResponse，就处理中止，返回到网页上。</p>
<p>中间件不用继承自任何类（可以继承 object ），下面一个中间件大概的样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>还有 process_view, process_exception 和 process_template_response 函数。</p>
<h2 id="一，比如我们要做一个-拦截器，发现有恶意访问网站的人，就拦截他！"><a href="#一，比如我们要做一个-拦截器，发现有恶意访问网站的人，就拦截他！" class="headerlink" title="一，比如我们要做一个  拦截器，发现有恶意访问网站的人，就拦截他！"></a>一，比如我们要做一个  拦截器，发现有恶意访问网站的人，就拦截他！</h2><p>假如我们通过一种技术， 比如统计一分钟访问页面数，太多就把他的 IP 加入到黑名单 BLOCKED_IPS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#项目 md 文件名 md/middleware.py</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedIpMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] <span class="keyword">in</span> <span class="built_in">getattr</span>(settings, <span class="string">&quot;BLOCKED_IPS&quot;</span>, []):</span><br><span class="line">            <span class="keyword">return</span> http.HttpResponseForbidden(<span class="string">&#x27;&amp;lt;h1&amp;gt;Forbidden&amp;lt;/h1&amp;gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的代码的功能就是 获取当前访问者的 IP (request.META[‘REMOTE_ADDR’])，如果这个 IP 在黑名单中就拦截，如果不在就返回 None (函数中没有返回值其实就是默认为 None)，把这个中间件的 Python 路径写到settings.py中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">        ...</span><br><span class="line">    <span class="string">&#x27;md.middleware.BlockedIpMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Django 会从 MIDDLEWARE_CLASSES 或 MIDDLEWARE 中按照从上到下的顺序一个个执行中间件中的 process_request 函数，而其中 process_response 函数则是最前面的最后执行。如上图所示</p>
]]></content>
  </entry>
  <entry>
    <title>XHR获取arraybuffer</title>
    <url>/2020/11/14/network/xhr-buffer/</url>
    <content><![CDATA[<blockquote>
<p>ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="number">1.</span> 文件格式 (mask file layout)</span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span> 综述 (overview)</span><br><span class="line">-----------------------------------</span><br><span class="line">| mask file header |</span><br><span class="line">-----------------------------------</span><br><span class="line">| mask frame indexing table |</span><br><span class="line">-----------------------------------</span><br><span class="line">| ... ... |</span><br><span class="line">| ... ... |</span><br><span class="line">-----------------------------------</span><br><span class="line">| mask frames data segment |</span><br><span class="line">-----------------------------------</span><br><span class="line">图 <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">总体而言, 文件的格式为: 文件头 + 帧索引表 + 若干帧数据段, 这三部分数据紧邻地存放于mask文件</span><br><span class="line">中, 位置关系如图<span class="number">1.0</span>所示.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> 文件头 (mask file header)</span><br><span class="line"></span><br><span class="line">| <span class="number">1</span> bytes   |  <span class="number">1</span> bytes  |   <span class="number">1</span> byte  |   <span class="number">1</span> bytes  |    <span class="number">1</span> bytes   |</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">| file tag  |  version  | codec_id  |  reserved  | entry_num |</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">图 <span class="number">1.1</span></span><br><span class="line">说明:</span><br><span class="line">文件头固定为<span class="number">16</span>字节, 位于mask文件的前<span class="number">16</span>字节. 文件头的组成由图<span class="number">2.1</span>所示</span><br><span class="line">file tag: 表示文件标识, 固定值为 \\<span class="string">&quot;AAAA\\&quot;</span>, 占用<span class="number">4</span>字节, 可以视作 magic number</span><br><span class="line">version: 表示文件版本号, 占用<span class="number">4</span>字节, 网络序, 无符号整型, 目前合法值为 <span class="number">1</span>, 遇到高版本需视为无效文件</span><br><span class="line">codec_id: 表示编码方式, 占用<span class="number">1</span>字节, 无符号整型, 描述了帧和帧数据段的编码格式, 目前合法值为:</span><br><span class="line"></span><br><span class="line">| codec_id | 帧编码方式 | 帧数据段格式 |</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">| <span class="number">0x0</span> | bitstream | 一系列帧按照pts_time_ms从小到大紧密排列, 而后使用gzip压缩 |</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">| <span class="number">0x1</span> | svg | 一系列帧按照pts_time_ms从小到大紧密排列, 不压缩 |</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">| <span class="number">0x2</span> | svg | 一系列帧按照pts_time_ms从小到大紧密排列, 后使用gzip压缩 | </span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">图 <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">reserved: 保留字段, 占用*字节, 目前填充为<span class="number">0</span></span><br><span class="line">entry_num: 帧索引表项的个数, 占用*字节, 网络序,无符号整型, 帧索引表项的长度固定为*字节</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> 帧索引表 (frame indexing table)</span><br><span class="line"></span><br><span class="line">|     <span class="number">8</span> bytes      |        <span class="number">8</span> bytes       |</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">| pts_time_ms      |      file_offset      |</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">| pts_time_ms      |     file_offset       |</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">| ... ... | ... ... |</span><br><span class="line">| ... ... | ... ... |</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">| pts_time_ms     | file_offset          |</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">图 <span class="number">1.3</span></span><br><span class="line">说明:</span><br><span class="line">帧索引表由若干个长度相同的表项 (entry) 紧密排列组成, 每一个表项的长度固定为<span class="number">16</span>字节每个表项的构成如</span><br><span class="line">图<span class="number">1.3</span>所示: 由 pts_time_ms 和 file_offset 组成</span><br><span class="line"></span><br><span class="line">帧索引表用于在文件中索引每个帧, 更准确地, 每一个表项均指向了文件中的一个帧数据段: 表项</span><br><span class="line">中的pts_time_ms是该帧数据段所包含的帧的起始pts_time, 表项中的file_offset就是该帧数据段</span><br><span class="line">在文件中的偏移量</span><br><span class="line"></span><br><span class="line">pts_time_ms: <span class="number">8</span>字节, 网络序, 无符号整型, 本表项指向的帧数据段的起始pts_time, 单位是ms</span><br><span class="line">file_offset: <span class="number">8</span>字节, 网络序, 无符号整型, 本表项指向的帧数据段在mask文件的偏移</span><br><span class="line"></span><br><span class="line">特别地, 帧索引表中的表项按照其pts_time_ms大小顺序存放, 这使得我们能快速检索某个已知其pts_time_ms的</span><br><span class="line">帧所在的帧数据段, 并且, 如果表项A在B前面, 那么A所指向的帧数据段的长度为B.file_offset - A.file_offset</span><br><span class="line">, 对于最后一个表项, 则是其file_offset到文件尾的长度</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span> 帧数据段 (mask frames data segment)</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">| mask frames sorted by pts_time_ms, optionally compressed |</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">| ... ... |</span><br><span class="line">| ... ... |</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">| mask frames sorted by pts_time_ms, optionally compressed |</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">图 <span class="number">1.4</span></span><br><span class="line">说明:</span><br><span class="line">每一个帧数据段都包含了若干连续的帧, 这些帧按照其pts_time_ms从大到小紧密排列, 是否压缩取决</span><br><span class="line">于codec_id值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 编码 (mask codec id)</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span> codec_id = <span class="number">0x0</span> (bitstream, gzip compressed)</span><br><span class="line"></span><br><span class="line">帧格式:</span><br><span class="line"></span><br><span class="line">| <span class="number">2</span> bytes  |  <span class="number">2</span> bytes  |    <span class="number">8</span> bytes      |  (width * height)/<span class="number">8</span> bytes |</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">|   width   |  height   | pts_time_ms |           data                      | </span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">图 <span class="number">2.1</span> bitstream 编码方式</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">帧的组成如图<span class="number">2.1</span>所示, 由: 帧宽度 + 帧高度 + 帧PTS + 帧数据 组成</span><br><span class="line">width: 帧的宽度, 占用<span class="number">2</span>字节, 网络序, 无符号整型</span><br><span class="line">height: 帧的高度, 占用<span class="number">2</span>字节, 网络序, 无符号整型</span><br><span class="line">pts_time_ms: 帧的pts时间, 占用<span class="number">8</span>字节, 网络序, 无符号整型, 单位 ms</span><br><span class="line">data: 帧的二进制数据, 占用 (width * height)/<span class="number">8</span> 字节, 每个bit位代表一个像素点, 宽度优先存储</span><br><span class="line"></span><br><span class="line">帧数据段格式:</span><br><span class="line">一系列帧按照其pts_time_ms从小到大紧密排列, 之后使用gzip压缩算法压缩而成, gzip level <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> codec_id = <span class="number">0x1</span> (svg)</span><br><span class="line"></span><br><span class="line">帧格式:</span><br><span class="line"></span><br><span class="line">| <span class="number">4</span> bytes    |       <span class="number">8</span> bytes       | data_size bytes |</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">| data_size  |  pts_time_ms        |        data     |</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">图 <span class="number">2.2</span> svg 编码方式</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">帧的组成如图<span class="number">2.2</span>所示, 由: 帧数据长度 + 帧PTS + 帧数据 组成</span><br><span class="line">data_size: 帧数据的长度, 占用<span class="number">4</span>字节, 网络序, 无符号整型, </span><br><span class="line">帧数据长度不包含data_size字段和pts_time_ms字段本身</span><br><span class="line">pts_time_ms: 帧的pts时间, 占用<span class="number">8</span>字节, 网络序, 无符号整型, 单位 ms</span><br><span class="line">data: 帧的二进制数据, 占用 data_size 字节, svg格式</span><br><span class="line"></span><br><span class="line">帧数据段格式:</span><br><span class="line">一系列帧按照其pts_time_ms从小到大紧密排列, 不压缩</span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span> codec_id = <span class="number">0x2</span> (svg, gzip compressed)</span><br><span class="line"></span><br><span class="line">帧格式:</span><br><span class="line"></span><br><span class="line">|    <span class="number">4</span> bytes  |     <span class="number">8</span> bytes     | data_size bytes |</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">| data_size   | pts_time_ms     |        data     |</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">图 <span class="number">2.2</span> svg 编码方式</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">帧的组成如图<span class="number">2.2</span>所示, 由: 帧数据长度 + 帧PTS + 帧数据 组成</span><br><span class="line">data_size: 帧数据的长度, 占用<span class="number">4</span>字节, 网络序, 帧数据长度不包含data_size字段和pts_time_ms字段本身</span><br><span class="line">pts_time_ms: 帧的pts时间, 占用<span class="number">8</span>字节, 网络序, 单位 ms</span><br><span class="line">data: 帧的二进制数据, 占用 data_size 字节, svg格式</span><br><span class="line"></span><br><span class="line">帧数据段格式:</span><br><span class="line">一系列帧按照其pts_time_ms从小到大紧密排列, 之后使用gzip压缩算法压缩而成, gzip level <span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        xhr获取指定长度、位置的arraybuffer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params">data: ApiConfig</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> xhr = <span class="built_in">this</span>.xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            xhr.open(<span class="string">&#x27;GET&#x27;</span>, data.url, <span class="literal">true</span>);</span><br><span class="line">            xhr.responseType = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line">            xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    data.success(xhr[<span class="string">&#x27;response&#x27;</span>]);</span><br><span class="line">                &#125;;</span><br><span class="line">            xhr.onerror = <span class="function">(<span class="params">error: any</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// data.error(error);</span></span><br><span class="line">                &#125;;</span><br><span class="line">            <span class="keyword">if</span> (data.withCredentials) &#123;</span><br><span class="line">                    xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (data.range) &#123;</span><br><span class="line">                <span class="comment">// 需要服务端设置允许请求头</span></span><br><span class="line">                xhr.setRequestHeader(<span class="string">&#x27;Range&#x27;</span>, data.range);</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="title">getBufferRange</span>(<span class="params"><span class="keyword">from</span>: number, to: number, cb: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> range = to === -<span class="number">1</span> ? <span class="string">`bytes=<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span>-`</span> : <span class="string">`bytes=<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span>-<span class="subst">$&#123;to&#125;</span>`</span>;</span><br><span class="line">    getData（&#123;</span><br><span class="line">        url,</span><br><span class="line">        range,</span><br><span class="line">        <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">            cb(data)</span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>移动端知识的一些总结</title>
    <url>/2020/11/14/other/mobile/</url>
    <content><![CDATA[<h1 id="一-css部分"><a href="#一-css部分" class="headerlink" title="一.css部分"></a>一.css部分</h1><p>1.meta标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=no&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>移动端加上这个标签才是真正的自适应，不加的话，假如你把一个980px宽度(手机端常规是980)的PC网页 放在手机上显示，倒也能正常显示不出现滚动条，不过是移动设备对页面 做了缩小优化，所以字体等都相应缩小了 （980px是相对于手机像素的，我的是超过1000px多一些就出现滚动条了，这个没具体研究）。<br>关于 initial-scale=1 ，这个参照iphone5的尺寸320568，如果你页面按照6401136做的话，scale就设为0.5</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- IOS中safari允许全屏浏览 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span>&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!-- IOS中Safari顶端状态条样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 忽略将数字变为电话号码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 忽略识别email --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;email=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span>&gt;</span>   </span><br><span class="line">```   </span><br><span class="line">2.图片尺寸 做全屏显示的图片时，一般为了兼容大部分的手机，图片尺寸一般设为 640*960（我是觉得这个尺寸好，也看不少的图片也是这个尺寸，视情况而定）</span><br><span class="line"></span><br><span class="line">3.去除 webkit的滚动条</span><br></pre></td></tr></table></figure>
<p>element::-webkit-scrollbar{</p>
<pre><code>display: none;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果要去除全部的，就把 element去掉 同时这个属性可让在 div里的滚动如丝般顺滑： -webkit-overflow-scrolling : touch;</span><br><span class="line"></span><br><span class="line">4.去除 button在 ios上的默认样式</span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"></span><br><span class="line">border-radius: 0</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>placeholder元素样式的修改</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure>

<p>6.不想让按钮 touch时有蓝色的边框或半透明灰色遮罩（根据系统而定）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span><span class="selector-pseudo">:rgba(0</span>,0,0,0);</span><br></pre></td></tr></table></figure>

<p>7.在移动端做动画效果的话，如果通过改变绝对定位的 top，或者 margin的话做出来的效果很差，很不流畅，而使用 css3的 transition、 transform或者 animation的效果将会非常棒（这一方面 IOS比 android又要好不少）。 如果用 **3d（translate3d）来实现动画，会开启 <a href="https://cloud.tencent.com/product/gpu" target="_blank">GPU</a>加速，动画会更加流畅，但硬件配置差的安卓用起来会耗很多性能</p>
<p>8.使用图片时，会发现图片下总是有大概 4px的空白，（原因据说图片是inline，触发baseline什么的。。。）常用解决方法有</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;<span class="attribute">display</span>:block&#125;；</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span>&#123;<span class="attribute">vertical-align</span>:top&#125;</span><br></pre></td></tr></table></figure>

<p>也可取其他几个值，视情况而定<br>9.关于使用弹性盒子 box布局 暂时有三种方案：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">display:-webkit-box; // 早期的版本</span><br><span class="line"></span><br><span class="line">display:-webkit-box-flex; // 过渡版本</span><br><span class="line"></span><br><span class="line">display:-webkit-flex; // 最新的版本</span><br></pre></td></tr></table></figure>

<p>我暂时使用的是 display:-webkit-box;暂时只有这个的兼容性最好， flex是最好用，还可以如 float一样排多个元素时自动换行，只是兼容性还太差，（即使是第一种，在火狐下兼容性也不是很好） 对于第一种常见用法是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line"></span><br><span class="line">display: -webkit-box;</span><br><span class="line"></span><br><span class="line">　　-webkit-box-align: center; // 设置里面的元素垂直居中</span><br><span class="line"></span><br><span class="line">　　-webkit-box-pack: center; // 设置水平居中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .box_flex1 &#123;</span><br><span class="line"></span><br><span class="line">　　box-flex: 1;</span><br><span class="line"></span><br><span class="line">　　-webkit-box-flex: 1;</span><br><span class="line"></span><br><span class="line">　　-moz-box-flex: 1;</span><br><span class="line"></span><br><span class="line">　　display: block;</span><br><span class="line"></span><br><span class="line">　　width: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想三个 li元素平分 box的宽度， width:0是关键（在这个坑里陷了好久，直到偶然的一次设置了 width：0突然就好了，后来在天猫上也看到了同样的设置 width:0） </p>
<p>10.使用 a 标签的话，尽量让 a 标签 block ，尽量让用户可点击区域最大化 </p>
<p>11.对两个 div使用了 transform之后， div下的 z-index有时就会失效，我遇到过，但没去认真探究，只是把 z-index提高就好了 </p>
<p>12.在 iOS中，当你点击比如 input 准备输入时，虚拟键盘弹出，整个视窗的 高度 就会变为 减去键盘 的高度，加入你在底部有 fixed的元素比如 btn，这个元素就会跑上来，一般都不会太美观。我是当 focus时就把它设为 absolute，视情况而定，也有比如显示一个新的层，将含有 fixed按钮的那一层隐藏的情况等等。 另外一种情况（一般在页面内容很少时 iphone5及以上常发生），当输入框弹出时 fixed元素挤到输入框上，当输入框消失时， fixed元素并没有随着输入框的消失而回到底部，这是因为整个视窗的高度还保持在 减去键盘的 高度，需要手动去触发让视窗高度回到正常，然后试了很多方法都没成功，后来的方案是输入框消失时给页面加隐形的很大的 padding比如 1000px并在 30ms后改为正常</p>
<p>13.禁止用户选中文字 -webkit-user-select:none</p>
<p>14.当把 input设为 width:100%时，有时可能会遇到 input的宽度超出了屏幕，这时可对 input加一个属性 box-sizing:border-box</p>
<p>关于 box-sizing:border-box，此属性是把边框的宽度和 padding包含在盒子的高宽中，假如你设置两个元素 float且各占 50%，又都有 border时，用这个属性就可以完美地让它们能显示在同一行</p>
<p>15.做一个方向箭头比如 “&gt;” 时，可以用一个正方形的 div，设置 border:1px 1px 0 0；然后 rotate(45deg)，这样就省去了一个图片</p>
<ol start="16">
<li>CSS权重： style是 1000， id是 100， class是 10，普通如 li、 div和伪类是 1，通用如 *是 0；</li>
</ol>
<p>17.使用 rem时，设某个 div比如的 height:3rem;line-height:1.5rem;overflow:hidden;时，在某些 android手机上可能会出现显示不止两行,第三行会显示点头部。 解决：利用 js获取文字 line-height再去设置 div高度 </p>
<p>18.使用 background时， background-position里使用了比如 center left后不能再加具体的数值去定位，比如 center 10px left（暂时兼容性差）</p>
<p>19.使用 rem布局时，由于 webkit支持的最小字体大小是 12px，所以使用 html使用 62.5%实际是 12px，这样很难计算，我的做法是设置成 625%即 100px，然后 1rem就相当于 100px</p>
<p>20.移动端字体使用 font-family: Helvetica,sans-serif;我看这也是天猫使用的</p>
<p>21.在 iphone原生键盘上用 keyup统计字符数时，系统不会自动监控你选择文字的事件，比如打了多个拼音，可能选择的实际文字比输入的字符数多或者少，但无法在用户确定自己的输入时监控到 keyup（其他事件也一样）判断字符数。 改成 input事件就可以了</p>
<p>22.实现毛玻璃效果，透过背景看其他元素模糊，自身元素不模糊。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-backdrop-filter</span>: <span class="selector-tag">saturate</span>(180%) <span class="selector-tag">blur</span>(20<span class="selector-tag">px</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure>

<p>这个效果暂时只有 IOS9上的 safari可以。 用 css3的 blur效果的话，是整层元素全部模糊，而透过模糊层看其他的元素不模糊</p>
<p>23.如果需要展示小于 12px的文字，用 transform:scale(%);它将元素缩小，但本身应该占的空间并不会变小，所以比如要元素居左对齐的话，还需设置 translateX 24.在移动端对 input框使用 disabled属性，会导致元素里面 value值在页面上被隐藏看不见，可以对元素使用 css3效果 pointer-event:none，意思就是此元素对鼠标事件无效</p>
<h1 id="二-js部分"><a href="#二-js部分" class="headerlink" title="二.js部分"></a>二.js部分</h1><p>1.如果使用 jquery绑定 touch事件的话，获取 touchstart， touchmove的触点坐标用 e.originalEvent.targetTouches[0].pageX，获取 touchend则用 e.originalEvent.changedTouches[0].pageX 2.利用 style获取获取 transform的 rotate值<li>parseInt(/rotateX\((.*?)\)/.exec(getALL.style.webkitTransform)[1])</li><li></li><li>如果页面一开始没有<code>style</code>值，<code>rotate</code>是写在<code>CSS</code>里的，需要用到<code>getComputedStyle</code>，具体请看[这里][5]  </li></p>
<p>3.有些版本的 iphone4中， audio和 video默认播放事件不会触发，比如使用 window.onload或计时器等都不能触发播放，必须用 JS写事件让用户手动点击触发才会开始播放，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).one(<span class="string">&#x27;touchstart&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    audio.play();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4.想要在 touchmove:function(e,参数一)加一个参数，结果直接使用 e.preventDefault()就会 e 报错，处理方法为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touchmove:<span class="function"><span class="keyword">function</span>(<span class="params">e,参数一</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> e=<span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">　　e.preventDefault()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.移动端的一些小页面可能没必要用到 zepto.js这些工具库，就可以使用一些新一点的 api，比如选取元素用 querySelector(“.class #id”)和 querySelectorAll(“.class element”),操作 class可以用 classList</p>
<p>6.点击一个元素时，使用 touchstart会立即触发，而使用 click则用有大概 0.3s的延迟 想模拟一个立即触发的点击事件有两种方法， fastclick.js和 zepto.js里的 tap事件。</p>
<p>不过 zepto的 tap事件有一个事件穿透的问题。假如你 tap一个弹出层元素（这个元素遮罩了一个 a标签），这个元素立即消失，这样由于上述的 0.3s延迟 tap事件就会传递给 a标签成 click事件造成a标签跳转。 以上面的例子来说，解决方案视情况而定： </p>
<p>① tap时让遮罩渐隐消失，这个过程超过 400ms就不会穿透到下一层去了 </p>
<p>② 在 touchend事件回调中加入 preventDefault, 并在下一层中加上 pointer-events:none。（这个没用过） </p>
<p>③ 有的时候比如弹出一个 iphone上滑动出来的层，点击黑色半透明区域弹出层消失，这种可以在黑色区域绑定 touchend也是和 tap差不多的效果</p>
<p>7.当弹窗出现时，想禁止屏幕的滑动，给那个遮罩层添加 touchmove事件即可，用 e.preventDefault()会阻止的 scroll， click等事件，消失时再 off掉，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.body_cover&quot;</span>).on(<span class="string">&quot;touchmove&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">　　e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>8.使用 input file上传文件时，可以指定接受的类型， accept=”image/png,image/jpeg,image/gif” ，同时在 android上默认不能使用相机，可以加 capture=”camera” 同时，由于原生的样式不好看，可以通过设置input的display:none,然后使用id.click()去触发input元素的点击。</p>
<p>9.给元素加:active伪类时，如果要求高，兼容性好的话，就得用js监控touchstart然后加相应的class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&quot;touchstart&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> target = $(e.target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target.hasClass(<span class="string">&quot;is_hover&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        target.addClass(<span class="string">&quot;hover_css&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>三、微信部分<br>1.判断是否来自微信浏览器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFromWeiXin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ua.match(<span class="regexp">/MicroMessenger/i</span>) == <span class="string">&quot;micromessenger&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>2.判断手机的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/android/i</span>.test(navigator.userAgent))&#123;</span><br><span class="line">    <span class="comment">//  android</span></span><br><span class="line">    user=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/ipad|iphone|mac/i</span>.test(navigator.userAgent))&#123;</span><br><span class="line">    <span class="comment">//  ios</span></span><br><span class="line">    user=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.如果在网页里嵌套一个 iframe， src为其他的网址等，当在微信浏览器打开时，如果 iframe里的页面过大，则 iframe的 src不能加载（具体多大不知道，只是遇到过）。</p>
<p>4.微信 jssdk里预览图片接口，图片的 url不能填 base64编码， ios上会很卡，估摸着微信得卡个 5秒左右才打得开，而 android上压跟就卡住或者一直卡在读取图片界面</p>
<p>5.微信当在输入框里输入消息时，会提示警示框不要输入qq密码等，这个可以在公众平台的功能设置的业务域名设置</p>
<p>6.微信里假如页面一使用 ajax获取数据，当你进入下一页面再按返回键返回页面一的时候，有些情况不会去请求 ajax数据，会使用缓存，然而 ajax来的数据又并没有存在缓存里。要设置 cache:false（iphone、android的某些手机都可能出现）</p>
<p>7.在微信 js config的时候，如果 URL的参数有如 ?a={“param”: “1”},会导致签名失败。给参数用 encodeURIComponent编码后再传过去也是失败！研究了好久。（后台代码没做任何修改，只在我前端修改代码）。所以最后还是使用了 ?param=1这样的格式</p>
<p><a href="https://segmentfault.com/a/1190000003908191" target="_blank">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>Babel原理及其使用</title>
    <url>/2020/11/14/project/babel/</url>
    <content><![CDATA[<h2 id="Babel的包构成"><a href="#Babel的包构成" class="headerlink" title="Babel的包构成"></a>Babel的包构成</h2><h2 id="核心包"><a href="#核心包" class="headerlink" title="核心包"></a>核心包</h2><ul><li>babel-core：babel转译器本身，提供了babel的转译API，如babel.transform等，用于对代码进行转译。像webpack的babel-loader就是调用这些API来完成转译过程的。</li><li>babylon：js的词法解析器</li><li>babel-traverse：用于对AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给plugin用</li><li>babel-generator：根据AST生成代码</li></ul>

<h2 id="功能包"><a href="#功能包" class="headerlink" title="功能包"></a>功能包</h2><ul><li>babel-types：用于检验、构建和改变AST树的节点</li><li>babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点</li><li>babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用</li><li>babel-code-frames：用于生成错误信息，打印出错误点源代码帧以及指出出错位置</li><li>babel-plugin-xxx：babel转译过程中使用到的插件，其中babel-plugin-transform-xxx是transform步骤使用的</li><li>babel-preset-xxx：transform阶段使用到的一系列的plugin</li><li>babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装</li><li>babel-runtime：功能类似babel-polyfill，一般用于library或plugin中，因为它不会污染全局作用域</li></ul>

<h2 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h2><p>babel-cli：babel的命令行工具，通过命令行对js代码进行转译<br>babel-register：通过绑定node.js的require来自动转译require引用的js代码文件</p>
<h2 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h2><h2 id="使用形式"><a href="#使用形式" class="headerlink" title="使用形式"></a>使用形式</h2><p>如果是以命令行方式使用babel，那么babel的设置就以命令行参数的形式带过去；<br>还可以在package.json里在babel字段添加设置；<br>但是建议还是使用一个单独的.babelrc文件，把babel的设置都放置在这里，所有babel API的options（除了回调函数之外）都能够支持，具体的options见<a href="https://babeljs.io/docs/usage/api/#options" target="_blank">babel的API options文档</a></p>
<h2 id="常用options字段说明"><a href="#常用options字段说明" class="headerlink" title="常用options字段说明"></a>常用options字段说明</h2><ul><li>env：指定在不同环境下使用的配置。比如production和development两个环境使用不同的配置，就可以通过这个字段来配置。env字段的从process.env.BABEL_ENV获取，如果BABEL_ENV不存在，则从process.env.NODE_ENV获取，如果NODE_ENV还是不存在，则取默认值"development"</li><li>plugins：要加载和使用的插件列表，插件名前的babel-plugin-可省略；plugin列表按从头到尾的顺序运行</li><li>presets：要加载和使用的preset列表，preset名前的babel-preset-可省略；presets列表的preset按从尾到头的逆序运行（为了兼容用户使用习惯）</li><li>同时设置了presets和plugins，那么plugins的先运行；每个preset和plugin都可以再配置自己的option</li></ul>

<h2 id="配置文件的查找"><a href="#配置文件的查找" class="headerlink" title="配置文件的查找"></a>配置文件的查找</h2><p>babel会从当前转译的文件所在目录下查找配置文件，如果没有找到，就顺着文档目录树一层层往上查找，一直到.babelrc文件存在或者带babel字段的package.json文件存在为止。</p>
<h2 id="babel的工作原理"><a href="#babel的工作原理" class="headerlink" title="babel的工作原理"></a>babel的工作原理</h2><p>babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则，而不像编译器那样，输出的是另一种更低级的语言代码。<br>但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p>
<blockquote>
<p>ES6代码输入 ==》 babylon进行解析 ==》 得到AST<br>==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树<br>==》 用babel-generator通过AST树生成ES5代码</p>
</blockquote>
<p>此外，还要注意很重要的一点就是，babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决</p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件应用于babel的转译过程，尤其是第二个阶段transforming，如果这个阶段不使用任何插件，那么babel会原样输出代码。<br>我们主要关注transforming阶段使用的插件，因为transform插件会自动使用对应的词法插件，所以parsing阶段的插件不需要配置。</p>
<h2 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h2><p>如果要自行配置转译过程中使用的各类插件，那太痛苦了，所以babel官方帮我们做了一些预设的插件集，称之为preset，这样我们只需要使用对应的preset就可以了。以JS标准为例，babel提供了如下的一些preset：<ul><li>es2015</li><li>es2016</li><li>es2017</li><li>env<br>es20xx的preset只转译该年份批准的标准，而env则代指最新的标准，包括了latest和es20xx各年份<br>另外，还有 stage-0到stage-4的标准成形之前的各个阶段，这些都是实验版的preset，建议不要使用。</li></ul></p>
<h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>polyfill是一个针对ES2015+环境的shim，实现上来说babel-polyfill包只是简单的把core-js和regenerator runtime包装了下，这两个包才是真正的实现代码所在（后文会详细介绍core-js）。<br>使用babel-polyfill会把ES2015+环境整体引入到你的代码环境中，让你的代码可以直接使用新标准所引入的新原生对象，新API等，一般来说单独的应用和页面都可以这样使用。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>先安装包： npm install --save babel-polyfill</li><li>要确保在入口处导入polyfill，因为polyfill代码需要在所有其他代码前先被调用
代码方式：import "babel-polyfill"</li><li>webpack配置：module.exports = { entry: ["babel-polyfill", "./app/js"] };</li></ol>
如果只是需要引入部分新原生对象或API，那么可以按需引入，而不必导入全部的环境，具体见下文的core-js
## runtime

<h2 id="polyfill和runtime的区别"><a href="#polyfill和runtime的区别" class="headerlink" title="polyfill和runtime的区别"></a>polyfill和runtime的区别</h2><p>直接使用babel-polyfill对于应用或页面等环境在你控制之中的情况来说，并没有什么问题。但是对于在library中使用polyfill，就变得不可行了。因为library是供外部使用的，但外部的环境并不在library的可控范围，而polyfill是会污染原来的全局环境的（因为新的原生对象、API这些都直接由polyfill引入到全局环境）。这样就很容易会发生冲突，所以这个时候，babel-runtime就可以派上用场了。</p>
<h2 id="transform-runtime和babel-runtime"><a href="#transform-runtime和babel-runtime" class="headerlink" title="transform-runtime和babel-runtime"></a>transform-runtime和babel-runtime</h2><p>babel-plugin-transform-runtime插件依赖babel-runtime，babel-runtime是真正提供runtime环境的包；也就是说transform-runtime插件是把js代码中使用到的新原生对象和静态方法转换成对runtime实现包的引用，举个例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入的ES6代码</span></span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// 通过transform-runtime转换后的ES5+runtime代码 </span></span><br><span class="line"><span class="keyword">var</span> _symbol = <span class="built_in">require</span>(<span class="string">&quot;babel-runtime/core-js/symbol&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sym = (<span class="number">0</span>, _symbol.default)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面这个例子可见，原本代码中使用的ES6新原生对象Symbol被transform-runtimec插件转换成了babel-runtime的实现，既保持了Symbol的功能，同时又没有像polyfill那样污染全局环境（因为最终生成的代码中，并没有对Symbol的引用）<br>另外，这里我们也可以隐约发现，babel-runtime其实也不是真正的实现代码所在，真正的代码实现是在core-js中，后面我们再说</p>
<h2 id="transform-runtime插件的功能"><a href="#transform-runtime插件的功能" class="headerlink" title="transform-runtime插件的功能"></a>transform-runtime插件的功能</h2><ol><li>把代码中的使用到的ES6引入的新原生对象和静态方法用babel-runtime/core-js导出的对象和方法替代</li><li>当使用generators或async函数时，用babel-runtime/regenerator导出的函数取代（类似polyfill分成regenerator和core-js两个部分）</li><li>把Babel生成的辅助函数改为用babel-runtime/helpers导出的函数来替代（babel默认会在每个文件顶部放置所需要的辅助函数，如果文件多的话，这些辅助函数就在每个文件中都重复了，通过引用babel-runtime/helpers就可以统一起来，减少代码体积）</li></ol>
上述三点就是transform-runtime插件所做的事情，由此也可见，babel-runtime就是一个提供了regenerator、core-js和helpers的运行时库。
建议不要直接使用babel-runtime，因为transform-runtime依赖babel-runtime，大部分情况下都可以用transform-runtime达成目的。
此外，transform-runtime在.babelrc里配置的时候，还可以设置helpers、polyfill、regenerator这三个开关，以自行决定runtime是否要引入对应的功能。
最后补充一点：由于runtime不会污染全局空间，所以实例方法是无法工作的（因为这必须在原型链上添加这个方法，这是和polyfill最大的不同） ，比如：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.fill(<span class="number">7</span>);  <span class="comment">// 实例方法不行</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.fill.apply(arr, <span class="number">7</span>);  <span class="comment">// 用原型链来调用也是不行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="通过core-js实现按需引入polyfill或runtime"><a href="#通过core-js实现按需引入polyfill或runtime" class="headerlink" title="通过core-js实现按需引入polyfill或runtime"></a>通过core-js实现按需引入polyfill或runtime</h2><p>core-js包才上述的polyfill、runtime的核心，因为polyfill和runtime其实都只是对core-js和regenerator的再封装，方便使用而已。<br>但是polyfill和runtime都是整体引入的，不能做细粒度的调整，如果我们的代码只是用到了小部分ES6而导致需要使用polyfill和runtime的话，会造成代码体积不必要的增大（runtime的影响较小）。所以，按需引入的需求就自然而然产生了，这个时候就得依靠core-js来实现了。</p>
<h2 id="core-js的组织结构"><a href="#core-js的组织结构" class="headerlink" title="core-js的组织结构"></a>core-js的组织结构</h2><p>首先，core-js有三种使用方式：<ul><li>默认方式：require(‘core-js’)<br>这种方式包括全部特性，标准的和非标准的</li><li>库的形式： var core = require(‘core-js/library’)<br>这种方式也包括全部特性，只是它不会污染全局名字空间</li><li>只是shim： require(‘core-js/shim’)或var shim = require(‘core-js/library/shim’)<br>这种方式只包括标准特性（就是只有polyfill功能，没有扩展的特性）</li></ul><br>core-js的结构是高度模块化的，它把每个特性都组织到一个小模块里，然后再把这些小模块组合成一个大特性，层层组织。比如：<br>core-js/es6（core-js/library/es6）就包含了全部的ES6特性，而core-js/es6/array（core-js/library/es6/array）则只包含ES6的Array特性，而core-js/fn/array/from（core-js/library/fn/array/from）则只有Array.from这个实现。<br>实现按需使用，就是自己选择使用到的特性，然后导入即可。具体的每个特性和对应的路径可以直接查看<a href="https://github.com/zloirock/core-js#ecmascript-6" target="_blank">core-js的github</a></p>
<h2 id="core-js的按需使用"><a href="#core-js的按需使用" class="headerlink" title="core-js的按需使用"></a>core-js的按需使用</h2><p>1、类似polyfill，直接把特性添加到全局环境，这种方式体验最完整</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/fn/set&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/fn/array/from&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/fn/array/find-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])); <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>, <span class="number">3</span>, <span class="number">4</span>].findIndex(<span class="built_in">isNaN</span>);   <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、类似runtime一样，以库的形式来使用特性，这种方式不会污染全局名字空间，但是不能使用实例方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Set</span>       = <span class="built_in">require</span>(<span class="string">&#x27;core-js/library/fn/set&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">from</span>      = <span class="built_in">require</span>(<span class="string">&#x27;core-js/library/fn/array/from&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> findIndex = <span class="built_in">require</span>(<span class="string">&#x27;core-js/library/fn/array/find-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]));      <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">findIndex([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="built_in">isNaN</span>); <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、因为第二种库的形式不能使用prototype方法，所以第三种方式使用了一个小技巧，通过::这个符号而不是.来调用实例方式，从而达到曲线救国的目的。这种方式的使用，路径中都会带有/virtual/</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fill, findIndex&#125; <span class="keyword">from</span> <span class="string">&#x27;core-js/library/fn/array/virtual&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">10</span>)::fill(<span class="number">0</span>).map(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b * b)::findIndex(<span class="function"><span class="params">it</span> =&gt;</span> it &amp;amp;&amp;amp; !(it % <span class="number">8</span>)); <span class="comment">// =&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比下polyfill的实现 </span></span><br><span class="line"><span class="comment">// Array(10).fill(0).map((a, b) =&gt; b * b).findIndex(it =&gt; it &amp;amp;&amp;amp; !(it % 8));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Babel使用的难点主要在于理解polyfill、runtime和core-js，通过本文，把这三者的概念和关系理清楚了，对babel的使用就不存在问题！</p>
]]></content>
  </entry>
  <entry>
    <title>Github + Webhooks 自动化部署流程（vue-ssr</title>
    <url>/2020/11/14/project/github-webhook/</url>
    <content><![CDATA[<h2 id="一、先说明下最终要实现的效果"><a href="#一、先说明下最终要实现的效果" class="headerlink" title="一、先说明下最终要实现的效果"></a>一、先说明下最终要实现的效果</h2><ul>
<li>1、服务器监听 GitHub，push代码后，拉取最新代码</li>
<li>2、安装依赖，打包代码</li>
<li>3、把打包的文件（dist/*）移动到发布目录，并命名（next</li>
<li>4、把正在运行的目录（dist）重命名（pre），（next）重命名（dist）</li>
<li>5、重启服务<h2 id="二、GitHub的webhooks"><a href="#二、GitHub的webhooks" class="headerlink" title="二、GitHub的webhooks"></a>二、GitHub的webhooks</h2><img src="/img/webhook.png"></li>
</ul>
<h2 id="三、创建-webhook-服务后端"><a href="#三、创建-webhook-服务后端" class="headerlink" title="三、创建 webhook 服务后端"></a>三、创建 webhook 服务后端</h2><p>webhook.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-family: &amp;quot;Source Sans Pro&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;</span>&gt;<span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);&lt;/span&gt;</span><br><span class="line"><span class="keyword">const</span> createHandler = <span class="built_in">require</span>(<span class="string">&quot;github-webhook-handler&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = createHandler(&#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">secret</span>: <span class="string">&quot;hongye&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// 上面的 secret 保持和 GitHub 后台设置的一致</span></span><br><span class="line"></span><br><span class="line">handler.on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&quot;Error:&quot;</span>, err.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handler.on(<span class="string">&quot;push&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> name = event.payload.repository.name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Received a push event for %s to %s&quot;</span>, name, event.payload.ref);</span><br><span class="line">  <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;vue-ssr&quot;</span>:</span><br><span class="line">      runCmd(<span class="string">&quot;sh&quot;</span>, [<span class="string">&quot;./deploy.sh&quot;</span>, name], <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(text);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runCmd</span>(<span class="params">cmd, args, callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>).spawn;</span><br><span class="line">  <span class="keyword">const</span> child = spawn(cmd, args);</span><br><span class="line">  <span class="keyword">let</span> resp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  child.stdout.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        resp += buffer.toString();</span><br><span class="line">  &#125;);</span><br><span class="line">  child.stdout.on(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(resp);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        handler(req, res, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          res.statusCode = <span class="number">404</span>;</span><br><span class="line">      res.end(<span class="string">&quot;no such location&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8080</span>);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>packages.json</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgLoad</span>(<span class="params">url</span>) </span>&#123;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hongye&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;webhook.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;pm2 start webhook.js&quot;</span>,</span><br><span class="line">        <span class="string">&quot;red&quot;</span>: <span class="string">&quot;pm2 restart webhook.js&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="string">&quot;pm2 start ./server&quot;</span>, <span class="comment">//vue-项目启动程序</span></span><br><span class="line">        <span class="string">&quot;re&quot;</span>: <span class="string">&quot;pm2 restart ./server&quot;</span>  <span class="comment">// vue-项目重启</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;axios&quot;</span>: <span class="string">&quot;^0.19.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tslib&quot;</span>: <span class="string">&quot;^1.10.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;^3.7.2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;koa&quot;</span>: <span class="string">&quot;^2.11.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;koa-static&quot;</span>: <span class="string">&quot;^5.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;koa-send&quot;</span>: <span class="string">&quot;^5.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue-class-component&quot;</span>: <span class="string">&quot;^7.0.2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue-property-decorator&quot;</span>: <span class="string">&quot;^8.3.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.1.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vuex&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue-server-renderer&quot;</span>: <span class="string">&quot;^2.6.10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vue-lazyload&quot;</span>: <span class="string">&quot;^1.3.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;github-webhook-handler&quot;</span>: <span class="string">&quot;^0.7.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>deploy.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 网站的根目录</span><br><span class="line">WEB_PATH&#x3D;&#39;&#x2F;var&#x2F;www&#x2F;vue-ssr&#39;</span><br><span class="line">DEP_PATH&#x3D;&#39;&#x2F;var&#x2F;www&#x2F;deploy&#39;</span><br><span class="line"> </span><br><span class="line">cd $WEB_PATH</span><br><span class="line">echo &quot;fetching from remote...&quot;</span><br><span class="line"># 为了避免冲突，强制更新本地文件</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;master</span><br><span class="line">npm i</span><br><span class="line">npm run build:mac</span><br><span class="line"></span><br><span class="line">mkdir -p $DEP_PATH&#x2F;next</span><br><span class="line">mv .&#x2F;dist&#x2F;* $DEP_PATH&#x2F;next</span><br><span class="line"></span><br><span class="line">cd $DEP_PATH</span><br><span class="line">rm -rf .&#x2F;pre</span><br><span class="line">mv -f .&#x2F;dist .&#x2F;pre</span><br><span class="line">mv -f .&#x2F;next .&#x2F;dist</span><br><span class="line">rm -rf .&#x2F;next&#x2F;*</span><br><span class="line"></span><br><span class="line">npm run re</span><br><span class="line"></span><br><span class="line">echo &quot;done&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>git的commit规范及强制校验</title>
    <url>/2020/11/14/project/commitlint/</url>
    <content><![CDATA[<blockquote>
<p>commitlint 配合husky 在git push 代码之前检测commit messages</p>
</blockquote>
<p><a href="https://github.com/typicode/husky" target="_blank">https://github.com/typicode/husky</a></p>
<p><a href="https://commitlint.js.org/#/" target="_blank">https://commitlint.js.org/#/</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank">Commit message 和 Change log 编写指南</a></p>
<h2 id="一：安装commitlint"><a href="#一：安装commitlint" class="headerlink" title="一：安装commitlint"></a>一：安装commitlint</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -D @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure>
<p>生成配置文件：&gt; commitlint.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line"> <span class="keyword">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>],</span><br><span class="line"> rules: &#123; </span><br><span class="line">  <span class="string">&#x27;type-enum&#x27;</span>: </span><br><span class="line">    [<span class="number">2</span>, <span class="string">&#x27;always&#x27;</span>, </span><br><span class="line">      [ <span class="string">&quot;feat&quot;</span>, <span class="string">&quot;fix&quot;</span>, <span class="string">&quot;docs&quot;</span>, <span class="string">&quot;style&quot;</span>, <span class="string">&quot;refactor&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;chore&quot;</span>, <span class="string">&quot;revert&quot;</span> ]</span><br><span class="line">    ], </span><br><span class="line">   <span class="string">&#x27;subject-full-stop&#x27;</span>: [<span class="number">0</span>, <span class="string">&#x27;never&#x27;</span>], </span><br><span class="line">   <span class="string">&#x27;subject-case&#x27;</span>: [<span class="number">0</span>, <span class="string">&#x27;never&#x27;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二：安装husky</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install husky -D</span><br></pre></td></tr></table></figure>
<p>husky继承了Git下所有的钩子，在触发钩子的时候，husky可以阻止不合法的commit,push等等。注意使用husky之前，必须先将代码放到git 仓库中，否则本地没有.git文件，就没有地方去继承钩子了。</p>
<p>项目下的package.json中配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三： 配合pretty-quick 格式化代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev prettier pretty-quick</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>terser-webpack-plugin</title>
    <url>/2020/11/14/project/terser-webpack-plugin/</url>
    <content><![CDATA[<p><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank">github</a></p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>To begin, you’ll need to install terser-webpack-plugin:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>Then add the plugin to your webpack config. For example:</p>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      optimization: &#123;</span><br><span class="line">        minimizer: [<span class="keyword">new</span> TerserPlugin()],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>test：<br>Type: String|RegExp|Array&lt;String|RegExp&gt; Default: /\.m?js(\?.*)?$/i</li>
</ul>
<ul>
<li><p>include/exclude:</p>
<p>  Type: String|RegExp|Array&lt;String|RegExp&gt; Default: undefined</p>
</li>
</ul>
<ul>
<li><p>chunkFilter:</p>
<p>  Type: Function&lt;(chunk) -&gt; boolean&gt; Default: () =&gt; true</p>
<p>  允许过滤哪些块应压缩（默认情况下，所有块都压缩）。返回true使块压缩，否则返回false。</p>
</li>
<li><p>cache:<br>  Type: 指定路径或者默认路径Boolean|String Default: false</p>
<p>  启用文件缓存。缓存目录的默认路径：node_modules/.cache/terser webpack plugin。</p>
<p>  _如果使用自己的minify功能，请正确阅读minify部分以了解缓存的无效性。</p>
</li>
</ul>
<ul>
<li><p>cacheKeys:<br>  Type: Function&lt;(defaultCacheKeys, file) -&gt; Object&gt; Default: defaultCacheKeys =&gt; defaultCacheKeys</p>
</li>
<li><p>parallel:<br>  Type: Boolean|Number Default: false</p>
<p>  使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus（）.length-1。<br>  _并行化可以显著加快构建速度，因此强烈推荐。</p>
</li>
<li><p>sourceMap:<br>  Type: Boolean Default: false</p>
<p>  使用源映射将错误消息位置映射到模块（这会减慢编译速度）。</p>
<p>  如果使用自己的minify函数，请阅读minify部分以正确处理源映射。</p>
<p>  cheap-source-map  选项不适用于此插件。</p>
</li>
<li><p>minify:<br>  Type: Function Default: undefined</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">            test: <span class="regexp">/\\.js(\\?.*)?$/i</span>,</span><br><span class="line">            include: <span class="regexp">/\\/i</span>ncludes/,</span><br><span class="line">            exclude: <span class="regexp">/\\/</span>excludes/,</span><br><span class="line">            chunkFilter: <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// Exclude uglification for the `vendor` chunk</span></span><br><span class="line">                <span class="keyword">if</span> (chunk.name === <span class="string">&#x27;vendor&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            cache: <span class="literal">true</span> / <span class="string">&#x27;path/to/cache&#x27;</span>,</span><br><span class="line">            cacheKeys: <span class="function">(<span class="params">defaultCacheKeys, file</span>) =&gt;</span> &#123;</span><br><span class="line">                defaultCacheKeys.myCacheKey = <span class="string">&#x27;myCacheKeyValue&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> defaultCacheKeys;</span><br><span class="line">            &#125;,</span><br><span class="line">            parallel: <span class="number">4</span> / <span class="literal">true</span>,</span><br><span class="line">            sourceMap: <span class="literal">true</span>,</span><br><span class="line">            minify: <span class="function">(<span class="params">file, sourceMap</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> extractedComments = []</span><br><span class="line">                <span class="comment">// Custom logic for extract comments</span></span><br><span class="line">                <span class="keyword">const</span> &#123;error,map,code,warnings &#125;=<span class="built_in">require</span>(<span class="string">&#x27;uglify-module&#x27;</span>) </span><br><span class="line">                <span class="comment">// Or require(&#x27;./path/to/uglify-module&#x27;)</span></span><br><span class="line">            .minify(file, &#123;</span><br><span class="line">                  <span class="comment">/* Your options for minification */</span></span><br><span class="line">            &#125;);</span><br><span class="line">          <span class="keyword">return</span> &#123; error, map, code, warnings, extractedComments &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>允许覆盖默认的缩小功能。默认插件使用terser包。用于使用和测试未发布的版本或分叉。<br>启用并行选项时，始终使用要求内部缩小功能。</p>
<h2 id="terserOptions"><a href="#terserOptions" class="headerlink" title="terserOptions:"></a>terserOptions:</h2><p>Type: Object Default: default<br><a href="https://github.com/terser/terser#minify-options" target="_blank">详细信息看这</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">          <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">            terserOptions: &#123;</span><br><span class="line">              ecma: <span class="literal">undefined</span>,</span><br><span class="line">          warnings: <span class="literal">false</span>,</span><br><span class="line">          parse: &#123;&#125;,</span><br><span class="line">          compress: &#123;&#125;,</span><br><span class="line">          mangle: <span class="literal">true</span>, <span class="comment">// Note `mangle.properties` is `false` by default.</span></span><br><span class="line">          <span class="built_in">module</span>: <span class="literal">false</span>,</span><br><span class="line">          output: <span class="literal">null</span>,</span><br><span class="line">          toplevel: <span class="literal">false</span>,</span><br><span class="line">          nameCache: <span class="literal">null</span>,</span><br><span class="line">          ie8: <span class="literal">false</span>,</span><br><span class="line">          keep_classnames: <span class="literal">undefined</span>,</span><br><span class="line">          keep_fnames: <span class="literal">false</span>,</span><br><span class="line">          safari10: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="extractComments"><a href="#extractComments" class="headerlink" title="extractComments:"></a>extractComments:</h2><p>Type: Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;|Object Default: false<br>是否将注释提取到单独的文件中（见详细信息）。</p>
<p>默认情况下，仅使用/^ \**提取注释！|@保留@license@cc_on/i regexp条件并删除剩余注释。</p>
<p>如果原始文件名为foo.js，则注释将存储到foo.js.license。</p>
<p>terseroptions.output.comments选项指定是否保留注释，<br>即可以在提取其他注释的同时保留某些注释（例如注释），甚至可以保留已提取的注释。</p>
<p>condition：<br>Type: Boolean|String|RegExp|Function&lt;(node, comment) -&gt; Boolean|Object&gt;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">          <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                extractComments: &#123;</span><br><span class="line">                condition: <span class="regexp">/^\\**!|@preserve|@license|@cc_on/i</span>,</span><br><span class="line">                filename: <span class="string">&#x27;extracted-comments.js&#x27;</span>,</span><br><span class="line">                banner: <span class="function">(<span class="params">licenseFile</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">`License information can be found in <span class="subst">$&#123;licenseFile&#125;</span>`</span>;</span><br><span class="line">                 &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>webpack 编写一个plugin</title>
    <url>/2020/11/14/project/webpack-plugin/</url>
    <content><![CDATA[<blockquote>
<p>创建插件比创建 loader 更加高级，因为你将需要理解一些 webpack 底层的内部特性来实现相应的钩子，所以做好阅读一些源码的准备！</p>
</blockquote>
<p><a href="https://webpack.docschina.org/contribute/writing-a-plugin/" target="_blank">编写一个插件</a></p>
<p>一个插件由以下构成</p>
<ul>
<li>一个具名 JavaScript 函数。</li>
<li>在它的原型上定义 apply 方法。</li>
<li>指定一个触及到 webpack 本身的 <a href="https://webpack.docschina.org/api/compiler-hooks/">事件钩子</a>。</li>
<li>操作 webpack 内部的实例特定数据。</li>
<li>在实现功能后调用 webpack 提供的 callback。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个 JavaScript class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExampleWebpackPlugin</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将 `apply` 定义为其原型方法，此方法以 compiler 作为参数</span></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定要附加到的事件钩子函数</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(</span><br><span class="line">          <span class="string">&#x27;MyExampleWebpackPlugin&#x27;</span>,</span><br><span class="line">      (compilation, callback) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;This is an example plugin!&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Here’s the `compilation`</span></span><br><span class="line"><span class="string">        object which represents a single build of assets:&#x27;</span>, compilation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 webpack 提供的 plugin API 操作构建结果</span></span><br><span class="line">        compilation.addModule(<span class="comment">/* ... */</span>);</span><br><span class="line"></span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件是由一个构造函数（此构造函数上的 prototype 对象具有 apply 方法）的所实例化出来的。这个 apply方法在安装插件时，会被 webpack compiler 调用一次。apply 方法可以接收一个 webpack compiler 对象的引用，从而可以在回调函数中访问到 compiler 对象。</p>
<p>然后，要使用这个插件，在你的 webpack 配置的 plugins 数组中添加一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> HelloWorldPlugin = <span class="built_in">require</span>(<span class="string">&#x27;hello-world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      <span class="comment">// ... 这里是其他配置 ...</span></span><br><span class="line">  plugins: [<span class="keyword">new</span> HelloWorldPlugin(&#123; <span class="attr">options</span>: <span class="literal">true</span> &#125;)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="compiler-和-compilation"><a href="#compiler-和-compilation" class="headerlink" title="compiler 和 compilation"></a>compiler 和 compilation</h2><p>在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloCompilationPlugin</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// tap(触及) 到 compilation hook，而在 callback 回调时，会将 compilation 对象作为参数，</span></span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">&#x27;HelloCompilationPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 现在，通过 compilation 对象，我们可以 tap(触及) 到各种可用的 hooks 了</span></span><br><span class="line">      compilation.hooks.optimize.tap(<span class="string">&#x27;HelloCompilationPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;正在优化资源。&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloCompilationPlugin;</span><br></pre></td></tr></table></figure>










]]></content>
  </entry>
  <entry>
    <title>webpack 打包结构</title>
    <url>/2020/11/14/project/webpack-end/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line"><span class="built_in">window</span>[ <span class="string">&quot;YYJ&quot;</span> ]  =</span><br><span class="line">( <span class="function"><span class="keyword">function</span> (<span class="params"> modules </span>) </span>&#123;  <span class="comment">// webpackBootstrap</span></span><br><span class="line">   <span class="comment">// The module cache</span></span><br><span class="line">   <span class="keyword">var</span>  installedModules  =  &#123;&#125;;</span><br><span class="line">   <span class="comment">// The require function</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span>   <span class="title">__webpack_require__</span> (<span class="params"> moduleId </span>) </span>&#123;</span><br><span class="line">           <span class="comment">// Check if module is in cache</span></span><br><span class="line">           <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">               <span class="keyword">return</span>  installedModules[moduleId].exports;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">       <span class="keyword">var</span>  <span class="built_in">module</span>  =  installedModules[moduleId]  =  &#123;</span><br><span class="line">               i:  moduleId,</span><br><span class="line">               l:   <span class="literal">false</span> ,</span><br><span class="line">               <span class="built_in">exports</span>:  &#123;&#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// Execute the module function</span></span><br><span class="line">       modules[moduleId] .call ( <span class="built_in">module</span> . <span class="built_in">exports</span> ,  <span class="built_in">module</span> ,  <span class="built_in">module</span> . <span class="built_in">exports</span> , __webpack_require__);</span><br><span class="line">       <span class="comment">// Flag the module as loaded</span></span><br><span class="line">       <span class="built_in">module</span> .l  =   <span class="literal">true</span> ;</span><br><span class="line">       <span class="comment">// Return the exports of the module</span></span><br><span class="line">       <span class="keyword">return</span>   <span class="built_in">module</span> . <span class="built_in">exports</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line">   __webpack_require__.m  =  modules;</span><br><span class="line">   <span class="comment">// expose the module cache</span></span><br><span class="line">   __webpack_require__.c  =  installedModules;</span><br><span class="line">   <span class="comment">// define getter function for harmony exports</span></span><br><span class="line">   __webpack_require__. d   =   <span class="function"><span class="keyword">function</span> (<span class="params"> <span class="built_in">exports</span> ,  name ,  getter </span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ( ! __webpack_require__ .o ( <span class="built_in">exports</span> , name)) &#123;</span><br><span class="line">               <span class="built_in">Object</span> .defineProperty ( <span class="built_in">exports</span> , name, &#123;  <span class="attr">enumerable</span>:   <span class="literal">true</span> ,  <span class="attr">get</span>:  getter &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// define __esModule on exports</span></span><br><span class="line">   __webpack_require__. r   =   <span class="function"><span class="keyword">function</span> (<span class="params"> <span class="built_in">exports</span> </span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ( <span class="keyword">typeof</span>  <span class="built_in">Symbol</span>  !==   <span class="string">&#x27;undefined&#x27;</span>   &amp;&amp;  <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">               <span class="built_in">Object</span> .defineProperty ( <span class="built_in">exports</span> , <span class="built_in">Symbol</span>.toStringTag, &#123;  <span class="attr">value</span>:   <span class="string">&#x27;Module&#x27;</span>  &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">Object</span> .defineProperty ( <span class="built_in">exports</span> ,  <span class="string">&#x27;__esModule&#x27;</span> , &#123;  <span class="attr">value</span>:   <span class="literal">true</span>  &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// create a fake namespace object</span></span><br><span class="line">   <span class="comment">// mode &amp; 1: value is a module id, require it</span></span><br><span class="line">   <span class="comment">// mode &amp; 2: merge all properties of value into the ns</span></span><br><span class="line">   <span class="comment">// mode &amp; 4: return value when already ns object</span></span><br><span class="line">   <span class="comment">// mode &amp; 8|1: behave like require</span></span><br><span class="line">   __webpack_require__. t   =   <span class="function"><span class="keyword">function</span> (<span class="params"> value ,  mode </span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (mode  &amp;   <span class="number">1</span> ) value  =   __webpack_require__ (value);</span><br><span class="line">           <span class="keyword">if</span> (mode  &amp;   <span class="number">8</span> )  <span class="keyword">return</span>  value;</span><br><span class="line">           <span class="keyword">if</span> ((mode  &amp;   <span class="number">4</span> )  &amp;&amp;   <span class="keyword">typeof</span>  value  ===   <span class="string">&#x27;object&#x27;</span>   &amp;&amp;  value  &amp;&amp;  value.__esModule)  <span class="keyword">return</span>  value;</span><br><span class="line">           <span class="keyword">var</span>  ns  =  <span class="built_in">Object</span> .create ( <span class="literal">null</span> );</span><br><span class="line">           __webpack_require__ .r (ns);</span><br><span class="line">           <span class="built_in">Object</span> .defineProperty (ns,  <span class="string">&#x27;default&#x27;</span> , &#123;  <span class="attr">enumerable</span>:   <span class="literal">true</span> ,  <span class="attr">value</span>:  value &#125;);</span><br><span class="line">       <span class="keyword">if</span> (mode  &amp;   <span class="number">2</span>   &amp;&amp;   <span class="keyword">typeof</span>  value  !=   <span class="string">&#x27;string&#x27;</span> )  <span class="keyword">for</span> ( <span class="keyword">var</span>  key  <span class="keyword">in</span>  value) __webpack_require__ .d (ns, key,  <span class="function"><span class="keyword">function</span> (<span class="params"> key </span>) </span>&#123;  <span class="keyword">return</span>  value[key]; &#125; .bind ( <span class="literal">null</span> , key));</span><br><span class="line">       <span class="keyword">return</span>  ns;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line">   __webpack_require__. n   =   <span class="function"><span class="keyword">function</span> (<span class="params"> <span class="built_in">module</span> </span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span>  getter  =   <span class="built_in">module</span>   &amp;&amp;   <span class="built_in">module</span> .__esModule  ?</span><br><span class="line">               <span class="function"><span class="keyword">function</span>   <span class="title">getDefault</span> (<span class="params"></span>) </span>&#123;  <span class="keyword">return</span>   <span class="built_in">module</span> [ <span class="string">&#x27;default&#x27;</span> ]; &#125;  :</span><br><span class="line">           <span class="function"><span class="keyword">function</span>   <span class="title">getModuleExports</span> (<span class="params"></span>) </span>&#123;  <span class="keyword">return</span>   <span class="built_in">module</span> ; &#125;;</span><br><span class="line">       __webpack_require__ .d (getter,  <span class="string">&#x27;a&#x27;</span> , getter);</span><br><span class="line">       <span class="keyword">return</span>  getter;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line">   __webpack_require__. o   =   <span class="function"><span class="keyword">function</span> (<span class="params"> object ,  property </span>) </span>&#123;  <span class="keyword">return</span>  <span class="built_in">Object</span> . prototype . hasOwnProperty .call (object, property); &#125;;</span><br><span class="line">   <span class="comment">// __webpack_public_path__</span></span><br><span class="line">   __webpack_require__.p  =   <span class="string">&quot;&quot;</span> ;</span><br><span class="line">       <span class="comment">// Load entry module and return exports</span></span><br><span class="line">       <span class="keyword">return</span>   __webpack_require__ (__webpack_require__.s  =   <span class="string">&quot;./src/yyj.ts&quot;</span> );</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">/************************************************************************/</span></span><br><span class="line">   (&#123;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">/***/</span>   <span class="string">&quot;./src/yyj.ts&quot;</span> :</span><br><span class="line">   <span class="comment">/*!********************!*\\</span></span><br><span class="line"><span class="comment">   !*** ./src/yyj.ts ***!</span></span><br><span class="line"><span class="comment">   \\********************/</span></span><br><span class="line">   <span class="comment">/*! exports provided: yyj */</span></span><br><span class="line">   <span class="comment">/***/</span>  ( <span class="function"><span class="keyword">function</span> (<span class="params"> <span class="built_in">module</span> ,  __webpack_exports__ ,  __webpack_require__ </span>) </span>&#123;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"><span class="meta">   &quot;use strict&quot;</span> ;</span><br><span class="line">   __webpack_require__ .r (__webpack_exports__);</span><br><span class="line">   <span class="comment">/* harmony export (binding) */</span>  __webpack_require__ .d (__webpack_exports__,  <span class="string">&quot;yyj&quot;</span> ,  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="keyword">return</span>  yyj; &#125;);</span><br><span class="line">   <span class="keyword">var</span>  yyj  =   <span class="number">35131</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/***/</span>  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;)[ <span class="string">&quot;default&quot;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">//# sourceMappingURL=yyj.js.map</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>webpack 编写一个loader</title>
    <url>/2020/11/14/project/webpack-loader/</url>
    <content><![CDATA[<blockquote>
<p>loader就是一个node模块，它输出了一个函数。</p>
</blockquote>
<p>当某种资源需要用这个loader转换时，这个函数会被调用。<br>并且，这个函数可以通过提供给它的this上下文访问Loader API。<br>reverse-txt-loader<br>定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//src是原文件内容（abcde），下面对内容进行处理，这里是反转</span></span><br><span class="line">  <span class="keyword">var</span> result = src.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>); </span><br><span class="line">  <span class="comment">//返回JavaScript源码，必须是String或者Buffer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = &#x27;<span class="subst">$&#123;result&#125;</span>&#x27;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\\.txt$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="string">&#x27;./path/reverse-txt-loader&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="loader-工具库-Loader-Utilities"><a href="#loader-工具库-Loader-Utilities" class="headerlink" title="loader 工具库(Loader Utilities)"></a>loader 工具库(Loader Utilities)</h2><p>充分利用 <a href="https://github.com/webpack/loader-utils">loader-utils</a> 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项。<a href="https://github.com/webpack-contrib/schema-utils">schema-utils</a> 包配合 loader-utils，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验。这里有一个简单使用两者的例子：</p>
<p>loader.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getOptions &#125; <span class="keyword">from</span> <span class="string">&#x27;loader-utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> validateOptions <span class="keyword">from</span> <span class="string">&#x27;schema-utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">      type: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">        test: &#123;</span><br><span class="line">          type: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> options = getOptions(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  validateOptions(schema, options, <span class="string">&#x27;Example Loader&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对资源应用一些转换……</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`export default <span class="subst">$&#123; <span class="built_in">JSON</span>.stringify(source) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>webpack 4 Code Splitting 的 splitChunks</title>
    <url>/2020/11/14/project/webpack-splitchunks/</url>
    <content><![CDATA[<blockquote>
<p>webpack 4 废弃了之前的不怎么好用的 CommonsChunk，取而代之的是 SplitChunks</p>
</blockquote>
<h2 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a>Code Splitting</h2><p>首先 webpack 总共提供了<span style="font-size: large; color: rgb(249, 150, 59);">三种办法来实现 Code Splitting，如下：<ul><li>入口配置：entry 入口使用多个入口文件；</li><li>抽取公有代码：使用 SplitChunks 抽取公有代码；</li><li>动态加载 ：动态加载一些代码。</li></ul></p>
<h2 id="SplitChunks"><a href="#SplitChunks" class="headerlink" title="SplitChunks"></a>SplitChunks</h2><p>首先我们所说的 SplitChunks 是由 webpack 4 内置的 <a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank">SplitChunksPlugin</a> 插件提供的能力，可直接在 optimization 选项中配置，其默认配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">&#x27;async&#x27;</span>, </span><br><span class="line">            minSize: <span class="number">30000</span>,</span><br><span class="line">            maxSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">            automaticNameDelimiter: <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">            name: <span class="literal">true</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: <span class="regexp">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class="line">                    priority: -<span class="number">10</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    minChunks: <span class="number">2</span>,</span><br><span class="line">                    priority: -<span class="number">20</span>,</span><br><span class="line">                    reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明如下：<ul><li>chunks：表示从哪些chunks里面抽取代码，除了三个可选字符串值 initial、async、all 之外，还可以通过函数来过滤所需的 chunks；</li><li>minSize：表示抽取出来的文件在压缩前的最小大小，默认为 30000；</li><li>maxSize：表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小；</li><li>minChunks：表示被引用次数，默认为1；</li><li>maxAsyncRequests：最大的按需(异步)加载次数，默认为 5；</li><li>maxInitialRequests：最大的初始化加载次数，默认为 3；</li><li>automaticNameDelimiter：抽取出来的文件的自动生成名字的分割符，默认为 ~；</li><li>name：抽取出来文件的名字，默认为 true，表示自动生成文件名；</li><li>cacheGroups: 缓存组。（这才是配置的关键）</li></ul><h3 id="cachegroups">cacheGroups</h3><br>上面的那么多参数，其实都可以不用管，cacheGroups 才是我们配置的关键。它可以继承/覆盖上面 splitChunks 中所有的参数值，除此之外还额外提供了三个配置，分别为：test, priority 和 reuseExistingChunk。<ul><li>test: 表示要过滤 modules，默认为所有的 modules，可匹配模块路径或 chunk 名字，当匹配的是 chunk 名字的时候，其里面的所有 modules 都会选中；</li><li>priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；</li><li>reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。</li></ul></p>
<h3 id="-">配置实战</h3>
一般来说我们常用的配置都是 common + page 的形式。而 page 在 entry 入口的时候就已经配置好了。那么现在就只剩下 common 的处理，这里讨论几种方案：

<h2 id="一刀切"><a href="#一刀切" class="headerlink" title="一刀切"></a>一刀切</h2><p>下面我们把所有 node_modules 的模块被不同的 chunk 引入超过 1 次的抽取为 common。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cacheGroups: &#123;</span><br><span class="line">        common: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class="line">        name: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">        chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">        priority: <span class="number">2</span>,</span><br><span class="line">        minChunks: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line">或者干脆把所有模块被不同的 chunk 引入超过 <span class="number">1</span> 次的抽取为 common。</span><br><span class="line"></span><br><span class="line">cacheGroups: &#123;</span><br><span class="line">    common: &#123;</span><br><span class="line">        name: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">        chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">        priority: <span class="number">2</span>,</span><br><span class="line">        minChunks: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进一步抽取"><a href="#进一步抽取" class="headerlink" title="进一步抽取"></a>进一步抽取</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cacheGroups: &#123;</span><br><span class="line">        reactBase: &#123;</span><br><span class="line">        name: <span class="string">&#x27;reactBase&#x27;</span>,</span><br><span class="line">        test: <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/react|redux|prop-types/</span>.test(<span class="built_in">module</span>.context);</span><br><span class="line">        &#125;,</span><br><span class="line">        chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">        priority: <span class="number">10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        common: &#123;</span><br><span class="line">            name: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">            chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">            priority: <span class="number">2</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CSS-配置"><a href="#CSS-配置" class="headerlink" title="CSS 配置"></a>CSS 配置</h2><p>同样对于通过 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/" target="_blank">MiniCssExtractPlugin</a> 生成的 CSS 文件也可以通过 SplitChunks 来进行抽取公有样式等。<br>如下表示将所有 CSS 文件打包为一个（注意将权重设置为最高，不然可能其他的 cacheGroups 会提前打包一部分样式文件）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                styles: &#123;</span><br><span class="line">                    name: <span class="string">&#x27;styles&#x27;</span>,</span><br><span class="line">                    test: <span class="regexp">/\\.css$/</span>,</span><br><span class="line">                    chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                    enforce: <span class="literal">true</span>,</span><br><span class="line">                    priority: <span class="number">20</span>, </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>InnoDB数据页结构</title>
    <url>/2020/11/14/database/Innodb/</url>
    <content><![CDATA[<blockquote>
<p>ySQL服务器上负责对表中的数据的读取和写入的工作的部分是存储引擎，而关于服务器会支持不同类型的服务器，如：InnoDB、MyISAM、Memory……</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>不同的存储引擎都是为了实现不同的特性进行开发的，真实数据的存储在不同的存储引擎中存放的格式一般是不同的，有的存储引擎比如Memory都不用磁盘来存储数据，就跟NoSQL一样，服务器关闭后数据就不见了。InnoDB是MySQL的默认储存引擎，也是我们大家常用的存储引擎。

Mysql把页作为管理存储空间的基本单位，一个页的大小一般是16KB</code></pre>
<h2 id="InnoDB页"><a href="#InnoDB页" class="headerlink" title="InnoDB页"></a>InnoDB页</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写之间的差距就不再多说，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 &lt;strong&gt;16&lt;/strong&gt;KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</code></pre>
<h2 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h2><pre><code>页的本质介绍一个大小为16KB大小的存储空间，页有很多种类型的，不同的类型有不同的作用；

用于存储记录的页被称为数据页 ，大小也为16KB，但是这16KB大小的存储空间被划分为多个部分，不同的部分当然有着不同的功能，结构如下：</code></pre>
<p><img src="/img/Innodb.jpg"></p>
<pre><code>从上面的图可以看到，InnoDB的页结构分为七个部分，下面用表格说明一下各个部分对应的作用：</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>文件头</td>
<td>38字节</td>
<td>描述页的信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页头</td>
<td>56字节</td>
<td>页的状态信息</td>
</tr>
<tr>
<td>Infimum  + SupreMum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录（后面会说明）</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页目录</td>
<td>不确定</td>
<td>页中的记录相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件结尾</td>
<td>8字节</td>
<td>结尾信息</td>
</tr>
</tbody>
</table>

<pre><code>下面会详细介绍他们的作用</code></pre>
<hr>
<h3 id="页中的存储"><a href="#页中的存储" class="headerlink" title="页中的存储"></a>页中的存储</h3><p>当我们在存储数据的时候，记录会存储到User Records部分 。但是在一个页新形成的时候是不存在User Records 这个部分的，每当我们在插入一条记录的时候，都会从Free Space中去申请一块大小符合该记录大小的空间并划分到User Records，当Free Space的部分空间全部被User Records部分替换掉之后，就意味着当前页使用完毕，如果还有新的记录插入，需要再去申请新的页，过程如下：</p>
<p><img src="/img/sql_save.jpg"></p>
<h3 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h3><p>对于User Records中的每一条记录的管理，MySQL做了很多的处理，究竟做出了什么处理呢，这需要从每条记录里面的记录的额外信息部分中的记录头信息说起 这是有关行格式的知识，关于行格式（指的就是一条记录的存储结构，有多种格式），有兴趣的可以去看一下<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect" target="_blank" rel="nofollow noopener noreferrer">InnoDB记录存储结构</a> 这篇文章。</p>
<pre><code>首先，创建一个表：</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;; CREATE TABLE page_demo(</span><br><span class="line">    &gt;     c1 INT,</span><br><span class="line">    &gt;     c2 INT,</span><br><span class="line">    &gt;     c3 VARCHAR(10000),</span><br><span class="line">    &gt;     PRIMARY KEY (c1)</span><br><span class="line">    &gt; ) CHARSET&#x3D;ascii ROW_FORMAT&#x3D;Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">mysql&gt;;</span><br></pre></td></tr></table></figure>


<p>如上所示，表中有三列，c1和c2用来存储整数的，c3用来存储字符串的。因为指定了主键为c1，所以MySQL就不会去创建那个隐藏的 row_id 列。指定了ascii字符集以及Compact的行格式，所以里面的每一条记录的行格式如下：</p>
<p><img src="/img/in_table.jpg"></p>
<pre><code>先看一下行格式中每个属性代表的意思：</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>标记该记录是否为B+树的非叶子节点中的最小记录（索引时用到）</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前槽管理的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>

<pre><code>由于这里只是描述在User Records中记录头的作用，所以下面只会说明一些相关的属性以及c1、c2、c3列的信息（其他信息没画不代表它们不存在，只是为了理解上的方便省略了～），简化后的行格式示意图就是这样：</code></pre>
<p><img src="/img/in_line.jpg"></p>
<pre><code>我们往表中插入几条数据：</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;; INSERT INTO page_demo VALUES(1, 100, &#39;aaaa&#39;), (2, 200, &#39;bbbb&#39;), (3, 300, &#39;cccc&#39;), (4, 400, &#39;dddd&#39;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面看看几条记录在页中的User Records是以何种形式进行体现的，为了方便理解，下面的图中把记录中的头信息和实际的数据都用的十进制进行的表示（其实都是二进制）：</p>
<p><img src="/img/in_line0.jpg"><br>&nbsp;<br>下面说说，记录头中的各个部分代表的含义：</p>
<h2 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h2><p>这个属性说的是当前这条记录是否被删除，当值为0的时候代表着没有被删除，为1的时候标志着被删除了。</p>
<p>是的，您没看错，当您执行删除一个记录的操作的时候，被删除的记录还存在页中，您对它进行了删除，它会把的</p>
<p>记录头中的这个属性设置为1，只是打了个标记。</p>
<p>原因</p>
<p>这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
<p>如果您想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimize table &#39;表名&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。</p>
<h2 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h2><pre><code>有关索引的，暂时不说，后面说到索引会说明；</code></pre>
<h2 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h2><pre><code>下面会讲</code></pre>
<h2 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h2><pre><code>这个属性是表示的当前记录在当前页中的位置，上面的一张图如果您仔细看了的话，会发现它们的位置分别是2、3、4、5，那么问题来了？ 0和1呢？

这是因为在每次创建的一页里面会自动的加入两条记录，这被称为伪记录 或者 虚拟记录 （因为不是我们自己插入的）;

这两条伪记录一个代表着最小记录，一个代表着最大记录 ；

记录大小的比较是通过主键值来比较的。在上面我们插入的几条记录中的从小到大的顺序就是：1 &amp;lt; 2 &amp;lt; 3 &amp;lt; 4,</code></pre>
<p>这标志着这4条记录的大小依次递增。</p>
<pre><code>不管我们插入了什么数据，页中的最小记录 和 最大记录 都是页生成时候的那两条伪记录。这两条伪记录的结构页相对简单，如下：</code></pre>
<p><img src="/img/in_min.jpg"></p>
<pre><code>还记得页结构组成的七部分中一个部分叫Infimum + SupreMum ，这个部分用来存储最小记录和最大记录的，没错，就是这两条伪记录。</code></pre>
<p>原因：由于这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p>
<p><img src="/img/in_record.jpg"></p>
<pre><code>由上面的图可以看出，最小记录和最大记录的heap_no的值分别为0和1，也就是说它们的位置最靠前。</code></pre>
<h2 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h2><pre><code>这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3 ，关于1暂且不说；</code></pre>
<h2 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h2><pre><code>这个属性表示这从当前记录真实数据到下一条记录的真实数据的地址偏移量 ；

假如有一条记录的next_record 的值为12，就标志着从这条记录的真实数据的地址往后找12个字节就是下一条记录的真实数据（链表）。也就是说页中的数据之间的联系是一个&lt;strong&gt;根据大小&lt;/strong&gt;比较后从小指到大的&lt;strong&gt;单向链表&lt;/strong&gt;。



规定 &lt;strong&gt;最小记录&lt;/strong&gt; 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 &lt;strong&gt;最大记录&lt;/strong&gt;(最大的那条伪记录) ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：</code></pre>
<p><img src="/img/in_p1.jpg"></p>
<pre><code>从上面可以看出，最大记录 的 next_record 的值为0，代表着最大记录的下一条记录是不存在的，它也是链条中的最后一个节点。

当我们从页中删除一条数据后可以看看链表会发生那些变化：</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;; DELETE FROM page_demo WHERE c1 &#x3D; 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删掉第2条记录后的示意图就是：</p>
<p><img src="/img/in_p2.jpg"></p>
<pre><code>从上面可以看到：</code></pre>
<p>当我们删除第二条记录后，链表中的变化最明显的就是各个节点之间的联系，它会把被删除数据的上一条记录和被删除数据的下一条数据进行关联（这条数据还是存在的，之前说的那个删除标记别忘了哦）。<ul></p>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li>
<li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的next_record指向了第3条记录。</li>
<li>还有一点您可能忽略了，就是最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。</li>
</ul>

<p>所以得到：不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p>
<pre><code>下面我们再做一个操作，把删除的记录再次插入：</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;; INSERT INTO page_demo VALUES(2, 200, &#39;bbbb&#39;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>我们来看看发生了什么变化：</code></pre>
<p><img src="/img/in_p3.jpg"></p>
<pre><code>很明显的可以看到，InnoDB并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</code></pre>
<h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><pre><code>通过上面，我们知道到了页中记录是一个按照大小从下到大连续的单向链表，现在来想想，当我们根据主键查询一条记录的时候是怎样进行的，我们来看看;</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM page_demo WHERE c1 &#x3D; 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面是一条查询语句，我们想想它的执行方式可能是：</p>
<p>从最小记录开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于您想要查找的主键值时，如果这个时候还没找到数据的话您就可以停止查找了（代表找不到），因为该节点后边的节点的主键值都是依次递增。</p>
<p>上面的方式存在的问题就是，当页中的存储的记录数量比较少的情况用起来也没啥问题，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以这个方式很笨啊。</p>
<p>我们来看看InnoDB 的处理方式：InnoDB 的处理方式相当于我们平时看书的时候，想看那一章的时候不会傻到去一页一页的找，而是通过目录去找到对应的页数，直接就定位过去了。说说InnoDB 这样处理的步骤吧：</p>
<ul>
<li><p>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</p>
</li>
<li><p>每个组的最后一条记录的头信息中的n_owned属性表示该组内共有几条记录。</p>
</li>
<li><p>将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（英文名：Slot）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为Page Directory 。</p>
</li>
</ul>
<p>比如说，现在表中有6条记录，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p>
<p><img src="/img/in_group.jpg"></p>
<pre><code>从上面的图中可以看到：</code></pre>
<ul>
<li>Page Directory中有两个槽，也就是两个组，槽0的值是90，代表最小记录的地址偏移量；槽2的值是112，代表最大记录的地址偏移量；</li>
<li>注意记录中的最小记录和最大记录，他们分别是1和5：</li><li>
&nbsp;
<ul>
<li>最小记录的n_owned 的值为1，代表着以最小记录结尾的这个分组中只有1条记录，就是最小记录本身；</li>
<li>同理，最大记录的n_owned 的值为5，代表着以最大记录结尾的这个分组中只有5条记录，这5条记录包括它本身，就是说除了它本身还有其它4条记录；</li><li>
</li>
</ul>
</li>
</ul>

<p>我们用图来表示一下：</p>
<p><img src="/img/in_page.jpg"></p>
<p>上面的图中为了方便理解，暂时没管各条记录在存储设备上的排列方式了，单纯从逻辑上看一下这些记录和页目录的关系。真实的Page Directory 是在下面的。</p>
<p>再说说，为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？它们是怎么分配的？</p>
<p>InnoDB 对每个分组中的记录条数是有规定的，对于最小记录所在的分组只能有 <strong>1</strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong>1<del>8</strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong>4</del>8</strong> 条之间。所以分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里面只有最小记录和最大记录（伪记录），它们属于不同的分组，也就是两个；</li><li>
</li>
<li>之后插入的每一条记录都会放到最大记录所在的组，直到最大记录所在组的记录数等于8条；</li><li>
</li>
<li>当最大记录所在组中的记录数等于8条的时候，如果还有记录插入的话，就会将最大记录所在组平均分裂成2个组，这个时候最大记录所在组就只剩下4条记录，这里再把这条记录再放入最大记录所在组；</li><li>
</li>
</ul>

<pre><code>我们一口气又往表中添加了12条记录，现在就一共有16条正常的记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</code></pre>
<p><img src="/img/in_pages.jpg"></p>
<p>上图中，只保留了头信息中的n_owned和next_record属性，也省略了各个记录之间的箭头，没画不等于没有！</p>
<p>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。4个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为5的记录，现在我们再来看看查找一条记录的步骤：</p>
<ul>
<li><p> 首先得到中间槽的位置：(0 + 4)/2 = 2 ,所以得到槽2，根据槽2的地址偏移量知道它的主键值是8，因为8&gt;;5，设置high=2 ，low不变；</p>
</li>
<li><p>再次计算中间槽的位置：(0 + 2)/2 = 1 ,所以得到槽1，根据槽1的地址偏移量知道它的主键值是4, 因为4&lt;5，设置low=1 ，high不变；</p>
</li>
<li><p> 因为high - low的值为1，所以确定主键值为5的记录在槽1和槽2之间，接下来就是遍历链表的查找了；</p>
</li>
</ul>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ul>
<li><p>通过二分法确定该记录所在的槽。</p>
</li>
<li><p>通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。</p>
</li>
</ul>
<h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>设计InnoDB的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，Page Directory中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：byte）</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2</td>
<td>第一个记录的地址</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2</td>
<td>指向可重用空间的地址（就是标记为删除的记录地址）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2</td>
<td>已删除的字节数，行记录结构中delete_flag为1的记录大小总数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2</td>
<td>最后插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>2</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2</td>
<td>当前页在索引树中的位置，高度</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR</td>
<td>10</td>
<td>非叶节点所在段的segment header，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>10</td>
<td>B+树所在段的segment header，仅在B+树的Root页定义</td>
</tr>
</tbody>
</table>

<pre><code>如果大家认真看过前边的文章，那么大致能看明白这里头前边一半左右的状态信息的意思，剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学。在这里想强调以下PAGE_DIRECTION和PAGE_N_DIRECTION的意思。</code></pre>
<ul>
<li>
PAGE_DIRECTION

<p>假如新插入的一条记录的主键值比上一条记录的主键值比上一条记录大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。</p>
</li><li>

</li>
<li>

<p>PAGE_N_DIRECTION</p>
<p>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p>
</li><li>

</li>
</ul>

<h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><pre><code>如果说Page Header描述的是页内的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀，那么File Header描述的就是页外的各种状态信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦。File Header是InnoDB页的第一部分，这个部分占用固定的38个字节，下边我们看看这个部分的各个字节都是代表啥意思吧：</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：byte）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8</td>
<td>最后被修改的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2</td>
<td>该页的类型（之前我们说的是数据页）</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间中都是0</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4</td>
<td>页属于哪个表空间</td>
</tr>
</tbody>
</table>
    对照着这个表格，我们看几个目前比较重要的部分：
<ul>
<li>

<p>FIL_PAGE_SPACE_OR_CHKSUM</p>
<p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个值，这个值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的（hashCode和equals），所以省去了直接比较两个比较长的字节串的时间损耗(和后面的File Trailer里面的那个相对应，看到后面您就明白了)。</p>
</li><li>

</li>
<li>

<p>FIL_PAGE_OFFSET</p>
<p>每一个页都有一个单独的页号，就跟您的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</p>
</li><li>

</li>
<li>

<p>FIL_PAGE_TYPE</p>
<p>这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，本集中介绍的其实都是存储记录的数据页，其实还有很多别的类型的页：</p>
</li><li>

</li>
<li>

<p>FIL_PAGE_PREV和FIL_PAGE_NEXT</p>
<p>一张表中可以有成千上万条记录，一个页只有16KB，所以可能需要好多页来存放数据，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号（双向链表）。</li><li></p>
</li></ul>

<p><img src="/img/in_file.jpg"></p>
<ul><li>
Page Header 的其它属性就不说了；
</li><li>

</li>
</ul>

<h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>对于这个部分，我的理解比较简单，我们知道InnoDB 会把数据从内存刷新到磁盘，中间交互的单位是页 ，但是我们想想，假如再刷新到磁盘的时候出现了问题，这样的话怎么办呢？</p>
<p>这就是File Trailer 作用，这个部分由8个字节组成，可以分成2个小部分：</p>
<ul>
<li>前四个字节代表页的检验和：</li><li>
&nbsp;
<ul>
<li>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错；</li><li>
</li>
</ul>
</li>
<li>后四个字节代表日志序列位置（LSN）
<ul>
<li>这个部分也是为了校验页的完整性的，可以先不用管这个属性。</li><li>
</li>
</ul>
</li>
</ul>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>InnoDB为了不同的目的而设计了不同类型的页，用于存放我们记录的页也叫做<code>数据页</code>。</li>
<li>一个数据页可以被分为7个部分，分别是<ul>
<li><code>File Header</code>，表示文件头，占固定的38字节。</li>
<li><code>Page Header</code>，表示页里的一些状态信息，占固定的56个字节。</li>
<li><code>Infimum + Supremum</code>，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的<code>26</code>个字节。</li>
<li><code>User Records</code>：真实存储我们插入的记录的部分，大小不固定。</li>
<li><code>Free Space</code>：页中尚未使用的部分，大小不确定。</li>
<li><code>Page Directory</code>：页中的记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li>
</ul>
</li>
</ol>
<ol start="3">
<li>
</li><li>每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单向链表。</li><li>
</li>
<li>InnoDB会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，所以在一个页中根据主键查找记录是非常快的，分为两步：</li><li>
&nbsp;
<ul>
<li>通过二分法确定该记录所在的槽。</li><li>
</li>
<li>通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。</li><li>
</li>
</ul>
</li>
<li>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。</li><li>
</li>
<li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题。</li></ol>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p> 本文的大部分内容都是参考并使用的原文中的内容，只是在中间加入了一些自己的理解，并希望把它更清楚的表达出来，大家也可以去看看原文：<br>&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483678&idx=1&sn=913780d42e7a81fd3f9b747da4fba8ec&chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&scene=21#wechat_redirect" target="_blank" rel="nofollow noopener noreferrer">InnoDB数据页结构</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端开发中的 MVC/MVP/MVVM 模式</title>
    <url>/2020/11/14/frame/web-mvc/</url>
    <content><![CDATA[<blockquote>
<p>MVC，MVP和MVVM都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。</p>
</blockquote>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank">原文地址</a></h2><p>参考：<a href="https://draveness.me/mvx" target="_blank">MVC、MVP 和 MVVM 架构模式</a><br><a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a></p>
<p>要了解MVC、MVP和MVVM，就要知道它们的相同点和不同点。不同部分是C(Controller)、P(Presenter)、VM(View-Model)，而相同的部分则是MV(Model-View)。</p>
<h2 id="Model-amp-View"><a href="#Model-amp-View" class="headerlink" title="Model&amp;View"></a>Model&amp;View</h2><p>这里有一个可以对数值进行加减操作的组件：上面显示数值，两个按钮可以对数值进行加减操作，操作后的数值会更新显示。</p>
<p>我们将依照这个“栗子”，尝试用JavaScript实现简单的具有MVC/MVP/MVVM模式的Web应用。</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>Model层用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法。这里我们把需要用到的数值变量封装在Model中，并定义了add、sub、getVal三种操作数值方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myapp = &#123;&#125;; <span class="comment">// 创建这个应用对象</span></span><br><span class="line"></span><br><span class="line">myapp.Model = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> val = <span class="number">0</span>; <span class="comment">// 需要操作的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 操作数据的方法 */</span></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">100</span>) val += v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sub = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span>) val -= v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>View作为视图层，主要负责数据的展示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.View = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 视图元素 */</span></span><br><span class="line">    <span class="keyword">var</span> $num = $(<span class="string">&#x27;#num&#x27;</span>),</span><br><span class="line">        $incBtn = $(<span class="string">&#x27;#increase&#x27;</span>),</span><br><span class="line">        $decBtn = $(<span class="string">&#x27;#decrease&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 渲染数据 */</span></span><br><span class="line">    <span class="built_in">this</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</span><br><span class="line">        $num.text(model.getVal() + <span class="string">&#x27;rmb&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在通过Model&amp;View完成了数据从模型层到视图层的逻辑。但对于一个应用程序，这远远是不够的，我们还需要响应用户的操作、同步更新View和Model。于是，在MVC中引入了控制器controller，让它来定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>那时计算机世界天地混沌，浑然一体，然后出现了一个创世者，将现实世界抽象出模型形成model，将人机交互从应用逻辑中分离形成view，然后就有了空气、水、鸡啊、蛋什么的。<br>——《前端MVC变形记》<a href="https://efe.baidu.com/blog/mvc-deformation/" target="_blank">前端MVC变形记</a></p>
<p>上个世纪70年代，<a href="https://link.juejin.im?target=http%3A%2F%2Fbaike.baidu.com%2Flink%3Furl%3Dux_43rkE1Ythy0RI6WZIB6NZpSbJYxOSzVk1W7LItMteveUBPdAgoegLc2j8zA8XRqZPS0tTwMAKtAXhZ9jTClBFGzj4GV2zstDqWP7kFC3" target="_blank" rel="nofollow noopener noreferrer">美国施乐帕克研究中心</a>，就是那个发明图形用户界面(GUI)的公司，开发了<a href="https://link.juejin.im?target=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FSmalltalk%2F1379989" target="_blank" rel="nofollow noopener noreferrer">Smalltalk</a>编程语言，并开始用它编写图形界面的应用程序。</p>
<p>到了Smalltalk-80这个版本的时候，一位叫Trygve Reenskaug的工程师为Smalltalk设计了MVC（Model-View-Controller）这种架构模式，极大地降低了GUI应用程序的管理难度，而后被大量用于构建桌面和服务器端应用程序。</p>
<p><img src="/img/mvc1.png"></p>
<p>如图，实线代表方法调用，虚线代表事件通知。</p>
<p>MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</p>
<h2 id="Model-1"><a href="#Model-1" class="headerlink" title="Model"></a>Model</h2><p>Model层用来存储业务的数据，一旦数据发生变化，模型将通知有关的视图。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.Model = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">100</span>) val += v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sub = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span>) val -= v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ／* 观察者模式 *／</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>, </span><br><span class="line">        views = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.register = <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">            views.push(view);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.notify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; views.length; i++</span>)</span> &#123;</span><br><span class="line">                views[i].render(self);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Model和View之间使用了观察者模式，View事先在此Model上注册，进而观察Model，以便更新在Model上发生改变的数据。</p>
<h2 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h2><p>view和controller之间使用了策略模式，这里View引入了Controller的实例来实现特定的响应策略，比如这个栗子中按钮的 click 事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.View = <span class="function"><span class="keyword">function</span>(<span class="params">controller</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $num = $(<span class="string">&#x27;#num&#x27;</span>),</span><br><span class="line">        $incBtn = $(<span class="string">&#x27;#increase&#x27;</span>),</span><br><span class="line">        $decBtn = $(<span class="string">&#x27;#decrease&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</span><br><span class="line">            $num.text(model.getVal() + <span class="string">&#x27;rmb&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  绑定事件  */</span></span><br><span class="line">    $incBtn.click(controller.increase);</span><br><span class="line">    $decBtn.click(controller.decrease);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要实现不同的响应的策略只要用不同的Controller实例替换即可。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>控制器是模型和视图之间的纽带，MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.Controller = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> model = <span class="literal">null</span>,</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* 初始化Model和View */</span></span><br><span class="line">        model = <span class="keyword">new</span> myapp.Model();</span><br><span class="line">        view = <span class="keyword">new</span> myapp.View(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* View向Model注册，当Model更新就会去通知View啦 */</span></span><br><span class="line">        model.register(view);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让Model更新数值并通知View更新视图 */</span></span><br><span class="line">    <span class="built_in">this</span>.increase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            model.add(<span class="number">1</span>);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.decrease = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            model.sub(<span class="number">1</span>);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们实例化View并向对应的Model实例注册，当Model发生变化时就去通知View做更新，这里用到了观察者模式。</p>
<p>当我们执行应用的时候，使用Controller做初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> controller = <span class="keyword">new</span> myapp.Controller();</span><br><span class="line">    controller.init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>可以明显感觉到，MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。而且MVC中View和Controller一般是一一对应的，捆绑起来表示一个组件，视图与控制器间的过于紧密的连接让Controller的复用性成了问题，如果想多个View共用一个Controller该怎么办呢？这里有一个解决方案：MVP</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model-View-Presenter）是MVC模式的改良，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示。</p>
<p><img src="/img/mvc2.png"></p>
<p>虽然在MVC里，View是可以直接访问Model的，但MVP中的View并不能直接使用Model，而是通过为Presenter提供接口，让Presenter去更新Model，再通过观察者模式更新View。</p>
<p>与MVC相比，MVP模式通过解耦View和Model，完全分离视图和模型使职责划分更加清晰；由于View不依赖Model，可以将View抽离出来做成组件，它只需要提供一系列接口提供给上层操作。</p>
<h2 id="Model-2"><a href="#Model-2" class="headerlink" title="Model"></a>Model</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.Model = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">100</span>) val += v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sub = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span>) val -= v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Model层依然是主要与业务相关的数据和对应处理数据的方法。</p>
<h2 id="View-2"><a href="#View-2" class="headerlink" title="View"></a>View</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.View = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $num = $(<span class="string">&#x27;#num&#x27;</span>),</span><br><span class="line">        $incBtn = $(<span class="string">&#x27;#increase&#x27;</span>),</span><br><span class="line">        $decBtn = $(<span class="string">&#x27;#decrease&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params">model</span>) </span>&#123;</span><br><span class="line">            $num.text(model.getVal() + <span class="string">&#x27;rmb&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> presenter = <span class="keyword">new</span> myapp.Presenter(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        $incBtn.click(presenter.increase);</span><br><span class="line">        $decBtn.click(presenter.decrease);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>MVP定义了Presenter和View之间的接口，用户对View的操作都转移到了Presenter。比如这里可以让View暴露setter接口以便Presenter调用，待Presenter通知Model更新后，Presenter调用View提供的接口更新视图。</p>
<h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myapp.Presenter = <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _model = <span class="keyword">new</span> myapp.Model();</span><br><span class="line">    <span class="keyword">var</span> _view = view;</span><br><span class="line"></span><br><span class="line">    _view.render(_model);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.increase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _model.add(<span class="number">1</span>);</span><br><span class="line">        _view.render(_model);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.decrease = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _model.sub(<span class="number">1</span>);</span><br><span class="line">        _view.render(_model);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Presenter作为View和Model之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从View到Model和从Model到View的数据进行“手动同步”，这样Presenter显得很重，维护起来会比较困难。而且由于没有数据绑定，如果Presenter对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，Presenter也需要改动。</p>
<p>运行程序时，以View为入口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> view = <span class="keyword">new</span> myapp.View();</span><br><span class="line">    view.init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM（Model-View-ViewModel）最早由微软提出。ViewModel指 “Model of View”——视图的模型。这个概念曾在一段时间内被前端圈热炒，以至于很多初学者拿jQuery和Vue做对比…</p>
<p><img src="/img/mvc3.png"></p>
<p>MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。</p>
<p>这里我们使用Vue来完成这个栗子。</p>
<h2 id="Model-3"><a href="#Model-3" class="headerlink" title="Model"></a>Model</h2><p>在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责），这里可以把它理解为一个类似json的数据对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">        val: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="View-3"><a href="#View-3" class="headerlink" title="View"></a>View</h2><p>和MVC/MVP不同的是，MVVM中的View通过使用模板语法来声明式的将数据渲染进DOM，当ViewModel对Model进行更新的时候，会通过数据绑定更新到View。写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myapp&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; val &#125;&#125;rmb&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">&quot;sub(1)&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">&quot;add(1)&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel大致上就是MVC的Controller和MVP的Presenter了，也是整个模式的重点，业务逻辑也主要集中在这里，其中的一大核心就是数据绑定，后面将会讲到。与MVP不同的是，没有了View为Presente提供的接口，之前由Presenter负责的View和Model之间的数据同步交给了ViewModel中的数据绑定进行处理，当Model发生变化，ViewModel就会自动更新；ViewModel变化，Model也会更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#myapp&#x27;</span>,</span><br><span class="line">    data: data,</span><br><span class="line">    methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">add</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.val &lt; <span class="number">100</span></span>)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.val += v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">sub</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.val &gt; <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.val -= v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>整体来看，比MVC/MVP精简了很多，不仅仅简化了业务与界面的依赖，还解决了数据频繁更新（以前用jQuery操作DOM很繁琐）的问题。因为在MVVM中，View不知道Model的存在，ViewModel和Model也察觉不到View，这种低耦合模式可以使开发过程更加容易，提高应用的可重用性。</p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>双向数据绑定，可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。——《界面之下：还原真实的MV*模式》<br><img src="/img/mvc4.png"></p>
<p>在Vue中，使用了双向绑定技术（Two-Way-Data-Binding），就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p>
<p>不同的MVVM框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种：</p>
<ul>
<li>数据劫持 (Vue)</li>
<li>发布-订阅模式 (Knockout、Backbone)</li>
<li>脏值检查 (Angular)</li>
</ul>

<p>我们这里主要讲讲Vue。</p>
<p>Vue采用数据劫持&amp;发布-订阅模式的方式，通过ES5提供的 Object.defineProperty() 方法来劫持（监控）各属性的 getter 、setter ，并在数据（对象）发生变动时通知订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。要实现Vue中的双向数据绑定，大致可以划分三个模块：Observer、Compile、Watcher，如图：<br><img src="/img/mvc5.png"></p>
<ul><li>
Observer 数据监听器
  负责对数据对象的所有属性进行监听（数据劫持），监听到数据发生变化后通知订阅者。
  </li>
  <li>
Compiler 指令解析器
  扫描模板，并对指令进行解析，然后绑定指定事件。
  </li>
  <li>
Watcher 订阅者
  关联Observer和Compile，能够订阅并收到属性变动的通知，执行指令绑定的相应操作，更新视图。Update()是它自身的一个方法，用于执行Compile中绑定的回调，更新视图。
  </li>
  </ul>
## 数据劫持

<p>一般对数据的劫持都是通过Object.defineProperty方法进行的，Vue中对应的函数为 defineReactive ，其普通对象的劫持的精简版代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">    version: <span class="string">&#x27;2.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用递归劫持对象属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听子属性 比如这里data对象里的 &#x27;name&#x27; 或者 &#x27;version&#x27;</span></span><br><span class="line">    observe(value)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = newVal</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`监听成功：<span class="subst">$&#123;value&#125;</span> --&gt; <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(foo)</span><br><span class="line">foo.name = <span class="string">&#x27;angular&#x27;</span> <span class="comment">// “监听成功：vue --&gt; angular”</span></span><br></pre></td></tr></table></figure>

<p>上面完成了对数据对象的监听，接下来还需要在监听到变化后去通知订阅者，这需要实现一个消息订阅器 Dep ，Watcher通过 Dep 添加订阅者，当数据改变便触发 Dep.notify() ，Watcher调用自己的 update() 方法完成视图更新。</p>
<p>写着写着发现离主题越来越远了。。。数据劫持就先讲这么多吧～对于想深入vue.js的同学可以参考勾三股四的<a href="https://link.juejin.im?target=http%3A%2F%2Fjiongks.name%2Fblog%2Fvue-code-review%2F" target="_blank" rel="nofollow noopener noreferrer">Vue.js 源码学习笔记</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MV*的目的是把应用程序的数据、业务逻辑和界面这三块解耦，分离关注点，不仅利于团队协作和测试，更有利于<strike>甩锅</strike>维护和管理。业务逻辑不再关心底层数据的读写，而这些数据又以对象的形式呈现给业务逻辑层。从 MVC –&gt; MVP –&gt; MVVM，就像一个打怪升级的过程，它们都是在MVC的基础上随着时代和应用环境的发展衍变而来的。</p>
<p>在我们纠结于使用什么架构模式或框架的时候，不如先了解它们。静下来思考业务场景和开发需求，不同需求下会有最适合的解决方案。我们使用这个框架就代表认同它的思想，相信它能够提升开发效率解决当前的问题，而不仅仅是因为大家都在学。</p>
<p>有人对新技术乐此不疲，有人对新技术不屑一顾。正如狄更斯在《双城记》中写的：</p>
<p>这是最好的时代，这是最坏的时代，这是智慧的时代，这是愚蠢的时代；这是信仰的时期，这是怀疑的时期；这是光明的季节，这是黑暗的季节；这是希望之春，这是失望之冬；人们面前应有尽有，人们面前一无所有；人们正在直登天堂；人们正在直下地狱。</p>
<p>请保持一颗拥抱变化的心，在新技术面前不盲目，不守旧。</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器周期</title>
    <url>/2021/02/01/brower/lifecycle/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>应用程序生命周期是现代操作系统管理资源的关键方式。在Android、iOS和最新的Windows版本上，操作系统可以随时启动和停止应用程序。这使得这些平台能够将资源优化并重新分配到最有利于用户的地方。</p>
<p>在web端，历史上没有这样的生命周期，应用程序可以一直保持激活。随着大量网页的运行，内存、CPU、电池和网络等关键系统资源可能会被过度订阅，从而导致终端用户体验差。</p>
<p>虽然web平台早就有了与生命周期状态相关的事件，比如 load, unload, and visibilitychange，但这些事件只允许开发人员响应用户行为的生命周期状态更改。为了让web在低功耗设备上可靠地工作（并且在所有平台上都能展示更多资源），浏览器需要一种主动回收和重新分配系统资源的方法。</p>
<p>事实上，如今的浏览器已经采取了积极的措施来节省后台选项卡中页面的资源，许多浏览器（尤其是Chrome浏览器）都想做更多的工作，以减少它们的总体资源占用。</p>
<p>问题是，目前开发者还没法干预这些系统启动，即使知道它们正在启动，这就意味着，浏览器需要采用保守的策略或者冒着页面出错的风险。</p>
<p>页面生命周期API试图通过以下方式解决此问题：</p>
<ul>
<li><p>在web上引入并标准化生命周期状态的概念。</p>
</li>
<li><p>定义新的系统启动状态，允许浏览器限制隐藏或非活动选项卡可以使用的资源。</p>
</li>
<li><p>创建新的api和事件，允许web开发人员响应这些新的系统启动状态的转换。</p>
</li>
</ul>
<p>此解决方案给web开发人员构建可适应系统干预的应用程序提供了可能，并允许浏览器更积极地优化系统资源，最终使所有web用户受益。</p>
<p>本文的其余部分将介绍Chrome68中提供的新页面生命周期特性，并探讨它们与所有现有web平台状态和事件的关系。它还将为每个州的开发人员应该（不应该）做的工作类型提供建议和最佳实践。</p>
<h2 id="页面生命周期状态和事件概述"><a href="#页面生命周期状态和事件概述" class="headerlink" title="页面生命周期状态和事件概述"></a>页面生命周期状态和事件概述</h2><p>所有页面生命周期状态都是离散的，并且相互排斥，这意味着一个页面一次只能处于一种状态。对页面生命周期状态的大多数更改通常可以通过DOM事件观察到（请参阅开发人员对每个状态的建议以了解异常）。</p>
<p>一图胜千言<br> <img src="/img/lifecycle.png"></p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>下表详细说明了每个状态。它还列出了可能出现在前后的状态，以及开发人员可以用来观察更改的事件。</p>
<ul>
<li> Active</li>
</ul>
<p>A page is in the active state if it is visible and has input focus.</p>
<p>Possible previous states:</p>
<p>passive (via the focus event)</p>
<p>Possible next states:</p>
<p>passive (via the blur event) |</p>
<ul>
<li> Passive</li>
</ul>
<p>A page is in the passive state if it is visible and does not have input focus.</p>
<p>Possible previous states:</p>
<p>active (via the blur event)</p>
<p>hidden (via the visibilitychange event)</p>
<p>Possible next states:</p>
<p>active (via the focus event)</p>
<p>hidden (via the visibilitychange event)</p>
<ul>
<li> Hidden</li>
</ul>
<p>A page is in the hidden state if it is not visible and has not been frozen.</p>
<p>Possible previous states:</p>
<p>passive (via the visibilitychange event)</p>
<p>Possible next states:</p>
<p>passive (via the visibilitychange event)</p>
<p>frozen (via the freeze event)</p>
<p>terminated (via the pagehide event)</p>
<ul>
<li> Frozen</li>
</ul>
<p>在冻结状态下，浏览器将暂停执行页面任务队列中的可冻结任务，直到页面解冻。这意味着JavaScript计时器和fetch回调之类的东西不会运行。已经在运行的任务可以完成（最重要的是冻结回调），但是它们可能会受限于它们可以做什么以及可以运行多长时间。</p>
<p>浏览器冻结页面作为一种保存CPU/电池/数据使用的方法；它们也这样做作为一种实现更快的向后/向前导航的方法—避免了重新加载整个页面。</p>
<p>Possible previous states:</p>
<p>hidden (via the freeze event)</p>
<p>Possible next states:</p>
<p>active (via the resume event, then the pageshow event)</p>
<p>passive (via the resume event, then the pageshow event)</p>
<p>hidden (via the resume event)</p>
<ul>
<li> Terminated</li>
</ul>
<p>一旦页面开始被浏览器从内存中卸载和清除，它就处于终止状态。在此状态下不能启动任何新任务，正在进行的任务如果运行太长可能会被终止。</p>
<p>Possible previous states:</p>
<p>hidden (via the pagehide event)</p>
<p>Possible next states:</p>
<p>NONE</p>
<ul>
<li> Discarded</li>
</ul>
<p>当浏览器为了节省资源而卸载页面时，页面处于丢弃状态。任何任务、事件回调或任何类型的JavaScript都不能在此状态下运行，因为丢弃通常发生在资源受限的情况下，在资源受限的情况下启动新进程是不可能的。</p>
<p>在丢弃状态下，标签本身（包括标签标题和favicon）通常对用户可见，即使页面已经消失。</p>
<p>Possible previous states:</p>
<p>frozen (no events fired)</p>
<p>Possible next states:</p>
<p>NONE</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>浏览器发送很多事件，但只有一小部分事件表示页面生命周期状态可能发生变化。下表概述了与生命周期相关的所有事件，并列出了它们可能转换到的状态。</p>
<ul>
<li> focus</li>
</ul>
<p>DOM元素获取焦点。</p>
<blockquote>
<p> 注意：焦点事件不一定表示状态更改。它只在页面以前没有输入焦点时发出状态更改的信号。</p>
</blockquote>
<p>Possible previous states:</p>
<p>passive</p>
<p>Possible current states:</p>
<p>active</p>
<ul>
<li> blur<br>DOM元素失去焦点。</li>
</ul>
<blockquote>
<p>注意：blur事件不一定表示状态更改。如果页面不再具有输入焦点（即页面不只是将焦点从一个元素切换到另一个元素），则只会发出状态更改的信号。</p>
</blockquote>
<p>Possible previous states:</p>
<p>active</p>
<p>Possible current states:</p>
<p>passive</p>
<ul>
<li> visibilitychange</li>
</ul>
<p>文档的visibilityState值已更改。当用户导航到新页面、切换选项卡、关闭选项卡、最小化或关闭浏览器或切换移动操作系统上的应用程序时，就会发生这种情况。</p>
<p>Possible previous states:</p>
<p>passive</p>
<p>hidden</p>
<p>Possible current states:</p>
<p>passive</p>
<p>hidden</p>
<ul>
<li> freeze *</li>
</ul>
<p>页面刚刚被冻结。页面任务队列中的任何可释放任务都不会启动。</p>
<p>Possible previous states:</p>
<p>hidden</p>
<p>Possible current states:</p>
<p>frozen</p>
<ul>
<li> resume *<br>浏览器已恢复冻结页。</li>
</ul>
<p>Possible previous states:</p>
<p>frozen</p>
<p>Possible current states:</p>
<p>active (if followed by the pageshow event)</p>
<p>passive (if followed by the pageshow event)</p>
<p>hidden</p>
<ul>
<li> pageshow<br>正在遍历会话历史记录条目。</li>
</ul>
<p>这可以是全新的页面加载，也可以是从前向缓存中获取的页面。如果页是从前向缓存中获取的，则事件的持久化属性为true，否则为false。</p>
<p>Possible previous states:</p>
<p>frozen (a resume event would have also fired)</p>
<p>Possible current states:</p>
<p>active</p>
<p>passive</p>
<p>hidden</p>
<ul>
<li> pagehide</li>
</ul>
<p>正在从中遍历会话历史记录条目。</p>
<p>如果用户正在导航到另一个页面，并且浏览器能够将当前页面添加到后向缓存中以便稍后重用，则事件的persistend属性为true。如果为true，则页将进入冻结状态，否则将进入终止状态。</p>
<p>Possible previous states:</p>
<p>hidden</p>
<p>Possible current states:</p>
<p>frozen (event.persisted is true, freeze event follows)</p>
<p>terminated (event.persisted is false, unload event follows)</p>
<ul>
<li> beforeunload</li>
</ul>
<p>窗口、文档及其资源即将卸载。文档仍然可见，此时事件仍然可以取消。</p>
<blockquote>
<p>警告：beforeunload事件只能用于警告用户未保存的更改。保存这些更改后，应删除该事件。决不能无条件地将其添加到页面中，因为这样做在某些情况下会损害性能。有关详细信息，请参阅下面legacy api部分。</p>
</blockquote>
<ul>
<li> unload</li>
</ul>
<p>正在卸载该页。</p>
<blockquote>
<p>警告：不建议使用unload事件，因为它不可靠，并且在某些情况下会影响性能。有关更多详细信息，请参阅legacy api部分。</p>
</blockquote>
<p>Possible previous states:</p>
<p>hidden</p>
<p>Possible current states:</p>
<p>terminated</p>
<h2 id="New-features-added-in-Chrome-68"><a href="#New-features-added-in-Chrome-68" class="headerlink" title="New features added in Chrome 68"></a>New features added in Chrome 68</h2><p>上面的图表显示了系统启动而不是用户启动的两种状态：冻结和丢弃。如上所述，现在的浏览器已经偶尔冻结和丢弃隐藏的标签（由他们自己决定），但是开发人员无法知道何时会发生这种情况。</p>
<p>在chrome68中，开发人员现在可以通过监听文档上的冻结和恢复事件来观察隐藏选项卡何时被冻结和解冻。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;freeze&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The page is now frozen.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;resume&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The page has been unfrozen.</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>在chrome68中，document对象现在还包括一个wasdoccarded属性。要确定页是否在隐藏选项卡中被丢弃，可以在页加载时检查此属性的值（注意：丢弃的页必须重新加载才能再次使用）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.wasDiscarded) &#123;</span><br><span class="line">  <span class="comment">// Page was previously discarded by the browser while in a hidden tab.</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>有关冻结和恢复事件中的重要操作，以及如何处理和准备丢弃的页面的建议，请参阅下面每个状态建议。</p>
<p>接下来的几节将概述这些新特性如何适应现有的web平台状态和事件。</p>
<h2 id="监测页面生命周期状态变化"><a href="#监测页面生命周期状态变化" class="headerlink" title="监测页面生命周期状态变化"></a>监测页面生命周期状态变化</h2><p>在active, passive, and hidden 状态下，可以运行JavaScript代码，从现有web平台api确定当前页面生命周期状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.visibilityState === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hasFocus()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;passive&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>另一方面，冻结和终止状态只能在其各自的事件侦听器（冻结和页面隐藏）中检测到，因为状态正在更改。</p>
<h3 id="观察状态变化"><a href="#观察状态变化" class="headerlink" title="观察状态变化"></a>观察状态变化</h3><p>在上面定义的getState（）函数的基础上，您可以使用以下代码观察所有页生命周期状态的更改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stores the initial state using the `getState()` function (defined above).</span></span><br><span class="line"><span class="keyword">let</span> state = getState();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepts a next state and, if there&#x27;s been a state change, logs the</span></span><br><span class="line"><span class="comment">// change to the console. It also updates the `state` value defined above.</span></span><br><span class="line"><span class="keyword">const</span> logStateChange = <span class="function">(<span class="params">nextState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prevState = state;</span><br><span class="line">  <span class="keyword">if</span> (nextState !== prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`State change: <span class="subst">$&#123;prevState&#125;</span> &gt;&gt;&gt; <span class="subst">$&#123;nextState&#125;</span>`</span>);</span><br><span class="line">    state = nextState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These lifecycle events can all use the same listener to observe state</span></span><br><span class="line"><span class="comment">// changes (they call the `getState()` function to determine the next state).</span></span><br><span class="line">[<span class="string">&#x27;pageshow&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;visibilitychange&#x27;</span>, <span class="string">&#x27;resume&#x27;</span>].forEach(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(type, <span class="function">() =&gt;</span> logStateChange(getState()), &#123;<span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The next two listeners, on the other hand, can determine the next</span></span><br><span class="line"><span class="comment">// state from the event itself.</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;freeze&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// In the freeze event, the next state is always frozen.</span></span><br><span class="line">  logStateChange(<span class="string">&#x27;frozen&#x27;</span>);</span><br><span class="line">&#125;, &#123;<span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pagehide&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">    <span class="comment">// If the event&#x27;s persisted property is `true` the page is about</span></span><br><span class="line">    <span class="comment">// to enter the Back-Forward Cache, which is also in the frozen state.</span></span><br><span class="line">    logStateChange(<span class="string">&#x27;frozen&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If the event&#x27;s persisted property is not `true` the page is</span></span><br><span class="line">    <span class="comment">// about to be unloaded.</span></span><br><span class="line">    logStateChange(<span class="string">&#x27;terminated&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;<span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">上面的代码做了三件事：</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用getState（）函数设置初始状态。</p>
</li>
<li><p>定义一个接受下一个状态的函数，如果有更改，则将状态更改记录到控制台。</p>
</li>
<li><p>为所有必要的生命周期事件添加捕获事件侦听器，这些事件反过来调用logStateChange（），传递下一个状态。</p>
</li>
</ul>
<blockquote>
<p>警告！这段代码在不同的浏览器中产生不同的结果，因为事件的顺序和可靠性没有得到一致的实现。要了解如何最好地处理这些不一致，请参阅管理跨浏览器差异。</p>
</blockquote>
<p>以上代码需要注意的一点是，所有事件侦听器都被添加到window中，并且它们都传递{capture:true}。有几个原因：</p>
<ul>
<li><p>并非所有页面生命周期事件都具有相同的目标。pagehide和pageshow在window上启动；visibilitychange、freeze和resume在document上启动，focus和blur在各自的DOM元素上启动。</p>
</li>
<li><p>这些事件中的大多数都没有冒泡，这意味着不可能将非捕获的事件侦听器添加到一个公共祖先元素并观察所有这些事件。</p>
</li>
<li><p>捕获阶段在目标或冒泡阶段之前执行，因此在那里添加侦听器有助于确保它们在其他代码取消它们之前运行。</p>
</li>
</ul>
<h2 id="管理跨浏览器差异"><a href="#管理跨浏览器差异" class="headerlink" title="管理跨浏览器差异"></a>管理跨浏览器差异</h2><p>本文开头的图表根据页面生命周期API概述了状态和事件流。但是由于这个API刚刚被引入，新的事件和 DOM API 并没有在所有浏览器中实现。</p>
<p>此外，目前在所有浏览器中实现的事件并不是一致地实现的。例如：</p>
<ul>
<li><p>某些浏览器在切换选项卡时不会触发模糊事件。这意味着（与上面的图表和表格相反）页面可以从活动状态转到隐藏状态，而无需先经历被动状态。</p>
</li>
<li><p>一些浏览器实现了一个前向缓存，页面生命周期API将缓存的页面分类为处于冻结状态。由于这个API是全新的，这些浏览器还没有实现冻结和恢复事件，尽管这个状态仍然可以通过pagehide和pageshow事件观察到。</p>
</li>
<li><p>旧版本的Internet Explorer（10及以下）不实现visibilitychange事件。</p>
</li>
<li><p>pagehide和visibilitychange事件的调度顺序已更改。以前的浏览器会在pagehide之后调度visibilitychange，如果页面的可见性状态在卸载页面时是可见的。新的Chrome版本将在pagehide之前发送visibilitychange，而不管文档在卸载时的可见性状态如何。</p>
</li>
<li><p>Safari在关闭选项卡时不会可靠地触发pagehide或visibilitychange事件（webkit Bug:151610和151234），因此在Safari中，您可能还需要侦听beforeunload事件以检测隐藏状态的更改。但由于beforeunload事件可以取消，因此需要等到事件传播完成后，才能知道状态是否已更改为hidden。重要提示：只有在Safari中才能使用beforeunload事件，因为在其他浏览器中使用此事件可能会影响性能。有关详细信息，请参阅legacy api部分。</p>
</li>
</ul>
<p>为了让开发人员更容易处理这些跨浏览器的不一致性，并且只关注于遵循生命周期状态的建议和最佳实践 , 有PageLifecycle.js，一个用于观察页面生命周期API状态更改的JavaScript库。</p>
<p>PageLifecycle.js规范化事件触发顺序中的跨浏览器差异，以便状态更改始终完全按照本文中图表和表格中的概述进行（并且在所有浏览器中都是一致的）。</p>
<p><a href="https://github.com/GoogleChromeLabs/page-lifecycle">PageLifecycle.js</a></p>
<h2 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h2><p>作为开发人员，了解页面生命周期状态并知道如何在代码中观察它们是很重要的，因为应该（和不应该）执行的工作类型在很大程度上取决于页面所处的状态。</p>
<p>例如，如果页面处于隐藏状态，则向用户显示临时通知显然没有意义。虽然这个例子很明显，但还有其他一些不太明显的建议值得列举。</p>
<ul>
<li>Active<br>激活状态是用户最关键的时间，因此也是页面响应用户输入的最重要时间。</li>
</ul>
<p>任何可能阻塞主线程的非UI任务都应该置为闲置，或交给web worker</p>
<ul>
<li>Passive<br>页面失焦，但是能看到</li>
</ul>
<p>用户不与页面交互，但仍然可以看到页面。这意味着UI更新和动画应该仍然是平滑的，但是这些更新发生的时间并不那么关键。</p>
<p>当页面从Active更改为Passive时，正是保存未保存的应用程序状态的好时机。</p>
<ul>
<li>Hidden<br>当页面从Passive变为Hidden时，在重新加载之前，用户可能不会再次与之交互。</li>
</ul>
<p>向hidden的转换通常也是开发人员可以可靠观察到的最后一个状态更改（在移动设备上尤其如此，因为用户可以关闭选项卡或浏览器应用程序本身，在这些情况下不会触发beforeunload、pagehide和unload事件）。</p>
<p>这意味着您应该将隐藏状态视为用户会话的可能结束。换句话说，保存任何未保存的应用程序状态并发送任何未发送的分析数据。</p>
<p>您还应该停止进行UI更新（因为用户看不到它们），并且应该停止用户不希望在后台运行的任何任务。</p>
<ul>
<li>Frozen<br>在冻结状态下，任务队列中可冻结的任务将被挂起，直到页面解除冻结-这可能永远不会发生（例如，如果页面被丢弃）。</li>
</ul>
<p>这意味着当页面从隐藏变为冻结时，必须停止任何计时器或断开任何连接，如果这些连接冻结，可能会影响同一来源中其他打开的选项卡，或影响浏览器将页面放入前向缓存的能力。</p>
<p>尤其重要的是：</p>
<p>关闭所有打开的IndexedDB连接。</p>
<p>关闭开放频道连接。</p>
<p>关闭活动的WebRTC连接。</p>
<p>停止任何网络轮询或关闭任何打开的Web套接字连接。</p>
<p>释放所有持有的Web锁。</p>
<p>您还应该将任何动态视图状态（例如，无限列表视图中的滚动位置）持久化到sessionStorage（或IndexedDB via commit（）），以便在以后丢弃并重新加载页面时恢复这些状态。</p>
<p>如果页面从冻结变回隐藏，则可以重新打开所有关闭的连接，或重新启动页面最初冻结时停止的任何轮询。</p>
<ul>
<li>Terminated</li>
</ul>
<p>当页转换到终止状态时，通常不需要执行任何操作。</p>
<p>由用户操作而卸载的页面在进入终止状态之前总是经过隐藏状态，隐藏状态是应该执行会话结束逻辑（例如，持久化应用程序状态和向分析报告）的位置。</p>
<p>另外（正如在关于隐藏状态的建议中提到的），开发人员必须认识到，在许多情况下（尤其是在移动设备上）无法可靠地检测到向终止状态的转换，因此依赖终止事件（例如beforeunload、pagehide和unload）的开发人员可能会丢失数据。</p>
<ul>
<li>Discarded</li>
</ul>
<p>在丢弃页面时，开发人员无法观察到丢弃的状态。这是因为页面通常在资源限制下被丢弃，在大多数情况下，仅仅为了允许脚本响应丢弃事件而解冻页面是不可能的。</p>
<p>因此，您应该在从hidden更改为freezed时准备放弃的可能性，然后可以通过检查文档已丢弃.</p>
<h2 id="要避免的遗留生命周期API"><a href="#要避免的遗留生命周期API" class="headerlink" title="要避免的遗留生命周期API"></a>要避免的遗留生命周期API</h2><ul>
<li>The unload event</li>
</ul>
<p>许多开发人员将unload事件视为有保证的回调，并将其用作会话结束信号来保存状态和发送分析数据，但这样做极不可靠，尤其是在移动设备上！卸载事件在许多典型的卸载情况下都不会触发，包括从移动设备上的选项卡切换器关闭选项卡或从应用切换器关闭浏览器应用程序。</p>
<p>因此，最好依靠visibilitychange事件来确定会话何时结束，并将隐藏状态视为保存应用程序和用户数据的最后可靠时间。</p>
<p>此外，仅仅存在一个注册的卸载事件处理程序（通过onunload或addEventListener（））就可以阻止浏览器将页面放在前向缓存中以实现更快的前向和后向加载。</p>
<p>在所有现代浏览器（包括IE11）中，建议始终使用pagehide事件来检测可能的页面卸载（即终止状态），而不是unload事件。如果您需要支持InternetExplorer版本10及更低版本，您应该检测pagehide事件，并且只有在浏览器不支持pagehide的情况下才使用unload</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> terminationEvent = <span class="string">&#x27;onpagehide&#x27;</span> <span class="keyword">in</span> self ? <span class="string">&#x27;pagehide&#x27;</span> : <span class="string">&#x27;unload&#x27;</span>;</span><br><span class="line"></span><br><span class="line">addEventListener(terminationEvent, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Note: if the browser is able to cache the page, `event.persisted`</span></span><br><span class="line">  <span class="comment">// is `true`, and the state is frozen rather than terminated.</span></span><br><span class="line">&#125;, &#123;<span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<ul>
<li>The beforeunload event</li>
</ul>
<p>beforeunload事件与unload事件有一个类似的问题，即当存在该事件时，它会阻止浏览器在其前向缓存中缓存页面。</p>
<p>beforeunload和unload的区别在于beforeunload有合法的用法。例如，当您想警告用户他们有未保存的更改时，如果他们继续卸载页面，这些更改将丢失。</p>
<p>由于使用beforeunload有正当理由，但使用它会阻止将页添加到前向缓存，因此建议您仅在用户有未保存的更改时添加beforeunload侦听器，然后在保存未保存的更改后立即将其删除。</p>
<p>换句话说，不要这样做（因为它会无条件地添加beforeunload侦听器）：</p>
<p>参考文档：<br><a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api"> Overview of page lifecycle states</a><br><a href="https://wicg.github.io/page-lifecycle/"> W3c  Page Lifecycle</a> </p>
]]></content>
  </entry>
  <entry>
    <title>es6相关（一）</title>
    <url>/2020/11/14/js/es6-1/</url>
    <content><![CDATA[<p><a href="http://es6.ruanyifeng.com/#README">正则、数值、函数、数组、数值、对象</a></p>
<h2 id="一-正则的扩展"><a href="#一-正则的扩展" class="headerlink" title="(一)正则的扩展"></a>(一)正则的扩展</h2><ul>
<li><p>1、添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于 \uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
</li>
<li><p>2、新增 unicode 属性，表示是否设置了 u 修饰符。</p>
</li>
<li><p>3、加了 y 修饰符，叫做“粘连”（sticky）修饰符</p>
</li>
<li><p>4、与 y 修饰符相匹配，ES6 的正则实例对象多了 sticky 属性，表示是否设置了 y 修饰符</p>
</li>
<li><p>5、新增了 flags 属性，会返回正则表达式的修饰符。</p>
</li>
<li><p>6、<a href="https://github.com/tc39/proposal-regexp-dotall-flag">ES2018 引入 s 修饰符，使得 . 可以匹配任意单个字符</a></p>
</li>
</ul>
<p>四个字符属于“行终止符”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">U+<span class="number">0</span>00A 换行符（ \</span><br><span class="line"> ）</span><br><span class="line">U+<span class="number">0</span>00D 回车符（ \\r ）</span><br><span class="line">U+<span class="number">2028</span> 行分隔符（line separator）</span><br><span class="line">U+<span class="number">2029</span> 段分隔符（paragraph separator）</span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">&#x27;foo\</span></span><br><span class="line"><span class="string">bar&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="二-数值的扩展"><a href="#二-数值的扩展" class="headerlink" title="( 二 )数值的扩展"></a>( 二 )数值的扩展</h2><ul>
<li><p>1、二进制和八进制数值的新的写法，分别用前缀 0b （或 0B ）和 0o （或 0O ）表示。</p>
</li>
<li><p>2、新提供了 Number.isFinite() 和 Number.isNaN() 两个方法<br>注传统方法先调用 Number() 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效， Number.isFinite() 对于非数值一律返回 false ,  Number.isNaN() 只有对于 NaN 才返回 true ，非 NaN 一律返回 false 。</p>
</li>
<li><p>3、将全局方法 parseInt() 和 parseFloat() ，移植到 Number 对象上面，行为完全保持不变。</p>
</li>
<li><p>4、 Number.isInteger() 用来判断一个数值是否为整数。</p>
</li>
<li><p>5、新增一个极小的常量 Number.EPSILON 。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
</li>
<li><p>6、JavaScript 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点） Number.isSafeInteger() 则是用来判断一个整数是否落在这个范围之内</p>
</li>
<li><p>7、 Math.trunc 方法用于去除一个数的小数部分，返回整数部分</p>
</li>
<li><p>8、 Math.sign 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。</p>
<ul>
<li>参数为正数，返回 +1 ；</li>
<li>参数为负数，返回 -1 ；</li>
<li>参数为 0，返回 0 ；</li>
<li>参数为-0，返回 -0 ;</li>
<li>其他值，返回 NaN </li>
</ul>
</li>
<li><p>9、 Math.cbrt 方法用于计算一个数的立方根。</p>
</li>
<li><p>10、 新增了一个指数运算符（ ** ）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h2 id="三-函数的扩展"><a href="#三-函数的扩展" class="headerlink" title="(三)函数的扩展"></a>(三)函数的扩展</h2></li>
<li><p>1、参数默认值可以与解构赋值的默认值，结合起来使用。<br>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后， length 属性将失真。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>2、引入 rest 参数（形式为 …变量名 ），用于获取函数的多余参数，这样就不需要使用 arguments 对象了</p>
</li>
<li><p>3、ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
</li>
<li><p>4、ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。<br>Function 构造函数返回的函数实例， name 属性的值为 anonymous 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name</span><br><span class="line"><span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure>
<p>bind 返回的函数， name 属性值会加上 bound 前缀。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name</span><br><span class="line"><span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name</span><br><span class="line"><span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>5、允许使用“箭头”（ =&gt; ）定义函数。<br>箭头函数有几个使用注意点。<br>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
</li>
<li><p>6、尾调用优化<br>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;  </span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、 g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>
</li>
<li><p>7、尾递归优化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> factorial(<span class="number">5</span>)</span><br><span class="line">  <span class="comment">// 120</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span></span><br><span class="line"><span class="comment">// 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> factorial(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>8、<a href="https://github.com/jeffmo/es-trailing-function-commas">ES2017 允许函数的最后一个参数有尾逗号（trailing comma）</a></p>
</li>
</ul>
<h2 id="四-数组的扩展"><a href="#四-数组的扩展" class="headerlink" title="(四)数组的扩展"></a>(四)数组的扩展</h2><ul>
<li><p>1、扩展运算符（spread）是三个点（ … ）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
</li>
<li><p>2、 Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>
</li>
<li><p>3、 Array.of 方法用于将一组值，转换为数组。</p>
</li>
<li><p>4、数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</span></span><br><span class="line"><span class="comment">// start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</span></span><br><span class="line"><span class="comment">// end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</span></span><br><span class="line"><span class="comment">// 这三个参数都应该是数值，如果不是，会自动转为数值。 </span></span><br></pre></td></tr></table></figure></li>
<li><p>5、数组实例的 find、 findIndex方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &amp;lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure></li>
<li><p>6、 fill 方法使用给定值，填充一个数组。</p>
</li>
<li><p>7、ES6 提供三个新的方法—— entries() ， keys() 和 values() ——用于遍历数组。</p>
</li>
<li><p>8、 Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与 字符串的 includes 方法类似。</p>
</li>
<li><p>9、数组的成员有时还是数组， Array.prototype.flat(number) 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。number: 表示要“拉平”number层的嵌套数组<br>flatMap() 方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map() ），然后对返回值组成的数组执行 flat() 方法。该方法返回一个新数组，不改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">  <span class="comment">// [2, 4, 3, 6, 4, 8] </span></span><br><span class="line"><span class="comment">//   注意</span></span><br><span class="line"><span class="comment">// 将数组的空位，转为 undefined </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.from([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br><span class="line"> [...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"> <span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ] </span></span><br><span class="line"> [,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;] </span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] </span></span><br><span class="line"> <span class="keyword">let</span> arr = [, ,];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 1</span></span><br><span class="line"> <span class="comment">// 1  </span></span><br></pre></td></tr></table></figure>
<h2 id="五-对象的扩展"><a href="#五-对象的扩展" class="headerlink" title="(五)对象的扩展"></a>(五)对象的扩展</h2></li>
<li><p>1、ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">    foo，</span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: &quot;bar&quot;，method：function method()&#123;...&#125;&#125; </span></span><br></pre></td></tr></table></figure></li>
<li><p>2、可枚举性与遍历：<br>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。es5的方法： Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"> <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125; </span></span><br></pre></td></tr></table></figure>
<p>描述对象的 enumerable 属性，称为“可枚举性”，如果该属性为 false ，就表示某些操作会忽略当前属性。<br>目前，有四个操作会忽略 enumerable 为 false 的属性(不遍历)。</p>
<ul>
<li>for…in 循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys() ：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify() ：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign() ： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。<br>前三个是 ES5 就有的，最后一个 Object.assign() 是 ES6 新增的<blockquote>
<p>ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
</blockquote>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3>ES6 一共有 5 种方法可以遍历对象的属性。</li>
</ul>
</li>
<li><p>for…in</p>
<blockquote>
<p>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</blockquote>
</li>
<li><p>Object.keys(obj)</p>
<blockquote>
<p>Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</blockquote>
</li>
<li><p>Object.getOwnPropertyNames(obj)</p>
<blockquote>
<p>Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
</blockquote>
</li>
<li><p>Object.getOwnPropertySymbols(obj)</p>
<blockquote>
<p>Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
</blockquote>
</li>
<li><p>Reflect.ownKeys(obj)</p>
<blockquote>
<p>Reflect.ownKeys 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
</blockquote>
</li>
</ul>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li><p>首先遍历所有数值键，按照数值升序排列。</p>
</li>
<li><p>其次遍历所有字符串键，按照加入时间升序排列。</p>
</li>
<li><p>最后遍历所有 Symbol 键，按照加入时间升序排列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()] </span></span><br></pre></td></tr></table></figure></li>
<li><p>3、 this 关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super ，指向当前对象的原型对象。</p>
</li>
<li><p>4、<a href="ttps://github.com/sebmarkbage/ecmascript-rest-spread">ES2018 将扩展运算符（ …）引入对象。</a></p>
</li>
<li><p>5、函数的 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。<br>如果对象的方法使用了取值函数（ getter ）和存值函数（ setter ），则 name 属性不是在该方法上面，而是该方法的属性的描述对象的 get 和 set 属性上面，返回值是方法名前加上 get 和 set 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  person.sayName.name   <span class="comment">// &quot;sayName&quot;  </span></span><br><span class="line">  obj.foo.name</span><br><span class="line">   <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">   descriptor.set.name <span class="comment">// &quot;set foo&quot;  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//  有两种特殊情况： </span></span><br><span class="line"><span class="comment">//  bind方法创造的函数，name属性返回bound加上原函数的名字；  </span></span><br><span class="line"><span class="comment">//  Function构造函数创造的函数，name属性返回anonymous  </span></span><br><span class="line"></span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line">   <span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;;</span><br><span class="line">   doSomething.bind().name <span class="comment">// &quot;bound doSomething&quot;  </span></span><br><span class="line"><span class="comment">//  如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</span></span><br><span class="line">    <span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        [key1]() &#123;&#125;,</span><br><span class="line">        [key2]() &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    obj[key1].name <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">    obj[key2].name <span class="comment">// &quot;&quot;   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h3></li>
<li><p>1、 Object.is 。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。<br>不同之处只有两个：一是 +0 不等于 -0 ，二是 NaN 等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true </span></span><br></pre></td></tr></table></figure></li>
<li><p>2、 Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
</li>
<li><p>3、ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors() 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
</li>
<li><p>4、 Object.setPrototypeOf 方法的作用与 <strong>proto</strong> 相同，用来设置一个对象的 prototype 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法(接收两个参数)<br>如果第一个参数不是对象，会自动转为对象（ undefined 和 null 无法转为对象会报错）。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p>Object.getPrototypeOf(obj);与 Object.setPrototypeOf 方法配套，用于读取一个对象的原型对象。如果参数不是对象，会被自动转为对象。如果参数是 undefined 或 null ，它们无法转为对象，所以会报错。</p>
</li>
<li><p>5、ES5 引入了 Object.keys 方法，返回一个数组、<a href="https://github.com/tc39/proposal-object-values-entries">ES2017 引入</a>了跟 Object.keys 配套的 Object.values 和 Object.entries ，作为遍历一个对象的补充手段，供 for…of 循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]  属性名为数值的属性（同上文属性的遍历规则），是按照数值大小，从小到大遍历的，因此返回的顺序是 b、c、a  </span></span><br></pre></td></tr></table></figure>
<p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）<br>所有可遍历（enumerable）属性的键值对数组。如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] </span></span><br></pre></td></tr></table></figure></li>
<li><p>6、 Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象。</p>
</li>
</ul>
<h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>ES5 中  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create </a></p>
<p> Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </p>
<p>语法：<br> Object.create(proto, [propertiesObject]) </p>
<ul>
<li><p>proto<br> 新创建对象的原型对象。</p>
</li>
<li><p>propertiesObject<br> 可选。如果没有指定为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined">undefined</a> ，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应[Object.defineProperties()](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties的第二个参数。</a></p>
<p> 如果 propertiesObject 参数不是  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null">null</a> 或一个对象，则抛出一个  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError">TypeError</a> 异常。</p>
</li>
</ul>
<p>ES5 中 Object.defineProperties() </p>
<p>语法：</p>
<p> Object.defineProperties(<var>obj</var>, <var>props</var>) <dl><dt> obj </dt><dd>在其上定义或修改属性的对象。</dd><dt> props </dt><dd>要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty()</a>）。描述符具有以下键：</dd><dd><dl><dt>     configurable </dt><dd>          对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。<br>                     默认为  false </dd><dt>     enumerable </dt><dd>         true  当且仅当在枚举相应对象上的属性时该属性显现。<br>                     默认为  false </dd></dl><dl><dt>     value </dt><dd>                与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。<br>                 默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"> undefined </a>.</dd><dt>     writable </dt><dd>         true 当且仅当与该属性相关联的值可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" title="赋值运算符（assignment operator）基于右值（right operand）的值，给左值（left operand）赋值。">assignment operator</a>改变时。<br>                     默认为  false </dd></dl><dl><dt>     get </dt><dd>                作为该属性的 getter 函数，如果没有 getter 则为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"> undefined </a>。函数返回值将被用作属性的值。<br>                 默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"> undefined </a></dd><dt>     set </dt><dd>                作为属性的 setter 函数，如果没有 setter 则为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"> undefined </a>。函数将仅接受参数赋值给该属性的新值。<br>                 默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"> undefined </a></dd></dl></dd></dl><br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> bValue;<span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="string">&#x27;property1&#x27;</span>: &#123;</span><br><span class="line">    get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set : <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">            bValue = newValue;</span><br><span class="line">    &#125;,    <span class="comment">// value: true, 数据描述符和存取描述符不能混合使用</span></span><br><span class="line">        writable: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;property2&#x27;</span>: &#123;</span><br><span class="line">            value: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// etc. etc.</span></span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="comment">// 显式</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;key&quot;</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&quot;static&quot;</span></span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP 简介</title>
    <url>/2020/11/14/network/http-info/</url>
    <content><![CDATA[<blockquote>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
</blockquote>
<h2 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a><a href="https://www.w3cschool.cn/http/u9ktefmo.html" target="_blank">W3C</a></h2><h2 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h2><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<h2 id="HTTP三点注意事项："><a href="#HTTP三点注意事项：" class="headerlink" title="HTTP三点注意事项："></a>HTTP三点注意事项：</h2><ul><li>
HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>

</li><li>
HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>

</li><li>
HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>

</li></ul>
以下图表展示了HTTP协议通信流程：

<p><img src="/img/http5.gif"></p>
<h2 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="/img/http6.png"></p>
<h2 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h2><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img src="/img/http7.jpg"></p>
<h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p>
<p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<table><tbody><tr><th width="5%">序号</th><th width="10%">方法</th><th>描述</th></tr><tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主体。
.</td></tr><tr><td>2</td><td>HEAD</td><td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
.</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
.</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。
.</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。
.</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
.</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。
.</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr></tbody></table>


<h2 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h2><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息</p>
<table><tbody><tr><th>应答头</th><th>说明</th></tr><tr><td>Allow</td><td>服务器支持哪些请求方法（如GET、POST等）。</td></tr><tr><td>Content-Encoding</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压 缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的 Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept- Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。
.</td></tr><tr><td>Content-Length</td><td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。
.</td></tr><tr><td>Content-Type</td><td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。
. 
</td></tr><tr><td>Date</td><td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
.</td></tr><tr><td>Expires</td><td>应该在什么时候认为文档已经过期，从而不再缓存它？
.</td></tr><tr><td>Last-Modified</td><td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。
.</td></tr><tr><td>Location</td><td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。
.</td></tr><tr><td>Refresh</td><td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。 
注 意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的 HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 

<p>注意Refresh的意义是”N秒之后刷 新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可 以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 </p>
<p>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。<br>.</td></tr><tr><td>Server</td><td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。<br>.</td></tr><tr><td>Set-Cookie</td><td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。<br>.</td></tr><tr><td>WWW-Authenticate</td><td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的 应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td></tr></tbody></table></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h2><p>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。</p>
<h2 id="HTTP-content-type-对照表"><a href="#HTTP-content-type-对照表" class="headerlink" title="HTTP  content-type 对照表"></a>HTTP  content-type 对照表</h2><p><a href="https://www.w3cschool.cn/http/ahkmgfmz.html" target="_blank">content-type 对照表</a><table><tbody><tr><th>文件扩展名</th><th>Content-Type(Mime-Type)</th><th>文件扩展名</th><th>Content-Type(Mime-Type)</th></tr></tbody><tbody><tr><td>.<em>（ 二进制流，不知道下载文件类型）</td><td>application/octet-stream</td><td>.tif</td><td>image/tiff</td></tr><tr><td>.001———————————</td><td>application/x-001——————</td><td>.301—–</td><td>application/x-301</td></tr><tr><td>.323———————————</td><td>text/h323—————————–</td><td>.906—–</td><td>application/x-906</td></tr><tr><td>.907———————————</td><td>drawing/907————————–</td><td>.a11—–</td><td>application/x-a11</td></tr><tr><td>.acp———————————</td><td>audio/x-mei-aac———————-</td><td>.ai——–</td><td>application/postscript</td></tr><tr><td>.aif——————————–</td><td>audio/aiff————————–</td><td>.aifc—–</td><td>audio/aiff</td></tr><tr><td>.aiff———————————</td><td>audio/aiff————————–</td><td>.anv</td><td>application/x-anv</td></tr><tr><td>.asa———————————</td><td>text/asa————————–</td><td>.asf</td><td>video/x-ms-asf</td></tr><tr><td>.asp———————————</td><td>text/asp————————–</td><td>.asx</td><td>video/x-ms-asf</td></tr><tr><td>.au———————————</td><td>audio/basic————————–</td><td>.avi</td><td>video/avi</td></tr><tr><td>.awf———————————</td><td>application/vnd.adobe.workflow</td><td>.biz</td><td>text/xml</td></tr><tr><td>.bmp——————————–</td><td>application/x-bmp</td><td>.bot</td><td>application/x-bot</td></tr><tr><td>.c4t———————————</td><td>application/x-c4t</td><td>.c90</td><td>application/x-c90</td></tr><tr><td>.cal———————————</td><td>application/x-cals</td><td>.cat</td><td>application/vnd.ms-pki.seccat</td></tr><tr><td>.cdf———————————</td><td>application/x-netcdf</td><td>.cdr</td><td>application/x-cdr</td></tr><tr><td>.cel———————————</td><td>application/x-cel</td><td>.cer</td><td>application/x-x509-ca-cert</td></tr><tr><td>.cg4———————————</td><td>application/x-g4</td><td>.cgm</td><td>application/x-cgm</td></tr><tr><td>.cit———————————</td><td>application/x-cit———————–</td><td>.class</td><td>java/</em></td></tr><tr><td>.cml———————————</td><td>text/xml————————–</td><td>.cmp</td><td>application/x-cmp</td></tr><tr><td>.cmx——————————–</td><td>application/x-cmx</td><td>.cot</td><td>application/x-cot</td></tr><tr><td>.crl———————————</td><td>application/pkix-crl</td><td>.crt</td><td>application/x-x509-ca-cert</td></tr><tr><td>.csi———————————</td><td>application/x-csi</td><td>.css</td><td>text/css</td></tr><tr><td>.cut———————————</td><td>application/x-cut</td><td>.dbf</td><td>application/x-dbf</td></tr><tr><td>.dbm——————————–</td><td>application/x-dbm</td><td>.dbx</td><td>application/x-dbx</td></tr><tr><td>.dcd———————————</td><td>text/xml</td><td>.dcx</td><td>application/x-dcx</td></tr><tr><td>.der———————————</td><td>application/x-x509-ca-cert</td><td>.dgn</td><td>application/x-dgn</td></tr><tr><td>.dib———————————</td><td>application/x-dib</td><td>.dll</td><td>application/x-msdownload</td></tr><tr><td>.doc———————————</td><td>application/msword</td><td>.dot</td><td>application/msword</td></tr><tr><td>.drw———————————</td><td>application/x-drw</td><td>.dtd</td><td>text/xml</td></tr><tr><td>.dwf———————————</td><td>Model/vnd.dwf</td><td>.dwf</td><td>application/x-dwf</td></tr><tr><td>.dwg——————————–</td><td>application/x-dwg</td><td>.dxb</td><td>application/x-dxb</td></tr><tr><td>.dxf———————————</td><td>application/x-dxf</td><td>.edn</td><td>application/vnd.adobe.edn</td></tr><tr><td>.emf———————————</td><td>application/x-emf</td><td>.eml</td><td>message/rfc822</td></tr><tr><td>.ent———————————</td><td>text/xml————————–</td><td>.epi</td><td>application/x-epi</td></tr><tr><td>.eps———————————</td><td>application/x-ps</td><td>.eps</td><td>application/postscript</td></tr><tr><td>.etd———————————</td><td>application/x-ebx</td><td>.exe</td><td>application/x-msdownload</td></tr><tr><td>.fax———————————</td><td>image/fax————————–</td><td>.fdf</td><td>application/vnd.fdf</td></tr><tr><td>.fif———————————</td><td>application/fractals</td><td>.fo</td><td>text/xml</td></tr><tr><td>.frm———————————</td><td>application/x-frm</td><td>.g4</td><td>application/x-g4</td></tr><tr><td>.gbr———————————</td><td>application/x-gbr</td><td>.</td><td>application/x-</td></tr><tr><td>.gif———————————</td><td>image/gif————————–</td><td>.gl2</td><td>application/x-gl2</td></tr><tr><td>.gp4———————————</td><td>application/x-gp4</td><td>.hgl</td><td>application/x-hgl</td></tr><tr><td>.hmr———————————</td><td>application/x-hmr</td><td>.hpg</td><td>application/x-hpgl</td></tr><tr><td>.hpl———————————</td><td>application/x-hpl</td><td>.hqx</td><td>application/mac-binhex40</td></tr><tr><td>.hrf———————————</td><td>application/x-hrf</td><td>.hta</td><td>application/hta</td></tr><tr><td>.htc———————————</td><td>text/x-component</td><td>.htm</td><td>text/html</td></tr><tr><td>.html——————————–</td><td>text/html</td><td>.htt</td><td>text/webviewhtml</td></tr><tr><td>.htx———————————</td><td>text/html</td><td>.icb</td><td>application/x-icb</td></tr><tr><td>.ico———————————</td><td>image/x-icon</td><td>.ico</td><td>application/x-ico</td></tr><tr><td>.iff———————————</td><td>application/x-iff</td><td>.ig4</td><td>application/x-g4</td></tr><tr><td>.igs———————————</td><td>application/x-igs</td><td>.iii</td><td>application/x-iphone</td></tr><tr><td>.img———————————</td><td>application/x-img</td><td>.ins</td><td>application/x-internet-signup</td></tr><tr><td>.isp———————————</td><td>application/x-internet-signup</td><td>.IVF</td><td>video/x-ivf</td></tr><tr><td>.java———————————</td><td>java/*————————–</td><td>.jfif</td><td>image/jpeg</td></tr><tr><td>.jpe———————————</td><td>image/jpeg————————–</td><td>.jpe</td><td>application/x-jpe</td></tr><tr><td>.jpeg——————————–</td><td>image/jpeg————————–</td><td>.jpg</td><td>image/jpeg</td></tr><tr><td>.jpg———————————</td><td>application/x-jpg</td><td>.js</td><td>application/x-javascript</td></tr><tr><td>.jsp———————————</td><td>text/html————————–</td><td>.la1</td><td>audio/x-liquid-file</td></tr><tr><td>.lar———————————</td><td>application/x-laplayer-reg</td><td>.latex</td><td>application/x-latex</td></tr><tr><td>.lavs———————————</td><td>audio/x-liquid-secure</td><td>.lbm</td><td>application/x-lbm</td></tr><tr><td>.lmsff——————————–</td><td>audio/x-la-lms</td><td>.ls</td><td>application/x-javascript</td></tr><tr><td>.ltr———————————</td><td>application/x-ltr</td><td>.m1v</td><td>video/x-mpeg</td></tr><tr><td>.m2v——————————–</td><td>video/x-mpeg————————-</td><td>.m3u</td><td>audio/mpegurl</td></tr><tr><td>.m4e——————————–</td><td>video/mpeg4</td><td>.mac</td><td>application/x-mac</td></tr><tr><td>.man——————————–</td><td>application/x-troff-man</td><td>.math</td><td>text/xml</td></tr><tr><td>.mdb——————————–</td><td>application/msaccess</td><td>.mdb</td><td>application/x-mdb</td></tr><tr><td>.mfp———————————</td><td>application/x-shockwave-flash</td><td>.mht</td><td>message/rfc822</td></tr><tr><td>.mhtml——————————</td><td>message/rfc822———————-</td><td>.mi</td><td>application/x-mi</td></tr><tr><td>.mid———————————</td><td>audio/mid————————–</td><td>.midi</td><td>audio/mid</td></tr><tr><td>.mil———————————</td><td>application/x-mil</td><td>.mml</td><td>text/xml</td></tr><tr><td>.mnd——————————–</td><td>audio/x-musicnet-download</td><td>.mns</td><td>audio/x-musicnet-stream</td></tr><tr><td>.mocha——————————</td><td>application/x-javascript</td><td>.movie</td><td>video/x-sgi-movie</td></tr><tr><td>.mp1——————————-</td><td>audio/mp1</td><td>.mp2</td><td>audio/mp2</td></tr><tr><td>.mp2v——————————-</td><td>video/mpeg</td><td>.mp3</td><td>audio/mp3</td></tr><tr><td>.mp4——————————–</td><td>video/mpeg4</td><td>.mpa</td><td>video/x-mpg</td></tr><tr><td>.mpd——————————–</td><td>application/vnd.ms-project</td><td>.mpe</td><td>video/x-mpeg</td></tr><tr><td>.mpeg——————————-</td><td>video/mpg————————–</td><td>.mpg</td><td>video/mpg</td></tr><tr><td>.mpga——————————-</td><td>audio/rn-mpeg</td><td>.mpp</td><td>application/vnd.ms-project</td></tr><tr><td>.mps——————————–</td><td>video/x-mpeg————————-</td><td>.mpt</td><td>application/vnd.ms-project</td></tr><tr><td>.mpv——————————–</td><td>video/mpg————————–</td><td>.mpv2</td><td>video/mpeg</td></tr><tr><td>.mpw——————————–</td><td>application/vnd.ms-project</td><td>.mpx</td><td>application/vnd.ms-project</td></tr><tr><td>.mtx———————————</td><td>text/xml————————–</td><td>.mxp</td><td>application/x-mmxp</td></tr><tr><td>.net———————————</td><td>image/pnetvue</td><td>.nrf</td><td>application/x-nrf</td></tr><tr><td>.nws———————————</td><td>message/rfc822</td><td>.odc</td><td>text/x-ms-odc</td></tr><tr><td>.out———————————</td><td>application/x-out</td><td>.p10</td><td>application/pkcs10</td></tr><tr><td>.p12———————————</td><td>application/x-pkcs12</td><td>.p7b</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.p7c———————————</td><td>application/pkcs7-mime</td><td>.p7m</td><td>application/pkcs7-mime</td></tr><tr><td>.p7r———————————</td><td>application/x-pkcs7-certreqresp</td><td>.p7s</td><td>application/pkcs7-signature</td></tr><tr><td>.pc5———————————</td><td>application/x-pc5</td><td>.pci</td><td>application/x-pci</td></tr><tr><td>.pcl———————————</td><td>application/x-pcl</td><td>.pcx</td><td>application/x-pcx</td></tr><tr><td>.pdf———————————</td><td>application/pdf</td><td>.pdf</td><td>application/pdf</td></tr><tr><td>.pdx———————————</td><td>application/vnd.adobe.pdx</td><td>.pfx</td><td>application/x-pkcs12</td></tr><tr><td>.pgl———————————</td><td>application/x-pgl</td><td>.pic</td><td>application/x-pic</td></tr><tr><td>.pko———————————</td><td>application/vnd.ms-pki.pko</td><td>.pl</td><td>application/x-perl</td></tr><tr><td>.plg———————————</td><td>text/html————————–</td><td>.pls</td><td>audio/scpls</td></tr><tr><td>.plt———————————</td><td>application/x-plt</td><td>.png</td><td>image/png</td></tr><tr><td>.png———————————</td><td>application/x-png</td><td>.pot</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppa———————————</td><td>application/vnd.ms-powerpoint</td><td>.ppm</td><td>application/x-ppm</td></tr><tr><td>.pps———————————</td><td>application/vnd.ms-powerpoint</td><td>.ppt</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppt———————————</td><td>application/x-ppt</td><td>.pr</td><td>application/x-pr</td></tr><tr><td>.prf———————————</td><td>application/pics-rules</td><td>.prn</td><td>application/x-prn</td></tr><tr><td>.prt———————————</td><td>application/x-prt</td><td>.ps</td><td>application/x-ps</td></tr><tr><td>.ps———————————</td><td>application/postscript</td><td>.ptn</td><td>application/x-ptn</td></tr><tr><td>.pwz———————————</td><td>application/vnd.ms-powerpoint</td><td>.r3t</td><td>text/vnd.rn-realtext3d</td></tr><tr><td>.ra———————————</td><td>audio/vnd.rn-realaudio</td><td>.ram</td><td>audio/x-pn-realaudio</td></tr><tr><td>.ras———————————</td><td>application/x-ras</td><td>.rat</td><td>application/rat-file</td></tr><tr><td>.rdf———————————</td><td>text/xml————————–</td><td>.rec</td><td>application/vnd.rn-recording</td></tr><tr><td>.red———————————</td><td>application/x-red</td><td>.rgb</td><td>application/x-rgb</td></tr><tr><td>.rjs———————————</td><td>application/vnd.rn-realsystem-rjs</td><td>.rjt</td><td>application/vnd.rn-realsystem-rjt</td></tr><tr><td>.rlc———————————</td><td>application/x-rlc———————–</td><td>.rle</td><td>application/x-rle</td></tr><tr><td>.rm———————————</td><td>application/vnd.rn-realmedia</td><td>.rmf</td><td>application/vnd.adobe.rmf</td></tr><tr><td>.rmi———————————</td><td>audio/mid————————–</td><td>.rmj</td><td>application/vnd.rn-realsystem-rmj</td></tr><tr><td>.rmm——————————–</td><td>audio/x-pn-realaudio</td><td>.rmp</td><td>application/vnd.rn-rn_music_package</td></tr><tr><td>.rms———————————</td><td>application/vnd.rn-realmedia-secure</td><td>.rmvb</td><td>application/vnd.rn-realmedia-vbr</td></tr><tr><td>.rmx———————————</td><td>application/vnd.rn-realsystem-rmx</td><td>.rnx</td><td>application/vnd.rn-realplayer</td></tr><tr><td>.rp———————————</td><td>image/vnd.rn-realpix</td><td>.rpm</td><td>audio/x-pn-realaudio-plugin</td></tr><tr><td>.rsml——————————–</td><td>application/vnd.rn-rsml</td><td>.rt</td><td>text/vnd.rn-realtext</td></tr><tr><td>.rtf———————————</td><td>application/msword</td><td>.rtf</td><td>application/x-rtf</td></tr><tr><td>.rv———————————</td><td>video/vnd.rn-realvideo</td><td>.sam</td><td>application/x-sam</td></tr><tr><td>.sat———————————</td><td>application/x-sat</td><td>.sdp</td><td>application/sdp</td></tr><tr><td>.sdw———————————</td><td>application/x-sdw</td><td>.sit</td><td>application/x-stuffit</td></tr><tr><td>.slb———————————</td><td>application/x-slb</td><td>.sld</td><td>application/x-sld</td></tr><tr><td>.slk———————————</td><td>drawing/x-slk————————–</td><td>.smi</td><td>application/smil</td></tr><tr><td>.smil———————————</td><td>application/smil</td><td>.smk</td><td>application/x-smk</td></tr><tr><td>.snd———————————</td><td>audio/basic————————–</td><td>.sol</td><td>text/plain</td></tr><tr><td>.sor———————————</td><td>text/plain————————–</td><td>.spc</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.spl———————————</td><td>application/futuresplash</td><td>.spp</td><td>text/xml</td></tr><tr><td>.ssm———————————</td><td>application/streamingmedia</td><td>.sst</td><td>application/vnd.ms-pki.certstore</td></tr><tr><td>.stl———————————</td><td>application/vnd.ms-pki.stl</td><td>.stm</td><td>text/html</td></tr><tr><td>.sty———————————</td><td>application/x-sty</td><td>.svg</td><td>text/xml</td></tr><tr><td>.swf———————————</td><td>application/x-shockwave-flash</td><td>.tdf</td><td>application/x-tdf</td></tr><tr><td>.tg4———————————</td><td>application/x-tg4</td><td>.tga</td><td>application/x-tga</td></tr><tr><td>.tif———————————</td><td>image/tiff————————–</td><td>.tif</td><td>application/x-tif</td></tr><tr><td>.tiff———————————</td><td>image/tiff————————–</td><td>.tld</td><td>text/xml</td></tr><tr><td>.top———————————</td><td>drawing/x-top</td><td>.torrent</td><td>application/x-bittorrent</td></tr><tr><td>.tsd———————————</td><td>text/xml————————–</td><td>.txt</td><td>text/plain</td></tr><tr><td>.uin———————————</td><td>application/x-icq</td><td>.uls</td><td>text/iuls</td></tr><tr><td>.vcf———————————</td><td>text/x-vcard————————–</td><td>.vda</td><td>application/x-vda</td></tr><tr><td>.vdx———————————</td><td>application/vnd.visio</td><td>.vml</td><td>text/xml</td></tr><tr><td>.vpg———————————</td><td>application/x-vpeg005</td><td>.vsd</td><td>application/vnd.visio</td></tr><tr><td>.vsd———————————</td><td>application/x-vsd</td><td>.vss</td><td>application/vnd.visio</td></tr><tr><td>.vst———————————</td><td>application/vnd.visio</td><td>.vst</td><td>application/x-vst</td></tr><tr><td>.vsw———————————</td><td>application/vnd.visio</td><td>.vsx</td><td>application/vnd.visio</td></tr><tr><td>.vtx———————————</td><td>application/vnd.visio</td><td>.vxml</td><td>text/xml</td></tr><tr><td>.wav———————————</td><td>audio/wav————————–</td><td>.wax</td><td>audio/x-ms-wax</td></tr><tr><td>.wb1——————————–</td><td>application/x-wb1</td><td>.wb2</td><td>application/x-wb2</td></tr><tr><td>.wb3——————————–</td><td>application/x-wb3</td><td>.wbmp</td><td>image/vnd.wap.wbmp</td></tr><tr><td>.wiz———————————</td><td>application/msword</td><td>.wk3</td><td>application/x-wk3</td></tr><tr><td>.wk4———————————</td><td>application/x-wk4</td><td>.wkq</td><td>application/x-wkq</td></tr><tr><td>.wks———————————</td><td>application/x-wks</td><td>.wm</td><td>video/x-ms-wm</td></tr><tr><td>.wma——————————–</td><td>audio/x-ms-wma</td><td>.wmd</td><td>application/x-ms-wmd</td></tr><tr><td>.wmf——————————–</td><td>application/x-wmf</td><td>.wml</td><td>text/vnd.wap.wml</td></tr><tr><td>.wmv——————————–</td><td>video/x-ms-wmv</td><td>.wmx</td><td>video/x-ms-wmx</td></tr><tr><td>.wmz——————————–</td><td>application/x-ms-wmz</td><td>.wp6</td><td>application/x-wp6</td></tr><tr><td>.wpd——————————–</td><td>application/x-wpd</td><td>.wpg</td><td>application/x-wpg</td></tr><tr><td>.wpl———————————</td><td>application/vnd.ms-wpl</td><td>.wq1</td><td>application/x-wq1</td></tr><tr><td>.wr1———————————</td><td>application/x-wr1</td><td>.wri</td><td>application/x-wri</td></tr><tr><td>.wrk———————————</td><td>application/x-wrk</td><td>.ws</td><td>application/x-ws</td></tr><tr><td>.ws2———————————</td><td>application/x-ws</td><td>.wsc</td><td>text/scriptlet</td></tr><tr><td>.wsdl——————————–</td><td>text/xml————————–</td><td>.wvx</td><td>video/x-ms-wvx</td></tr><tr><td>.xdp———————————</td><td>application/vnd.adobe.xdp</td><td>.xdr</td><td>text/xml</td></tr><tr><td>.xfd———————————</td><td>application/vnd.adobe.xfd</td><td>.xfdf</td><td>application/vnd.adobe.xfdf</td></tr><tr><td>.xhtml——————————-</td><td>text/html————————–</td><td>.xls</td><td>application/vnd.ms-excel</td></tr><tr><td>.xls———————————</td><td>application/x-xls</td><td>.xlw</td><td>application/x-xlw</td></tr><tr><td>.xml———————————</td><td>text/xml————————–</td><td>.xpl</td><td>audio/scpls</td></tr><tr><td>.xq———————————</td><td>text/xml</td><td>.xql</td><td>text/xml</td></tr><tr><td>.xquery——————————</td><td>text/xml————————–</td><td>.xsd</td><td>text/xml</td></tr><tr><td>.xsl———————————</td><td>text/xml————————–</td><td>.xslt</td><td>text/xml</td></tr><tr><td>.xwd———————————</td><td>application/x-xwd</td><td>.x_b</td><td>application/x-x_b</td></tr><tr><td>.sis———————————</td><td>application/vnd.symbian.install</td><td>.sisx</td><td>application/vnd.symbian.install</td></tr><tr><td>.x_t———————————</td><td>application/x-x_t———————-</td><td>.ipa</td><td>application/vnd.iphone</td></tr><tr><td>.apk———————————</td><td>application/vnd.android.package-archive</td><td>.xap</td><td>application/x-silverlight-app</td></tr></tbody></table></p>
]]></content>
  </entry>
  <entry>
    <title>《Java工程师修炼之道》</title>
    <url>/2020/11/14/other/java/</url>
    <content><![CDATA[<h2 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user where name=xx and city=xx ; ／／可以命中索引</span><br><span class="line">select * from user where name=xx ; <span class="comment">// 可以命中索引</span></span><br><span class="line">select * from user where city=xx ; <span class="comment">// 无法命中索引       </span></span><br></pre></td></tr></table></figure>



<p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。</p>
<h2 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h2><p>冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p>MySQL5.7 版本后，可以通过查询 sys 库的 schema_redundant_indexes 表来查看冗余索引</p>
<h2 id="Mysql如何为表字段添加索引？"><a href="#Mysql如何为表字段添加索引？" class="headerlink" title="Mysql如何为表字段添加索引？"></a>Mysql如何为表字段添加索引？</h2><p>1.添加PRIMARY KEY（主键索引）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` <span class="function">ADD PRIMARY <span class="title">KEY</span> <span class="params">( `column` )</span> </span></span><br></pre></td></tr></table></figure>



<p>2.添加UNIQUE(唯一索引)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` <span class="function">ADD <span class="title">UNIQUE</span> <span class="params">( `column` )</span> </span></span><br></pre></td></tr></table></figure>



<p>3.添加INDEX(普通索引)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` <span class="function">ADD INDEX <span class="title">index_name</span> <span class="params">( `column` )</span></span></span><br></pre></td></tr></table></figure>



<p>4.添加FULLTEXT(全文索引)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE `table_name` <span class="function">ADD <span class="title">FULLTEXT</span> <span class="params">( `column`)</span></span></span><br></pre></td></tr></table></figure>



<p>5.添加多列索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` <span class="function">ADD INDEX <span class="title">index_name</span> <span class="params">( `column1`, `column2`, `column3` )</span></span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎<h4></h4><h4></h2></h4><h4>一些常用命令</h4>


<p>查看MySQL提供的所有存储引擎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>



<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<p>查看MySQL当前默认的存储引擎</p>
<p>我们也可以通过下面的命令查看默认的存储引擎。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>查看表的存储引擎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show table status like <span class="string">&quot;table_name&quot;</span> ;</span><br></pre></td></tr></table></figure>
<h4>MyISAM和InnoDB区别</h4>


<p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃回复问题的话）。</p>
<p>两者的对比：<ol><li><br>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li><br>是否支持事务和崩溃后的安全恢复：MyISAM 强调的是性能，每次查询具有原子性,其执行比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li><li><br>是否支持外键： MyISAM不支持，而InnoDB支持。</li><li><br>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。</li><li><br>……</li></ol></p>
<p>《MySQL高性能》上面有一句话这样写到:<blockquote>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</blockquote><br>一般情况下我们选择 InnoDB 都是没有问题的，但是某事情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<h2 id="乐观锁与悲观锁的区别"><a href="#乐观锁与悲观锁的区别" class="headerlink" title="乐观锁与悲观锁的区别"></a>乐观锁与悲观锁的区别</h2><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h2 id="乐观锁常见的两种实现方式乐观锁一般会使用版本号机制或CAS算法实现。1-版本号机制"><a href="#乐观锁常见的两种实现方式乐观锁一般会使用版本号机制或CAS算法实现。1-版本号机制" class="headerlink" title="乐观锁常见的两种实现方式乐观锁一般会使用版本号机制或CAS算法实现。1. 版本号机制"></a>乐观锁常见的两种实现方式<blockquote>乐观锁一般会使用版本号机制或CAS算法实现。</blockquote><h4>1. 版本号机制</h4></h2><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol><li>
操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>
在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>
操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>
操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol>


<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4>2. CAS算法</h4>


<p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数<ul><li><br>需要读写的内存值 V</li><li><br>进行比较的值 A</li><li><br>拟写入的新值 B</li></ul></p>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h2 id="乐观锁的缺点ABA-问题是乐观锁一个常见的问题1、ABA-问题"><a href="#乐观锁的缺点ABA-问题是乐观锁一个常见的问题1、ABA-问题" class="headerlink" title="乐观锁的缺点ABA 问题是乐观锁一个常见的问题1、ABA 问题"></a>乐观锁的缺点<blockquote>ABA 问题是乐观锁一个常见的问题</blockquote><h4>1、ABA 问题</h4></h2><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4>2、循环时间长开销大</h4>


<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4>3、只能保证一个共享变量的原子操作</h4>


<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul><li>
MyISAM 采用表级锁(table-level locking)。</li><li>
InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li></ul>


<p>表级锁和行级锁对比：</p>
<ul><li>
表级锁： Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li><li>
行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。<span style="color: rgb(249, 150, 59);">行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</span></li><li>

</li></ul><h2>死锁案例</h2>
1、

<p><img src="/img/sql_s1.jpg"></p>
<p>死锁的根本原因是有两个或多个事务之间加锁顺序的不一致导致的，这个死锁案例其实是最经典的死锁场景。<br>首先，事务 A 获取 id = 20 的锁（lock_mode X locks rec but not gap），事务 B 获取 id = 30 的锁；然后，事务 A 试图获取 id = 30 的锁，而该锁已经被事务 B 持有，所以事务 A 等待事务 B 释放该锁，然后事务 B 又试图获取 id = 20 的锁，这个锁被事务 A 占有，于是两个事务之间相互等待，导致死锁。</p>
<p>2、<br><img src="/img/sql_s2.jpg"></p>
<p>首先事务 A 和事务 B 执行了两条 UPDATE 语句，但是由于 id = 25 和 id = 26 记录都不存在，事务 A 和 事务 B 并没有更新任何记录，但是由于数据库隔离级别为 RR，所以会在 (20, 30) 之间加上间隙锁（lock_mode X locks gap before rec），间隙锁和间隙锁并不冲突。之后事务 A 和事务 B 分别执行 INSERT 语句要插入记录 id = 25 和 id = 26，需要在 (20, 30) 之间加插入意向锁（lock_mode X locks gap before rec insert intention），插入意向锁和间隙锁冲突，所以两个事务互相等待，最后形成死锁。</p>
<p>要解决这个死锁很简单，显然，前面两条 UPDATE 语句是无效的，将其删除即可。另外也可以将数据库隔离级别改成 RC，这样在 UPDATE 的时候就不会有间隙锁了。这个案例正是文章开头提到的死锁日志中的死锁场景，别看这个 UPDATE 语句是无效的，看起来很傻，但是确实是真实的场景，因为在真实的项目中代码会非常复杂，比如采用了 ORM 框架，应用层和数据层代码分离，一般开发人员写代码时都不知道会生成什么样的 SQL 语句，我也是从 DBA 那里拿到了 binlog，然后从里面找到了事务执行的所有 SQL 语句，发现其中竟然有一行无效的 UPDATE 语句，最后追本溯源，找到对应的应用代码，将其删除，从而修复了这个死锁。</p>
<p>3、<br><img src="/img/sql_s3.jpg"><br>别看这个案例里每个事务都只有一条 SQL 语句，但是却实实在在可能会导致死锁问题，其实说起来，这个死锁和案例一并没有什么区别，只不过理解起来要更深入一点。要知道在范围查询时，加锁是一条记录一条记录挨个加锁的，所以虽然只有一条 SQL 语句，如果两条 SQL 语句的加锁顺序不一样，也会导致死锁。</p>
<p>在案例一中，事务 A 的加锁顺序为： id = 20 -&gt; 30，事务 B 的加锁顺序为：id = 30 -&gt; 20，正好相反，所以会导致死锁。这里的情景也是一样，事务 A 的范围条件为 id &lt; 30，加锁顺序为：id = 15 -&gt; 18 -&gt; 20，事务 B 走的是二级索引 age，加锁顺序为：(age, id) = (24, 18) -&gt; (24, 20) -&gt; (25, 15) -&gt; (25, 49)，其中，对 id 的加锁顺序为 id = 18 -&gt; 20 -&gt; 15 -&gt; 49。可以看到事务 A 先锁 15，再锁 18，而事务 B 先锁 18，再锁 15，从而形成死锁。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>在工作过程中偶尔会遇到死锁问题，虽然这种问题遇到的概率不大，但每次遇到的时候要想彻底弄懂其原理并找到解决方案却并不容易。其实，对于 MySQL 的 InnoDb 存储引擎来说，死锁问题是避免不了的，没有哪种解决方案可以说完全解决死锁问题，但是我们可以通过一些可控的手段，降低出现死锁的概率。</p>
<ol><li>1、如上面的案例一和案例三所示，对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</span></li><li>
</span></li><li>2、如上面的案例二所示，Gap 锁往往是程序中导致死锁的真凶，由于默认情况下 MySQL 的隔离级别是 RR，所以如果能确定幻读和不可重复读对应用的影响不大，可以考虑将隔离级别改成 RC，可以避免 Gap 锁导致的死锁；</span></li><li>
</span></li><li>3、为表添加合理的索引，如果不走索引将会为表的每一行记录加锁，死锁的概率就会大大增大；</span></li><li>
</span></li><li>4、我们知道 MyISAM 只支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁，所以，我们也可以使用同样的思想，在事务中一次锁定所需要的所有资源，减少死锁概率；</span></li><li>
</span></li><li>5、避免大事务，尽量将大事务拆成多个小事务来处理；因为大事务占用资源多，耗时长，与其他事务冲突的概率也会变高；</span></li><li>
</span></li><li>6、避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行；</span></li><li>
</span></li><li>7、设置锁等待超时参数：innodb_lock_wait_timeout，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</span></li><li>
</li></ol>
InnoDB存储引擎的锁的算法有三种：<ul><li>
Record lock：单个行记录上的锁</li><li>
Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>
Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul>


<p>相关知识点：<ul><li><br>innodb对于行的查询使用next-key lock</li><li><br>Next-locking keying为了解决Phantom Problem幻读问题</li><li><br>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li><br>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li><br>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ul></p>
<h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h2 id="1、限定数据的范围"><a href="#1、限定数据的范围" class="headerlink" title="1、限定数据的范围"></a>1、限定数据的范围</h2><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h2 id="2、读-写分离"><a href="#2、读-写分离" class="headerlink" title="2、读/写分离"></a>2、读/写分离</h2><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h2 id="3、垂直分区"><a href="#3、垂直分区" class="headerlink" title="3、垂直分区"></a>3、垂直分区</h2><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<ul><li>
垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li>
垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li></ul>

<h2 id="4、水平分区"><a href="#4、水平分区" class="headerlink" title="4、水平分区"></a>4、水平分区</h2><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p>
<p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul><li>
客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>
中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul>]]></content>
  </entry>
  <entry>
    <title>GPU硬件加速</title>
    <url>/2021/05/07/brower/gpu-acc/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://dev.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>
</blockquote>
<blockquote>
<p>注： 某些类名可能已更改（例如，RenderObject到LayoutObject，RenderLayer到PaintLayer）。</p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提供了在Chrome中实现硬件加速合成的背景和细节。</p>
<p>简介：为什么要进行硬件合成？</p>
<p>传统上，web浏览器完全依赖CPU来呈现网页内容。现在，即使是最小的设备，也有能力的gpu成为不可或缺的一部分，人们的注意力已经转向寻找更有效地使用这种底层硬件的方法，以实现更好的性能和节能。使用GPU合成网页的内容可以大大提高速度。</p>
<p>硬件合成的好处有三种：</p>
<blockquote>
<ul>
<li>在涉及大量像素的绘图和合成操作中，在GPU上合成页面层可以获得比CPU更好的效率（无论是在速度还是功耗方面）。硬件是专门为这些类型的工作负载设计的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>GPU上已有的内容（如加速视频、Canvas2D或WebGL）不需要昂贵的回读。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>CPU与GPU之间的并行性，可以同时运行，创建高效的图形流水线。</li>
</ul>
</blockquote>
<p>最后，在我们开始之前，有一个很大的免责声明：Chrome图形堆栈在过去几年中已经有了实质性的发展。本文档将重点介绍编写时最先进的体系结构，这不是所有平台上的装运配置。有关在何处启用的功能的详细信息，<a href="http://dev.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/gpu-architecture-roadmap">请参阅GPU体系结构路线图</a>。</p>
<h1 id="第1部分：Blink渲染基础知识"><a href="#第1部分：Blink渲染基础知识" class="headerlink" title="第1部分：Blink渲染基础知识"></a>第1部分：Blink渲染基础知识</h1><p>Blink渲染引擎的源代码庞大、复杂，而且几乎没有文档记录。为了理解GPU加速在Chrome中的工作原理，首先了解Blink如何呈现页面的基本构建块是很重要的。</p>
<h2 id="节点和DOM树"><a href="#节点和DOM树" class="headerlink" title="节点和DOM树"></a>节点和DOM树</h2><p>在Blink中，web页面的内容在内部存储为一个名为DOM树的节点对象树。页面上的每个HTML元素以及元素之间出现的文本都与一个节点相关联。DOM树的顶层节点始终是文档节点。</p>
<h2 id="从节点到渲染对象"><a href="#从节点到渲染对象" class="headerlink" title="从节点到渲染对象"></a>从节点到渲染对象</h2><p>DOM树中产生可视输出的每个节点都有一个对应的RenderObject。RenderObjects存储在并行树结构中，称为渲染树。RenderObject知道如何在显示曲面上绘制节点的内容。它通过向GraphicsContext发出必要的draw调用来实现。GraphicsContext负责将像素写入位图，最终显示在屏幕上。在Chrome中，GraphicsContext包装了我们的2D绘图库Skia。</p>
<p>传统上，大多数GraphicsContext调用都变成了对SkCanvas或SkPlatformCanvas的调用，即立即绘制到软件位图中（有关Chrome如何使用Skia的旧模型的更多详细信息，<a href="http://www.chromium.org/developers/design-documents/graphics-and-skia">请参阅本文档</a>）。但是为了将绘画从主线移开（本文后面将详细介绍），这些命令现在被记录到一个SkPicture中。SkPicture是一种可串行化的数据结构，它可以捕获命令，然后在以后回放命令，类似于显示列表。</p>
<h2 id="从渲染对象到渲染层"><a href="#从渲染对象到渲染层" class="headerlink" title="从渲染对象到渲染层"></a>从渲染对象到渲染层</h2><p>每个RenderObject都通过祖先RenderObject直接或间接地与RenderLayer关联。</p>
<p>共享相同坐标空间（例如受相同CSS变换影响）的渲染对象通常属于同一渲染层。RenderLayers存在，以便以正确的顺序合成页面元素，以正确显示重叠内容、半透明元素等。有许多条件将触发为特定RenderObject创建新的RenderLayer，如RenderBoxModelObject:：RequireReslayer（）中定义的，并覆盖某些派生类。RenderObject的常见情况，保证创建RenderLayer：</p>
<blockquote>
<ul>
<li>它是页面的根对象</li>
<li>它具有显式CSS位置属性（相对、绝对或转换）</li>
<li>它是透明的</li>
<li>具有溢出、alpha遮罩或反射</li>
<li>有CSS过滤器</li>
<li>对应于具有三维（WebGL）上下文或加速二维上下文的 canvas 元素</li>
<li>对应于 video 元素</li>
</ul>
</blockquote>
<blockquote>
<p>注意，RenderObjects和RenderLayers之间没有一对一的对应关系。特定的RenderObject与为其创建的RenderLayer关联，如果有一个，或者与具有一个的第一个祖先的RenderLayer关联。</p>
</blockquote>
<p>RenderLayers也构成树层次结构。根节点是与页面中根元素相对应的RenderLayer，每个节点的子节点都是可视化包含在父层中的层。每个渲染层的子层都被保存为两个排序列表，它们都按升序排序，其中NegzordList包含负z索引的子层（因此，位于当前层下的层）和PosZoorderList包含具有正z索引的子层（高于当前层的层）。</p>
<h2 id="从渲染层到图形层"><a href="#从渲染层到图形层" class="headerlink" title="从渲染层到图形层"></a>从渲染层到图形层</h2><p>为了使用合成器，一些（但不是全部）渲染层会获得自己的背衬面（具有自己背衬面的层被广泛地称为合成层）。每个RenderLayer要么有自己的GraphicsLayer（如果是合成层），要么使用它的第一个祖先的GraphicsLayer。这类似于RenderObject与RenderLayers的关系。</p>
<p>每个GraphicsLayer都有一个GraphicsContext供相关的renderlayer绘制。在随后的合成过程中，合成器最终负责将GraphicsContexts的位图输出合并成最终的屏幕图像。</p>
<p>虽然理论上每个渲染层都可以将自己绘制到一个单独的背衬面中，但实际上这在内存方面可能是相当浪费的（尤其是VRAM）。在当前的Blink实现中，RenderLayer要获得自己的合成层，必须满足以下条件之一（请参见CompositingReasons.h）：</p>
<blockquote>
<ul>
<li>层具有三维或透视变换CSS属性</li>
<li>层由使用加速视频解码的 video 元素使用</li>
<li>层由具有3D上下文或加速2D上下文的 canvas 元素使用</li>
<li>层用于合成插件</li>
<li>层使用CSS动画作为其不透明度，或使用动画webkit变换</li>
<li>层使用加速CSS过滤器</li>
<li>层的子体是合成层</li>
<li>层有一个具有较低z索引的同级，该同级有一个合成层（换句话说，该层与合成层重叠，应在其上渲染）</li>
</ul>
</blockquote>
<h2 id="层压缩"><a href="#层压缩" class="headerlink" title="层压缩"></a>层压缩</h2><p>没有规则就没有例外。如上所述，GraphicsLayer在内存和其他资源方面可能成本高昂（例如，一些关键操作的CPU时间复杂度与GraphicsLayer树的大小成正比）。可以为RenderLayer创建许多附加层，这些层将RenderLayer与其自己的背衬面重叠，这可能会非常昂贵。</p>
<p>我们称之为内在合成原因（例如，层上有三维变换）“直接”合成原因。当许多元素位于具有直接合成原因的层的顶部时，为了防止“层爆炸”，Blink使用多个与直接合成原因RenderLayer重叠的RenderLayer，并将它们“挤压”到单个备份存储中。这样可以防止重叠导致的层爆炸。更详细的激励层挤压可以在本演示中找到，更详细的代码之间的渲染层和合成层可以在本演示中找到；虽然该准则在2014年发生了重大变化，但截至2014年1月左右，这两个准则都是现行的。</p>
<h2 id="从GraphicsLayers到WebLayers再到CC-Layers"><a href="#从GraphicsLayers到WebLayers再到CC-Layers" class="headerlink" title="从GraphicsLayers到WebLayers再到CC Layers"></a>从GraphicsLayers到WebLayers再到CC Layers</h2><p>在我们开始Chrome的compositor实现之前，只需要再进行几层抽象！Graphicslayer可以通过一个或多个WebLayers来表示他们的内容。这些是WebKit端口需要实现的接口；请参阅Blink的public/platform目录以获取诸如WebContentsLayer.h或WebScrollbarLayer.h之类的接口。Chrome的实现在src/webkit/renderer/compositor\u绑定中，这些绑定使用Chrome compositor层类型实现抽象Web*层接口。</p>
<h2 id="Putting-it-Together：合成"><a href="#Putting-it-Together：合成" class="headerlink" title="Putting it Together：合成"></a>Putting it Together：合成</h2><p>在概念上有四种并行树结构，它们的渲染目的略有不同：</p>
<blockquote>
<ul>
<li>DOM树，这是我们的基本模型</li>
<li>RenderObject树，它与DOM树的可见节点有1:1的映射。RenderObjects知道如何绘制相应的DOM节点。</li>
<li>RenderLayer树，由映射到RenderObject树上RenderObject的RenderLayer组成。映射是多对一的，因为每个RenderObject要么与自己的RenderLayer关联，要么与拥有RenderLayer的第一个祖先的RenderLayer关联。RenderLayer树保留层之间的z顺序。</li>
<li>GraphicsLayer树，将GraphicsLayer映射为一对多renderlayer。</li>
</ul>
</blockquote>
<p>每个GraphicsLayer都有用Chrome实现的WebLayers和Chrome合成层。合成器知道如何对这些最后的“cc层”（cc=Chrome合成器）进行操作。</p>
<p>从这里开始，在本文档中“layer”将指的是一个通用的cc层，因为对于硬件合成来说，这些是最有趣的——但是不要被愚弄了，在其他地方，当有人说“layer”时，他们可能指的是上面的任何构造！</p>
<p><img src="/hide/tree.png"></p>
<p>现在我们（简短地）介绍了Blink中将DOM链接到合成器的数据结构，我们准备认真研究合成器本身。</p>
<h1 id="第2部分：合成器"><a href="#第2部分：合成器" class="headerlink" title="第2部分：合成器"></a>第2部分：合成器</h1><p>Chrome的compositor是一个用于管理GraphicsLayer树和协调框架生命周期的软件库。它的代码位于src/cc目录中，在Blink之外。</p>
<h2 id="介绍合成器"><a href="#介绍合成器" class="headerlink" title="介绍合成器"></a>介绍合成器</h2><p>回想一下，渲染分为两个阶段：首先绘制，然后合成。这允许合成器在每个合成层的基础上执行额外的工作。例如，合成器负责在合成每个合成层的位图之前，对其应用必要的变换（由层的CSS变换属性指定）。此外，由于层的绘制与合成分离，因此使这些层之一无效只会导致单独重新绘制该层的内容并重新组合。</p>
<p>每次浏览器需要创建一个新的框架时，合成器都会进行绘制。注意这个（令人困惑的）术语区别：<br>drawing是将层合并到最终屏幕图像中的合成器；<br>painting是图层背景的填充（带有软件光栅化的位图；硬件光栅化中的纹理）。</p>
<h2 id="GPU在哪里？"><a href="#GPU在哪里？" class="headerlink" title="GPU在哪里？"></a>GPU在哪里？</h2><p>那么GPU是如何发挥作用的呢？合成器可以使用GPU执行其drawing步骤。这与旧的软件渲染模型有很大的不同，在旧的软件渲染模型中，渲染器进程（通过IPC和共享内存）将带有页面内容的位图传递给浏览器进程进行显示（有关如何工作的更多信息，请参阅“附录F： 旧的软件渲染路径”附录）。</p>
<p>在硬件加速架构中，合成是通过调用特定于平台的3D api（Windows上的D3D；其他地方）。渲染器的合成器基本上是使用GPU将页面的矩形区域（即所有那些合成层，根据层树的变换层次相对于视口定位）绘制成单个位图，这是最终的页面图像。</p>
<h1 id="架构插曲：GPU进程"><a href="#架构插曲：GPU进程" class="headerlink" title="架构插曲：GPU进程"></a>架构插曲：GPU进程</h1><p>在我们进一步研究合成器生成的GPU命令之前，了解渲染器进程如何向GPU发出任何命令非常重要。在Chrome的多进程模型中，我们有一个专门的进程来完成这个任务：GPU进程。GPU进程的存在主要是出于安全原因。请注意，Android是一个例外，Chrome使用进程内GPU实现，在浏览器进程中作为线程运行。另外，Android上的GPU线程的行为方式与其他平台上的GPU进程相同。</p>
<p>由于沙盒的限制，渲染器进程（包含Blink和cc的实例）不能直接调用OS（GL/D3D）提供的3D api。因此，我们使用一个单独的进程来访问设备。我们称这个进程为GPU进程。GPU进程是专门设计用来提供从渲染器沙盒或更严格的本地客户端“jail”中访问系统的3D api的。它通过客户机-服务器模型工作，如下所示：</p>
<blockquote>
<ul>
<li> 客户机（在呈现程序中或NaCl模块中运行的代码）不是直接向系统api发出调用，而是将它们序列化并将它们放入一个环形缓冲区（命令缓冲区）中，该缓冲区位于自身和服务器进程之间共享的内存中。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>服务器（在限制较少的沙盒中运行的GPU进程，允许访问平台的3D api）从共享内存中提取序列化命令，解析它们并执行适当的图形调用。</li>
</ul>
</blockquote>
<p><img src="/hide/gpu2.png"></p>
<h2 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h2><p>GPU进程接受的命令在GL ES 2.0API之后进行密切的模式化（例如，有一个与glClear、一个到GLDRAWARRARY等对应的命令）。由于大多数GL调用没有返回值，所以客户端和服务器可以以异步方式工作，从而使性能开销相当低。客户端和服务器之间的任何必要同步，例如客户端通知服务器需要执行其他工作，都通过IPC机制进行处理。</p>
<p>从客户机的角度来看，应用程序可以选择直接将命令写入命令缓冲区，或者通过我们提供的客户端库使用GL ES 2.0API，该库处理后台序列化。合成器和WebGL当前都使用GL ES客户端库以方便。在服务器端，通过命令缓冲区接收到的命令将转换为通过角度将调用转换为桌面OpenGL或Direct3D。</p>
<h2 id="资源共享和同步"><a href="#资源共享和同步" class="headerlink" title="资源共享和同步"></a>资源共享和同步</h2><p>除了为命令缓冲区提供存储外，Chrome还使用共享内存在客户端和服务器之间传递更大的资源，例如纹理位图、顶点阵列等。有关命令格式和数据传输的详细信息，<a href="http://www.chromium.org/developers/design-documents/gpu-command-buffer">请参阅命令缓冲区文档</a>。</p>
<p>另一个结构称为mailbox，提供了一种方法，可以在命令缓冲区之间共享纹理并管理它们的生命周期。mailbox是一个简单的字符串标识符，它可以附加（消耗）到任何命令缓冲区的本地纹理id，然后通过该纹理id别名访问。以这种方式附着的每个纹理id都会在底层真实纹理上保留一个参照，一旦通过删除局部纹理id释放所有参照，则真实纹理也将被销毁。</p>
<p>同步点用于在希望通过mailboxes共享纹理的命令缓冲区之间提供非阻塞同步。在命令缓冲区a上插入同步点，然后在命令缓冲区B上的同步点上“等待”，确保在B上插入的命令不会在插入同步点之前运行在a上的命令。</p>
<h2 id="命令缓冲区多路复用"><a href="#命令缓冲区多路复用" class="headerlink" title="命令缓冲区多路复用"></a>命令缓冲区多路复用</h2><p>目前，Chrome对每个浏览器实例使用一个GPU进程，服务于所有渲染器进程和任何插件进程的请求。GPU进程可以在多个命令缓冲区之间进行多路复用，每个命令缓冲区都与自己的呈现上下文相关联。</p>
<p>每个渲染器可以有多个GL源，例如WebGL画布元素直接创建GL命令流。其内容直接在GPU上创建的层的合成工作如下：它们不是直接渲染到backbuffer中，而是渲染到纹理（使用帧缓冲区对象），合成器上下文在渲染GraphicsLayer时获取并使用该纹理。需要注意的是，为了使合成器的GL上下文能够访问由屏幕外GL上下文（即用于其他graphicslayer的fbo的GL上下文）生成的纹理，GPU进程使用的所有GL上下文都会被创建，以便它们共享资源。</p>
<p>生成的体系结构如下所示：</p>
<p><img src="/hide/gpu3.png"></p>
<h2 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h2><p>GPU进程体系结构提供了几个好处，包括：</p>
<blockquote>
<ul>
<li>安全性：大部分渲染逻辑仍保留在沙盒渲染器进程中，对平台3D api的访问仅限于GPU进程。</li>
<li>健壮性：GPU进程崩溃（例如，由于错误的驱动程序）不会导致浏览器关闭。</li>
<li>一致性：在opengles2.0上标准化作为浏览器的渲染API，不管平台是什么，都允许在Chrome的所有OS端口上使用一个更易于维护的代码库。</li>
<li>并行性：渲染器可以快速地将命令发布到命令缓冲区，并返回到CPU密集型的渲染活动，让GPU进程来处理它们。多亏了这个流水线，我们可以在多核机器上很好地利用这两个进程以及GPU和CPU。</li>
</ul>
</blockquote>
<p>有了这个解释，我们可以回到解释GL命令和资源是如何由渲染器的合成器生成的。</p>
<h1 id="第3部分：线程合成器"><a href="#第3部分：线程合成器" class="headerlink" title="第3部分：线程合成器"></a>第3部分：线程合成器</h1><p>合成器是在gles2.0客户端库之上实现的，该客户端库将图形调用代理到GPU进程（使用上面解释的方法）。当一个页面通过合成器呈现时，它的所有像素都被绘制出来（记住，绘制！=绘画）直接进入窗口的backbuffer通过GPU进程。</p>
<p>合成器的体系结构随着时间的推移而发展：最初它位于渲染器的主线程中，然后被移动到自己的线程（所谓的合成器线程），然后在绘制发生时承担额外的协调责任（所谓的impl-side绘制）。本文件将侧重于最新版本；请参阅GPU架构路线图，了解旧版本可能仍在使用的位置。</p>
<p>从理论上讲，线程合成器的基本任务是从主线程获取足够的信息，以独立地生成帧来响应未来的用户输入，即使主线程很忙并且不能请求额外的数据。实际上，这目前意味着它将为视口当前位置周围区域中的层区域制作cc层树和SkPicture记录的副本。</p>
<h2 id="Recording-从Blink的角度绘画"><a href="#Recording-从Blink的角度绘画" class="headerlink" title="Recording:从Blink的角度绘画"></a>Recording:从Blink的角度绘画</h2><p>感兴趣区域是在视口周围记录图片的区域。当DOM发生更改时（例如，由于某些元素的样式现在与前一个主线程框架不同并且已失效），Blink会将感兴趣区域内失效层的区域绘制到SkPicture-backed GraphicsContext中。这实际上并不产生新的像素，而是产生产生这些新像素所需的Skia命令的显示列表。此显示列表稍后将由合成器自行决定用于生成新像素。</p>
<h2 id="commit：切换到合成器线程"><a href="#commit：切换到合成器线程" class="headerlink" title="commit：切换到合成器线程"></a>commit：切换到合成器线程</h2><p>线程合成器的关键属性是对主线程状态副本的操作，因此它可以生成帧，而无需向主线程请求任何内容。因此，线程合成器有两个面：主线程面和（名称不好的）“impl”面，这是合成器线程的一半。主线程有一个LayerTreeHost，它是层树的副本，impl线程有一个LayerTreeHostImpl，它是层树的副本。自始至终都遵循类似的命名约定。</p>
<p>从概念上讲，这两层树是完全独立的，合成器（impl）线程的副本可以用来生成帧，而不需要与主线程进行任何交互。这意味着主线程可以忙于运行JavaScript，而合成器仍然可以在GPU上重新绘制先前提交的内容，而不会中断。</p>
<p>为了产生新帧，合成器线程需要知道它应该如何修改它的状态（例如，更新层变换以响应滚动之类的事件）。因此，一些输入事件（如滚动）首先从浏览器进程转发到合成器，然后从合成器转发到渲染器主线程。通过控制输入和输出，线程合成器可以保证对用户输入的视觉响应。除了滚动之外，合成器还可以执行任何其他页面更新，而不需要请求Blink重新绘制任何内容。到目前为止，CSS动画和CSS过滤器是其他主要的合成器驱动的页面更新。</p>
<p>两层树由一系列称为commit的消息保持同步，这些消息由合成器的调度程序（在cc/trees/thread\u proxy.cc中）介导。commit将主线程的世界状态传输到合成器线程（包括更新的层树、任何新的SkPicture记录等），阻塞主线程以便可以进行此同步。它是主线程参与特定帧的生产的最后一步。</p>
<p>在自己的线程中运行合成器允许合成器的层树副本在不涉及主线程的情况下更新层转换层次结构，但是主线程最终也需要滚动偏移信息（例如，JavaScript可以知道视口滚动到的位置）。因此，commit还负责将任何合成器线程层树更新应用于主线程的树和一些其他任务。</p>
<p>有趣的是，这种体系结构是JavaScript touch事件处理程序阻止合成滚动的原因，而滚动事件处理程序却没有。JavaScript可以在touch事件上调用preventDefault（），但不能在scroll事件上调用。因此，如果合成器不首先询问JavaScript（在主线程上运行）是否要取消传入的touch事件，就无法滚动页面。另一方面，滚动事件是无法阻止的，并且是异步传递给JavaScript的；因此，无论主线程是否立即处理滚动事件，合成器线程都可以立即开始滚动。</p>
<h2 id="树激活"><a href="#树激活" class="headerlink" title="树激活"></a>树激活</h2><p>当合成器线程从主线程获得一个新的图层树时，它会检查新的树以查看哪些区域无效，并重新光栅化这些图层。在此期间，活动树仍然是合成器线程以前的旧层树，挂起树是内容正在光栅化的新层树。</p>
<p>为保持显示内容的一致性，只有当其可见（即在视口中）高分辨率内容完全光栅化时，挂起树才会激活。从当前活动树交换到现在准备就绪的挂起树称为激活。等待光栅化内容就绪的净效果意味着用户通常至少可以看到一些内容，但这些内容可能已经过时。如果没有可用的内容，Chrome将显示一个空白或棋盘格图案，而使用GL着色器。</p>
<p>需要注意的是，即使是活动树的光栅区域也可以滚动过去，因为Chrome只记录感兴趣区域内的图层区域的SkPictures。如果用户滚动到一个未记录的区域，合成器将要求主线程记录和提交额外的内容，但是如果不能记录、提交和光栅化新内容以及时激活，用户将滚动到棋盘区域。</p>
<p>为了减少棋盘格，Chrome还可以在高分辨率之前快速为挂起的树光栅化低分辨率内容。如果只有低分辨率内容可用于视口的挂起树比当前屏幕上的内容更好（例如，传出的活动树对于当前视口根本没有光栅化内容），则会激活该树。tile管理器（将在下一节中介绍）决定何时光栅化哪些内容。</p>
<p>此体系结构将光栅化与帧生产流的其余部分隔离开来。它支持多种技术来提高图形系统的响应能力。图像解码和调整大小操作是异步执行的，这是以前在绘制期间执行的昂贵的主线程操作。本文前面提到的异步纹理上传系统也与impl side painting一起介绍。</p>
<h2 id="平铺"><a href="#平铺" class="headerlink" title="平铺"></a>平铺</h2><p>将页面上的每个层的整个光栅化是浪费CPU时间（用于绘制操作）和内存（RAM用于任何软件位图，该层需要；纹理存储的VRAM）。合成器不必对整个页面进行光栅化，而是将大多数web内容层拆分为平铺，并在每个平铺基础上对层进行栅格化。</p>
<p>Web内容层平铺的优先级由许多因素启发式地排序，包括该平铺与视口的接近程度及其在屏幕上的估计时间。然后，GPU内存根据其优先级分配给瓷砖，并从SkPicture录制中擦除瓷砖，以按优先级顺序填充可用内存预算。目前（2014年5月）正在重新加工瓷砖优先级的具体方法；有关详细信息，请参阅“瓷砖优先级设计文档”。</p>
<p>注意，对于内容已经驻留在GPU上的图层类型（例如加速视频或WebGL），不需要平铺（对于好奇的情况，图层类型是在cc/layers目录中实现的）。</p>
<h2 id="光栅化：从cc-Skia的角度看绘画"><a href="#光栅化：从cc-Skia的角度看绘画" class="headerlink" title="光栅化：从cc/Skia的角度看绘画"></a>光栅化：从cc/Skia的角度看绘画</h2><p>合成线程上的SkPicture记录可以通过两种方式之一转换为GPU上的位图：由Skia的软件光栅化器绘制成位图并作为纹理上传到GPU，或者由Skia的OpenGL后端（Ganesh）直接绘制到GPU上的纹理。</p>
<p>对于Ganesh光栅化层，SkPicture将与Ganesh一起播放，并通过命令缓冲区将生成的GL命令流传递给GPU进程。当合成器决定对任何瓷砖进行光栅化时，GL命令生成立即发生，并且将瓷砖捆绑在一起，以避免在GPU上进行平铺光栅化的开销。有关该方法的更多信息，请参阅GPU加速光栅化设计文档。</p>
<p>对于软件光栅化层，绘制目标是渲染器进程和GPU进程之间共享的内存中的位图。位图通过上述资源传输机制传递给GPU过程。由于软件光栅化可能非常昂贵，所以这种光栅化不会发生在compositor线程本身（在其中它可以阻止为活动树绘制新框架），而是在compositor光栅工作线程中。多光栅工作线程可以用来加速软件光栅化；每个工作人员都从优先级的平铺队列前面提取。已完成的瓷砖将作为纹理上载到GPU。</p>
<p>位图纹理上传是内存带宽受限平台上的一个不平凡的瓶颈。这妨碍了软件光栅化层的性能，并继续妨碍硬件光栅化器所需位图的上传（例如，对于图像数据或CPU渲染的掩码）。Chrome过去有各种不同的纹理上传机制，但最成功的是一个异步上传器，它在GPU进程的工作线程中执行上传（或者在浏览器进程中的附加线程，在Android的情况下）。这就防止了其他操作不得不阻止可能长时间的纹理上载。</p>
<p>一种完全消除纹理上传问题的方法是在暴露此类原语的统一内存体系结构设备上使用CPU和GPU共享的零拷贝缓冲区。Chrome目前不使用此结构，但将来可能使用；有关详细信息，请参阅GpuMemoryBuffer设计文档。</p>
<p>另外，在使用GPU进行光栅化时，还可以采取第三种方法来绘制内容：在绘制时将每个层的内容直接光栅化到backbuffer中，而不是事先将其绘制为纹理。这具有节省内存（无中间纹理）和一些性能改进（在绘图时将纹理副本保存到backbuffer）的优点，但当纹理有效缓存层内容时（因为现在需要重新绘制每个帧）时，性能会降低。“直接到backbuffer”或“direct Ganesh”模式在2014年5月之前未实现，但有关其他相关考虑，请参阅GPU光栅化设计文件。</p>
<p><img src="/hide/gpu4.png"></p>
<h2 id="在GPU、平铺和四边形上绘制"><a href="#在GPU、平铺和四边形上绘制" class="headerlink" title="在GPU、平铺和四边形上绘制"></a>在GPU、平铺和四边形上绘制</h2><p>一旦填充了所有的纹理，呈现页面的内容就只需对层层次结构进行深度优先遍历，然后发出GL命令，将每个层的纹理绘制到帧缓冲区中。</p>
<p>在屏幕上绘制一个图层实际上就是绘制它的每个瓷砖。瓷砖表示为四边形（简单的4角，即矩形；请参见用给定层内容的子区域填充绘制的cc/quads。合成器生成四边形和一组渲染过程（渲染过程是包含四边形列表的简单数据结构）。用于绘制的实际GL命令是与四边形分开生成的（请参见cc/output/GL\u renderer.cc）。这是从quad实现中抽象出来的，因此可以为合成器编写非GL后端（唯一重要的非GL实现是软件合成器，稍后将介绍）。绘制四边形大致相当于为每个渲染过程设置视口，然后在渲染过程的四边形列表中为每个四边形设置变换并绘制。</p>
<p>请注意，首先执行遍历深度可确保cc层的正确z顺序，并且与该cc层关联的潜在多个RenderLayers的z顺序在绘制层的RenderObjects时通过RenderObjectTree遍历的顺序提前得到保证。</p>
<h2 id="可变比例因子"><a href="#可变比例因子" class="headerlink" title="可变比例因子"></a>可变比例因子</h2><p>impl-side painting的一个显著优点是合成器可以以任意比例因子重新呈现现有的SkPictures。这在两种主要情况下非常有用：收缩到缩放和在快速翻转期间生成低分辨率的平铺。</p>
<p>合成器将截获用于收缩/缩放的输入事件，并在GPU上适当缩放已光栅化的分幅，但在发生这种情况时，它也会以更合适的目标分辨率重新启动。每当新的磁贴准备就绪（光栅化和上传）时，可以通过激活挂起的树来交换它们，从而提高收缩/缩放屏幕的分辨率（即使收缩尚未完成）。</p>
<p>在软件中进行光栅化时，合成器还尝试快速生成低分辨率的瓷砖（通常绘制成本要低得多），如果高分辨率瓷砖还没有准备好，则在滚动过程中显示它们。这就是为什么有些页面在快速滚动时看起来很模糊的原因——合成器在屏幕上显示低分辨率的平铺，而高分辨率的平铺是光栅。</p>
<h1 id="附录A：浏览器合成"><a href="#附录A：浏览器合成" class="headerlink" title="附录A：浏览器合成"></a>附录A：浏览器合成</h1><p>本文档主要介绍用于显示web内容的呈现程序过程中的活动。不过，Chrome的UI也使用了相同的底层合成基础设施，值得注意的是浏览器的参与。</p>
<h2 id="浏览器合成-Aura-Ash"><a href="#浏览器合成-Aura-Ash" class="headerlink" title="浏览器合成 Aura/Ash"></a>浏览器合成 Aura/Ash</h2><p>Chrome&amp;ChromeOS有一个由Ash和Aura组合而成的复合窗口管理器（Ash是窗口管理器本身，而Aura提供了窗口和输入事件等基本原语）。窗口管理器Ash只在ChromeOS和Win8的Metro模式下使用；在Linux和非Metro Windows上，Aura Windows包装本机操作系统Windows。Aura使用cc来合成Aura窗口，而Views使用cc-through-Aura来合成窗口浏览器UI中的不同元素。大多数光环窗口只有一层，尽管有些视图也可以弹出到自己的层中。这些镜像了Blink使用cc合成web内容层的方式。有关Aura的更多信息，请参阅Aura设计文档索引。</p>
<h2 id="Ubercompositor"><a href="#Ubercompositor" class="headerlink" title="Übercompositor"></a>Übercompositor</h2><p>最初，Blink会将渲染器的所有层（即web内容区域的层）合成为一个纹理，然后该纹理将通过浏览器进程中cc的第二个副本与浏览器UI的其余层合成。这很简单，但有一个主要的缺点，那就是在每一帧中都会产生一个额外的视口大小副本（因为内容层首先被合成为一个纹理，然后在浏览器合成器的绘制过程中该纹理会被复制）。</p>
<p>这个Übercompositor在一个绘图过程中执行浏览器UI和渲染器层的所有合成。渲染器不是自己绘制四边形，而是将所有四边形都交给浏览器，在浏览器合成器的层树中，它们被绘制在DelegatedRenderLayer的位置。有关此主题的更多详细信息，请参阅üBER合成器设计文件。</p>
<h1 id="附录B：软件合成器"><a href="#附录B：软件合成器" class="headerlink" title="附录B：软件合成器"></a>附录B：软件合成器</h1><p>在某些情况下，硬件合成是不可行的，例如，如果设备的图形驱动程序被封锁，或者设备完全没有GPU。对于这些情况，是GL渲染器的替代实现，称为softwarerender（参见src/cc/output/software\u renderer）。当OutputSurface（参见src/cc/output/output\u surface）ContextProvider不可用时，许多其他地方（RasterWorkerPool、ResourceProvider等）也需要自己的软件回退。总而言之，在不使用GPU的情况下运行时，Chrome在软件方面的功能大致相同，但在实现上有一些关键的区别：</p>
<blockquote>
<ul>
<li>它没有将四边形作为纹理上传到GPU，而是将它们留在系统内存中，并作为共享内存来回穿梭</li>
<li>软件渲染器没有使用GL将内容纹理分片复制到backbuffer中，而是使用Skia的软件光栅化器来执行复制（并执行任何必要的矩阵运算和剪裁）</li>
</ul>
</blockquote>
<p>这意味着像3D转换和复合CSS过滤器这样的操作“只适用于”软件渲染器，但本质上依赖GL（例如WebGL）的web内容却不适用。对于WebGL的软件渲染，Chrome使用SwiftShader，一个软件GL光栅化器。</p>
<h1 id="附录C：Grafix-4-N00bs词汇表"><a href="#附录C：Grafix-4-N00bs词汇表" class="headerlink" title="附录C：Grafix 4 N00bs词汇表"></a>附录C：Grafix 4 N00bs词汇表</h1><p>bitmap：内存中像素值的缓冲区（主存储器或GPU的视频RAM）</p>
<p>texture：一个位图，用于GPU上的三维模型 —— 纹理</p>
<p>texture quad：应用于非常简单模型的纹理：四点多边形，例如矩形。当您只想将纹理显示为平面矩形曲面时非常有用，可能会转换（二维或三维），这正是我们在合成时所做的。</p>
<p>invalidation：标记为脏的文档区域，通常意味着需要重新打印。样式系统有一个类似的无效概念，因此样式也可以被玷污，但通常这指的是需要重新绘制的区域。</p>
<p>painting：在我们的术语中，渲染阶段，RenderObjects调用GraphicsContext API以使自己可视化表示</p>
<p>rasterization：在我们的术语中，渲染的阶段，位图备份渲染层是填充的。这可能会立即发生，因为GraphicsContext调用是由RenderObjects进行的，或者如果我们使用SkPicture记录进行绘制和SkPicture回放进行光栅化，则可能在稍后发生。</p>
<p>compositing：按照我们的说法，渲染阶段，将RenderLayer的纹理合并为最终屏幕图像</p>
<p>drawing：在我们的术语中，渲染的阶段，实际上把像素放在屏幕上（即将最终的屏幕图像放到屏幕上）。</p>
<p>backbuffer：当双缓冲时，呈现到的屏幕缓冲区，而不是当前显示的缓冲区</p>
<p>frontbuffer：当双缓冲时，当前显示的屏幕缓冲区，而不是当前呈现到的屏幕缓冲区</p>
<p>swapbuffers：切换前缓冲区和后缓冲区</p>
<p>Frame Buffer Object：OpenGL术语，用于纹理，可以渲染到屏幕外，就像它是一个普通屏幕缓冲区（例如backbuffer）。对我们很有用，因为我们希望能够渲染到纹理，然后复合这些纹理；有了FBO，我们可以假装给WebGL自己的框架，它不必担心页面上发生的任何其他事情。</p>
<p>damage：屏幕的区域，它被用户交互或编程更改（例如JavaScript更改样式）“污染”。这是更新时需要重新绘制的屏幕区域。</p>
<p>retained mode：图形系统维护要渲染对象的完整模型的渲染方法。web平台保留在DOM是模型的状态，平台（即浏览器）跟踪DOM的状态，其API（即JavaScript对DOM的访问）可以用于修改或查询其当前状态，但浏览器可以随时从模型呈现，而不需要JavaScript的任何指令。</p>
<p>immediate mode：一种渲染方法，图形系统不跟踪整个场景状态，而是立即执行给它的任何命令，并忘记它们。要重新绘制整个场景，需要重新发出所有命令。Direct3D是即时模式，就像Canvas2D一样。</p>
<p>context virtualization（上下文虚拟化）：GPU进程不一定为给定的命令缓冲区客户端创建实际的驱动程序级GL上下文。它还可以为多个客户端提供共享的真实上下文，并在解析其GL命令时将GL状态恢复到给定客户端的预期状态——我们将此阴影状态称为“虚拟上下文”。这在Android上用于解决某些驱动程序的错误和性能问题（GL上下文切换慢、FBO跨多上下文呈现的同步问题以及使用共享组时崩溃）。Chrome通过GPU阻止列表文件在驱动程序子集上启用上下文虚拟化。</p>
<h1 id="附录D：相关标志"><a href="#附录D：相关标志" class="headerlink" title="附录D：相关标志"></a>附录D：相关标志</h1><p>如果您对合成层的结构感兴趣，请使用“显示合成层边界”标志。您也可以尝试“线程合成”、“线程动画”。全部提供about:flags.</p>
<p>如前所述，WebKit（和Chromium）中的加速合成只有在某些类型的内容出现在页面上时才起作用。强制页面切换到合成器的一个简单技巧是提供一个-webkit-transform:translateZ（0）页中的元素。</p>
<h1 id="附录E：调试合成层"><a href="#附录E：调试合成层" class="headerlink" title="附录E：调试合成层"></a>附录E：调试合成层</h1><p>使用–show composited layer borders标志将显示图层周围的边框，并使用颜色显示有关图层或图层中的平铺的信息。</p>
<p>这些颜色有时会发生变化，以前的列表很快就会过时，因此请参阅src/cc/debug/debug\u colors.cc中的注释以了解当前的颜色列表及其含义。</p>
<h1 id="附录F：旧的软件渲染路径"><a href="#附录F：旧的软件渲染路径" class="headerlink" title="附录F：旧的软件渲染路径"></a>附录F：旧的软件渲染路径</h1><p>本节将作为WebKit预合成的原始设计的一部分，供后人参考。这条路到2014年5月仍在徘徊，但很快将彻底被移除。</p>
<p>WebKit从根层开始遍历RenderLayer层次结构，从根本上呈现网页。WebKit代码库包含两个不同的代码路径，用于呈现页面内容，软件路径和硬件加速路径。软件路径是传统的模型。</p>
<p>在软件路径中，通过从后到前依次绘制所有渲染层来渲染页面。RenderLayer层次结构从根开始递归遍历，大部分工作都在RenderLayer:：paintLayer（）中完成，该过程执行以下基本步骤（此处简化步骤列表以明确）：</p>
<p>确定层是否与早期输出的损坏矩形相交。</p>
<p>递归地为NegzordList中的层调用paintLayer（）来绘制此层下面的层。</p>
<p>要求与此渲染层关联的渲染对象绘制自己。</p>
<p>这是通过递归的RenderObject树从创建层的RenderObject开始的。每当发现与不同渲染层关联的RenderObject时，遍历停止。</p>
<p>通过调用posZOrderList中的图层的paintLayer（）递归地绘制此层之上的层。</p>
<p>在这种模式下，RenderObjects通过向单个共享GraphicsContext发出绘制调用（通过Skia在Chrome中实现）来将自己绘制到目标位图中。</p>
<p>注意GraphicsContext本身没有图层概念，但是为了使半透明图层的绘制正确，在要求渲染对象绘制之前，有一个警告：半透明RenderLayers调用GraphicsContext:：BeginSparkyLayer（）。在Skia实现中，对begin途SparkyLayer（）的调用会导致所有后续的绘制调用以单独的位图呈现，当图层图形完成时，将与原始图形合成，并在绘制所有半透明RenderLayer的RenderLabel项目后，对GraphicsContext调用endTransparencyLayer（）进行匹配调用。</p>
<p>From WebKit to the Screen  </p>
<p><img src="/hide/gpu5.png"></p>
<p>一旦所有渲染层都绘制到共享位图中，位图仍然需要在屏幕上显示。在Chrome中，位图驻留在共享内存中，位图的控制权通过IPC传递给浏览器进程。然后，浏览器进程负责通过操作系统的窗口API（例如，使用Windows上的相关HWND）在适当的选项卡/窗口中绘制位图。</p>
]]></content>
  </entry>
  <entry>
    <title>ES6、ES7、ES8、ES9、ES10新特性一览</title>
    <url>/2020/11/14/js/es6-next/</url>
    <content><![CDATA[<p>ECMA规范最终由TC39敲定。TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript提案沿着一条严格的发展道路前进。 从提案到入选ECMA规范主要有以下几个阶段：</p>
<p><a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank">原文</a></p>
<ul>
<li>Stage 0: strawman——最初想法的提交。</li>
<li>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。</li>
<li>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。</li>
<li>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈</li>
<li>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间。</li>
</ul>
<h2 id="ES6新特性（2015）"><a href="#ES6新特性（2015）" class="headerlink" title="ES6新特性（2015）"></a>ES6新特性（2015）</h2><p>ES6的特性比较多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度很大，所以ES6中的特性比较多。<br>在这里列举几个常用的：</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let与Const</li>
</ul>
<h2 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1.类（class）"></a>1.类（class）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// toString 是原型对象上的属性</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;,color:&#x27;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);<span class="comment">//实例化Animal</span></span><br><span class="line"> animal.toString();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"> <span class="built_in">console</span>.log(animal.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.</span></span><br><span class="line">    <span class="comment">// 如果没有置顶consructor,默认带super函数的constructor将会被添加、</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.action = action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.toString());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;catch&#x27;</span>)</span><br><span class="line"> cat.toString();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。</span></span><br><span class="line"> <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br><span class="line"> <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-模块化-Module"><a href="#2-模块化-Module" class="headerlink" title="2.模块化(Module)"></a>2.模块化(Module)</h2><p>ES5不支持原生的模块化，在ES6中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<h3 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h3><p>ES6允许在一个模块中使用export来导出多个变量或函数。</p>
<p>导出变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&#x27;Rainbow&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>心得：ES6不仅支持变量的导出，也支持常量的导出。 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;<span class="comment">//导出常量</span></span><br></pre></td></tr></table></figure>

<p>ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Rainbow&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="string">&#x27;24&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, age&#125;;</span><br></pre></td></tr></table></figure>
<p>导出函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myModule.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params">someArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someArg;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h4><p>定义好模块的输出以后就可以在另外一个模块通过import引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myModule&#125; <span class="keyword">from</span> <span class="string">&#x27;myModule&#x27;</span>;<span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name,age&#125; <span class="keyword">from</span> <span class="string">&#x27;test&#x27;</span>;<span class="comment">// test.js</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>心得:一条import 语句可以同时导入默认函数和其它变量。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultMethod, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;xxx.js&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3.箭头（Arrow）函数"></a>3.箭头（Arrow）函数</h2><p>这是ES6中最令人激动的特性之一。=&gt;不只是关键字function的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个this,能帮你很好的解决this的指向问题。</p>
<h3 id="箭头函数的结构"><a href="#箭头函数的结构" class="headerlink" title="箭头函数的结构"></a>箭头函数的结构</h3><p>箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数的例子</span></span><br><span class="line">()=&gt;<span class="number">1</span></span><br><span class="line">v=&gt;v+<span class="number">1</span></span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">        alert(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>/e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>心得：不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
</blockquote>
<h3 id="卸载监听器时的陷阱"><a href="#卸载监听器时的陷阱" class="headerlink" title="卸载监听器时的陷阱"></a>卸载监听器时的陷阱</h3><p>错误的做法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onAppPaused</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的做法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>._onAppPaused = <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onAppPaused</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除上述的做法外，我们还可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
</blockquote>
<h2 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4.函数参数默认值"></a><a href="https://link.juejin.im/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/default_parameters">4.函数参数默认值</a></h2><p>ES6支持在定义函数的时候为其设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">&#x27;red&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不使用默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样写一般没问题，但当参数的布尔值为false时，就会有问题了。比如，我们这样调用foo函数：</span></span><br><span class="line">foo(<span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>因为0的布尔值为false，这样height的取值将是50。同理color的取值为‘red’。</p>
<p>所以说，函数参数默认值不仅能是代码变得更加简洁而且能规避一些问题。</p>
<h2 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h2><p>ES6支持模板字符串，使得字符串的拼接更加的简洁、直观。</p>
<p>不使用模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Your name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在ES6中通过${}就可以完成字符串的拼接，只需要将变量放在大括号之中。</p>
<h2 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6.解构赋值"></a><a href="https://link.juejin.im/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">6.解构赋值</a></h2><p>解构赋值语法是JavaScript的一种表达式，可以方便的从数组或者对象中快速提取值赋给定义的变量。</p>
<h3 id="获取数组中的值"><a href="#获取数组中的值" class="headerlink" title="获取数组中的值"></a>获取数组中的值</h3><p>从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [one, two, three] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(two); <span class="comment">// &quot;two&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(three); <span class="comment">// &quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你要忽略某些值，你可以按照下面的写法获取你想要的值</span></span><br><span class="line"><span class="keyword">var</span> [first, , , last] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(last); <span class="comment">// &quot;four&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//你也可以这样写</span></span><br><span class="line"><span class="keyword">var</span> a, b; <span class="comment">//先声明变量</span></span><br><span class="line"></span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有从数组中的获取到值，你可以为变量设置一个默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">[a=<span class="number">5</span>, b=<span class="number">7</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过解构赋值可以方便的交换两个变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取对象中的值"><a href="#获取对象中的值" class="headerlink" title="获取对象中的值"></a>获取对象中的值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">      name:<span class="string">&#x27;Ming&#x27;</span>,</span><br><span class="line">  age:<span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  city:<span class="string">&#x27;Shanghai&#x27;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,city&#125; = student;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// &quot;Ming&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// &quot;18&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(city); <span class="comment">// &quot;Shanghai&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-延展操作符-Spread-operator"><a href="#7-延展操作符-Spread-operator" class="headerlink" title="7.延展操作符(Spread operator)"></a>7.延展操作符(Spread operator)</h2><p>延展操作符…可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造对象时, 将对象表达式按key-value的方式展开。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>函数调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myFunction(...iterableObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组构造或字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...iterableObj, <span class="string">&#x27;4&#x27;</span>, ...<span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造对象时,进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objClone = &#123; ...obj &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在函数调用时使用延展操作符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, numbers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...numbers));<span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>构造数组</li>
</ul>
<p>没有展开语法的时候，只能组合使用 push，splice，concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法, 构造新数组会变得更简单、更优雅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stuendts = [<span class="string">&#x27;Jine&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>]; </span><br><span class="line"><span class="keyword">const</span> persons = [<span class="string">&#x27;Tony&#x27;</span>,...stuendts,<span class="string">&#x27;Aaron&#x27;</span>,<span class="string">&#x27;Anna&#x27;</span>];</span><br><span class="line">conslog.log(persions)<span class="comment">// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和参数列表的展开类似,  … 在构造字数组时, 可以在任意位置多次使用。</p>
<ul>
<li>数组拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// 等同于 arr.slice()</span></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。</p>
<ul>
<li>连接多个数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];<span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.concat(arr2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在ECMAScript-2018中延展操作符增加了对对象的支持"><a href="#在ECMAScript-2018中延展操作符增加了对对象的支持" class="headerlink" title="在ECMAScript 2018中延展操作符增加了对对象的支持"></a>在ECMAScript 2018中延展操作符增加了对对象的支持</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="在React中的应用"><a href="#在React中的应用" class="headerlink" title="在React中的应用"></a>在React中的应用</h4><p>通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props 。但是当传递大量的props时，会非常繁琐，这时我们可以使用 <code>...(延展操作符,用于取出参数对象的所有可遍历属性)</code> 来进行传递。</p>
<h4 id="一般情况下我们应该这样写"><a href="#一般情况下我们应该这样写" class="headerlink" title="一般情况下我们应该这样写"></a>一般情况下我们应该这样写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;CustomComponent name =<span class="string">&#x27;Jine&#x27;</span> age =&#123;<span class="number">21</span>&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 … ，等同于上面的写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jine&#x27;</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;CustomComponent &#123;...params&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配合解构赋值避免传入一些不需要的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    name: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    title: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; type, ...other &#125; = params;</span><br><span class="line"></span><br><span class="line">&lt;CustomComponent type=<span class="string">&#x27;normal&#x27;</span> number=&#123;<span class="number">2</span>&#125; &#123;...other&#125; /&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">&lt;CustomComponent type=<span class="string">&#x27;normal&#x27;</span> number=&#123;<span class="number">2</span>&#125; name=<span class="string">&#x27;123&#x27;</span> title=<span class="string">&#x27;456&#x27;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h2><p>在ES6中允许我们在设置一个对象的属性的时候不指定属性名。</p>
<p>不使用ES6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;Ming&#x27;</span>,age=<span class="string">&#x27;18&#x27;</span>,city=<span class="string">&#x27;Shanghai&#x27;</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name:name,</span><br><span class="line">    age:age,</span><br><span class="line">    city:city</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student);<span class="comment">//&#123;name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象中必须包含属性和值，显得非常冗余。</p>
<p>使用ES6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;Ming&#x27;</span>,age=<span class="string">&#x27;18&#x27;</span>,city=<span class="string">&#x27;Shanghai&#x27;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">        name,</span><br><span class="line">    age,</span><br><span class="line">    city</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student);<span class="comment">//&#123;name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象中直接写变量，非常简洁。</p>
<h2 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9.Promise"></a><a href="https://link.juejin.im/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">9.Promise</a></h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>不使用ES6</p>
<p>嵌套两个setTimeout回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 1秒后输出&quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>); <span class="comment">// 2秒后输出&quot;Hi&quot;</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用ES6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> waitSecond = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitSecond</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 1秒后输出&quot;Hello&quot;</span></span><br><span class="line">        <span class="keyword">return</span> waitSecond;</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 2秒后输出&quot;Hi&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上面的的代码使用两个then来进行异步编程串行化，避免了回调地狱：</p>
<h2 id="10-支持let与const"><a href="#10-支持let与const" class="headerlink" title="10.支持let与const"></a>10.支持let与const</h2><p>在之前JS是没有块级作用域的，const与let填补了这方便的空白，const与let都是块级作用域。</p>
<p>使用var定义的变量为函数级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>
<p>使用let与const定义的变量为块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//-1 or Error“ReferenceError: a is not defined”</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ES7新特性（2016）"><a href="#ES7新特性（2016）" class="headerlink" title="ES7新特性（2016）"></a>ES7新特性（2016）</h2><p>ES2016添加了两个小的特性来说明标准化过程：</p>
<p>数组includes()方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</p>
<p>a ** b指数运算符，它与 Math.pow(a, b)相同。</p>
<h2 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h2><p>includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回false。</p>
<p>includes 函数与 indexOf 函数很相似，下面两个表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.includes(x)</span><br><span class="line">arr.indexOf(x) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来判断数字中是否包含某个元素：</p>
<p>在ES7之前的做法</p>
<p>使用indexOf()验证数组中是否存在某个元素，这时需要根据返回值是否为-1来判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;angular&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">&#x27;react&#x27;</span>) !== -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;react存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ES7的includes()</p>
<p>使用includes()验证数组中是否存在某个元素，这样更加直观简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;angular&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="string">&#x27;react&#x27;</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;react存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2.指数操作符"></a>2.指数操作符</h2><p>在ES7中引入了指数运算符<strong>，</strong>具有与Math.pow(..)等效的计算结果。</p>
<ul>
<li>不使用指数操作符</li>
</ul>
<p>使用自定义的递归函数calculateExponent或者Math.pow()进行指数运算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateExponent</span>(<span class="params">base, exponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> base * calculateExponent(base, exponent - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateExponent(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用指数操作符</li>
</ul>
<p>使用指数运算符**，就像+、-等操作符一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>);<span class="comment">// 输出1024</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ES8新特性（2017）"><a href="#ES8新特性（2017）" class="headerlink" title="ES8新特性（2017）"></a>ES8新特性（2017）</h2><ul>
<li>async/await</li>
<li>Object.values()</li>
<li>Object.entries()</li>
<li>String padding: padStart()和padEnd()，填充字符串达到当前长度</li>
</ul>
<p>函数参数列表结尾允许逗号</p>
<ul>
<li><p>Object.getOwnPropertyDescriptors()</p>
</li>
<li><p>ShareArrayBuffer和Atomics对象，用于从共享内存位置读取和写入</p>
</li>
</ul>
<h2 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1.async/await"></a>1.async/await</h2><p>ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for…of循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">        doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2.Object.values()"></a>2.Object.values()</h2><p>Object.values()是一个与Object.keys()类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。</p>
<p>假设我们要遍历如下对象obj的所有值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不使用Object.values() :ES7</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vals=<span class="built_in">Object</span>.keys(obj).map(<span class="function"><span class="params">key</span>=&gt;</span>obj[key]);</span><br><span class="line"><span class="built_in">console</span>.log(vals);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>使用Object.values() :ES8</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values=<span class="built_in">Object</span>.values(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(values);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出Object.values()为我们省去了遍历key，并根据这些key获取value的步骤。</p>
<h2 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.Object.entries()</h2><p>Object.entries()函数返回一个给定对象自身可枚举属性的键值对的数组。</p>
<p>接下来我们来遍历上文中的obj对象的所有属性的key和value：</p>
<p>不使用Object.entries() :ES7</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;key:&#x27;</span>+key+<span class="string">&#x27; value:&#x27;</span>+obj[key]);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br></pre></td></tr></table></figure>

<p>使用Object.entries() :ES8</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1)</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4.String padding"></a>4.String padding</h2><p>在ES8中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<p>String.padStart(targetLength,[padString])</p>
<p>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>
<p>padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">4</span>,<span class="string">&#x27;10&#x27;</span>)) <span class="comment">//10.0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">20</span>))<span class="comment">// 0.00    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>String.padEnd(targetLength,padString])</p>
<p>targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>
<p>padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padEnd(<span class="number">4</span>,<span class="string">&#x27;0&#x27;</span>)) <span class="comment">//0.00    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padEnd(<span class="number">10</span>,<span class="string">&#x27;0&#x27;</span>))<span class="comment">//0.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5.函数参数列表结尾允许逗号"></a>5.函数参数列表结尾允许逗号</h2><p>主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。</p>
<h2 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6.Object.getOwnPropertyDescriptors()"></a>6.Object.getOwnPropertyDescriptors()</h2><p>Object.getOwnPropertyDescriptors()函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
<p>函数原型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回obj对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jine&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;18&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj2)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   age: &#123;</span></span><br><span class="line">    <span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function age()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line">    <span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//value:&quot;Jine&quot;,</span></span><br><span class="line"><span class="comment">//writable:true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7.SharedArrayBuffer对象"></a>7.SharedArrayBuffer对象</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>length 所创建的数组缓冲区的大小，以字节(byte)为单位。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;SharedArrayBuffer&#125;</span> </span>一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> SharedArrayBuffer(length)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8.Atomics对象"></a>8.Atomics对象</h2><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。</p>
<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>
<p>Atomics.add()</p>
<p>将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p>
<p>Atomics.and()</p>
<p>将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p>
<p>Atomics.compareExchange()</p>
<p>如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</p>
<p>Atomics.exchange()</p>
<p>将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p>
<p>Atomics.load()</p>
<p>返回数组中指定元素的值。</p>
<p>Atomics.or()</p>
<p>将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p>
<p>Atomics.store()</p>
<p>将数组中指定的元素设置为给定的值，并返回该值。</p>
<p>Atomics.sub()</p>
<p>将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p>
<p>Atomics.xor()</p>
<p>将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p>
<p>wait() 和 wake() 方法采用的是 Linux 上的 futexes 模型（fast user-space mutex，快速用户空间互斥量），可以让进程一直等待直到某个特定的条件为真，主要用于实现阻塞。</p>
<p>Atomics.wait()</p>
<p>检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p>
<p>Atomics.wake()</p>
<p>唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p>
<p>Atomics.isLockFree(size)</p>
<p>可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。–&gt;</p>
<h2 id="ES9新特性（2018）"><a href="#ES9新特性（2018）" class="headerlink" title="ES9新特性（2018）"></a>ES9新特性（2018）</h2><p>异步迭代</p>
<p>Promise.finally()</p>
<p>Rest/Spread 属性</p>
<p><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fesnext.justjavac.com%2Fproposal%2Fregexp-named-groups.html" rel="nofollow noopener noreferrer">正则表达式命名捕获组</a>（Regular Expression Named Capture Groups）</p>
<p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000006824133" rel="nofollow noopener noreferrer">正则表达式反向断言</a>（lookbehind）</p>
<p>正则表达式dotAll模式</p>
<p><a target="_blank" href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1" rel="">正则表达式 Unicode 转义</a></p>
<p><a target="_blank" href="https://juejin.im/post/5b2a186cf265da596d04a648#heading-1" rel="">非转义序列的模板字符串</a></p>
<h2 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1.异步迭代"></a>1.异步迭代</h2><p>在async/await的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">        <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码不会正常运行，下面这段同样也不会：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">      array.forEach(<span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。</p>
<p>ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for…of循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">        doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2.Promise.finally()"></a>2.Promise.finally()</h2><p>一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p>.finally()允许你指定最终的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// finish here!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3.Rest/Spread 属性"></a>3.Rest/Spread 属性</h2><p>ES2015引入了<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FRest_parameters" rel="">Rest参数</a>和<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FSpread_syntax" rel="">扩展运算符</a>。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p1 = 1</span></span><br><span class="line">    <span class="comment">// p2 = 2</span></span><br><span class="line">    <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如Math.max()返回给定数字中的最大值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">99</span>, <span class="number">100</span>, -<span class="number">1</span>, <span class="number">48</span>, <span class="number">16</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...values) ); <span class="comment">// 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...x &#125; = myObject;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者你可以使用它给函数传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(&#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">&#123; a, ...x &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// a = 1</span></span><br><span class="line">    <span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。</p>
<p>扩展运算符可以在其他对象内使用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">z</span>: <span class="number">26</span> &#125;;</span><br><span class="line"><span class="comment">// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以使用扩展运算符拷贝一个对象，像是这样obj2 = {…obj1}，但是 这只是一个对象的浅拷贝。另外，如果一个对象A的属性是对象B，那么在克隆后的对象cloneB中，该属性指向对象B。</p>
<h2 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4.正则表达式命名捕获组"></a>4.正则表达式命名捕获组</h2><p>JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以YYYY-MM-DD的格式解析日期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year   = match[<span class="number">1</span>], <span class="comment">// 2018</span></span><br><span class="line">  month  = match[<span class="number">2</span>], <span class="comment">// 04</span></span><br><span class="line">  day    = match[<span class="number">3</span>]; <span class="comment">// 30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。</p>
<p>ES2018允许命名捕获组使用符号?<name>，在打开捕获括号(后立即命名，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year   = match.groups.year,  <span class="comment">// 2018</span></span><br><span class="line">  month  = match.groups.month, <span class="comment">// 04</span></span><br><span class="line">  day    = match.groups.day;   <span class="comment">// 30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何匹配失败的命名组都将返回undefined。</p>
<p>命名捕获也可以使用在replace()方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  d      = <span class="string">&#x27;2018-04-30&#x27;</span>,</span><br><span class="line">  usDate = d.replace(reDate, <span class="string">&#x27;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5.正则表达式反向断言"></a>5.正则表达式反向断言</h2><p>目前JavaScript在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookahead = <span class="regexp">/\\D(?=\\d+)/</span>,</span><br><span class="line">  match       = reLookahead.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// $</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehind = <span class="regexp">/(?&lt;=\\D)\\d+/</span>,</span><br><span class="line">  match        = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// 123.89</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是 肯定反向断言，非数字\D必须存在。同样的，还存在 否定反向断言，表示一个值必须不存在，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehindNeg = <span class="regexp">/(?&lt;!\\D)\\d+/</span>,</span><br><span class="line">  match           = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6.正则表达式dotAll模式"></a>6.正则表达式dotAll模式</h2><p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">&#x27;hello\</span></span><br><span class="line"><span class="string">world&#x27;</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">&#x27;hello\</span></span><br><span class="line"><span class="string">world&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-正则表达式-Unicode-转义"><a href="#7-正则表达式-Unicode-转义" class="headerlink" title="7.正则表达式 Unicode 转义"></a>7.正则表达式 Unicode 转义</h2><p>到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为\p{…}和\P{…}，在正则表达式中使用标记 u (unicode) 设置，在\p块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reGreekSymbol = <span class="regexp">/\\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">reGreekSymbol.test(<span class="string">&#x27;π&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。</p>
<h2 id="8-非转义序列的模板字符串"><a href="#8-非转义序列的模板字符串" class="headerlink" title="8.非转义序列的模板字符串"></a>8.非转义序列的模板字符串</h2><p>之前，\u开始一个 unicode 转义，\x开始一个十六进制转义，\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:\uuu\xxx\111。更多细节参考<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2Ftemplate_string\" rel="nofollow noopener noreferrer">模板字符串</a>。</p>
<h2 id="ES10新特性（2019）"><a href="#ES10新特性（2019）" class="headerlink" title="ES10新特性（2019）"></a>ES10新特性（2019）</h2><p>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</p>
<p>更加友好的 JSON.stringify</p>
<p>新增了Array的flat()方法和flatMap()方法</p>
<p>新增了String的trimStart()方法和trimEnd()方法</p>
<p>Object.fromEntries()</p>
<p>Symbol.prototype.description</p>
<p>String.prototype.matchAll</p>
<p>Function.prototype.toString()现在返回精确字符，包括空格和注释</p>
<p>简化try {} catch {},修改 catch 绑定</p>
<p>新的基本数据类型BigInt</p>
<p>globalThis</p>
<p>import()</p>
<p>Legacy RegEx</p>
<p>私有的实例方法和访问器</p>
<h2 id="1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配"><a href="#1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与JSON匹配" class="headerlink" title="1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配"></a>1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</h2><p>以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致SyntaxError异常。</p>
<h2 id="2-更加友好的-JSON-stringify"><a href="#2-更加友好的-JSON-stringify" class="headerlink" title="2.更加友好的 JSON.stringify"></a>2.更加友好的 JSON.stringify</h2><p>如果输入 Unicode 格式但是超出范围的字符，在原先JSON.stringify返回格式错误的Unicode字符串。现在实现了一个改变JSON.stringify的<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-well-formed-stringify" rel="nofollow noopener noreferrer">第3阶段提案</a>，因此它为其输出转义序列，使其成为有效Unicode（并以UTF-8表示）</p>
<h2 id="3-新增了Array的flat-方法和flatMap-方法"><a href="#3-新增了Array的flat-方法和flatMap-方法" class="headerlink" title="3.新增了Array的flat()方法和flatMap()方法"></a>3.新增了Array的flat()方法和flatMap()方法</h2><p>flat()和flatMap()本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<h3 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h3><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p>flat()方法最基本的作用就是数组降维</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr3.flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span></span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>其次，还可以利用flat()方法的特性来去除数组的空项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat();</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h3><p>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。<br>这里我们拿map方法与flatMap方法做一个比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-新增了String的trimStart-方法和trimEnd-方法"><a href="#4-新增了String的trimStart-方法和trimEnd-方法" class="headerlink" title="4.新增了String的trimStart()方法和trimEnd()方法"></a>4.新增了String的trimStart()方法和trimEnd()方法</h2><p>新增的这两个方法很好理解，分别去除字符串首尾空白字符，这里就不用例子说声明了。</p>
<h2 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5.Object.fromEntries()"></a>5.Object.fromEntries()</h2><p>Object.entries()方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<p>而Object.fromEntries() 则是 Object.entries() 的反转。</p>
<p>Object.fromEntries() 函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。</p>
<p>通过 Object.fromEntries， 可以将 Map 转化为 Object:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>] ]);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过 Object.fromEntries， 可以将 Array 转化为 Object:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] ];</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-Symbol-prototype-description"><a href="#6-Symbol-prototype-description" class="headerlink" title="6.Symbol.prototype.description"></a>6.Symbol.prototype.description</h2><p>通过工厂函数Symbol（）创建符号时，您可以选择通过参数提供字符串作为描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;The description&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以前，访问描述的唯一方法是将符号转换为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(<span class="built_in">String</span>(sym), <span class="string">&#x27;Symbol(The description)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在引入了getter Symbol.prototype.description以直接访问描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(sym.description, <span class="string">&#x27;The description&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7.String.prototype.matchAll"></a>7.String.prototype.matchAll</h2><p>matchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。<br>在 matchAll 出现之前，通过在循环中调用regexp.exec来获取所有匹配项信息（regexp需使用/g标志：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regexp.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 9.&quot;</span></span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 19.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用／g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for…of, array spread, or Array.from() 可以更方便实现功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>,<span class="string">&#x27;g&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot; ]</span></span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// matches iterator is exhausted after the for..of iteration</span></span><br><span class="line"><span class="comment">// Call matchAll again to create a new iterator</span></span><br><span class="line">matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(matches, <span class="function"><span class="params">m</span> =&gt;</span> m[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot;, &quot;foo&quot; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="matchAll可以更好的用于分组"><a href="#matchAll可以更好的用于分组" class="headerlink" title="matchAll可以更好的用于分组"></a>matchAll可以更好的用于分组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;test1test2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.match(regexp); </span><br><span class="line"><span class="comment">// Array [&#x27;test1&#x27;, &#x27;test2&#x27;]</span></span><br><span class="line"><span class="string">``</span><span class="string">` javascript</span></span><br></pre></td></tr></table></figure>

<p>let array = […str.matchAll(regexp)];</p>
<p>array[0];<br>// [‘test1’, ‘e’, ‘st1’, ‘1’, index: 0, input: ‘test1test2’, length: 4]<br>array[1];<br>// [‘test2’, ‘e’, ‘st2’, ‘2’, index: 5, input: ‘test1test2’, length: 4]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 8.Function.prototype.toString()现在返回精确字符，包括空格和注释</span><br><span class="line">&#96;&#96;&#96; javascript</span><br><span class="line">function &#x2F;* comment *&#x2F; foo &#x2F;* another comment *&#x2F;() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 之前不会打印注释部分</span><br><span class="line">console.log(foo.toString()); &#x2F;&#x2F; function foo()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES2019 会把注释一同打印</span><br><span class="line">console.log(foo.toString()); &#x2F;&#x2F; function &#x2F;* comment *&#x2F; foo &#x2F;* another comment *&#x2F; ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数</span><br><span class="line">const bar &#x2F;* comment *&#x2F; &#x3D; &#x2F;* another comment *&#x2F; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(bar.toString()); &#x2F;&#x2F; () &#x3D;&gt; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="9-修改-catch-绑定"><a href="#9-修改-catch-绑定" class="headerlink" title="9.修改 catch 绑定"></a>9.修改 catch 绑定</h2><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10 提案使我们能够简单的把变量省略掉。</p>
<p>不算大的改动。</p>
<p>之前是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-新的基本数据类型BigInt"><a href="#10-新的基本数据类型BigInt" class="headerlink" title="10.新的基本数据类型BigInt"></a>10.新的基本数据类型BigInt</h2><p>现在的基本数据类型（值类型）不止5种（ES6之后是六种）了哦！加上BigInt一共有七种基本数据类型，分别是：<br>String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
<p><a target="_blank" href="https://juejin.im/post/5b9cb3336fb9a05d290ee47e" rel="">ES6、ES7、ES8学习指南</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端异常监控解决方案</title>
    <url>/2020/11/14/js/web-err/</url>
    <content><![CDATA[<blockquote>
<p>前端监控包括行为监控、异常监控、性能监控等,一个用户在操作应用过程中如果出现异常，有可能是前端引起，也有可能是后端引起，需要有一个机制，将前后端串联起来，使监控本身统一于监控系统。</p>
</blockquote>
<p><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank">原文地址</a></p>
<p>一个监控系统，大致可以分为四个阶段:</p>
<p>采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。</p>
<p>存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。</p>
<p>分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。</p>
<p>报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。</p>
<h2 id="一、前端异常"><a href="#一、前端异常" class="headerlink" title="一、前端异常"></a>一、前端异常</h2><h2 id="1-1-前端异常分类"><a href="#1-1-前端异常分类" class="headerlink" title="1.1 前端异常分类"></a>1.1 前端异常分类</h2><p>a. 出错<br>界面呈现的内容与用户预期的内容不符，例如点击进入非目标界面，数据不准确，出现的错误提示不可理解，界面错位，提交后跳转到错误界面等情况。这类异常出现时，虽然产品本身功能还能正常使用，但用户无法达成自己目标。</p>
<p>b. 呆滞<br>界面出现操作后没有反应的现象，例如点击按钮无法提交，提示成功后无法继续操作。这类异常出现时，产品已经存在界面级局部不可用现象。</p>
<p>c. 损坏<br>界面出现无法实现操作目的的现象，例如点击无法进入目标界面，点击无法查看详情内容等。这类异常出现时，应用部分功能无法被正常使用。</p>
<p>d. 假死<br>界面出现卡顿，无法对任何功能进行使用的现象。例如用户无法登陆导致无法使用应用内功能，由于某个遮罩层阻挡且不可关闭导致无法进行任何后续操作。这类异常出现时，用户很可能杀死应用。</p>
<p>e. 崩溃<br>应用出现经常性自动退出或无法操作的现象。例如间歇性crash，网页无法正常加载或加载后无法进行任何操作。这类异常持续出现，将直接导致用户流失，影响产品生命力。</p>
<h2 id="1-2-异常错误原因分类"><a href="#1-2-异常错误原因分类" class="headerlink" title="1.2 异常错误原因分类"></a>1.2 异常错误原因分类</h2><p>前端产生异常的原因主要分5类：<table><tbody><tr><td>原因</td><td>案例</td><td>频率</td></tr><tr><td>逻辑错误</td><td>1)    业务逻辑判断条件错误<br>2)    事件绑定顺序错误<br>3)    调用栈时序错误<br>4)    错误的操作js对象</td><td>经常</td></tr><tr><td>数据类型错误</td><td>1)    将null视作对象读取property<br>2)    将undefined视作数组进行遍历<br>3)    将字符串形式的数字直接用于加运算<br>4)    函数参数未传</td><td>经常</td></tr><tr><td>语法句法错误</td><td></td><td>较少</td></tr><tr><td>网络错误</td><td>1)    慢<br>2)    服务端未返回数据但仍200，前端按正常进行数据遍历<br>3)    提交数据时网络中断<br>4)    服务端500错误时前端未做任何错误处理</td><td>偶尔</td></tr><tr><td>系统错误</td><td>1)    内存不够用<br>2)    磁盘塞满<br>3)    壳不支持API<br>4)    不兼容</td><td>较少</td></tr></tbody></table></p>
<h2 id="2-异常采集"><a href="#2-异常采集" class="headerlink" title="2 异常采集"></a>2 异常采集</h2><h2 id="2-1-采集内容"><a href="#2-1-采集内容" class="headerlink" title="2.1 采集内容"></a>2.1 采集内容</h2><p>当异常出现的时候，我们需要知道异常的具体信息，根据异常的具体信息来决定采用什么样的解决方案。在采集异常信息时，可以遵循4W原则：<br><em><u><br></u></em><br><em><u>WHO</u></em><em> <u>did WHAT</u> and <u>get WHICH exception</u> <u>in WHICH environment</u>?</em></p>
<p>a. 用户信息<br>出现异常时该用户的信息，例如该用户在当前时刻的状态、权限等，以及需要区分用户可多终端登录时，异常对应的是哪一个终端。</p>
<p>b. 行为信息<br>用户进行什么操作时产生了异常：所在的界面路径；执行了什么操作；操作时使用了哪些数据；当时的API吐了什么数据给客户端；如果是提交操作，提交了什么数据；上一个路径；上一个行为日志记录ID等。</p>
<p>c. 异常信息<br>产生异常的代码信息：用户操作的DOM元素节点；异常级别；异常类型；异常描述；代码stack信息等。</p>
<p>d. 环境信息<br>网络环境；设备型号和标识码；操作系统版本；客户端版本；API接口版本等。</p>
<table><tbody><tr><td>字段</td><td>类型</td><td>解释</td></tr><tr><td>requestId</td><td>String</td><td>一个界面产生一个requestId</td></tr><tr><td>traceId</td><td>String</td><td>一个阶段产生一个traceId，用于追踪和一个异常相关的所有日志记录</td></tr><tr><td>hash</td><td>String</td><td>这条log的唯一标识码，相当于logId，但它是根据当前日志记录的具体内容而生成的</td></tr><tr><td>time</td><td>Number</td><td>当前日志产生的时间（保存时刻）</td></tr><tr><td>userId</td><td>String</td><td></td></tr><tr><td>userStatus</td><td>Number</td><td>当时，用户状态信息（是否可用/禁用）</td></tr><tr><td>userRoles</td><td>Array</td><td>当时，前用户的角色列表</td></tr><tr><td>userGroups</td><td>Array</td><td>当时，用户当前所在组，组别权限可能影响结果</td></tr><tr><td>userLicenses</td><td>Array</td><td>当时，许可证，可能过期</td></tr><tr><td>path</td><td>String</td><td>所在路径，URL</td></tr><tr><td>action</td><td>String</td><td>进行了什么操作</td></tr><tr><td>referer</td><td>String</td><td>上一个路径，来源URL</td></tr><tr><td>prevAction</td><td>String</td><td>上一个操作</td></tr><tr><td>data</td><td>Object</td><td>当前界面的state、data</td></tr><tr><td>dataSources</td><td>Array<Object></td><td>上游api给了什么数据</td></tr><tr><td>dataSend</td><td>Object</td><td>提交了什么数据</td></tr><tr><td>targetElement</td><td>HTMLElement</td><td>用户操作的DOM元素</td></tr><tr><td>targetDOMPath</td><td>Array<HTMLElement></td><td>该DOM元素的节点路径</td></tr><tr><td>targetCSS</td><td>Object</td><td>该元素的自定义样式表</td></tr><tr><td>targetAttrs</td><td>Object</td><td>该元素当前的属性及值</td></tr><tr><td>errorType</td><td>String</td><td>错误类型</td></tr><tr><td>errorLevel</td><td>String</td><td>异常级别</td></tr><tr><td>errorStack</td><td>String</td><td>错误stack信息</td></tr><tr><td>errorFilename</td><td>String</td><td>出错文件</td></tr><tr><td>errorLineNo</td><td>Number</td><td>出错行</td></tr><tr><td>errorColNo</td><td>Number</td><td>出错列位置</td></tr><tr><td>errorMessage</td><td>String</td><td>错误描述（开发者定义）</td></tr><tr><td>errorTimeStamp</td><td>Number</td><td>时间戳</td></tr><tr><td>eventType</td><td>String</td><td>事件类型</td></tr><tr><td>pageX</td><td>Number</td><td>事件x轴坐标</td></tr><tr><td>pageY</td><td>Number</td><td>事件y轴坐标</td></tr><tr><td>screenX</td><td>Number</td><td>事件x轴坐标</td></tr><tr><td>screenY</td><td>Number</td><td>事件y轴坐标</td></tr><tr><td>pageW</td><td>Number</td><td>页面宽度</td></tr><tr><td>pageH</td><td>Number</td><td>页面高度</td></tr><tr><td>screenW</td><td>Number</td><td>屏幕宽度</td></tr><tr><td>screenH</td><td>Number</td><td>屏幕高度</td></tr><tr><td>eventKey</td><td>String</td><td>触发事件的键</td></tr><tr><td>network</td><td>String</td><td>网络环境描述</td></tr><tr><td>userAgent</td><td>String</td><td>客户端描述</td></tr><tr><td>device</td><td>String</td><td>设备描述</td></tr><tr><td>system</td><td>String</td><td>操作系统描述</td></tr><tr><td>appVersion</td><td>String</td><td>应用版本</td></tr><tr><td>apiVersion</td><td>String</td><td>接口版本</td></tr></tbody></table>

<p>这是一份非常庞大的日志字段表，它几乎囊括了一个异常发生时，能够对异常周遭环境进行详细描述的所有信息。不同情况下，这些字段并不一定都会收集，由于我们会采用文档数据库存储日志，因此，并不影响它的实际存储结果。</p>
<h2 id="2-2-异常捕获"><a href="#2-2-异常捕获" class="headerlink" title="2.2 异常捕获"></a>2.2 异常捕获</h2><p>前端捕获异常分为全局捕获和单点捕获。全局捕获代码集中，易于管理；单点捕获作为补充，对某些特殊情况进行捕获，但分散，不利于管理。</p>
<p>a、全局捕获</p>
<p>通过全局的接口，将捕获代码集中写在一个地方，可以利用的接口有：</p>
<ul><li>window.addEventListener(‘error’) / window.addEventListener(“unhandledrejection”) / document.addEventListener(‘click’) 等</li><li>
</li><li>框架级别的全局监听，例如aixos中使用interceptor进行拦截，vue、react都有自己的错误采集接口</li><li>
</li><li>通过对全局函数进行封装包裹，实现在在调用该函数时自动捕获异常</li><li>
</li><li>对实例方法重写（Patch），在原有功能基础上包裹一层，例如对console.error进行重写，在使用方法不变的情况下也可以异常捕获</li><li>
</li></ul>
b、单点捕获


<p>在业务代码中对单个代码块进行包裹，或在逻辑流程中打点，实现有针对性的异常捕获：</p>
<ul><li>try…catch</li><li>
</li><li>专门写一个函数来收集异常信息，在异常发生时，调用该函数</li><li>
</li><li>专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一模一样，只是在发生异常时可以捕获异常</li><li>
</li></ul>
## 2.3 跨域脚本异常


<p>由于浏览器安全策略限制，跨域脚本报错时，无法直接获取错误的详细信息，只能得到一个Script Error。例如，我们会引入第三方依赖，或者将自己的脚本放在CDN时。</p>
<p>解决Script Error的方法：</p>
<p>方案一：<ul><li>将js内联到HTML中</li><li>将js文件与HTML放在同域下</li><li></p>
</li></ul>
方案二：<ol><li>为页面上script标签添加crossorigin属性</li><li>被引入脚本所在服务端响应头中，增加 Access-Control-Allow-Origin 来支持跨域资源共享</li><li>
</li></ol>
## 2.4 异常录制


<p>对于一个异常，仅仅拥有该异常的信息还不足以完全抓住问题的本质，因为异常发生的位置，并不一定是异常根源所在的位置。我们需要对异常现场进行还原，才能复原问题全貌，甚至避免类似问题在其他界面中发生。这里需要引进一个概念，就是“异常录制”。录制通过“时间”“空间”两个维度记录异常发生前到发生的整个过程，对于找到异常根源更有帮助。</p>
<h2 id="2-5-异常级别"><a href="#2-5-异常级别" class="headerlink" title="2.5 异常级别"></a>2.5 异常级别</h2><p>一般而言，我们会将收集信息的级别分为info，warn，error等，并在此基础上进行扩展。</p>
<p>当我们监控到异常发生时，可以将该异常划分到“重要——紧急”模型中分为A、B、C、D四个等级。有些异常，虽然发生了，但是并不影响用户的正常使用，用户其实并没有感知到，虽然理论上应该修复，但是实际上相对于其他异常而言，可以放在后面进行处理。<br><img src="//api.webq.top/static/img/error_level.jpg" style="max-width:100%;"></p>
<p>下文会讨论告警策略，一般而言，越靠近右上角的异常会越快通知，保证相关人员能最快接收到信息，并进行处理。A级异常需要快速响应，甚至需要相关负责人知悉。</p>
<p>在收集异常阶段，可根据第一节划分的异常后果来判断异常的严重程度，在发生异常时选择对应的上报方案进行上报。</p>
<h2 id="3-整理与上报方案"><a href="#3-整理与上报方案" class="headerlink" title="3 整理与上报方案"></a>3 整理与上报方案</h2><p>前文已经提到，除了异常报错信息本身，我们还需要记录用户操作日志，以实现场景复原。这就涉及到上报的量和频率问题。如果任何日志都立即上报，这无异于自造的DDOS攻击。因此，我们需要合理的上报方案。下文会介绍4种上报方案，但实际我们不会仅限于其中一种，而是经常同时使用，对不同级别的日志选择不同的上报方案。</p>
<h2 id="3-1-前端存储日志"><a href="#3-1-前端存储日志" class="headerlink" title="3.1 前端存储日志"></a>3.1 前端存储日志</h2><p>我们前面提到，我们并不单单采集异常本身日志，而且还会采集与异常相关的用户行为日志。单纯一条异常日志并不能帮助我们快速定位问题根源，找到解决方案。但如果要收集用户的行为日志，又要采取一定的技巧，而不能用户每一个操作后，就立即将该行为日志传到服务器，对于具有大量用户同时在线的应用，如果用户一操作就立即上传日志，无异于对日志服务器进行DDOS攻击。因此，我们先将这些日志存储在用户客户端本地，达到一定条件之后，再同时打包上传一组日志。</p>
<p>那么，如何进行前端日志存储呢？我们不可能直接将这些日志用一个变量保存起来，这样会挤爆内存，而且一旦用户进行刷新操作，这些日志就丢失了，因此，我们自然而然想到前端数据持久化方案。</p>
<p>目前，可用的持久化方案可选项也比较多了，主要有：Cookie、localStorage、sessionStorage、IndexedDB、webSQL 、FileSystem 等等。那么该如何选择呢？我们通过一个表来进行对比：</p>
<table><tbody><tr><td>存储方式</td><td>cookie</td><td>localStorage</td><td>sessionStorage</td><td>IndexedDB</td><td>webSQL</td><td>FileSystem</td></tr><tr><td>类型</td><td></td><td>key-value</td><td>key-value</td><td>NoSQL</td><td>SQL</td><td></td></tr><tr><td>数据格式</td><td>string</td><td>string</td><td>string</td><td>object</td><td></td><td></td></tr><tr><td>容量</td><td>4k</td><td>5M</td><td>5M</td><td>500M</td><td>60M</td><td></td></tr><tr><td>进程</td><td>同步</td><td>同步</td><td>同步</td><td>异步</td><td>异步</td><td></td></tr><tr><td>检索</td><td></td><td>key</td><td>key</td><td>key, index</td><td>field</td><td></td></tr><tr><td>性能</td><td></td><td>读快写慢</td><td></td><td>读慢写快</td><td></td><td></td></tr></tbody></table>

<p>综合之后，IndexedDB是最好的选择，它具有容量大、异步的优势，异步的特性保证它不会对界面的渲染产生阻塞。<br>而且IndexedDB是分库的，每个库又分store，还能按照索引进行查询，具有完整的数据库管理思维，比localStorage更适合做结构化数据管理。<br>但是它有一个缺点，就是api非常复杂，不像localStorage那么简单直接。<br>针对这一点，我们可以使用hello-indexeddb这个工具，它用Promise对复杂api进行来封装，简化操作，使IndexedDB的使用也能做到localStorage一样便捷。<br>另外，IndexedDB是被广泛支持的HTML5标准，兼容大部分浏览器，因此不用担心它的发展前景。</p>
<p>接下来，我们究竟应该怎么合理使用IndexedDB，保证我们前端存储的合理性呢？<br><img src="//api.webq.top/static/img/e_storage.jpg" style="max-width:100%;"></p>
<p>上图展示了前端存储日志的流程和数据库布局。<br>当一个事件、变动、异常被捕获之后，形成一条初始日志，被立即放入暂存区（indexedDB的一个store），<br>之后主程序就结束了收集过程，后续的事只在webworker中发生。<br>在一个webworker中，一个循环任务不断从暂存区中取出日志，对日志进行分类，<br>将分类结果存储到索引区中，并对日志记录的信息进行丰富，<br>将最终将会上报到服务端的日志记录转存到归档区。<br>而当一条日志在归档区中存在的时间超过一定天数之后，它就已经没有价值了，但是为了防止特殊情况，它被转存到回收区，<br>再经历一段时间后，就会被从回收区中清除。</p>
<h2 id="3-2-前端整理日志"><a href="#3-2-前端整理日志" class="headerlink" title="3.2 前端整理日志"></a>3.2 前端整理日志</h2><p>上文讲到，在一个webworker中对日志进行整理后存到索引区和归档区，那么这个整理过程是怎样的呢？</p>
<p>由于我们下文要讲的上报，是按照索引进行的，因此，我们在前端的日志整理工作，主要就是根据日志特征，整理出不同的索引。我们在收集日志时，会给每一条日志打上一个type，以此进行分类，并创建索引，同时通过object-hashcode计算每个log对象的hash值，作为这个log的唯一标志。</p>
<ul><li>将所有日志记录按时序存放在归档区，并将新入库的日志加入索引</li><li>
</li><li>BatchIndexes：批量上报索引（包含性能等其他日志），可一次批量上报100条</li><li>
</li><li>MomentIndexes：即时上报索引，一次全部上报</li><li>
</li><li>FeedbackIndexes：用户反馈索引，一次上报一条</li><li>
</li><li>BlockIndexes：区块上报索引，按异常/错误（traceId，requestId）分块，一次上报一块</li><li>
</li><li>上报完成后，被上报过的日志对应的索引删除</li><li>
</li><li>3天以上日志进入回收区</li><li>7天以上的日志从回收区清除</li><li>
</li></ul>

<p>rquestId：同时追踪前后端日志。<br>由于后端也会记录自己的日志，因此，在前端请求api的时候，默认带上requestId，后端记录的日志就可以和前端日志对应起来。</p>
<p>traceId：追踪一个异常发生前后的相关日志。<br>当应用启动时，创建一个traceId，直到一个异常发生时，刷新traceId。<br>把一个traceId相关的requestId收集起来，把这些requestId相关的日志组合起来，就是最终这个异常相关的所有日志，用来对异常进行复盘。</p>
<img src="//api.webq.top/static/img/e_block.jpg" style="max-width:100%;">


<p>上图举例展示了如何利用traceId和requestId找出和一个异常相关的所有日志。<br>在上图中，hash4是一条异常日志，我们找到hash4对应的traceId为traceId2，在日志列表中，有两条记录具有该traceId，但是hash3这条记录并不是一个动作的开始，<br>因为hash3对应的requestId为reqId2，而reqId2开始于hash2，<br>因此，我们实际上要把hash2也加入到该异常发生的整个复盘备选记录中。</p>
<p>总结起来就是，我们要找出同一个traceId对应的所有requestId对应的日志记录，虽然有点绕，但稍理解就可以明白其中的道理。</p>
<p>我们把这些和一个异常相关的所有日志集合起来，称为一个block，再利用日志的hash集合，得出这个block的hash，并在索引区中建立索引，等待上报。</p>
<h2 id="3-3-上报日志"><a href="#3-3-上报日志" class="headerlink" title="3.3 上报日志"></a>3.3 上报日志</h2><p>上报日志也在webworker中进行，为了和整理区分，可以分两个worker。<br>上报的流程大致为：在每一个循环中，从索引区取出对应条数的索引，通过索引中的hash，到归档区取出完整的日志记录，再上传到服务器。</p>
<p>按照上报的频率（重要紧急度）可将上报分为四种：</p>
<h4>a. 即时上报</h4>


<p>收集到日志后，立即触发上报函数。仅用于A类异常。而且由于受到网络不确定因素影响，A类日志上报需要有一个确认机制，只有确认服务端已经成功接收到该上报信息之后，才算完成。否则需要有一个循环机制，确保上报成功。</p>
<h4>b. 批量上报</h4>


<p>将收集到的日志存储在本地，当收集到一定数量之后再打包一次性上报，或者按照一定的频率（时间间隔）打包上传。这相当于把多次合并为一次上报，以降低对服务器的压力。</p>
<h4>c. 区块上报</h4>


<p>将一次异常的场景打包为一个区块后进行上报。它和批量上报不同，批量上报保证了日志的完整性，全面性，但会有无用信息。而区块上报则是针对异常本身的，确保单个异常相关的日志被全部上报。</p>
<h4>d. 用户主动提交</h4>


<p>在界面上提供一个按钮，用户主动反馈bug。这有利于加强与用户的互动。</p>
<p>或者当异常发生时，虽然对用户没有任何影响，但是应用监控到了，弹出一个提示框，让用户选择是否愿意上传日志。这种方案适合涉及用户隐私数据时。</p>
<table><tbody><tr><td> </td><td>即时上报</td><td>批量上报</td><td>区块上报</td><td>用户反馈</td></tr><tr><td>时效</td><td>立即</td><td>定时</td><td>稍延时</td><td>延时</td></tr><tr><td>条数</td><td>一次全部上报</td><td>一次100条</td><td>单次上报相关条目</td><td>一次1条</td></tr><tr><td>容量</td><td>小</td><td>中</td><td>–</td><td>–</td></tr><tr><td>紧急</td><td>紧急重要</td><td>不紧急</td><td>不紧急但重要</td><td>不紧急</td></tr></tbody></table>

<p>即时上报虽然叫即时，但是其实也是通过类似队列的循环任务去完成的，它主要是尽快把一些重要的异常提交给监控系统，好让运维人员发现问题，因此，它对应的紧急程度比较高。</p>
<p>批量上报和区块上报的区别：<br>批量上报是一次上报一定条数，比如每2分钟上报1000条，直到上报完成。而区块上报是在异常发生之后，马上收集和异常相关的所有日志，查询出哪些日志已经由批量上报上报过了，剔除掉，把其他相关日志上传，和异常相关的这些日志相对而言更重要一些，它们可以帮助尽快复原异常现场，找出发生异常的根源。</p>
<p>用户提交的反馈信息，则可以慢悠悠上报上去。</p>
<p>为了确保上报是成功的，在上报时需要有一个确认机制，由于在服务端接收到上报日志之后，并不会立即存入数据库，而是放到一个队列中，因此，前后端在确保日志确实已经记录进数据库这一点上需要再做一些处理。</p>
<img src="//api.webq.top/static/img/e_upload.jpg" style="max-width:100%;">

<p>上图展示了上报的一个大致流程，在上报时，先通过hash查询，让客户端知道准备要上报的日志集合中，是否存在已经被服务端保存好的日志，如果已经存在，就将这些日志去除，避免重复上报，浪费流量。</p>
<h2 id="3-4-压缩上报数据"><a href="#3-4-压缩上报数据" class="headerlink" title="3.4 压缩上报数据"></a>3.4 压缩上报数据</h2><p>一次性上传批量数据时，必然遇到数据量大，浪费流量，或者传输慢等情况，网络不好的状态下，可能导致上报失败。因此，在上报之前进行数据压缩也是一种方案。</p>
<p>对于合并上报这种情况，一次的数据量可能要十几k，对于日 pv 大的站点来说，产生的流量还是很可观的。<br>所以有必要对数据进行压缩上报。lz-string是一个非常优秀的字符串压缩类库，兼容性好，代码量少，压缩比高，压缩时间短，压缩率达到惊人的60%。但它基于LZ78压缩，如果后端不支持解压，可选择gzip压缩，一般而言后端会默认预装gzip，<br>因此，选择gzip压缩数据也可以，工具包pako中自带了gzip压缩，可以尝试使用。</p>
<h2 id="4-日志接收与存储"><a href="#4-日志接收与存储" class="headerlink" title="4 日志接收与存储"></a>4 日志接收与存储</h2><h2 id="4-1-接入层与消息队列"><a href="#4-1-接入层与消息队列" class="headerlink" title="4.1 接入层与消息队列"></a>4.1 接入层与消息队列</h2><p>一般通过提供独立的日志服务器接收客户端日志，接收过程中，要对客户端日志内容的合法性、安全性等进行甄别，防止被人攻击。而且由于日志提交一般都比较频繁，多客户端同时并发的情况也常见。通过消息队列将日志信息逐一处理后写入到数据库进行保存也是比较常用的方案。</p>
<img src="//api.webq.top/static/img/e_brower.png" style="max-width:100%;">

<p>上图为腾讯BetterJS的架构图，其中“接入层”和“推送中心”就是这里提到的接入层和消息队列。<br>BetterJS将整个前端监控的各个模块进行拆分，推送中心承担了将日志推送到存储中心进行存储和推送给其他系统（例如告警系统）的角色，<br>但我们可以把接收日志阶段的队列独立出来看，在接入层和存储层之间做一个过渡。</p>
<h2 id="4-2-日志存储系统"><a href="#4-2-日志存储系统" class="headerlink" title="4.2 日志存储系统"></a>4.2 日志存储系统</h2><p>存储日志是一个脏活累活，但是不得不做。<br>对于小应用，单库单表加优化就可以应付。<br>一个成规模的应用，如果要提供更标准高效的日志监控服务，常常需要在日志存储架构上下一些功夫。<br>目前业界已经有比较完备的日志存储方案，<br>主要有：Hbase系，Dremel系，Lucene系等。</p>
<p>总体而言，日志存储系统主要面对的问题是数据量大，数据结构不规律，写入并发高，查询需求大等。<br>一般一套日志存储系统，要解决上面这些问题，就要解决写入的缓冲，存储介质按日志时间选择，为方便快速读取而设计合理的索引系统等等。</p>
<p>由于日志存储系统方案比较成熟，这里就不再做更多讨论。</p>
<h2 id="4-3-搜索"><a href="#4-3-搜索" class="headerlink" title="4.3 搜索"></a>4.3 搜索</h2><p>日志的最终目的是要使用，由于一般日志的体量都非常大，因此，要在庞大的数据中找到需要的日志记录，需要依赖比较好的搜索引擎。<br>Splunk是一套成熟的日志存储系统，但它是付费使用的。<br>按照Splunk的框架，Elk是Splunk的开源实现，Elk是ElasticSearch、Logstash、Kibana的结合，ES基于Lucene的存储、索引的搜索引擎；<br>logstash是提供输入输出及转化处理插件的日志标准化管道；Kibana提供可视化和查询统计的用户界面。</p>
<h2 id="5-日志统计与分析"><a href="#5-日志统计与分析" class="headerlink" title="5 日志统计与分析"></a>5 日志统计与分析</h2><p>一个完善的日志统计分析工具需要提供各方面方便的面板，以可视化的方式给日志管理员和开发者反馈信息。</p>
<h2 id="5-1-用户纬度"><a href="#5-1-用户纬度" class="headerlink" title="5.1 用户纬度"></a>5.1 用户纬度</h2><p>同一个用户的不同请求实际上会形成不同的story线，因此，针对用户的一系列操作设计唯一的request id是有必要的。同一个用户在不同终端进行操作时，也能进行区分。用户在进行某个操作时的状态、权限等信息，也需要在日志系统中予以反应。</p>
<h2 id="5-2-时间维度"><a href="#5-2-时间维度" class="headerlink" title="5.2 时间维度"></a>5.2 时间维度</h2><p>一个异常是怎么发生的，需要将异常操作的前后story线串联起来观察。它不单单涉及一个用户的一次操作，甚至不限于某一个页面，而是一连串事件的最终结果。</p>
<h2 id="5-3-性能维度"><a href="#5-3-性能维度" class="headerlink" title="5.3 性能维度"></a>5.3 性能维度</h2><p>应用运行过程中的性能情况，例如，界面加载时间，api请求时长统计，单元计算的消耗，用户呆滞时间。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-4-运行环境维度"><a href="#5-4-运行环境维度" class="headerlink" title="5.4 运行环境维度"></a>5.4 运行环境维度</h2><p>应用及服务所运行的环境情况，例如应用所在的网络环境，操作系统，设备硬件信息等，服务器cpu、内存状况，网络、宽带使用情况等。</p>
<h2 id="5-4-细粒度代码追踪"><a href="#5-4-细粒度代码追踪" class="headerlink" title="5.4 细粒度代码追踪"></a>5.4 细粒度代码追踪</h2><p>异常的代码stack信息，定位到发生异常的代码位置和异常堆栈。</p>
<h2 id="5-6-场景回溯"><a href="#5-6-场景回溯" class="headerlink" title="5.6 场景回溯"></a>5.6 场景回溯</h2><p>通过将异常相关的用户日志连接起来，以动态的效果输出发生异常的过程。</p>
<h2 id="6-监控与通知"><a href="#6-监控与通知" class="headerlink" title="6 监控与通知"></a>6 监控与通知</h2><p>对异常进行统计和分析只是基础，而在发现异常时可以推送和告警，甚至做到自动处理，才是一个异常监控系统应该具备的能力。</p>
<h2 id="6-1-自定义触发条件的告警"><a href="#6-1-自定义触发条件的告警" class="headerlink" title="6.1 自定义触发条件的告警"></a>6.1 自定义触发条件的告警</h2><p>a. 监控实现</p>
<p>当日志信息进入接入层时，就可以触发监控逻辑。当日志信息中存在较为高级别的异常时，也可以立即出发告警。告警消息队列和日志入库队列可以分开来管理，实现并行。</p>
<p>对入库日志信息进行统计，对异常信息进行告警。对监控异常进行响应。所谓监控异常，是指：有规律的异常一般而言都比较让人放心，比较麻烦的是突然之间的异常。例如在某一时段突然频繁接收到D级异常，虽然D级异常是不紧急一般重要，但是当监控本身发生异常时，就要提高警惕。</p>
<p>b. 自定义触发条件</p>
<p>除了系统开发时配置的默认告警条件，还应该提供给日志管理员可配置的自定义触发条件。</p>
<ul><li>日志内含有什么内容时</li><li>日志统计达到什么度、量时</li><li>向符合什么条件的用户告警</li><li>
</li></ul>
## 6.2 推送渠道


<p>可选择的途径有很多，例如邮件、短信、微信、电话。</p>
<h2 id="6-3-推送频率"><a href="#6-3-推送频率" class="headerlink" title="6.3 推送频率"></a><span style="font-size: 14px;">6.3 推送频率</h2><span style="font-size: 14px;">

<p>针对不同级别的告警，推送的频率也可以进行设定。低风险告警可以以报告的形式一天推送一次，高风险告警10分钟循环推送，直到处理人手动关闭告警开关。</p>
<h2 id="6-4-自动报表"><a href="#6-4-自动报表" class="headerlink" title="6.4 自动报表"></a>6.4 自动报表</h2><p>对于日志统计信息的推送，可以做到自动生成日报、周报、月报、年报并邮件发送给相关群组。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="6-5-自动产生bug工单"><a href="#6-5-自动产生bug工单" class="headerlink" title="6.5 自动产生bug工单"></a>6.5 自动产生bug工单</h2><p>当异常发生时，系统可以调用工单系统API实现自动生成bug单，工单关闭后反馈给监控系统，形成对异常处理的追踪信息进行记录，在报告中予以展示。</p>
<h2 id="7-修复异常"><a href="#7-修复异常" class="headerlink" title="7 修复异常"></a>7 修复异常</h2><h2 id="7-1-sourcemap"><a href="#7-1-sourcemap" class="headerlink" title="7.1 sourcemap"></a>7.1 sourcemap</h2><p>前端代码大部分情况都是经过压缩后发布的，上报的stack信息需要还原为源码信息，才能快速定位源码进行修改。</p>
<p>发布时，只部署js脚本到服务器上，将sourcemap文件上传到监控系统，在监控系统中展示stack信息时，利用sourcemap文件对stack信息进行解码，得到源码中的具体信息。</p>
<p>但是这里有一个问题，就是sourcemap必须和正式环境的版本对应，还必须和git中的某个commit节点对应，这样才能保证在查异常的时候可以正确利用stack信息，找到出问题所在版本的代码。这些可以通过建立CI任务，在集成化部署中增加一个部署流程，以实现这一环节。</p>
<h2 id="7-2-从告警到预警"><a href="#7-2-从告警到预警" class="headerlink" title="7.2 从告警到预警"></a>7.2 从告警到预警</h2><p>预警的本质是，预设可能出现异常的条件，当触发该条件时异常并没有真实发生，因此，可以赶在异常发生之前对用户行为进行检查，及时修复，避免异常或异常扩大。</p>
<p>怎么做呢？其实就是一个统计聚类的过程。将历史中发生异常的情况进行统计，从时间、地域、用户等不同维度加以统计，找出规律，并将这些规律通过算法自动加入到预警条件中，当下次触发时，及时预警。</p>
<h2 id="7-3-智能修复"><a href="#7-3-智能修复" class="headerlink" title="7.3 智能修复"></a>7.3 智能修复</h2><p>自动修复错误。例如，前端要求接口返回数值，但接口返回了数值型的字符串，那么可以有一种机制，监控系统发送正确数据类型模型给后端，后端在返回数据时，根据该模型控制每个字段的类型。</p>
<h2 id="8-异常测试"><a href="#8-异常测试" class="headerlink" title="8 异常测试"></a>8 异常测试</h2><h2 id="8-1-主动异常测试"><a href="#8-1-主动异常测试" class="headerlink" title="8.1 主动异常测试"></a>8.1 主动异常测试</h2><p>撰写异常用例，在自动化测试系统中，加入异常测试用户。在测试或运行过程中，每发现一个异常，就将它加入到原有的异常用例列表中。</p>
<h2 id="8-2-随机异常测试"><a href="#8-2-随机异常测试" class="headerlink" title="8.2 随机异常测试"></a>8.2 随机异常测试</h2><p>模拟真实环境，在模拟器中模拟真实用户的随机操作，利用自动化脚本产生随机操作动作代码，并执行。<br>定义异常，例如弹出某个弹出框，包含特定内容时，就是异常。将这些测试结果记录下来，再聚类统计分析，对防御异常也很有帮助。</p>
<h2 id="9-部署"><a href="#9-部署" class="headerlink" title="9 部署"></a>9 部署</h2><h2 id="9-1-多客户端"><a href="#9-1-多客户端" class="headerlink" title="9.1 多客户端"></a>9.1 多客户端</h2><p>一个用户在不同终端上登录，或者一个用户在登录前和登录后的状态。通过特定算法生成requestID，通过该requestId可以确定某个用户在独立客户端上的一系列操作，根据日志时序，可以梳理出用户产生异常的具体路径。</p>
<h2 id="9-2-集成便捷性"><a href="#9-2-集成便捷性" class="headerlink" title="9.2 集成便捷性"></a>9.2 集成便捷性</h2><p>前端写成包，全局引用即可完成大部分日志记录、存储和上报。在特殊逻辑里面，可以调用特定方法记录日志。<br>后端与应用本身的业务代码解耦，可以做成独立的服务，通过接口和第三方应用交互。利用集成部署，可以将系统随时进行扩容、移植等操作。</p>
<h2 id="9-3-管理系统的可扩展"><a href="#9-3-管理系统的可扩展" class="headerlink" title="9.3 管理系统的可扩展"></a>9.3 管理系统的可扩展</h2><p>整套系统可扩展，不仅服务单应用，可支持多个应用同时运行。同一个团队下的所有应用都可以利用同一个平台进行管理。</p>
<h2 id="9-4-日志系统权限"><a href="#9-4-日志系统权限" class="headerlink" title="9.4 日志系统权限"></a>9.4 日志系统权限</h2><p>不同的人在访问日志系统时权限不同，一个访问者只能查看自己相关的应用，有些统计数据如果比较敏感，可以单独设置权限，敏感数据可脱敏。</p>
<h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10 其他"></a>10 其他</h2><h2 id="10-1-性能监控"><a href="#10-1-性能监控" class="headerlink" title="10.1 性能监控"></a>10.1 性能监控</h2><p>异常监控主要针对代码级别的报错，但也应该关注性能异常。性能监控主要包括：</p>
<ul><li>运行时性能：文件级、模块级、函数级、算法级</li><li>网络请求速率</li><li>系统性能
</li><li>
</li></ul>
## 10.2 API Monitor


<p>后端API对前端的影响也非常大，虽然前端代码也控制逻辑，但是后端返回的数据是基础，因此对API的监控可以分为：</p>
<ul><li>稳定性监控</li><li>数据格式和类型</li><li>报错监控</li><li>数据准确性监控</li><li>
</li></ul>
## 10.3 数据脱敏


<p>敏感数据不被日志系统采集。由于日志系统的保存是比较开放的，虽然里面的数据很重要，但是在存储上大部分日志系统都不是保密级，因此，如果应用涉及了敏感数据，最好做到：</p>
<ul><li>独立部署，不和其他应用共享监控系统</li><li>不采集具体数据，只采集用户操作数据，在重现时，通过日志信息可以取出数据api结果来展示</li><li>日志加密，做到软硬件层面的加密防护</li><li>必要时，可采集具体数据的ID用于调试，场景重现时，用mock数据替代，mock数据可由后端采用假的数据源生成</li><li>对敏感数据进行混淆</li></ul>


<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要是对前端异常监控的整体框架进行了研究，没有涉及到具体的技术实现，涉及前端部分和后台部分以及与整个问题相关的一些知识点，主要关注前端部分，它和后端的监控有重叠部分也有分支部分，需要在一个项目中不断实践，总结出项目本身的监控需求和策略。</p>
]]></content>
  </entry>
  <entry>
    <title>Gitlab CI/CD管道配置参考</title>
    <url>/2020/11/19/doc/ci/</url>
    <content><![CDATA[<h3 id="Gitlab-CI-CD管道配置参考"><a href="#Gitlab-CI-CD管道配置参考" class="headerlink" title="Gitlab CI/CD管道配置参考"></a>Gitlab CI/CD管道配置参考</h3><p>在每个项目中，使用名为.gitlab-ci.yml的yaml文件配置Gitlab CI/CD管道。</p>
<p>.gitlab-ci.yml文件定义了管道的结构和顺序，并确定：</p>
<p>使用Gitlab Runner执行什么。</p>
<p>遇到特殊情况时要做什么决定？例如，当一个进程成功或失败时。</p>
<p>本主题介绍CI/CD管道配置。有关其他CI/CD配置信息，请参阅：</p>
<p>Gitlab CI/CD变量，用于配置管道运行的环境。</p>
<p>Gitlab Runner高级配置，用于配置Gitlab Runner。</p>
<p>我们有配置管道的完整示例：</p>
<p>要快速介绍Gitlab CI，请遵循我们的快速入门指南。</p>
<p>有关示例的集合，请参见Gitlab CI/CD示例。</p>
<p>要查看企业中使用的大型.gitlab-ci.yml文件，请参见gitlab ce的.gitlab-ci.yml文件。</p>
<blockquote>
<p>如果你有一个镜像存储库，其中有gitlab，你可能需要在项目的Settings &gt; Repository &gt; Pull from a remote repository &gt; Trigger镜像更新管道。</p>
</blockquote>
<h3 id="a1">1. 介绍</h3>

<p>管道配置从job开始。jobs是.gitlab-ci.yml文件最基本的元素。</p>
<p>工作包括：</p>
<p>定义了在什么条件下应该执行它们的约束。</p>
<p>具有任意名称的顶级元素，必须至少包含script子句。</p>
<p>不限于可定义的数量。</p>
<p>例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;execute-script-for-job1&quot;</span></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;execute-script-for-job2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例是最简单的CI/CD配置，有两个独立的job，其中每个job执行不同的命令。当然，命令可以直接执行代码（./configure；make；make install）或者在存储库中运行script（test.sh）。<br>工作由Runners挑选并在Runner的环境。重要的是，每个job都在运行彼此独立。</p>
<h3 id="a2">2. 验证 .gitlab-ci.yml</h3>

<p>Gitlab CI的每个实例都有一个名为lint的嵌入式调试工具，用于验证.gitlab-ci.yml文件的内容。您可以在您的页面ci/lint下找到lint。项目命名空间。例如，<a href="https://gitlab.example.com/gitlab-org/project-123//ci/lint%E3%80%82">https://gitlab.example.com/gitlab-org/project-123//ci/lint。</a></p>
<h3 id="a3">3. Unavailable names for jobs </h3>

<p>每个job必须有一个唯一的名称，但有一些保留的关键字不能用作job名称：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">image</span></span><br><span class="line"><span class="string">services</span></span><br><span class="line"><span class="string">stages</span></span><br><span class="line"><span class="string">types</span></span><br><span class="line"><span class="string">before_script</span></span><br><span class="line"><span class="string">after_script</span></span><br><span class="line"><span class="string">variables</span></span><br><span class="line"><span class="string">cache</span></span><br></pre></td></tr></table></figure>
<h3 id="a4">4. 使用保留关键字</h3>

<p>如果在使用特定值（例如，true or false）时出现验证错误，请尝试：</p>
<p>–引用它们。</p>
<p>–将它们更改为其他形式。例如，/bin/true。</p>
<h3 id="a5">5. 配置参数</h3>

<p>job定义为定义job行为的参数列表。</p>
<p>下表列出了job的可用参数：</p>
<table class="code">
<tbody>
    <tr>
        <td>Keyword</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>script</td>
        <td>由运行程序执行的shell脚本。</td>
    </tr>
    <tr>
        <td>image</td>
        <td>使用Docker图像。还提供：image:name和image:entrypoint。</td>
    </tr>
    <tr>
        <td>services</td>
        <td>使用Docker服务图像。还提供：services:name、services:alias、services:entrypoint和services:command。</td>
    </tr>
    <tr>
        <td>before_script</td>
        <td>重写在job之前执行的一组命令。</td>
    </tr>
    <tr>
        <td>after_script</td>
        <td>重写在job后执行的一组命令。</td>
    </tr>
    <tr>
        <td>stages</td>
        <td>定义管道中的阶段。</td>
    </tr>
    <tr>
        <td>stage</td>
        <td>定义job阶段（default: test）。</td>
    </tr>
    <tr>
        <td>only</td>
        <td>限制创建 when jobs。还可用：only：refs，only：kubernetes，only：variables，only：changes。</td>
    </tr>
    <tr>
        <td>except</td>
        <td>限制未创建 when jobs。还可用：except:refs，except:kubernetes，except:variables和except:changes。</td>
    </tr>
    <tr>
        <td>tags</td>
        <td>用于选择运行程序的标记列表。</td>
    </tr>
    <tr>
        <td>allow_failure</td>
        <td>允许job失败。失败的job不影响提交状态。</td>
    </tr>
    <tr>
        <td>when</td>
        <td>何时运行job。还可用：when:manual and when:delayed。</td>
    </tr>
    <tr>
        <td>environment</td>
        <td>job部署到的环境的名称。还可用：environment:name, environment:url, environment:on_stop, and environment:action.</td>
    </tr>
    <tr>
        <td>cache</td>
        <td>在后续运行之间应缓存的文件列表。还可用：cache:paths, cache:key, cache:untracked, and cache:policy.。</td>
    </tr>
    <tr>
        <td>artifacts</td>
        <td>成功时要附加到job的文件和目录列表。还可用：artifacts:paths, artifacts:name, artifacts:untracked, artifacts:when, artifacts:expire_in, artifacts:reports, and artifacts:reports:junit。在Gitlab企业版中，这些可用：artifacts:reports:codequality, artifacts:reports:sast, artifacts:reports:dependency_scanning, artifacts:reports:container_scanning, artifacts:reports:dast, artifacts:reports:license_management, artifacts:reports:performance and artifacts:reports:metrics。</td>
    </tr>
    <tr>
        <td>dependencies</td>
        <td>job所依赖的其他job，以便在它们之间传递artifacts。</td>
    </tr>
    <tr>
        <td>coverage</td>
        <td>给定job的代码覆盖率设置。</td>
    </tr>
    <tr>
        <td>retry</td>
        <td>如果出现故障，一个job可以自动重试的时间和次数。</td>
    </tr>
    <tr>
        <td>parallel</td>
        <td>一个job应并行运行多少个实例。</td>
    </tr>
    <tr>
        <td>trigger</td>
        <td>定义下游管道触发器。</td>
    </tr>
    <tr>
        <td>include</td>
        <td>允许此job包含外部yaml文件。还提供：include:local、include:file、include:template和include:remote。</td>
    </tr>
    <tr>
        <td>extends</td>
        <td>此job将从中继承的配置项。</td>
    </tr>
    <tr>
        <td>pages</td>
        <td>上载job的结果以用于Gitlab页面。</td>
    </tr>
    <tr>
        <td>variables</td>
        <td>在job级别定义job变量。</td>
    </tr>
</tbody>
</table>

<blockquote>
<p>NOTE: Note:Parameters types and type are deprecated.(弃用)</p>
</blockquote>
<h3 id="a6">6. 设置默认参数</h3>

<p>某些参数可以全局设置为所有job的默认值，使用默认值：关键字。然后，默认参数可以被特定于job的参数覆盖配置。</p>
<p>可以在默认块内定义以下job参数：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">image</span></span><br><span class="line"><span class="string">services</span></span><br><span class="line"><span class="string">before_script</span></span><br><span class="line"><span class="string">after_script</span></span><br><span class="line"><span class="string">cache</span></span><br></pre></td></tr></table></figure>

<p>在下面的示例中，ruby:2.5图像被设置为所有图像的默认值。job，rspec 2.6job除外，它使用ruby:2.6映像：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec 2.6:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ruby:2.6</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>
<h3 id="a7">7. 参数详细信息</h3>

<p>以下是用于配置CI/CD管道的参数的详细说明。</p>
<h4 id="a7-1">7.1. script</h4>

<p>script是job所需的唯一关键字。这是一个shellscript由运行程序执行。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;bundle exec rspec&quot;</span></span><br></pre></td></tr></table></figure>

<p>此参数还可以包含使用数组的多个命令：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时，script命令需要用单引号或双引号括起来。例如，包含冒号（：）的命令需要用引号括起来，因此yaml解析器知道将整个事件解释为字符串而不是“key:value”对。使用特殊字符时要小心:<br>:, {, }, [, ], ,, &amp;, *, #, ?, |, -, &lt;, &gt;, =, !, %, @, `.</p>
</blockquote>
<h3 id="a7-2">7.2. image</h3>

<p>用于指定要用于job的Docker映像。</p>
<p>用于：</p>
<p>简单定义示例，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener noreferrer">请参见从.gitlab-ci.yml定义图像和服务。</a> </p>
<p>详细使用信息，<a href="https://gitlab.com/help/ci/docker/README.md" target="_blank" rel="noopener noreferrer">请参阅Docker集成文档。</a> </p>
<h4>image:name</h4>

<p><a href="https://gitlab.com/help/ci/docker/using_docker_images.md#extended-docker-configuration-options" target="_blank" rel="noopener noreferrer">扩展Docker配置选项。</a> </p>
<p>有关详细信息，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#available-settings-for-image" target="_blank" rel="noopener noreferrer">请参阅图像的可用设置。</a> </p>
<h4>image:entrypoint</h4>

<p>扩展Docker配置选项。</p>
<p>有关详细信息，请参阅图像的可用设置。</p>
<h3 id="a7-3">7.3. services</h3>

<p>用于指定服务Docker映像，链接到映像中指定的基映像。</p>
<p>用于：</p>
<p>简单定义示例，请参见从.gitlab-ci.yml定义图像和服务。</pp></p>
<p>详细使用信息，请参阅Docker集成文档。</p>
<p>例如服务，<a href="https://gitlab.com/help/ci/services/README.md" target="_blank" rel="noopener noreferrer">请参见Gitlab CI Services。</a> </p>
<h4>services:name</h4>

<p>扩展Docker配置选项。有关详细信息，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#available-settings-for-services" target="_blank" rel="noopener noreferrer"> 请参阅“服务的可用设置”。</a></p>
<h4>services:alias</h4>

<p>扩展Docker配置选项。有关详细信息，请参阅“服务的可用设置”。</p>
<h4>services:entrypoint</h4>

<p>扩展Docker配置选项。有关详细信息，请参阅“服务的可用设置”。</p>
<h4>services:command</h4>

<p>扩展Docker配置选项。有关详细信息，请参阅“服务的可用设置”。</p>
<h3 id="a7-4">7.4. before_script / after_script</h3>

<p>before_script用于定义应在所有命令之前运行的命令job，包括部署job，但在恢复artifacts之后。这可以是一个数组或多行字符串。</p>
<p>after_script用于定义将要运行的命令job，包括失败的job。这必须是一个数组或多行字符串。</p>
<p>在before_script指定的script是：</p>
<p>与主script中指定的script连接。工作级别在script定义之前覆盖全局级别在script定义之前与script定义连接时。</p>
<p>与主scriptscript一起在单个shell中作为一个script执行上下文。</p>
<p>after_script指定的script：</p>
<p>将当前工作目录设置回默认值。</p>
<p>在与script和script之前分开的shell上下文中执行script。</p>
<p>由于上下文分隔，无法查看定义的script所做的更改在“script”或“before_script”，请执行以下操作之一：</p>
<p>在外壳中。例如，script中导出的命令别名和变量script。</p>
<p>在工作树之外（取决于运行者执行者）。例如，由before_script或scriptscript安装的软件。</p>
<p>可以覆盖在script之前和之后定义的全局,如果按job设置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">global</span> <span class="string">before</span> <span class="string">script</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute</span> <span class="string">this</span> <span class="string">instead</span> <span class="string">of</span> <span class="string">global</span> <span class="string">before</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my</span> <span class="string">command</span></span><br><span class="line">  <span class="attr">after_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute</span> <span class="string">this</span> <span class="string">after</span> <span class="string">my</span> <span class="string">script</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-5">7.5. stages</h3>

<p>stages用于全局定义job可以使用的阶段</p>
<p>stages的规格允许有灵活的多级管道。stages中元素的顺序定义了job执行的顺序：</p>
<p>同一阶段的job并行运行。</p>
<p>下一阶段的job在上一阶段的job之后运行成功完成。</p>
<p>让我们考虑下面的例子，它定义了3个阶段：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p>首先，build的所有job都是并行执行的。</p>
<p>如果build的所有job都成功，则test job将并行执行。</p>
<p>如果test的所有job都成功，则deploy job将并行执行。</p>
<p>如果Deploy的所有job都成功，则提交标记为通过。</p>
<p>如果以前的任何job失败，提交将标记为失败，并且不</p>
<p>执行下一阶段的工作。</p>
<p>还有两个边缘案例值得一提：</p>
<p>如果在.gitlab-ci.yml中没有定义阶段，默认情况下，build, test and deploy用作job的阶段。</p>
<p>如果job未指定阶段，则该job将被分配到test阶段。</p>
<h3 id="a7-6">7.6. stage</h3>

<p>stage是定义单个job，并依赖于全局的stages。它允许将job分组到不同的阶段，并且相同的job阶段是并行执行的（取决于某些条件）。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 1:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 2:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">artifacts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 3:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job 4:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p>Using your own Runners</p>
<p>使用自己的运行程序时，默认情况下，Gitlab运行程序一次只运行一个job（请参见运行程序全局设置中的并发标志）。</p>
<p>只有在以下情况下，job才会并行运行：</p>
<p>在不同程序上运行</p>
<p>运行程序的并发设置已更改。</p>
<h3 id="a7-7">7.7. only/except (basic)</h3>

<p>only和except两个参数将job策略设置为限制创建的job：</p>
<p>only定义要为其运行job的分支和标记的名称。</p>
<p>except定义排除的job</p>
<p>有一些规则适用于job策略的使用：</p>
<p>only和except是包容性的。如果只定义only和except在job规范中，引用only由和except。</p>
<p>only和except允许使用正则表达式（支持的regexp语法）。</p>
<p>only和except允许指定用于筛选job的存储库路径分支。</p>
<p>此外，only和except情况允许使用特殊关键字：</p>
<table class="code">
<tbody>
    <tr>
        <td>Value</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>branches</td>
        <td>当管道的Git引用是分支时。</td>
    </tr>
    <tr>
        <td>tags</td>
        <td>当管道的Git引用是标记时。</td>
    </tr>
    <tr>
        <td>api</td>
        <td>当管道被第二个管道API触发时（而不是触发API）。</td>
    </tr>
    <tr>
        <td>external</td>
        <td>使用Gitlab以外的CI服务时。</td>
    </tr>
    <tr>
        <td>pipelines</td>
        <td>对于多项目触发器，使用带有CI_JOB_TOKEN的API创建的。</td>
    </tr>
    <tr>
        <td>pushes</td>
        <td>管道由用户的git push触发。</td>
    </tr>
    <tr>
        <td>schedules</td>
        <td>用于计划的管道。</td>
    </tr>
    <tr>
        <td>triggers</td>
        <td>用于使用触发器标记创建的管道。</td>
    </tr>
    <tr>
        <td>web</td>
        <td>对于使用Gitlab UI中的“运行管道”按钮创建的管道（在项目的管道下）。</td>
    </tr>
    <tr>
        <td>merge_requests</td>
        <td>创建或更新合并请求时（有关合并请求，请参阅管道）。</td>
    </tr>
    <tr>
        <td>chats</td>
        <td>对于使用gitlab chatops命令创建的job。</td>
    </tr>
</tbody>
</table>


<p>在下面的示例中，job将仅对以问题-开头的引用运行，鉴于将跳过所有分支：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use regexp</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^issue-.*$/</span></span><br><span class="line">  <span class="comment"># use special keyword</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，模式匹配区分大小写。使用i标志修饰符，如/pattern/i使模式不区分大小写：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use regexp</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^issue-.*$/i</span></span><br><span class="line">  <span class="comment"># use special keyword</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches</span></span><br></pre></td></tr></table></figure>

<p>在本例中，job将仅对标记的引用运行，或者如果通过API触发器或管道计划显式请求生成：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use special keywords</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">triggers</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">schedules</span></span><br></pre></td></tr></table></figure>

<p>存储库路径只能用于执行父存储库的job，而不能用于分叉：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches@gitlab-org/gitlab-ce</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master@gitlab-org/gitlab-ce</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/^release/.*$/@gitlab-org/gitlab-ce</span></span><br></pre></td></tr></table></figure>

<p>上面的示例将为gitlab-org/gitlab-ce上的所有分支运行job，master和以release/作为前缀的分支除外。</p>
<p>only默认值：’’branches’、’tags’]</p>
<p>except默认值为空。</p>
<p>例如，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">echo</span> <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">echo</span> <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="attr">only:</span> [<span class="string">&#x27;branches&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4>Regular expressions</h4>

<p>因为@用于表示引用存储库路径的开头，匹配正则表达式中包含@字符的引用名称需要使用十六进制字符代码match \x40。</p>
<p>只有标记或分支名称才能与正则表达式匹配。如果给定存储库路径，则始终按字面匹配。</p>
<p>如果使用正则表达式来匹配标记或分支名称，模式的整个引用名称部分必须是正则表达式，必须用/包围。（在结束/后附加正则表达式标志）因此，问题-/.*/无法匹配所有标记名或分支名从问题开始。</p>
<blockquote>
<p>使用锚^和$避免正则表达式只匹配标记名或分支名的子字符串。例如，/^issue-.$/等于/^issue-/，而just/issue/也将匹配一个称为严重问题的分支。</p>
</blockquote>
<p>Supported only/except regexp syntax</p>
<p>警告：警告：这是Gitlab 11.9.4引入的突破性变化。</p>
<p>在Gitlab 11.9.4中，Gitlab开始内部转换使用的regexp仅限RE2和RE2的参数。</p>
<p>这意味着只有RubyRegexp提供的特性的子集支持。RE2限制了功能集由于计算的复杂性，这意味着一些特性在Gitlab 11.9.4中变得不可用。例如，负数lookaheads。</p>
<p>对于11.9.7到Gitlab 12.0的Gitlab版本，Gitlab提供了一个可以由管理员启用，允许用户使用不安全的regexp语法。这带来了兼容性使用以前允许的语法版本，并允许用户优雅地迁移到新语法。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Feature.enable(:allow_unsafe_ruby_regexp)</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-8">7.8. only/except (advanced)高级</h3>

<p>警告：警告：这是一个alpha功能，随时可能更改，恕不另行通知！</p>
<p>Gitlab支持简单和复杂的策略，因此可以使用数组和哈希配置方案。</p>
<p>有四把钥匙：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">refs</span></span><br><span class="line"><span class="string">variables</span></span><br><span class="line"><span class="string">changes</span></span><br><span class="line"><span class="string">kubernetes</span></span><br></pre></td></tr></table></figure>

<p>If you use multiple keys under only or except, they act as an AND. The logic is:</p>
<p>(any of refs) AND (any of variables) AND (any of changes) AND (if kubernetes is active)</p>
<h4>only:refs/except:refs</h4>

<p>refs策略可以采用与仅简化/例外配置相同的值。</p>
<p>在下面的示例中，只有在为主分支计划管道或运行管道时，才会创建部署job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">schedules</span></span><br></pre></td></tr></table></figure>
<h4>only:kubernetes/except:kubernetes</h4>

<p>kubernetes策略只接受活动关键字。</p>
<p>在下面的示例中，只有当项目中的kubernetes服务处于活动状态时，才会创建部署job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">kubernetes:</span> <span class="string">active</span></span><br></pre></td></tr></table></figure>
<h4>only:variables/except:variables</h4>

<p>variables关键字用于定义变量表达式。换句话说，您可以使用预定义的变量/project/group或环境范围的变量来定义一个表达式gitlab将要评估，以决定是否应该创建一个job。</p>
<p>使用变量表达式的示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">cap</span> <span class="string">staging</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RELEASE</span> <span class="string">==</span> <span class="string">&quot;staging&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$STAGING</span></span><br></pre></td></tr></table></figure>

<p>另一个用例是根据提交消息排除job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">end-to-end:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">test:end-to-end</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$CI_COMMIT_MESSAGE</span> <span class="string">=~</span> <span class="string">/skip-end-to-end-tests/</span></span><br></pre></td></tr></table></figure>
<p><a href="https://gitlab.com/help/ci/variables/README.md#environment-variables-expressions" target="_blank" rel="noopener noreferrer">Learn more about variables expressions.</a></p>
<h4>only:changes/except:changes</h4>

<p>使用changes关键字only或except可以定义是否应基于Git push事件修改的文件创建job。</p>
<p>For example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker build:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">my-image:$CI_COMMIT_REF_SLUG</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker/scripts/*</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dockerfiles/**/*</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">more_scripts/*.&#123;rb,py,sh&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上面的场景中，将多个提交推送到Gitlab时，分支，Gitlab创建并触发Docker构建job，前提是提交包含对以下任一项的更改：</p>
<p>Dockerfile文件。</p>
<p>docker/scripts/directory中的任何文件。</p>
<p>dockerfiles目录中的任何文件和子目录。</p>
<p>more_scripts目录中任何具有rb、py、sh扩展名的文件。</p>
<p>您还可以使用glob模式来匹配repo根目录或repo中的任何目录中的多个文件。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;*.json&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;**/*.sql&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的示例中，表达式被双引号括起来，因为它们是全局模式。Gitlab将无法解析带有未封装的glob模式的.gitlab-ci.yml文件。</p>
</blockquote>
<p>如果在repo根目录下扩展名为.md的任何文件中检测到更改，则以下示例将跳过CIjob：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;*.md&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：警告：在将此功能与新的分支和标记一起使用时，需要注意一些事项。请参阅下面的部分。</p>
</blockquote>
<p>使用带有新分支和标记的更改</p>
<p>在将新分支或新标记推送到Gitlab时，，策略的计算结果始终为true，Gitlab将创建job。此功能尚未与合并请求连接，并且，由于Gitlab正在创建管道，用户才能创建合并请求，因此此时目标分支的位置未知。</p>
<p>对合并请求使用更改</p>
<p>对于合并请求的管道，可以根据合并请求中修改的文件定义要创建的job。</p>
<p>For example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker build service one:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">my-service-one-image:$CI_COMMIT_REF_SLUG</span> <span class="string">.</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">merge_requests</span></span><br><span class="line">    <span class="attr">changes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">service-one/**/*</span></span><br></pre></td></tr></table></figure>

<p>在上面的场景中，如果创建或更新合并请求以更改service one目录或dockerfile中的文件，那么gitlab将创建并触发docker build service onejob。</p>
<h3 id="a7-9">7.9.  tags</h3>

<p>tags用于从允许运行此项目的所有运行者列表中选择特定的运行者。</p>
<p>在注册运行程序期间，可以指定运行程序的tags，例如ruby、postgres、development。</p>
<p>tags允许您使用分配了指定tags的运行者运行job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ruby</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>

<p>上面的规范将确保job由同时定义了ruby和postgres标记的运行程序构建。</p>
<p>标签也是在不同平台上运行不同job的好方法，例如，给定一个带有标签OSX的OSX运行程序和带有标签的Windows运行程序Windows，以下job在各自的平台上运行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">windows job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">windows</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">%USERNAME%!</span></span><br><span class="line"></span><br><span class="line"><span class="attr">osx job:</span></span><br><span class="line">  <span class="attr">stage:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">osx</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Hello, $USER!&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-10">7.10. allow_failure</h3>

<p>允许失败允许job失败而不影响CI套件的其余部分。默认值为假，手动job除外。</p>
<p>当启用并且job失败时，该job将在用户界面中显示橙色警告。但是，管道的逻辑流会将job视为成功/通过，并且不会被阻塞。</p>
<p>假设所有其他job都成功，则job的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记为“通过”，没有警告。</p>
<p>在下面的示例中，job1和job2将并行运行，但如果job1失败，则不会停止下一阶段的运行，因为它标记为allow_failure:true:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute_script_that_will_fail</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute_script_that_will_succeed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job3:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy_to_staging</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-11">7.11. when</h3>

<p>用于实现在失败或失败时运行的job。</p>
<p>when可以设置为以下值之一：</p>
<p>on_success-仅当先前阶段的所有job成功时执行job（或由于标记为“允许失败”而被视为成功）。这是默认设置。</p>
<p>on_failure-仅当先前阶段中的至少一个job失败时才执行job。</p>
<p>always-执行job，而不管先前阶段的job状态如何。</p>
<p>manual-手动执行job（在Gitlab 8.10中添加）。<a href="https://gitlab.com/help/ci/yaml/README.md#whenmanual" target="_blank" rel="noopener noreferrer">阅读下面的手动操作</a> 。</p>
<p>For example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cleanup_build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cleanup</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">make</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_build_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">cleanup_build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cleanup</span> <span class="string">build</span> <span class="string">when</span> <span class="string">failed</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">on_failure</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">cleanup</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cleanup</span> <span class="string">after</span> <span class="string">jobs</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>上面的脚本将：</p>
<p>仅当build_job失败时才执行cleanup_build_job。</p>
<p>始终在最后执行cleanup_job而不管成功或失败。</p>
<p>允许您从Gitlab的用户界面手动执行Deploy_job。</p>
<h4>when:manual</h4>

<p>手动操作是一种特殊类型的job，不能自动执行，需要由用户显式启动。手动操作的一个示例用法是部署到生产环境。可以从管道、job、环境和部署视图启动手动操作。<a href="https://gitlab.com/help/ci/environments.md#configuring-manual-deployments" target="_blank" rel="noopener noreferrer">Read more at the<br>environments documentation.</a> </p>
<p>手动操作可以是可选的，也可以是阻塞的。阻止手动操作将在定义此操作的阶段阻止管道的执行。它是当有人通过单击播放按钮执行阻止手动操作时，可以恢复管道的执行。</p>
<p>当管道被阻塞时，如果设置了“管道成功时合并”，则不会合并管道。阻塞的管道也有一个特殊的状态，称为手动。默认情况下，手动操作是非阻塞的。如果要进行手动操作阻止，则必须在.gitlab-ci.yml中的job定义中添加allow_failure:false。</p>
<p>可选的手动操作默认情况下allow_failure: true，其状态不会影响整个管道状态。因此，如果手动操作失败，管道最终会成功。</p>
<p>手动操作被认为是写操作，因此当用户希望触发操作时，将使用受保护分支的权限。换句话说，为了触发分配给正在运行管道的分支的手动操作，用户需要能够合并到此分支。</p>
<h4>when:delayed</h4>

<p>延迟job用于在一段时间后执行脚本。如果希望避免job立即进入挂起状态，则此操作非常有用。</p>
<p>您可以用start_in键设置周期。除非提供了一个单位，否则start_in key的值是以秒为单位的已用时间,并且时间必须小于或等于一小时。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="string">seconds</span></span><br><span class="line"><span class="number">30</span> <span class="string">minutes</span></span><br><span class="line"><span class="number">1</span> <span class="string">hour</span></span><br></pre></td></tr></table></figure>

<p>当某个阶段中存在延迟job时，管道将不会进行，直到延迟job完成。这意味着这个关键字也可以用于在不同阶段之间插入延迟。</p>
<p>延迟job的计时器在上一阶段完成后立即启动。与其他类型的job类似，延迟job的计时器将不会启动，除非上一阶段已通过。</p>
<p>下面的示例创建一个名为Timed Rollow 10%的job，该job在上一阶段完成30分钟后执行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">timed</span> <span class="string">rollout</span> <span class="number">10</span><span class="string">%:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">echo</span> <span class="string">&#x27;Rolling out 10% ...&#x27;</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">delayed</span></span><br><span class="line">  <span class="attr">start_in:</span> <span class="number">30</span> <span class="string">minutes</span></span><br></pre></td></tr></table></figure>

<p>通过单击Unschedule按钮，可以停止延迟job的活动计时器。除非手动执行该job，否则将来永远不会执行该job。</p>
<p>您可以通过单击“播放”按钮立即启动延迟的job。Gitlab Runner将很快选择您的工作并开始工作。</p>
<h3 id="a7-12">7.12. environment</h3>

<p>environment用于定义job部署到特定环境。如果指定了environment，并且该名称下不存在任何环境，则将自动创建一个新的环境。</p>
<p>在其最简单的形式中，environment关键字的定义如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy to production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="string">HEAD:master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，部署到生产job将标记为对生产环境进行部署。</p>
<h4>environment:name</h4>

<p>The environment name can contain:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">letters</span></span><br><span class="line"><span class="string">digits</span></span><br><span class="line"><span class="string">spaces</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="string">_</span></span><br><span class="line"><span class="string">/</span></span><br><span class="line"><span class="string">$</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的名称有qa, staging, and production，但是您可以将任何名称用于您的工作流。</p>
<p>除了在environment关键字后定义环境名称，还可以将其定义为单独的值。为此，请在环境下使用name关键字：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy to production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="string">HEAD:master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br></pre></td></tr></table></figure>
<h4>environment:url</h4>

<p>这是一个可选值，设置后，它会在Gitlab中的不同位置显示按钮，单击该按钮会将您带到定义的URL。</p>
<p>在下面的示例中，如果job成功完成，它将在合并请求和环境/部署页面中创建按钮，这些页面将指向<a href="https://prod.example.com./">https://prod.example.com。</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy to production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="string">HEAD:master</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://prod.example.com</span></span><br></pre></td></tr></table></figure>
<h4>environment:on_stop</h4>

<p>关闭（停止）环境可以通过在environment下定义的on-stop关键字来实现。它声明了一个不同的job，该job运行的目的是关闭环境。</p>
<p>例如，请阅读environment:action部分。</p>
<h4>environment:action</h4>

<p>action关键字将与on_stop一起使用，并在调用以关闭环境的job中定义。</p>
<p>例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">review_app:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy-app</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">review</span></span><br><span class="line">    <span class="attr">on_stop:</span> <span class="string">stop_review_app</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stop_review_app:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">GIT_STRATEGY:</span> <span class="string">none</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">delete-app</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">review</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">stop</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们设置了review-appjob以部署到review环境中，并且在on-stop下定义了一个新的stop-review-appjob。一旦review_app完成，它将根据“when”下定义的内容触发stop_review_app。在本例中，我们将其设置为手动，以便它需要通过Gitlab的Web界面进行手动操作才能运行。</p>
<p>同样在这个例子中，GIT_STRATEGY被设置为“none”，这样当自动触发stop_review_app时，Gitlab Runner不会在删除分支后尝试check out代码。</p>
<p>stop_review_app需要定义以下关键字：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">when</span> <span class="bullet">-</span> <span class="string">reference</span></span><br><span class="line"><span class="string">environment:name</span></span><br><span class="line"><span class="string">environment:action</span></span><br><span class="line"><span class="string">stage应与review_app相同，以便在删除分支时环境自动停止。</span></span><br></pre></td></tr></table></figure>

<p>动态环境</p>
<p>For example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy as review app:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">review/$CI_COMMIT_REF_NAME</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://$CI_ENVIRONMENT_SLUG.example.com/</span></span><br></pre></td></tr></table></figure>

<p>deploy as review app将标记为deployment，以动态创建review/$CI_COMMIT_REF_NAME环境，其中$CI_COMMIT_REF_NAME是运行程序设置的环境变量。$CI_ENVIRONMENT_SLUG变量基于环境名称，但适合包含在URL中。在这种情况下，如果在名为pow的分支中运行deploy as review app，则可以使用类似<a href="https://review/">https://review</a> pow.example.com/的URL访问此环境。</p>
<p>当然，这意味着承载应用程序的底层服务器配置正确。</p>
<p>常见的用例是为分支创建动态环境，并将它们用作审查应用程序。您可以在<a href="https://gitlab.com/gitlab-examples/review-apps-nginx/%E4%B8%8A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8review-apps%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%E3%80%82">https://gitlab.com/gitlab-examples/review-apps-nginx/上看到一个使用review-apps的简单示例。</a></p>
<h3 id="a7-13">7.13. cache</h3>
<a href="https://gitlab.com/help/ci/caching/index.md" target="_blank" rel="noopener noreferrer">TIP: Learn more:Read how caching works and find out some good practices in the caching dependencies documentation.</a>

<p>cache用于指定应在job之间缓存的文件和目录的列表。只能使用项目工作区内的路径。</p>
<p>如果cache是在job范围之外定义的，则意味着它是全局设置的，所有job都将使用该定义。</p>
<h4>cache:paths</h4>

<p>使用paths指令选择将缓存哪些文件或目录。可以使用通配符跟踪glob模式和filepath.match。</p>
<p>缓存以.apk和.config文件结尾的二进制文件中的所有文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/*.apk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.config</span></span><br></pre></td></tr></table></figure>

<p>本地定义的缓存覆盖全局定义的选项。以下rspecjob将只缓存二进制文件/：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my/files</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">rspec</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，由于缓存是在job之间共享的，如果您对不同的job使用不同的路径，则还应设置不同的cache:key，否则缓存内容会被覆盖。</p>
</blockquote>
<h4>cache:key</h4>

<p>由于缓存是在job之间共享的，如果您对不同的job使用不同的路径，则还应设置不同的cache:key，否则缓存内容会被覆盖。</p>
<p>key指令允许您定义job之间缓存的关联性，允许为所有job都有一个缓存、每个job缓存、每个分支缓存。或者其他适合您工作流程的方式。通过这种方式，您可以微调缓存，允许您在不同的job之间甚至不同的分支之间缓存数据。</p>
<p>cache:key变量可以使用任何预定义的变量，如果没有设置默认键，则它只是文字默认值，这意味着默认情况下，从gitlab 9.0开始，每个管道和job之间共享所有内容。</p>
<blockquote>
<p>cache:key变量不能包含/字符，或者编码为%2f的等效URI；也禁止使用仅由点（.，%2e）构成的值。</p>
</blockquote>
<p>例如，要启用每个分支缓存：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">&quot;$CI_COMMIT_REF_SLUG&quot;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>如果使用Windows批处理运行shell脚本，则需要将$替换为%：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">&quot;%CI_COMMIT_REF_SLUG%&quot;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
<h4>cache:untracked</h4>

<p>set untracked:true缓存Git存储库中所有未跟踪的文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>缓存binaries下的所有Git未跟踪文件和文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">untracked:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
<h4>cache:policy</h4>

<p>缓存job的默认行为是在执行开始时下载文件，并在结束时重新上传文件。这允许为将来的运行保留job所做的任何更改，称为pull-push缓存策略。</p>
<p>如果知道job不会更改缓存文件，可以通过设置policy:pull来跳过上传步骤。通常，这将与早期阶段的普通缓存job成对出现，以确保缓存不时更新：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">setup</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prepare:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">setup</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">gems</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vendor/bundle</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">install</span> <span class="string">--deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">gems</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vendor/bundle</span></span><br><span class="line">    <span class="attr">policy:</span> <span class="string">pull</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>这有助于加快job执行速度并减少缓存服务器上的负载，特别是当您有大量的缓存使用并行执行的job时。</p>
<p>此外，如果有一个job无条件地重新创建缓存而不引用其先前的内容，则可以使用policy: push跳过下载步骤。</p>
<h3 id="a7-14">7.14. artifacts</h3>

<p>artifacts用于指定在job成功、失败或总是失败时应附加到该job的文件和目录列表。</p>
<p>artifacts将在job完成后发送到Gitlab，并可在Gitlab UI中下载。<br><a href="https://gitlab.com/help/user/project/pipelines/job_artifacts.md" target="_blank" rel="noopener noreferrer">Read more about artifacts.</a></p>
<h4>artifacts:paths</h4>

<p>只能使用项目工作区内的路径。可以使用通配符跟踪glob模式和filepath.match。</p>
<p>要在不同job之间传递artifacts，see dependencies.。</p>
<p>发送binaries and .config:下所有文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">binaries/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.config</span></span><br></pre></td></tr></table></figure>

<p>要禁用artifacts传递，请使用dependencies: []</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">dependencies:</span> []</span><br></pre></td></tr></table></figure>

<p>您可能希望只为tags的版本创建artifacts，以避免用临时的artifacts填充构建服务器存储。</p>
<p>仅为tags创建artifacts（default-job不会创建artifacts）：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default-job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">test</span> <span class="string">-U</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line"></span><br><span class="line"><span class="attr">release-job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">package</span> <span class="string">-U</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/*.war</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>
<h4>artifacts:name</h4>

<p>name指令允许您定义创建的artifacts存档的名称。这样，当您想从Gitlab下载归档文件时，每个归档文件都可以有一个唯一的名称。artifacts:name变量可以使用任何预定义的变量。默认名称为artifacts，下载时将变为artifacts.zip。</p>
<blockquote>
<p>如果您的分支名称包含正斜杠（例如feature/my feature），建议使用$ci-commit-ref-slug而不是$ci-commit-ref-name来正确命名artifacts。</p>
</blockquote>
<p>要使用当前job的名称创建存档，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$CI_JOB_NAME&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>要使用当前分支或标记的名称（仅包括binaries文件夹）创建存档，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$CI_COMMIT_REF_NAME&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>要使用当前job的名称和当前分支或标记（仅包括binaries文件夹）创建存档，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$CI_JOB_NAME-$CI_COMMIT_REF_NAME&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>要创建具有当前阶段名称和分支名称的存档，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$CI_JOB_STAGE-$CI_COMMIT_REF_NAME&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>如果使用Windows批处理运行shell脚本，则需要将$替换为%：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;%CI_JOB_STAGE%-%CI_COMMIT_REF_NAME%&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>

<p>如果使用Windows PowerShell运行shell脚本，则需要将$替换为$env:：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;$env:CI_JOB_STAGE-$env:CI_COMMIT_REF_NAME&quot;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
<h4>artifacts:untracked</h4>

<p>artifacts:untracked用于将所有git未跟踪文件添加为artifacts（沿着artifacts:paths中定义的路径）。</p>
<blockquote>
<p>artifacts:untracked忽略存储库的.gitignore文件中的配置。</p>
</blockquote>
<p>发送所有git未跟踪文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line">  <span class="attr">untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>发送所有git未跟踪文件和二进制文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line">  <span class="attr">untracked:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">binaries/</span></span><br></pre></td></tr></table></figure>
<h4>artifacts:when</h4>

<p>artifacts:when用于在job失败或尽管失败时上载artifacts的时间。</p>
<p>artifacts:when可以设置为以下值之一：</p>
<p>on_success-仅当job成功时上载artifacts。这是默认设置。</p>
<p>on_failure-仅当job失败时才上载artifacts。</p>
<p>always-上载artifacts，不管job状态如何。</p>
<p>仅当job失败时上载项目：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">on_failure</span></span><br></pre></td></tr></table></figure>
<h4>artifacts:expire_in</h4>

<p>expire_-in允许您指定artifacts在过期之前应该存在多长时间，从而从它们上传和存储到Gitlab的时间开始删除。如果未定义到期时间，则默认为实例范围的设置。（默认为30天，永远在gitlab.com上）。</p>
<p>您可以使用“job”页上的“保留”按钮来覆盖过期时间并永久保留项目。</p>
<p>过期后，artifacts默认每小时删除一次（通过cronjob），并且不再可访问。</p>
<p>expire_in的值是以秒为单位的已用时间，除非提供了一个单位。可分析值示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;42&#x27;</span></span><br><span class="line"><span class="string">&#x27;3 mins 4 sec&#x27;</span></span><br><span class="line"><span class="string">&#x27;2 hrs 20 min&#x27;</span></span><br><span class="line"><span class="string">&#x27;2h20min&#x27;</span></span><br><span class="line"><span class="string">&#x27;6 mos 1 day&#x27;</span></span><br><span class="line"><span class="string">&#x27;47 yrs 6 mos and 4d&#x27;</span></span><br><span class="line"><span class="string">&#x27;3 weeks and 2 days&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要在上载后1周使项目过期，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br></pre></td></tr></table></figure>
<h4>artifacts:reports</h4>

<p>reports关键字用于从job收集测试报告并在Gitlab的UI（合并请求、管道视图）中公开它们。阅读如何将其与JUnit报告一起使用。</p>
<blockquote>
<p>无论job结果如何（成功或失败），都会收集测试报告。您可以使用artifacts:expire\u来设置其artifacts的到期日期。<br>如果还希望能够浏览报告输出文件，请包含artifacts:paths关键字。</p>
</blockquote>
<h4>artifacts:reports:junit</h4>

<p>JUnit报告将JUnit XML文件收集为artifacts。虽然JUnit最初是在爪哇开发的，但是有许多其他第三方端口，如yml、Python、Ruby等。</p>
<p>有关更多详细信息和示例，请参阅JUnit测试报告。下面是从Ruby的rspec测试工具收集JUnit XML文件的示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rspec</span> <span class="string">--format</span> <span class="string">RspecJunitFormatter</span> <span class="string">--out</span> <span class="string">rspec.xml</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">reports:</span></span><br><span class="line">      <span class="attr">junit:</span> <span class="string">rspec.xml</span></span><br></pre></td></tr></table></figure>

<p>收集到的JUnit报告将作为artifacts上传到Gitlab，并将自动显示在合并请求中。</p>
<p>如果JUnit工具使用导出到多个XML文件，则可以在一个job中指定多个测试报告路径，这些路径将自动连接到一个文件中。使用文件名模式（junit:rspec-<em>.xml）、文件名数组（junit:[rspec-1.xml、rspec-2.xml、rspec-3.xml]）或其组合（junit:[rspec.xml，测试结果/test-</em>.xml]）。</p>
<h4>artifacts:reports:codequality (STARTER)</h4>

<p>代码质量报告将代码质量问题收集为artifacts。</p>
<p>收集的代码质量报告将作为artifacts上传到Gitlab，并将自动显示在合并请求中。</p>
<h4>artifacts:reports:sast (ULTIMATE)终极</h4>

<p>sast报告将sast漏洞收集为artifacts。</p>
<p>收集的SAST报告将作为artifacts上传到Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p>
<h4>artifacts:reports:dependency_scanning (ULTIMATE)终极</h4>

<p>依赖项扫描报告将依赖项扫描漏洞收集为artifacts。</p>
<p>收集到的依赖项扫描报告将作为artifacts上载到Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表板提供数据。</p>
<h4>artifacts:reports:container_scanning (ULTIMATE)</h4>

<p>容器扫描报告将容器扫描漏洞收集为artifacts。</p>
<p>收集的容器扫描报告将作为一个artifacts上载到Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表板提供数据。</p>
<h4>artifacts:reports:dast (ULTIMATE)</h4>

<p>DAST报告将DAST漏洞收集为artifacts。</p>
<p>收集的DAST报告将作为artifacts上传到Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p>
<h4>artifacts:reports:license_management (ULTIMATE)</h4>

<p>许可证管理报告将许可证作为artifacts收集。</p>
<p>收集的许可证管理报告将作为一个artifacts上载到Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p>
<h4>artifacts:reports:performance (PREMIUM)</h4>

<p>性能报告将性能指标收集为artifacts。</p>
<p>收集到的性能报告将作为artifacts上传到Gitlab，并将自动显示在合并请求中。</p>
<h4>artifacts:reports:metrics (PREMIUM)</h4>

<p>性能报告将性能指标收集为artifacts。<br>收集到的性能报告将作为artifacts上传到Gitlab，并将自动显示在合并请求中。</p>
<h4>artifacts:reports:metrics (PREMIUM)</h4>

<p>度量报告将度量收集为artifacts。</p>
<p>收集的度量报告将作为artifacts上传到Gitlab，并将自动显示在合并请求中。</p>
<h3 id="a7-15">7.15. dependencies</h3>

<p>此功能应该与artifacts一起使用，并允许您定义要在不同job之间传递的artifacts。</p>
<p>请注意，默认情况下，来自所有先前阶段的artifacts都会被传递。</p>
<p>若要使用此功能，请在job的上下文中定义依赖项，并传递一个列表，其中列出了应从中下载artifacts的所有先前job。只能从当前job之前执行的阶段定义job。如果从当前阶段或下一阶段定义job，将显示一个错误。</p>
<p>定义空数组将跳过下载该job的任何artifacts。使用依赖项时不考虑上一个job的状态，因此如果它失败或是未运行的手动job，则不会发生错误。</p>
<p>在下面的示例中，我们用artifacts定义了两个job，build:osx和build:linux。执行test:osx时，来自build:osx的artifacts</p>
<p>将在生成上下文中下载和提取。对于test:linux和build:linux中的artifacts也是如此。</p>
<p>由于阶段优先，job部署将从所有以前的job下载项目：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build:osx:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build:osx</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:linux:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">build:linux</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:osx:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">test:osx</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build:osx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:linux:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">test:linux</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build:linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>
<h4>When a dependent job will fail</h4>

<p>如果设置为依赖项的job的artifacts已过期或清除，则依赖job将失败。</p>
<blockquote>
<p>您可以要求管理员翻转此开关并恢复旧行为。</p>
</blockquote>
<h3 id="a7-16">7.16. coverage</h3>

<p>Coverage允许您配置如何从job输出中提取代码覆盖率。</p>
<p>正则表达式是此处唯一有效的值类型。因此，为了一致和显式地表示正则表达式字符串，必须使用环绕/。如果你想从字面上匹配特殊字符，你必须转义它们。</p>
<p>A simple example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/Code coverage: \d+\.\d+/&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-17">7.17. retry</h3>

<p>重试”允许您配置一个job在发生故障时将重试多少次。</p>
<p>当一个job失败并配置了重试时，它将被再次处理到retry关键字指定的次数。</p>
<p>如果retry设置为2，并且job在第二次运行（第一次重试）中成功，则不会重试。</p>
<p>再一次。重试值必须是一个正整数，等于或大于0，但小于或等于2（最多两次重试，总共三次）。</p>
<p>在所有故障情况下重试的简单示例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">retry:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，将在所有失败情况下重试job。要更好地控制重试失败的次数，retry可以是具有以下键的哈希：</p>
<p>max：最大重试次数。</p>
<p>when：失败的案例要重试。</p>
<p>要最多重试两次运行程序系统故障，请执行以下操作：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">runner_system_failure</span></span><br></pre></td></tr></table></figure>

<p>如果存在除运行程序系统故障以外的其他故障，则不会重试job。</p>
<p>要在多个故障情况下重试，时间也可以是一个故障数组：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">when:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">runner_system_failure</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">stuck_or_timeout_failure</span></span><br></pre></td></tr></table></figure>

<p>Possible values for when are:</p>
<p>always：在出现任何故障时重试（默认）。</p>
<p>unknown_failure：失败原因未知时重试。</p>
<p>script_failure：当脚本失败时重试。</p>
<p>api_failure：在api失败时重试。</p>
<p>stuck_or_timeout_failure：当job卡住或超时时重试。</p>
<p>runner_system_failure：如果运行程序系统故障（例如设置job失败），请重试。</p>
<p>missing_dependency_failure：如果缺少依赖项，请重试。</p>
<p>runner_unsupported：如果运行程序不受支持，请重试。</p>
<h3 id="a7-18">7.18. parallel</h3>

<p>Parallel允许您配置要并行运行的job实例数。该值必须大于或等于两（2）且小于或等于50。</p>
<p>这将创建并行运行的同一job的n个实例。它们按顺序从job_name 1/n到job_name n/n命名。</p>
<p>对于每个job，都会设置CI_NODE_INDEX and CI_NODE_TOTAL environment variables。</p>
<p>一个简单的例子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">parallel:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>跨并行job并行化测试套件。不同的语言有不同的工具来促进这一点。</p>
</blockquote>
<h3 id="a7-19">7.19. trigger (PREMIUM)</h3>

<p>trigger允许您定义下游管道trigger。当从trigger定义创建的job由Gitlab启动时，将创建下游管道。<br><a href="https://gitlab.com/help/ci/multi_project_pipelines.md#creating-multi-project-pipelines-from-gitlab-ciyml" target="_blank" rel="noopener noreferrer">Learn more about multi-project pipelines.</a></p>
<p>简单触发器语法</p>
<p>配置下游触发器以使用具有下游项目完整路径的触发器关键字的最简单方法：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">staging:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">my/deployment</span></span><br></pre></td></tr></table></figure>

<p>复杂触发器语法</p>
<p>可以配置Gitlab用于创建下游管道的分支名称：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">staging:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">    <span class="attr">project:</span> <span class="string">my/deployment</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">stable</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-20">7.20. include</h3>

<p>使用include关键字，可以允许包含外部yaml文件。include要求外部yaml文件具有扩展名.yml或.yaml，否则将不包括外部文件。</p>
<p>include中定义的文件包括：</p>
<p>–与.gitlab-ci.yml中的合并。</p>
<p>–始终首先评估并与.gitlab-ci.yml的内容合并，而不管include关键字的位置如何。</p>
<blockquote>
<p>使用合并可使用本地定义自定义和覆盖包含的CI/CD配置。<br>不支持跨include源的不同yaml文件使用yaml别名。您只能引用同一文件中的别名。您可以使用extends关键字，而不是使用yaml锚。</p>
</blockquote>
<p>包含支持四个包含方法</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">local</span></span><br><span class="line"><span class="string">file</span></span><br><span class="line"><span class="string">template</span></span><br><span class="line"><span class="string">remote</span></span><br></pre></td></tr></table></figure>

<p><a href="https://gitlab.com/help/ci/yaml/README.md#include-examples" target="_blank" rel="noopener noreferrer">See usage examples.</a></p>
<blockquote>
<p>所有方法包含的.gitlab-ci.yml配置在管道创建时进行评估。配置是一个及时的快照，并持久存在于数据库中。在创建下一个管道之前，对引用的.gitlab-ci.yml配置所做的任何更改都不会反映在gitlab中。</p>
</blockquote>
<h4>include:local</h4>

<p>include:local包含来自与.gitlab-ci.yml相同存储库的文件。它是使用相对于根目录的完整路径来引用的（/）。</p>
<p>您只能在配置文件所在的分支上使用Git当前跟踪的文件。换句话说，当使用include:local时，请确保.gitlab-ci.yml和本地文件都在同一个分支上。</p>
<p>所有嵌套的include都将在同一个项目的范围内执行，因此可以使用本地、项目、远程或模板include。</p>
<blockquote>
<p>不支持通过git子模块路径包含本地文件。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>
<h4>include:file</h4>

<p>要在同一Gitlab实例下包含来自另一个私有项目的文件，请使用include:file。使用相对于根目录的完整路径（/）引用此文件。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">&#x27;my-group/my-project&#x27;</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还可以指定ref，默认值为项目的标题：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">&#x27;my-group/my-project&#x27;</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">&#x27;my-group/my-project&#x27;</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">&#x27;my-group/my-project&#x27;</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">787123b47f14b552955ca2786bc9542ae66fee5b</span> <span class="comment"># Git SHA</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所有嵌套的include都将在目标项目的范围内执行，因此可以使用本地（相对于目标项目）、项目、远程或模板include。</p>
<h4>include:template</h4>

<p>include:template可用于包含随Gitlab一起提供的.gitlab-ci.yml模板。</p>
<p>For example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File sourced from GitLab&#x27;s template collection</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Auto-DevOps.gitlab-ci.yml</span></span><br></pre></td></tr></table></figure>

<p>所有嵌套的include只能在用户的权限下执行，因此可以使用project、remote或template include。</p>
<h4>include:remote</h4>

<p>nclude:remote可用于包含来自不同位置的文件，使用http/https，使用完整的URL引用。远程文件必须通过简单的GET请求公开访问，因为不支持远程URL中的身份验证架构。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">remote:</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.gitlab-ci-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所有嵌套的include将作为公共用户在没有上下文的情况下执行，因此只允许使用其他远程、公共项目或模板。</p>
<h4>嵌套包含</h4>

<p>嵌套的include允许您组成一组include。总共允许50个。</p>
<p>重复包含被视为配置错误。</p>
<p>包括示例</p>
<p>下面还有一些例子。</p>
<p>单个字符串或多个值的数组，您可以将额外的yaml文件作为单个字符串或多个值的数组包含在内。下面的例子都是有效的。</p>
<p>包含include:local方法的单个字符串：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span> <span class="string">&#x27;/templates/.after-script-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>包含include方法的数组：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;/templates/.after-script-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>显式指定包含方法的单个字符串：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="attr">remote:</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>带有include:remote的数组是单个项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">remote:</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>具有多个包含方法的数组已明确指定：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">remote:</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">&#x27;/templates/.after-script-template.yml&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Auto-DevOps.gitlab-ci.yml</span></span><br></pre></td></tr></table></figure>

<p>数组混合语法：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;/templates/.after-script-template.yml&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Auto-DevOps.gitlab-ci.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">&#x27;my-group/my-project&#x27;</span></span><br><span class="line">    <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&#x27;/templates/.gitlab-ci-template.yml&#x27;</span></span><br></pre></td></tr></table></figure>
<h4>重新使用前脚本模板</h4>

<p>在下面的示例中，.before-script-template.yml的内容将与.gitlab-ci.yml的内容一起自动获取和评估。</p>
<p><a href="https://gitlab.com/awesome">https://gitlab.com/awesome</a> project/raw/master/.before-script-template.yml的内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">-qq</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">-qq</span> <span class="string">sqlite3</span> <span class="string">libsqlite3-dev</span> <span class="string">nodejs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gem</span> <span class="string">install</span> <span class="string">bundler</span> <span class="string">--no-document</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">install</span> <span class="string">--jobs</span> <span class="string">$(nproc)</span>  <span class="string">&quot;$&#123;FLAGS[@]&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Content of .gitlab-ci.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span> <span class="string">&#x27;https://gitlab.com/awesome-project/raw/master/.before-script-template.yml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<p>覆盖外部模板值以下示例显示了特定的yaml定义的变量以及在.gitlab-ci.yml中自定义的include文件中生产job的详细信息。</p>
<p><a href="https://company.com/autodevops-template.yml%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">https://company.com/autodevops-template.yml的内容：</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">POSTGRES_USER:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">testing_password</span></span><br><span class="line">  <span class="attr">POSTGRES_DB:</span> <span class="string">$CI_ENVIRONMENT_SLUG</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">install_dependencies</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://$CI_PROJECT_PATH_SLUG.$KUBE_INGRESS_BASE_DOMAIN</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>Content of .gitlab-ci.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span> <span class="string">&#x27;https://company.com/autodevops-template.yml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span> <span class="string">alpine:latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">POSTGRES_USER:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">secure_password</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://domain.com</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，变量postgres-user和postgres-password以及autodevops-template.yml中定义的生产job的环境url已被.gitlab-ci.yml中定义的新值覆盖。</p>
<p>合并允许扩展和重写字典映射，但不能向包含的数组添加或修改项。例如，要向生产job脚本添加其他项，必须重复现有的脚本项：</p>
<p><a href="https://company.com/autodevops-template.yml%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">https://company.com/autodevops-template.yml的内容：</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">install_dependencies</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p>Content of .gitlab-ci.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span> <span class="string">&#x27;https://company.com/autodevops-template.yml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="attr">production:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">install_dependencies</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">notify_owner</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果在.gitlab-ci.yml中不重复install_dependencies和deploy，它们将不会成为组合CI配置中生产job脚本的一部分。</p>
<h4>使用嵌套的include</h4>

<p>下面的示例说明如何使用不同方法的组合从不同的源嵌套include。</p>
<p>在本例中，.gitlab-ci.yml包含本地文件/.gitlab-ci/another-config.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">/.gitlab-ci/another-config.yml</span></span><br></pre></td></tr></table></figure>

<p>.gitlab ci/another-config.yml包含一个模板和另一个项目的/templates/docker-workflow.yml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">Bash.gitlab-ci.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">project:</span> <span class="string">group/my-project</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">/templates/docker-workflow.yml</span></span><br></pre></td></tr></table></figure>

<p>group/my项目中的/templates/docker-workflow.yml包含group/my项目的两个本地文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">/templates/docker-build.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">local:</span> <span class="string">/templates/docker-testing.yml</span></span><br></pre></td></tr></table></figure>

<p>group/my项目中的/templates/docker-build.yml添加了一个docker构建job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker-build:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">my-image</span> <span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>我们的第二个/templates/docker-test.yml出现在group/my项目中，它添加了一个docker测试job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker-test:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">docker</span> <span class="string">run</span> <span class="string">my-image</span> <span class="string">/run/tests.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="a7-21">7.21. extends</h3>

<p>扩展定义了使用扩展的job将从中继承的项名称。</p>
<p>它是使用yaml锚的替代方法，并且更灵活和易读：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.tests</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，rspecjob继承自.tests模板job。Gitlab将根据这些键执行反向深进。Gitlab想要：</p>
<p>递归地将rspec内容放入.tests。</p>
<p>不去键的值。</p>
<p>这将导致以下job：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="attr">refs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">branches</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，script:rake测试已被script:rake rspec覆盖。</p>
</blockquote>
<p>如果您想包括rake测试，请参见之前的脚本和之后的脚本。</p>
<p>.本例中的测试是隐藏的密钥，但也可以从常规job继承。扩展支持多级别继承，但不建议使用三个以上的级别。支持的最大嵌套级别为10。</p>
<p>以下示例具有两个继承级别：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pushes</span></span><br><span class="line"></span><br><span class="line"><span class="string">.rspec:</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.tests</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec 1:</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">RSPEC_SUITE:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec 2:</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">RSPEC_SUITE:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spinach:</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.tests</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">rake</span> <span class="string">spinach</span></span><br></pre></td></tr></table></figure>

<p>在Gitlab 12.0及更高版本中，也可以使用多个父级进行扩展。用于合并的算法是“最近的作用域获胜”，因此来自最后一个成员的键将始终隐藏在其他级别上定义的任何内容。例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.only-important:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="string">.in-docker:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">extends:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.only-important</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.in-docker</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>

<p>这将导致以下RSPECjob：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rake</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure>
<h4>Using extends and include together</h4>

<p>扩展配置文件和include的工作。</p>
<p>例如，如果您有本地included.yml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.template:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">Hello!</span></span><br></pre></td></tr></table></figure>

<p>然后，在.gitlab-ci.yml中，您可以这样使用它：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span> <span class="string">included.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">useTemplate:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">  <span class="attr">extends:</span> <span class="string">.template</span></span><br></pre></td></tr></table></figure>

<p>这将运行一个名为usetemplate的job，该job运行echo hello！根据.templatejob中的定义，并使用本地job中定义的Alpine Docker图像。</p>
<h3 id="a7-22">7.22. pages</h3>

<p>页面是一项特殊的工作，用于将静态内容上载到Gitlab，该工作可用于为您的网站提供服务。它有一个特殊的语法，所以这两个</p>
<p>必须满足以下要求：</p>
<p>任何静态内容都必须放在public/目录下。</p>
<p>必须定义具有公共/目录路径的项目。</p>
<p>下面的示例只是将所有文件从项目的根目录移动到public/directory。.public解决方案是这样的，cp不会无限循环地将public/复制到自身：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">.public</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">*</span> <span class="string">.public</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mv</span> <span class="string">.public</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p><a href="https://gitlab.com/help/user/project/pages/index.md" target="_blank" rel="noopener noreferrer">Read more on GitLab Pages user documentation.</a></p>
<h3 id="a7-23">7.23. variables</h3>
> 整数（以及字符串）对于变量的名称和值都是合法的。浮动不合法，不能使用。

<p>Gitlab CI/CD允许您在.gitlab-ci.yml中定义变量，然后在job环境中传递这些变量。它们可以全局设置，也可以按job设置。</p>
<p>在job级别上使用variables关键字时，它将覆盖全局yaml变量和预定义变量。</p>
<p>它们存储在Git存储库中，用于存储非敏感项目配置，例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DATABASE_URL:</span> <span class="string">&quot;postgres://postgres@postgres/my_database&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些变量稍后可以在所有执行的命令和脚本中使用。yaml定义的变量也被设置为所有创建的服务容器，从而允许对它们进行微调。</p>
<p>除了用户定义的变量之外，还有运行程序本身设置的变量。一个例子是ci-commit-ref-name，它具有为其构建项目的分支或标记名的值。除了可以在.gitlab-ci.yml中设置的变量外，还可以在gitlab的用户界面中设置所谓的变量。<br><a href="https://gitlab.com/help/ci/variables/README.md" target="_blank" rel="noopener noreferrer">Learn more about variables and their priority.</a></p>
<h4>Git strategy</h4>

<p>您可以在“变量”部分中设置用于获取最新应用程序代码的Git_策略（全局或每个job）。如果未指定，将使用项目设置中的默认值。</p>
<p>有三个可能的值：clone、fetch和none。</p>
<p>克隆是最慢的选项。它为每个job从头克隆存储库，确保项目工作空间始终是原始的。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_STRATEGY:</span> <span class="string">clone</span></span><br></pre></td></tr></table></figure>

<p>提取速度更快，因为它重新使用项目工作区（如果不存在则返回到克隆）。Git Clean用于撤消上一个job所做的任何更改，Git Fetch用于检索自上一个job运行以来所做的提交。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_STRATEGY:</span> <span class="string">fetch</span></span><br></pre></td></tr></table></figure>

<p>也没有人会重新使用项目工作区，但会跳过所有Git操作（包括Gitlab Runner的预克隆脚本，如果存在的话）。它主要用于只在artifacts上操作的job（例如部署）。Git存储库数据可能存在，但它肯定是过时的，因此您应该只依赖从缓存或artifacts引入到项目工作区的文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_STRATEGY:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Kubernetes的执行者不支持Git_策略，但将来可能会支持。有关更新，请参阅支持带kubernetes执行器的git策略的特性建议。</p>
</blockquote>
<h4>Git submodule strategy</h4>

<p>Git_子模块_策略变量用于控制在生成前获取代码时是否包含Git子模块/如何包含Git子模块。您可以在“变量”部分中全局或按job设置它们。</p>
<p>有三个可能的值：无、正常和递归：</p>
<p>无表示在获取项目代码时不包括子模块。这是默认值，与v1.10之前的行为匹配。</p>
<p>正常意味着只包括顶级子模块。相当于：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">submodule</span> <span class="string">sync</span></span><br><span class="line"><span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--init</span></span><br></pre></td></tr></table></figure>

<p>递归意味着将包括所有子模块（包括子模块的子模块）。此功能需要Git v1.8.1及更高版本。当使用不基于Docker的执行器的Gitlab运行程序时，请确保Git版本满足该要求。相当于：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">submodule</span> <span class="string">sync</span> <span class="string">--recursive</span></span><br><span class="line"><span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--init</span> <span class="string">--recursive</span></span><br></pre></td></tr></table></figure>

<p>请注意，要使此功能正常工作，子模块必须（在.gitmodules中）配置为：</p>
<p>公共可访问存储库的HTTP（S）URL，或指向同一Gitlab服务器上另一个存储库的相对路径。请参见Git子模块文档。</p>
<h4>Git checkout</h4>

<p>当git策略设置为clone或fetch以指定是否应运行git签出时，可以使用git签出变量。如果未指定，则默认为true。您可以在“变量”部分中全局或按job设置它们。如果设置为false，则运行程序将：</p>
<p>执行提取时-更新存储库并将工作副本保留在当前版本上，执行克隆时-克隆存储库并将工作副本保留在默认分支上。</p>
<p>将此设置设置为true意味着对于克隆和获取策略，运行程序将签出工作副本到与CI管道相关的修订：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_STRATEGY:</span> <span class="string">clone</span></span><br><span class="line">  <span class="attr">GIT_CHECKOUT:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">-B</span> <span class="string">master</span> <span class="string">origin/master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">merge</span> <span class="string">$CI_COMMIT_SHA</span></span><br></pre></td></tr></table></figure>
<h4>Git clean flags</h4>

<p>git-clean-flags变量用于控制签出源后git-clean的默认行为。您可以全局设置它，也可以在变量部分中为每个job设置它。</p>
<p>git_clean_标志接受git clean命令的所有可能选项。</p>
<p>如果指定了git_checkout:false，则禁用git clean。如果git_clean_标志是：</p>
<p>未指定，git clean标志默认为-ffdx。</p>
<p>给定值none，不执行git clean。</p>
<p>例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_CLEAN_FLAGS:</span> <span class="string">-ffdx</span> <span class="string">-e</span> <span class="string">cache/</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-al</span> <span class="string">cache/</span></span><br></pre></td></tr></table></figure>
<h4>Job stages attempts</h4>

<p>您可以设置正在运行的job将尝试执行以下每个阶段的尝试次数：</p>
<table class="code">
<tbody>
    <tr>
        <td>Variable</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>GET_SOURCES_ATTEMPTS</td>
        <td>尝试获取运行job的源的次数</td>
    </tr>
    <tr>
        <td>ARTIFACT_DOWNLOAD_ATTEMPTS</td>
        <td>尝试下载运行job的项目的次数</td>
    </tr>
    <tr>
        <td>RESTORE_CACHE_ATTEMPTS</td>
        <td>尝试还原运行job的缓存的次数</td>
    </tr>
</tbody>
</table>


<p>默认为一次尝试。</p>
<p>Example:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GET_SOURCES_ATTEMPTS:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4>Shallow cloning</h4>

<p>可以使用git_depth指定提取和克隆的深度。这允许对存储库进行浅层克隆，这可以显著加快对具有大量提交或旧的大型二进制文件的存储库的克隆。价值是</p>
<p>传递给了git fetch和git clone。</p>
<blockquote>
<p>如果使用深度1并有job队列或重试job，则job可能会失败。</p>
</blockquote>
<p>因为Git获取和克隆是基于引用的，例如分支名称，所以运行者不能克隆特定的commit SHA。如果队列中有多个job，或者您正在重试一个旧job，那么要测试的提交需要在克隆的Git历史记录中。为GIT_DEPTH设置的值太小可能导致无法运行这些旧提交。您将在中看到未解决的引用</p>
<p>job日志。然后，您应该重新考虑将GIT_DEPTH更改为更高的值。</p>
<p>当设置GIT_DEPTH时，依赖于Git描述的job可能无法正常工作，因为Git历史只有一部分存在。</p>
<p>要仅获取或克隆最后3个提交：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_DEPTH:</span> <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>您可以全局设置它，也可以在变量部分中为每个job设置它。</p>
<h3 id="a8">8. 不推荐使用的参数(见原文)</h3>

<p>以下参数已弃用。……</p>
]]></content>
  </entry>
  <entry>
    <title>Web框架本质-Django</title>
    <url>/2020/11/19/doc/dj/</url>
    <content><![CDATA[<h2 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h2><p>web系统概念</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> Http，无状态，短连接 </span><br><span class="line"><span class="number">2.</span> 浏览器（socket客户端）、网站（socket服务端）</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>web框架本质</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span>(<span class="params">client</span>):</span> </span><br><span class="line">buf = client.recv(<span class="number">1024</span>) </span><br><span class="line">client.send(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>) </span><br><span class="line">client.send(<span class="string">&quot;Hello, Seven&quot;</span>) </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line">sock.bind((<span class="string">&#x27;localhost&#x27;</span>,<span class="number">8000</span>)) </span><br><span class="line">sock.listen(<span class="number">5</span>) <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">connection, address = sock.accept() </span><br><span class="line">handle_request(connection) </span><br><span class="line">connection.close() <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>自定义Web框架</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a. socket服务端 </span><br><span class="line">b. 根据URL不同返回不同的内容 路由系统： URL -&gt; 函数 </span><br><span class="line">c. 字符串返回给用户 模板引擎渲染： HTML充当模板（特殊字符） 自己创造任意数据 字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态网站处理方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">request</span>):</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># #  处理用户请求，并返回相应的内容 :param request: 用户请求的所有信息 :return:  </span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;index.fsw&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) </span><br><span class="line">    data = f.read() </span><br><span class="line">    f.close() </span><br><span class="line">    <span class="keyword">return</span> data </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">request</span>):</span> </span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;aricle.tpl&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) </span><br><span class="line">    data = f.read() </span><br><span class="line">    f.close() </span><br><span class="line">    <span class="keyword">return</span> data </span><br><span class="line"></span><br><span class="line">routers = [ </span><br><span class="line">    (<span class="string">&#x27;/xxx&#x27;</span>, f1), </span><br><span class="line">    (<span class="string">&#x27;/ooo&#x27;</span>, f2), </span><br><span class="line">] </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span> </span><br><span class="line">    sock = socket.socket() </span><br><span class="line">    sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)) </span><br><span class="line">    sock.listen(<span class="number">5</span>) </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        conn,addr = sock.accept() <span class="comment"># hang住 # 有人来连接了 # 获取用户发送的数据 </span></span><br><span class="line">        data = conn.recv(<span class="number">8096</span>) </span><br><span class="line">        data = <span class="built_in">str</span>(data,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">        headers,bodys = data.split(<span class="string">&#x27;\r\n\r\n&#x27;</span>) </span><br><span class="line">        temp_list = headers.split(<span class="string">&#x27;\r\n&#x27;</span>) </span><br><span class="line">        method,url,protocal = temp_list[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">        conn.send(<span class="string">b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>) </span><br><span class="line">        func_name = <span class="literal">None</span> <span class="keyword">for</span> item <span class="keyword">in</span> routers: </span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">0</span>] == url: </span><br><span class="line">            func_name = item[<span class="number">1</span>] </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">        <span class="keyword">if</span> func_name: </span><br><span class="line">            response = func_name(data) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            response = <span class="string">b&quot;404&quot;</span> </span><br><span class="line">        conn.send(response) </span><br><span class="line">        conn.close() </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动态网站处理方式一（手动进行替换的模版引擎）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">import</span> pymysql <span class="comment"># 创建连接,获得数据 </span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;db666&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">    cursor.execute(<span class="string">&#x27;select id,username,password from userinfo&#x27;</span>) </span><br><span class="line">    user_list = cursor.fetchall() </span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() <span class="comment"># 组装数据模型 </span></span><br><span class="line">    content_list=[] </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> user_list: </span><br><span class="line">        tp = <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#x27;</span>%(row[<span class="string">&#x27;id&#x27;</span>],row[<span class="string">&#x27;username&#x27;</span>],row[<span class="string">&#x27;password&#x27;</span>]) </span><br><span class="line">        content_list.append(tp) </span><br><span class="line">        content = <span class="string">&quot;&quot;</span>.join(content_list) <span class="comment"># 将列表中的数据拼接成字符串 # 模板渲染（模板+数据） </span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;userlist.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">    template = f.read() </span><br><span class="line">    f.close() </span><br><span class="line">    data = template.replace(<span class="string">&#x27;@@sdfsdffd@@&#x27;</span>, content) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(data, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 路由系统 </span></span><br><span class="line"></span><br><span class="line">routers = [ (<span class="string">&#x27;/userlist.htm&#x27;</span>, f3), ] </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span> </span><br><span class="line">    sock = socket.socket() </span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>) </span><br><span class="line">    sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>)) </span><br><span class="line">    sock.listen(<span class="number">5</span>) </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        conn,addr = sock.accept() <span class="comment"># hang住 # 有人来连接了 # 获取用户发送的数据 </span></span><br><span class="line">        data = conn.recv(<span class="number">8096</span>) </span><br><span class="line">        data = <span class="built_in">str</span>(data,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">        headers,bodys = data.split(<span class="string">&#x27;\r\n\r\n&#x27;</span>) </span><br><span class="line">        temp_list = headers.split(<span class="string">&#x27;\r\n&#x27;</span>) </span><br><span class="line">        method,url,protocal = temp_list[<span class="number">0</span>].split(<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">        conn.send(<span class="string">b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>) </span><br><span class="line">        func_name = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> routers: </span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == url: </span><br><span class="line">                func_name = item[<span class="number">1</span>] </span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            <span class="keyword">if</span> func_name: </span><br><span class="line">                response = func_name(data) </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                response = <span class="string">b&quot;404&quot;</span> </span><br><span class="line"></span><br><span class="line">        conn.send(response) </span><br><span class="line">        conn.close() </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Django项目前期配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip3 install django # 创建Django程序 </span><br><span class="line">django-admin startproject mysite # 进入程序目录 </span><br><span class="line">cd mysite # 启动socket服务端，等待用户发送请求 </span><br><span class="line">python manage.py runserver 127.0.0.1:8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Django配置文件：</p>
<p>settings.py </p>
<p>…… </p>
<p>DIRS’: [os.path.join(BASE_DIR, ‘template’)], </p>
<p>……</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Mysql数据库： </span><br><span class="line">DATABASES = &#123; </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123; </span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>:<span class="string">&#x27;dbname&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">#备注： </span></span><br><span class="line"><span class="comment"># 由于Django内部连接MySQL时使用的是MySQLdb模块，而python3中还无此模块，所以需要使用pymysql来代替 </span></span><br><span class="line"><span class="comment"># 如下设置放置的与project同名的配置的 __init__.py文件中 </span></span><br><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">pymysql.install_as_MySQLdb()　</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态文件路径： static目录 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span> </span><br><span class="line">STATICFILES_DIRS = ( os.path.join(BASE_DIR,<span class="string">&#x27;static&#x27;</span>), )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>额外配置（跨站请求伪装crsf）: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    …… </span><br><span class="line">    <span class="comment">#&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, </span></span><br><span class="line">    …… </span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>项目案例</p>
<p>网站请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls.py </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    <span class="comment"># url(r&#x27;^admin/&#x27;, admin.site.urls), </span></span><br><span class="line">    url(<span class="string">r&#x27;^index/&#x27;</span>,index), </span><br><span class="line">] <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line"><span class="comment"># return HttpResponse(&#x27;Index&#x27;) </span></span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>,&#123; </span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;users&#x27;</span>:[<span class="string">&#x27;李志&#x27;</span>,<span class="string">&#x27;李杰&#x27;</span>], </span><br><span class="line">    <span class="string">&#x27;user_dict&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;k1&#x27;</span>:<span class="string">&#x27;v1&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;k2&#x27;</span>:<span class="string">&#x27;v2&#x27;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&#x27;user_list_dict&#x27;</span>:[ &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;tom@1231.com&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;tom@1231.com&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;tom@1231.com&#x27;</span></span><br><span class="line">    &#125;, </span><br><span class="line">] </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>网站登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls from django.conf.urls </span></span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> django.contrib </span><br><span class="line"><span class="keyword">import</span> admin <span class="keyword">from</span> django.shortcuts </span><br><span class="line"><span class="keyword">import</span> HttpResponse,render,redirect </span><br><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    <span class="comment"># url(r&#x27;^admin/&#x27;, admin.site.urls), </span></span><br><span class="line">    url(<span class="string">r&#x27;^login/&#x27;</span>,login), </span><br><span class="line">] </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment"># #  处理用户请求，并返回内容 :param request: 用户请求相关的所有信息（对象） :return:  # 字符串 # </span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>) </span><br><span class="line">    <span class="comment"># return HttpResponse(&#x27;login.html&#x27;) </span></span><br><span class="line">    <span class="comment"># 自动找到模板路径下的login.html文件，读取内容并返回给用户 </span></span><br><span class="line">    <span class="comment"># 模板路径的配置 print(request.GET) </span></span><br><span class="line">    <span class="comment"># 结果为字典格式，值为列表类型 if request.method == &quot;GET&quot;: return render(request,&#x27;login.html&#x27;) else: </span></span><br><span class="line">    <span class="comment"># 用户POST提交的数据（请求体） u = request.POST.get(&#x27;user&#x27;) p = request.POST.get(&#x27;pwd&#x27;) if u == &#x27;root&#x27; and p == &#x27;123&#x27;: </span></span><br><span class="line">    <span class="comment"># 登录成功 </span></span><br><span class="line">    <span class="comment"># return redirect(&#x27;http://www.oldboyedu.com&#x27;) return redirect(&#x27;/index/&#x27;) </span></span><br><span class="line">    <span class="comment"># 重定向 else: </span></span><br><span class="line">    <span class="comment"># 登录失败 return render(request,&#x27;login.html&#x27;,&#123;&#x27;msg&#x27;: &#x27;用户名或密码错误&#x27;&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a2">
<a id="django_473"></a>django学员管理系统</h2>


<p>数据库设计结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">表结构：班级\学生\老师 （班级表）： </span><br><span class="line"><span class="built_in">id</span>          title </span><br><span class="line"><span class="number">1</span>           全<span class="number">4</span>期 </span><br><span class="line"><span class="number">2</span>           全<span class="number">5</span>期 </span><br><span class="line">学生表）： </span><br><span class="line"><span class="built_in">id</span>          name        班级ID（FK） </span><br><span class="line"><span class="number">1</span>           张杰            <span class="number">1</span> </span><br><span class="line">老师表）： </span><br><span class="line"><span class="built_in">id</span>          name </span><br><span class="line"><span class="number">1</span>           林峰 </span><br><span class="line"><span class="number">2</span>           林狗 </span><br><span class="line"><span class="number">3</span>           苑天 </span><br><span class="line">老师班级关系表）： </span><br><span class="line"><span class="built_in">id</span>          老师ID         班级ID </span><br><span class="line"><span class="number">1</span>           <span class="number">1</span>               <span class="number">1</span> </span><br><span class="line"><span class="number">2</span>           <span class="number">1</span>               <span class="number">2</span> </span><br><span class="line"><span class="number">3</span>           <span class="number">2</span>               <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>班级管理模块</p>
<p>查(母版继承)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    <span class="comment"># url(r&#x27;^admin/&#x27;, admin.site.urls), </span></span><br><span class="line">    url(<span class="string">r&#x27;classes/&#x27;</span>, views.classes), </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># view from django.shortcuts </span></span><br><span class="line"><span class="keyword">import</span> render,redirect </span><br><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classes</span>(<span class="params">request</span>):</span> </span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">    <span class="comment"># 设置查询结果为字典格式 </span></span><br><span class="line">    cursor.execute(<span class="string">&quot;select id, title from class&quot;</span>) </span><br><span class="line">    class_list = cursor.fetchall() </span><br><span class="line">    <span class="comment"># 结果为字典 </span></span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() </span><br><span class="line">    print(class_list) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;classes.html&#x27;</span>,&#123;<span class="string">&#x27;class_list&#x27;</span>:class_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    <span class="comment"># url(r&#x27;^admin/&#x27;, admin.site.urls), </span></span><br><span class="line">    url(<span class="string">r&#x27;^add_class/&#x27;</span>, views.add_class), </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># view </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;add_class.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        print(request.POST) </span><br><span class="line">        v = request.POST.get(<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">        conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;s4db65&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">        cursor.execute(<span class="string">&#x27;insert into class(title) value(%s)&#x27;</span>, [v,]) </span><br><span class="line">        conn.commit() </span><br><span class="line">        <span class="comment"># 提交事务 </span></span><br><span class="line">        cursor.close() </span><br><span class="line">        conn.close() </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/classes/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    url(<span class="string">r&#x27;^del_class/&#x27;</span>, views.del_class),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># view </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">    nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">    cursor.execute(<span class="string">&#x27;delete from class where id=%s&#x27;</span>,[nid,]) </span><br><span class="line">    conn.commit() </span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() </span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/classes/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">urlpatterns = [ url(<span class="string">r&#x27;^edit_class/&#x27;</span>, views.edit_class), ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># view </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="comment"># 获取数据 </span></span><br><span class="line">        nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd = <span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">        cursor.execute(<span class="string">&#x27;select id, title from class where id=%s&#x27;</span>, [nid,]) </span><br><span class="line">        result = cursor.fetchone() </span><br><span class="line">        cursor.close() </span><br><span class="line">        conn.close() </span><br><span class="line">        print(result) </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_class.html&#x27;</span>,&#123;<span class="string">&#x27;result&#x27;</span>:result&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        title = request.POST.get(<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">        print(nid, title) </span><br><span class="line">        conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">        cursor.execute(<span class="string">&#x27;update class set title=%s where id=%s&#x27;</span>,[title,nid,]) conn.commit() cursor.close() conn.close() </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/classes/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模态对话框实现增加班级功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">urlpatterns = [url(<span class="string">r&#x27;^modal_add_class/&#x27;</span>, views.modal_add_class]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views sqlheper工具类（将增删改查进行封装）： </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span>(<span class="params">sql,args</span>):</span> </span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.execute(sql,args) </span><br><span class="line">    conn.commit() </span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() </span><br><span class="line">    ---------- </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modal_add_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">    title = request.POST.get(<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title) &gt; <span class="number">0</span>: </span><br><span class="line">        sqlheper.modify(<span class="string">&#x27;insert into class (title) value(%s)&#x27;</span>,[title,]) </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;班级标题不能为空&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>学生管理模块</p>
<p>查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^students/&#x27;</span>,views.students),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">students</span>(<span class="params">request</span>):</span> </span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;s4db65&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">    cursor.execute(<span class="string">&#x27;select student.id,student.name,class.title from student left JOIN class on student.class_id = class.id&#x27;</span>) </span><br><span class="line">    student_list = cursor.fetchall() </span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() </span><br><span class="line">    print(<span class="string">&#x27;结果：&#x27;</span>,student_list) </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;students.html&#x27;</span>,&#123;<span class="string">&#x27;student_list&#x27;</span>:student_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^add_student/&#x27;</span>,views.add_student)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="comment">#只负责跳转页面 </span></span><br><span class="line">        conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;s4db65&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">        cursor.execute(<span class="string">&#x27;select id,title from class&#x27;</span>) </span><br><span class="line">        class_list = cursor.fetchall() </span><br><span class="line">        cursor.close() </span><br><span class="line">        conn.close() </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;add_student.html&#x27;</span>,&#123;<span class="string">&#x27;class_list&#x27;</span>:class_list&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        <span class="comment">#负责提交数据的跳转页面 </span></span><br><span class="line">        class_id = request.POST.get(<span class="string">&#x27;class_id&#x27;</span>) </span><br><span class="line">        conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123&#x27;</span>,db=<span class="string">&#x27;s4db65&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">        cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">        cursor.execute(<span class="string">&#x27;insert into student(name,class_id)values(%s,%s)&#x27;</span>,[name,class_id,]) </span><br><span class="line">        conn.commit() </span><br><span class="line">        cursor.close() </span><br><span class="line">        conn.close() </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/students/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^edit_student/&#x27;</span>,views.edit_student),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> sqlheper </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_student</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        class_list = sqlheper.get_list(<span class="string">&quot;select id,title from class&quot;</span>,[]) </span><br><span class="line">        current_student_info = sqlheper.get_one(<span class="string">&#x27;select id,name,class_id from student where id=%s&#x27;</span>,[nid,]) </span><br><span class="line">        print(<span class="string">&#x27;结果：&#x27;</span>,class_list,current_student_info,nid) </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_student.html&#x27;</span>,&#123;<span class="string">&#x27;class_list&#x27;</span>: class_list,<span class="string">&#x27;current_student_info&#x27;</span>:current_student_info&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">        class_id = request.POST.get(<span class="string">&#x27;class_id&#x27;</span>) </span><br><span class="line">        sqlheper.modify(<span class="string">&#x27;update student set name=%s,class_id=%s where id=%s&#x27;</span>,[name,class_id,nid,]) </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/students/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模态对话框实现增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^modal_add_student/&#x27;</span>, views.modal_add_student),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modal_add_student</span>(<span class="params">request</span>):</span> </span><br><span class="line">    ret = &#123;<span class="string">&#x27;status&#x27;</span>:<span class="literal">True</span>,<span class="string">&#x27;message&#x27;</span>:<span class="literal">None</span>&#125; </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;result&#x27;</span>,name) </span><br><span class="line">        class_id = request.POST.get(<span class="string">&#x27;class_id&#x27;</span>) </span><br><span class="line">        sqlheper.modify(<span class="string">&#x27;insert into student (name,class_id)values(%s,%s)&#x27;</span>,[name,class_id,]) </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">        ret[<span class="string">&#x27;status&#x27;</span>]=<span class="literal">False</span> </span><br><span class="line">        ret[<span class="string">&#x27;message&#x27;</span>]=<span class="built_in">str</span>[e] </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(ret))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模态对话框实现改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^modal_edit_student/&#x27;</span>, views.modal_edit_student),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modal_edit_student</span>(<span class="params">request</span>):</span> </span><br><span class="line">    ret = &#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">True</span>,<span class="string">&#x27;message&#x27;</span>: <span class="literal">None</span>&#125; </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        nid = request.POST.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">        class_id = request.POST.get(<span class="string">&#x27;class_id&#x27;</span>) </span><br><span class="line">        sqlheper.modify(<span class="string">&#x27;update student set name=%s,class_id=%s where id=%s&#x27;</span>,[name,class_id,nid,]) </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">        ret[<span class="string">&#x27;status&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">        ret[<span class="string">&#x27;message&#x27;</span>] = <span class="built_in">str</span>(e) </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(ret))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>老师管理模块</p>
<p>查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^teachers/&#x27;</span>, views.teachers),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="comment"># 多对多，以老师表展示 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teachers</span>(<span class="params">request</span>):</span> </span><br><span class="line">    teacher_list = sqlheper.get_list(<span class="string">&#x27;select id,name from teacher&#x27;</span>,[]) </span><br><span class="line">    teacher_list = sqlheper.get_list(</span><br><span class="line">        <span class="comment">#  select teacher.id as tid,teacher.name,class.title from teacher </span></span><br><span class="line">                LEFT JOIN teacher2class on teacher.<span class="built_in">id</span> = teacher2class.teacher_id </span><br><span class="line">                <span class="comment"># left JOIN class on class.id = teacher2class.class_id; ,[]) </span></span><br><span class="line">    print(teacher_list) </span><br><span class="line">    result = &#123;&#125; </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> teacher_list: </span><br><span class="line">        tid =row[<span class="string">&#x27;tid&#x27;</span>] </span><br><span class="line">        <span class="keyword">if</span> tid <span class="keyword">in</span> result: </span><br><span class="line">            result[tid][<span class="string">&#x27;titles&#x27;</span>].append(row[<span class="string">&#x27;title&#x27;</span>]) </span><br><span class="line">        lse: </span><br><span class="line">            result[tid] = &#123;<span class="string">&#x27;tid&#x27;</span>: row[<span class="string">&#x27;tid&#x27;</span>],<span class="string">&#x27;name&#x27;</span>:row[<span class="string">&#x27;name&#x27;</span>],<span class="string">&#x27;titles&#x27;</span>: [row[<span class="string">&#x27;title&#x27;</span>],]&#125; </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;teacher.html&#x27;</span>,&#123;<span class="string">&#x27;teacher_list&#x27;</span>:result.values()&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># ursl </span></span><br><span class="line">url(<span class="string">r&#x27;^add_teacher/&#x27;</span>, views.add_teacher),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_teacher</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        class_list = sqlheper.get_list(<span class="string">&#x27;select id,title from class&#x27;</span>,[]) </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;add_teacher.html&#x27;</span>,&#123;<span class="string">&#x27;class_list&#x27;</span>: class_list&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">        <span class="comment"># 老师表中添加一条数据 </span></span><br><span class="line">        teacher_id = sqlheper.create(<span class="string">&#x27;insert into teacher(name) values(%s)&#x27;</span>,[name,]) </span><br><span class="line">        <span class="comment"># 老师和班级关系表中插入数据 </span></span><br><span class="line">        class_ids = request.POST.getlist(<span class="string">&#x27;class_ids&#x27;</span>) </span><br><span class="line">        <span class="comment"># 一次连接，一次提交 data_list = [] </span></span><br><span class="line">        <span class="keyword">for</span> cls_id <span class="keyword">in</span> class_ids: </span><br><span class="line">            temp = (teacher_id,cls_id,) </span><br><span class="line">            data_list.append(temp) </span><br><span class="line">            obj = sqlheper.SqlHelper() </span><br><span class="line">            <span class="comment"># 通过自定义的mysql组件获得mysql连接对象 </span></span><br><span class="line">            obj.multiple_modify(<span class="string">&#x27;insert into teacher2class(teacher_id,class_id) values(%s,%s)&#x27;</span>,data_list) obj.close() </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/teachers/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^edit_teacher/&#x27;</span>,views.edit_teacher),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_teacher</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">        obj = sqlheper.SqlHelper() </span><br><span class="line">        teacher_info = obj.get_one(<span class="string">&#x27;select id,name from teacher where id =%s&#x27;</span>,[nid,]) </span><br><span class="line">        class_id_list = obj.get_list(<span class="string">&#x27;select class_id from teacher2class where teacher_id=%s&#x27;</span>,[nid,]) </span><br><span class="line">        class_list = obj.get_list(<span class="string">&#x27;select id,title from class&#x27;</span>,[]) </span><br><span class="line">        obj.close() </span><br><span class="line">        print(<span class="string">&#x27;当前老师信息&#x27;</span>,teacher_info) </span><br><span class="line">        print(<span class="string">&#x27;当前老师任教的班级id&#x27;</span>,class_id_list) </span><br><span class="line">        temp = [] </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> class_id_list: </span><br><span class="line">            temp.append(i[<span class="string">&#x27;class_id&#x27;</span>]) </span><br><span class="line">            print(<span class="string">&#x27;所有班级&#x27;</span>,class_list) </span><br><span class="line">            <span class="comment"># return HttpResponse(&#x27;...&#x27;) </span></span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_teacher.html&#x27;</span>,&#123; <span class="string">&#x27;teacher_info&#x27;</span>: teacher_info, <span class="string">&#x27;class_id_list&#x27;</span>: temp, <span class="string">&#x27;class_list&#x27;</span>: class_list, &#125;) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            nid = request.GET.get(<span class="string">&#x27;nid&#x27;</span>) </span><br><span class="line">            name = request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">            class_ids = request.POST.getlist(<span class="string">&#x27;class_ids&#x27;</span>) </span><br><span class="line">            obj = sqlheper.SqlHelper() </span><br><span class="line">            <span class="comment"># 更新老师表 </span></span><br><span class="line">            obj.modify(<span class="string">&#x27;update teacher set name=%s where id=%s&#x27;</span>,[name,nid]) </span><br><span class="line">            <span class="comment"># 更新老师和班级关系表 </span></span><br><span class="line">            <span class="comment"># 先把当前老师和班级的对应关系删除，然后再添加 </span></span><br><span class="line">            obj.modify(<span class="string">&#x27;delete from teacher2class where teacher_id=%s&#x27;</span>,[nid,]) </span><br><span class="line">            data_list = [] </span><br><span class="line">            <span class="keyword">for</span> cls_id <span class="keyword">in</span> class_ids: </span><br><span class="line">                temp = (nid,cls_id,) </span><br><span class="line">                data_list.append(temp) </span><br><span class="line">                obj = sqlheper.SqlHelper() </span><br><span class="line">                obj.multiple_modify(<span class="string">&#x27;insert into teacher2class(teacher_id,class_id) values(%s,%s)&#x27;</span>,data_list) </span><br><span class="line">                </span><br><span class="line">                obj.close() </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/teachers/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模态对话框增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^get_all_class/&#x27;</span>, views.get_all_class), </span><br><span class="line">url(<span class="string">r&#x27;^modal_add_teacher/&#x27;</span>, views.modal_add_teacher),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">    obj = sqlheper.SqlHelper() </span><br><span class="line">    class_list = obj.get_list(<span class="string">&#x27;select id,title from class&#x27;</span>,[]) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(json.dumps(class_list)) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modal_add_teacher</span>(<span class="params">request</span>):</span> </span><br><span class="line">    ret = &#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">True</span>,<span class="string">&#x27;message&#x27;</span>: <span class="literal">None</span>&#125; </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line">        class_id_list = request.POST.getlist(<span class="string">&#x27;class_id_list&#x27;</span>) </span><br><span class="line">        teacher_id = sqlheper.create(<span class="string">&#x27;insert into teacher(name) values(%s)&#x27;</span>,[name,]) </span><br><span class="line">        data_list = [] </span><br><span class="line">        <span class="keyword">for</span> cls_id <span class="keyword">in</span> class_id_list: </span><br><span class="line">            temp = (teacher_id,cls_id,) </span><br><span class="line">            data_list.append(temp) </span><br><span class="line">            obj = sqlheper.SqlHelper() </span><br><span class="line">            obj.multiple_modify(<span class="string">&#x27;insert into teacher2class(teacher_id,class_id) values(%s,%s)&#x27;</span>,data_list) </span><br><span class="line">            obj.close() </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">        ret[<span class="string">&#x27;status&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">        ret[<span class="string">&#x27;message&#x27;</span>] = <span class="string">&quot;处理失败&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(ret))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># sqlheper </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">sql,args</span>):</span> </span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">    cursor.execute(sql,args) </span><br><span class="line">    conn.commit() </span><br><span class="line">    last_row_id = cursor.lastrowid </span><br><span class="line">    cursor.close() </span><br><span class="line">    conn.close() </span><br><span class="line">    <span class="keyword">return</span> last_row_id </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlHelper</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> </span><br><span class="line">        self.connect() </span><br><span class="line">        <span class="comment"># 读取配置文件 </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span> </span><br><span class="line">            self.conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">            self.cursor = self.conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">multiple_modify</span>(<span class="params">self,sql,args</span>):</span> </span><br><span class="line">            self.cursor.executemany(sql,args) </span><br><span class="line">            self.conn.commit() </span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span> </span><br><span class="line">            self.cursor.close() </span><br><span class="line">            self.conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>用户登陆(包含cookies内容)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls </span></span><br><span class="line">url(<span class="string">r&#x27;^login/&#x27;</span>, views.login),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        user = request.POST.get(<span class="string">&#x27;username&#x27;</span>) </span><br><span class="line">        pwd = request.POST.get(<span class="string">&#x27;password&#x27;</span>) </span><br><span class="line">        <span class="keyword">if</span> user == <span class="string">&#x27;tom&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;123&#x27;</span>: </span><br><span class="line">            obj = redirect(<span class="string">&#x27;/classes/&#x27;</span>) </span><br><span class="line">            obj.set_signed_cookie(<span class="string">&#x27;ticket&#x27;</span>,<span class="string">&quot;567&quot;</span>,salt=<span class="string">&#x27;jjjjjj&#x27;</span>,max_age=<span class="number">900</span>,path=<span class="string">&#x27;/&#x27;</span>) </span><br><span class="line">            <span class="comment"># 设置cookies，浏览器的cookies中会直接以明文显示567 </span></span><br><span class="line">            <span class="keyword">return</span> obj </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classes</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment"># 去请求的cookie中找凭证 </span></span><br><span class="line">    <span class="comment"># tk = request.COOKIES.get(&#x27;ticket&#x27;) </span></span><br><span class="line">    tk = request.get_signed_cookie(<span class="string">&#x27;ticket&#x27;</span>,salt=<span class="string">&#x27;jjjjjj&#x27;</span>) </span><br><span class="line">    print(tk) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tk: </span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>) </span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;&#x27;</span>, db=<span class="string">&#x27;s4db65&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>) </span><br><span class="line">cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) </span><br><span class="line">cursor.execute(<span class="string">&quot;select id,title from class&quot;</span>) </span><br><span class="line">class_list = cursor.fetchall() </span><br><span class="line">cursor.close() </span><br><span class="line">conn.close() </span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;classes.html&#x27;</span>, &#123;<span class="string">&#x27;class_list&#x27;</span>: class_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 内容延伸 装饰器装饰views中的函数 @xzxx </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line">    obj = HttpResponse(<span class="string">&#x27;...&#x27;</span>) </span><br><span class="line">    obj.set_cookie(.....) </span><br><span class="line">    request.COOKIES.get(...) </span><br><span class="line">    obj.set_signed_cookie(.....) </span><br><span class="line">    request.get_signed_cookie(....)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a3">
<a id="_1707"></a>动态路由</h2>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 动态路由 </span></span><br><span class="line"><span class="comment"># url(r&#x27;^edit/(\w+)/(\w+)/&#x27;, views.edit), </span></span><br><span class="line"><span class="comment"># url(r&#x27;^edit/(?P&lt;a1&gt;\w+)/(?P&lt;a2&gt;\w+)/&#x27;, views.edit), </span></span><br><span class="line"><span class="comment"># url(r&#x27;^edit/(\w+).html$&#x27;, views.edit) </span></span><br><span class="line"><span class="comment">#正则表达式实现静态伪装</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">request,*args,**kwargs</span>):</span></span><br><span class="line">    <span class="comment">#获得请求数据 </span></span><br><span class="line">    print(args,kwargs) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>路由分发</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">＃路由分发实现不同模块分开编辑，团队协作开发 </span><br><span class="line">url(<span class="string">r&#x27;^app01/&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),　</span><br><span class="line"><span class="comment">#不同的程序模块 </span></span><br><span class="line">url(<span class="string">r&#x27;^app02/&#x27;</span>, include(<span class="string">&#x27;app02.urls&#x27;</span>)), </span><br><span class="line"><span class="comment"># url(r&#x27;^&#x27;, default), </span></span><br><span class="line"><span class="comment"># 设置默认页面，接收任意请求 </span></span><br><span class="line"><span class="comment"># url(r&#x27;^&#x27;, views.index), #</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反向生成URL（Django独有）</p>
<p>通过别名反射成URL，简化URL的填写， 用于权限管理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#urls </span></span><br><span class="line">url(<span class="string">r&#x27;^edit/(\w+)/(\w+)/&#x27;</span>, views.edit,name=<span class="string">&#x27;n2&#x27;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ORM基本操作（数据表+数据行操作</p>
<p>操作前的配置步骤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__init__.py文件 (ORM默认使用SQLlite连接数据库,需改成Mysql) </span><br><span class="line">添加： </span><br><span class="line"><span class="keyword">import</span> pymysql </span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在mysql中手动创建数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 配置setting文件中重写数数据库配置 </span></span><br><span class="line">TEMPLATES = [</span><br><span class="line">…… </span><br><span class="line"><span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR,<span class="string">&#x27;templates&#x27;</span>)],</span><br><span class="line">…… </span><br><span class="line">] </span><br><span class="line">DATABASES = &#123; </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123; </span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>:<span class="string">&#x27;s4day70db&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>, </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>操作表</p>
<p>创建表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 在数据库中的表名为模块名_UserInfo </span></span><br><span class="line">    nid = models.BigAutoField(primary_key=<span class="literal">True</span>) </span><br><span class="line">    <span class="comment">#可不写，默认会生成表中的id字段 </span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># settings配置文件中安装app01模块 I</span></span><br><span class="line">NSTALLED_APPS = [ </span><br><span class="line">    …… </span><br><span class="line">    <span class="string">&#x27;app01&#x27;</span>, </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 执行语句 </span></span><br><span class="line"><span class="comment">#生成数据表配置文件，包含生成及修改等信息 </span></span><br><span class="line">python manage.py makemigrations </span><br><span class="line"></span><br><span class="line"><span class="comment">#执行生成的配置文件</span></span><br><span class="line">python manage.py migrate </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    …… </span><br><span class="line">    age = models.IntegerField(default=<span class="number">1</span>) </span><br><span class="line">    <span class="comment"># 新增字段时需设置默认值/允许为空 </span></span><br><span class="line">    <span class="comment"># age = models.IntegerField(null=True)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 执行语句：</span></span><br><span class="line"><span class="comment">#生成数据表配置文件，包含生成及修改等信息 </span></span><br><span class="line">python manage.py makemigrations </span><br><span class="line"></span><br><span class="line"><span class="comment">#执行生成的配置文件</span></span><br><span class="line">python manage.py migrate </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考修改表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建外键关联：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserGroup</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    <span class="comment">#等同于主表，需将该类写在子表前面 </span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    <span class="comment"># 外键所在的表等同于子表 </span></span><br><span class="line">    …… </span><br><span class="line">    ug = models.ForeignKey(<span class="string">&#x27;UserGroup&#x27;</span>,null=<span class="literal">True</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    <span class="comment"># 外键关联字段关联UserGroup表中的Id字段，ug在UserInfo数据表中的字段为ug_id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>操作单表数据行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 增 </span></span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models </span><br><span class="line">models.UserGroup.objects.create(title=<span class="string">&#x27;销售部&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 删 </span></span><br><span class="line">models.UserGroup.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">2</span>).delete()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 改 </span></span><br><span class="line">models.UserGroup.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">2</span>).update(title=<span class="string">&#x27;公关部&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查 </span></span><br><span class="line">group_list = models.UserGroup.objects.<span class="built_in">all</span>() </span><br><span class="line">group_list = models.UserGroup.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">group_list = models.UserGroup.objects.<span class="built_in">filter</span>(id__gt=<span class="number">1</span>) <span class="comment">#大于1 </span></span><br><span class="line">group_list = models.UserGroup.objects.<span class="built_in">filter</span>(id__lt=<span class="number">1</span>) <span class="comment">#小于1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a7">
<a id="DjangoCBV_1907"></a>Django视图CBV</h2>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^login.html$&#x27;</span>, views.Login.as_view),</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span>(<span class="params">View</span>):</span> </span><br><span class="line">    <span class="comment"># 继承View类作为父类 # </span></span><br><span class="line">    <span class="comment">#重写父类方法，该方法可作为装饰器功能 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span> </span><br><span class="line">        <span class="comment"># 自定制 dispatch方法，除了可以利用父类中原dispatch方法，还可以自定制处理逻辑 </span></span><br><span class="line">        print(<span class="string">&#x27;before&#x27;</span>) </span><br><span class="line">        obj = <span class="built_in">super</span>(Login,self).dispatch(request, *args, **kwargs) </span><br><span class="line">        <span class="comment"># 传入Login对象作为参数，调用父类中的方法 </span></span><br><span class="line">        print(<span class="string">&#x27;after&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> obj </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span> </span><br><span class="line">        <span class="comment"># 请求为get请求时，自动调用该方法 </span></span><br><span class="line">        <span class="comment"># return HttpResponse(&#x27;Login.get&#x27;) </span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="comment"># 请求是POST请求时，自动调用该方法 </span></span><br><span class="line">        print(request.POST.get(<span class="string">&#x27;user&#x27;</span>)) </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;Login.post&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a8">
<a id="ORM_1948"></a>ORM连表操作（一对多）（一对多中，外键存在于从表中）</h2>


<p>models</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    <span class="comment"># 用户类型 </span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">     用户表 </span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>) </span><br><span class="line">    age = models.IntegerField() </span><br><span class="line">    ut = models.ForeignKey(<span class="string">&#x27;UserType&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    <span class="comment"># 关联UserType表中的id字段</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^test.html$&#x27;</span>, views.test),</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建数据 </span></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title=&#x27;普通用户&#x27;) </span></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title=&#x27;二逼用户&#x27;) </span></span><br><span class="line"><span class="comment"># models.UserType.objects.create(title=&#x27;牛逼用户&#x27;)</span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;方少伟&#x27;,age=18,ut_id=1) </span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;由秦兵&#x27;,age=18,ut_id=2) </span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;刘庚&#x27;,age=18,ut_id=2) </span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;陈涛&#x27;,age=18,ut_id=3) </span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;王者&#x27;,age=18,ut_id=3) </span></span><br><span class="line"><span class="comment"># models.UserInfo.objects.create(name=&#x27;杨涵&#x27;,age=18,ut_id=1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一对多的正向操作（让存在外键的从表进行跨表，去查询关联主表中的字段）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得Queryset对象格式数据（格式：对象名.外键字段名.关联表字段名） </span></span><br><span class="line">obj = models.UserInfo.objects.<span class="built_in">all</span>().first() </span><br><span class="line"><span class="comment"># 获取一条数据，无需再obj[0]来获取具体的对象 </span></span><br><span class="line">print(obj.name,obj.age,obj.ut.title) </span><br><span class="line"><span class="comment"># 获取跨表后的字段用obj.ut.title方式，ut是外键关联中的字段</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得查询结果为字典格式组合成列表类型的Queryset数据,可用list方法转换成列表格式（从表中的外键字段名__主表中的字段名） </span></span><br><span class="line">v1 = models.UserInfo.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;ut__title&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得查询结果为元组格式组合成列表类型的Queryset数据,可用List转换成列表（从表中的外键字段名__主表中的字段名） </span></span><br><span class="line">result = models.UserInfo.objects.<span class="built_in">all</span>().values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>.<span class="string">&#x27;ut__title&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一对多的反向操作(让主表进行跨表，去查询（有外键关联字段）从表中相应的字段作为查询条件或查询结果)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得Queryset对象格式的数据,(格式：主表的QuerySet对象名.从表名__set.all()) （一个用户类型下可以有很多用户，获得所有用户类型对应的用户信息数据）： </span></span><br><span class="line">obj = models.UserType.objects.<span class="built_in">all</span>().first() </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> obj.userinfo_set.<span class="built_in">all</span>(): </span><br><span class="line">    print(row.name,row.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得字典格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表（从表表名小写__主表字段名） </span></span><br><span class="line">v2 = models.UserType.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;userinfo__name&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获得元组格式Queryset对象格式的数据,需要转换成json字符串格式通过ajax返回数据时，可用list方法转换成列表。（外键字段名__从表字段名） </span></span><br><span class="line">result = models.UserType.objects.<span class="built_in">all</span>().values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;userinfo__name&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一对多其他参考：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 跨表 </span></span><br><span class="line"><span class="comment"># 正向查询： </span></span><br><span class="line"><span class="number">1.</span> </span><br><span class="line">    q = UserInfo.objects.<span class="built_in">all</span>().first() </span><br><span class="line">    q.ug.title </span><br><span class="line"><span class="number">2.</span> </span><br><span class="line">    UserInfo.objects.values(<span class="string">&#x27;nid&#x27;</span>,<span class="string">&#x27;ug_id&#x27;</span>) </span><br><span class="line">    UserInfo.objects.values(<span class="string">&#x27;nid&#x27;</span>,<span class="string">&#x27;ug_id&#x27;</span>,<span class="string">&#x27;ug__title&#x27;</span>) </span><br><span class="line"><span class="number">3.</span> </span><br><span class="line">    UserInfo.objects.values_list(<span class="string">&#x27;nid&#x27;</span>,<span class="string">&#x27;ug_id&#x27;</span>,<span class="string">&#x27;ug__title&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向查询： </span></span><br><span class="line"><span class="number">1.</span> 小写的表名_set </span><br><span class="line">    obj = UserGroup.objects.<span class="built_in">all</span>().first() </span><br><span class="line">    result = obj.userinfo_set.<span class="built_in">all</span>() [userinfo对象,userinfo对象,] </span><br><span class="line"><span class="number">2.</span> 小写的表名 </span><br><span class="line">    v = UserGroup.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">    v = UserGroup.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;小写的从表名称&#x27;</span>) </span><br><span class="line">    v = UserGroup.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;小写的从表名称__age&#x27;</span>) </span><br><span class="line"><span class="number">3.</span> 小写的表名 </span><br><span class="line">    v = UserGroup.objects.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">    v = UserGroup.objects.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;小写的表名称&#x27;</span>) </span><br><span class="line">    v = UserGroup.objects.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;小写的表名称__age&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a9">
<a id="ORM_2066"></a>ORM连表操作（多对多）</h2>

<p>（多对多中，主表与从表的外键都共同存在于第3张关联表中） ##</p>
<p>手动创建第三张关联表（推荐，手动更灵活）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    b = models.ForeignKey(<span class="string">&#x27;Boy&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    g = models.ForeignKey(<span class="string">&#x27;Girl&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span> </span><br><span class="line">        <span class="comment">#添加联合唯一字段 </span></span><br><span class="line">        unique_together = [ (<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>), ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="comment"># 添加数据 </span></span><br><span class="line">objs = [ </span><br><span class="line">    models.Boy(name=<span class="string">&#x27;方少伟&#x27;</span>), </span><br><span class="line">    models.Boy(name=<span class="string">&#x27;由秦兵&#x27;</span>), </span><br><span class="line">    models.Boy(name=<span class="string">&#x27;陈涛&#x27;</span>), </span><br><span class="line">    models.Boy(name=<span class="string">&#x27;闫龙&#x27;</span>), </span><br><span class="line">    models.Boy(name=<span class="string">&#x27;吴彦祖&#x27;</span>), </span><br><span class="line">] </span><br><span class="line">models.Boy.objects.bulk_create(objs,<span class="number">5</span>) </span><br><span class="line"><span class="comment"># 批量添加数据 </span></span><br><span class="line">objss = [ </span><br><span class="line">    models.Girl(nick=<span class="string">&#x27;小鱼&#x27;</span>), </span><br><span class="line">    models.Girl(nick=<span class="string">&#x27;小周&#x27;</span>), </span><br><span class="line">    models.Girl(nick=<span class="string">&#x27;小猫&#x27;</span>), </span><br><span class="line">    models.Girl(nick=<span class="string">&#x27;小狗&#x27;</span>), </span><br><span class="line">] </span><br><span class="line">models.Girl.objects.bulk_create(objss,<span class="number">5</span>) </span><br><span class="line"><span class="comment"># 1. 查询和方少伟有关系的姑娘 </span></span><br><span class="line"><span class="comment"># 第一种查询方式：跨表反向查询，获得对象 </span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name=&#x27;方少伟&#x27;).first() </span></span><br><span class="line"><span class="comment"># love_list = obj.love_set.all() </span></span><br><span class="line"><span class="comment"># 反向查询，获得所有love表中的对象 </span></span><br><span class="line"><span class="comment"># for row in love_list: </span></span><br><span class="line"><span class="comment"># print(row.g.nick) </span></span><br><span class="line"><span class="comment"># 获得对应的姑娘数据 </span></span><br><span class="line"><span class="comment"># 第二种查询方式：连表查询（正向查询），直接查询love表，获得对象 </span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name=&#x27;方少伟&#x27;) </span></span><br><span class="line"><span class="comment">#获得Queryset对象 </span></span><br><span class="line"><span class="comment"># for row in love_list: </span></span><br><span class="line"><span class="comment"># print(row.g.nick) </span></span><br><span class="line"><span class="comment"># （推荐）第三种查询方式：只发送一次sql连接请求，获得字典,属于正向查询 </span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name=&#x27;方少伟&#x27;).values(&#x27;g__nick&#x27;) # for item in love_list: </span></span><br><span class="line"><span class="comment"># 获得字典格式的列表，[&#123;&#x27;g__nick&#x27;:&#x27;xxx&#125;,] # print(item[&#x27;g__nick&#x27;]) </span></span><br><span class="line"><span class="comment"># （推荐）第四种查询方式：相当于inner join方式连表查询，只发送一次sql连接请求，获得对象 </span></span><br><span class="line"><span class="comment"># love_list = models.Love.objects.filter(b__name=&#x27;方少伟&#x27;).select_related(&#x27;g&#x27;) </span></span><br><span class="line"><span class="comment"># for obj in love_list: </span></span><br><span class="line"><span class="comment"># 获得对象 </span></span><br><span class="line"><span class="comment"># print(obj.g.nick) </span></span><br><span class="line"><span class="comment"># 总结：多对多都是先获得关联表中的数据，再进行跨表操作 </span></span><br><span class="line"><span class="comment"># 对象格式用.（点）进行跨表 字典和元组采用_（双下划线）进行跨表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Django自动生成第三张关联表（无法再手动添加其它字段）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    m = models.ManyToManyField(<span class="string">&#x27;Girl&#x27;</span>) </span><br><span class="line"><span class="comment">#自动生成关联表m，以两张表中的id字段作为关联字段 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="comment"># 增 </span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name=&#x27;方少伟&#x27;).first() </span></span><br><span class="line"><span class="comment"># obj.m.add(2) </span></span><br><span class="line"><span class="comment"># obj.m.add(2,4) </span></span><br><span class="line"><span class="comment"># 创建关联表的多条数据 </span></span><br><span class="line"><span class="comment"># obj.m.add(*[1,3]) </span></span><br><span class="line"><span class="comment"># 以列表形式创建多条数据 </span></span><br><span class="line"><span class="comment"># 删 </span></span><br><span class="line"><span class="comment"># obj.m.remove(1) </span></span><br><span class="line"><span class="comment"># obj.m.remove(2,3) </span></span><br><span class="line"><span class="comment"># 删除关联表的多条数据 </span></span><br><span class="line"><span class="comment"># obj.m.remove(*[4,]) </span></span><br><span class="line"><span class="comment"># obj.m.set([1,]) </span></span><br><span class="line"><span class="comment"># 覆盖数据库所有数据,重置 </span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name=&#x27;方少伟&#x27;).first() </span></span><br><span class="line"><span class="comment"># obj.m.clear() </span></span><br><span class="line"><span class="comment"># 删除所有与方少伟的关联数据 </span></span><br><span class="line"><span class="comment"># 查 </span></span><br><span class="line"><span class="comment"># 正向查询出单条数据 </span></span><br><span class="line"><span class="comment"># obj = models.Boy.objects.filter(name=&#x27;方少伟&#x27;).first() </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># girl_list = obj.m.all() </span></span><br><span class="line"><span class="comment"># girl_list = obj.m.filter(nick=&#x27;小鱼&#x27;) </span></span><br><span class="line"><span class="comment"># 相当于从从表跨表到主表查询 </span></span><br><span class="line"><span class="comment"># print(girl_list) </span></span><br><span class="line"><span class="comment"># 反向查询出多条数据 </span></span><br><span class="line"><span class="comment"># obj = models.Girl.objects.filter(nick=&#x27;小鱼&#x27;).first() </span></span><br><span class="line"><span class="comment"># print(obj.id,obj.nick) </span></span><br><span class="line"><span class="comment"># boy_list = obj.boy_set.all() </span></span><br><span class="line"><span class="comment"># 相当于从主表跨表到从表反向查询</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>手动与自动结合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># models </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    m = models.ManyToManyField(to=<span class="string">&#x27;Girl&#x27;</span>,through=<span class="string">&quot;Love&quot;</span>,through_fields=(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,)) </span><br><span class="line"><span class="comment"># 可不写to关键字 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nick = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    b = models.ForeignKey(<span class="string">&#x27;Boy&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    g = models.ForeignKey(<span class="string">&#x27;Girl&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span> unique_together = [ (<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>), ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line">obj = models.Boy.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;方少伟&#x27;</span>).first() </span><br><span class="line">obj.m.add(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># obj.m.remove(1) </span></span><br><span class="line"><span class="comment"># obj.m.clear() 可以 v = obj.m.all() print(v)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a10">
<a id="ORM_2219"></a>ORM连表操作（多对多自关联）</h2>

<p>原理：等同于复制出一张新表</p>
<p>models</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>) </span><br><span class="line">    gender_choices = ( (<span class="number">1</span>,<span class="string">&#x27;男&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;女&#x27;</span>), ) </span><br><span class="line">    gender = models.IntegerField(choices=gender_choices) </span><br><span class="line">    m = models.ManyToManyField(<span class="string">&#x27;UserInfo&#x27;</span>) </span><br><span class="line"><span class="comment"># 多对多自关联字段，自动生成第二张表，字段分别为from_userinfo_id和to_userinfo_id; </span></span><br><span class="line"><span class="comment"># 表中的m属性不会在userinfo表中生成m字段</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span> </span><br><span class="line"><span class="comment"># 查男生（通过m字段查询属于正向操作） </span></span><br><span class="line">xz = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).first() </span><br><span class="line"><span class="comment">#id为1代表男生的1条数据 </span></span><br><span class="line">u = xz.m.<span class="built_in">all</span>() <span class="keyword">for</span> row <span class="keyword">in</span> u: print(row.nickname) </span><br><span class="line"><span class="comment"># 查女生(通过表名称_set查询属于反向操作) </span></span><br><span class="line">xz = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">4</span>).first() </span><br><span class="line"><span class="comment">#id为4代表女生的1条数据 </span></span><br><span class="line">v = xz.userinfo_set.<span class="built_in">all</span>() </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> v: </span><br><span class="line">    print(row.nickname) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>外键自关联（常用于评论表功能）</p>
<p>等同于复制出一张新表，用原表中的外键作连表操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    <span class="comment"># #  评论表  </span></span><br><span class="line">    <span class="comment"># 新闻ID </span></span><br><span class="line">    news_id = models.IntegerField() </span><br><span class="line">    <span class="comment"># 评论内容 </span></span><br><span class="line">    content = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    <span class="comment"># 评论者 </span></span><br><span class="line">    user = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    <span class="comment">#related_name表示反向查询时，代替 表名_set 和 表名__字段名 </span></span><br><span class="line">    reply = models.ForeignKey(<span class="string">&#x27;Comment&#x27;</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>,related_name=<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    新闻ID                        reply_id </span><br><span class="line">    <span class="number">1</span>           别比比 root         null </span><br><span class="line">    <span class="number">1</span>           就比比 root         null </span><br><span class="line">    <span class="number">1</span>           瞎比比 shaowei      null </span><br><span class="line">    <span class="number">2</span>           写的正好 root       null </span><br><span class="line">    <span class="number">1</span>           拉倒吧 由清滨         <span class="number">2</span> </span><br><span class="line">    <span class="number">1</span>           拉倒吧<span class="number">1</span> xxxxx        <span class="number">2</span> </span><br><span class="line">    <span class="number">1</span>           拉倒吧<span class="number">2</span> xxxxx       <span class="number">5</span> </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    新闻<span class="number">1</span> </span><br><span class="line">        别比比 </span><br><span class="line">        就比比 </span><br><span class="line">            - 拉倒吧 </span><br><span class="line">            - 拉倒吧<span class="number">2</span> </span><br><span class="line">        - 拉倒吧<span class="number">1</span> </span><br><span class="line">        瞎比比 </span><br><span class="line">        </span><br><span class="line">    新闻<span class="number">2</span>： </span><br><span class="line">        写的正好 </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a11">
<a id="ORMmodels_2294"></a>ORM操作补充（models模块中数据表属性定义操作）</h2>


<p>models</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> RegexValidator </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    email = models.EmailField(</span><br><span class="line">        ull=<span class="literal">True</span>,</span><br><span class="line">        default=<span class="string">&#x27;111&#x27;</span>, </span><br><span class="line">        db_index=<span class="literal">True</span>,</span><br><span class="line">        unique=<span class="literal">True</span>, </span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        verbose_name=<span class="string">&#x27;邮箱&#x27;</span>, </span><br><span class="line">        editable=<span class="literal">True</span>, </span><br><span class="line">        help_text=<span class="string">&#x27;字段提示信息的内容&#x27;</span>, </span><br><span class="line">    ) </span><br><span class="line"><span class="comment"># blank控制admin是否为空， </span></span><br><span class="line">file = models.FileField() </span><br><span class="line"><span class="comment">#文件字段，只针对admin </span></span><br><span class="line">ctime = models.DateTimeField() </span><br><span class="line"><span class="comment"># 日期字段 </span></span><br><span class="line"><span class="comment"># 自定义正则表达式验证规则 </span></span><br><span class="line">test = models.CharField(</span><br><span class="line">    max_length=<span class="number">32</span>, </span><br><span class="line">    error_messages=&#123; <span class="string">&#x27;c1&#x27;</span>: <span class="string">&#x27;优先错信息1&#x27;</span>, &#125;, </span><br><span class="line">    validators=[RegexValidator(regex=<span class="string">&#x27;root_\d+&#x27;</span>, message=<span class="string">&#x27;错误了&#x27;</span>, code=<span class="string">&#x27;c1&#x27;</span>)], </span><br><span class="line">    null=<span class="literal">True</span> </span><br><span class="line">) </span><br><span class="line"><span class="comment"># 数字及小数 </span></span><br><span class="line"><span class="comment"># num = models.FloatField() </span></span><br><span class="line"><span class="comment"># num = models.IntegerField() </span></span><br><span class="line">num = models.DecimalField(max_digits=<span class="number">30</span>,decimal_places=<span class="number">10</span>) </span><br><span class="line"><span class="comment"># 总长度为30，小数点后面10位 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举 c</span></span><br><span class="line">olor_list = ( </span><br><span class="line">    (<span class="number">1</span>,<span class="string">&#x27;黑色&#x27;</span>), </span><br><span class="line">    (<span class="number">2</span>,<span class="string">&#x27;白色&#x27;</span>), </span><br><span class="line">    (<span class="number">3</span>,<span class="string">&#x27;蓝色&#x27;</span>)</span><br><span class="line">) </span><br><span class="line">color = models.IntegerField(choices=color_list) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span> </span><br><span class="line">    unique_together=( </span><br><span class="line">        (<span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 字段联合唯一索引 </span></span><br><span class="line">) </span><br><span class="line">index_together=( </span><br><span class="line">    (<span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;username&#x27;</span>)   <span class="comment"># 联合索引，不做约束限制 </span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">的∂</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># admin模块 </span></span><br><span class="line"><span class="keyword">from</span> django.contrib </span><br><span class="line"><span class="keyword">import</span> admin <span class="keyword">from</span> app01 </span><br><span class="line"><span class="keyword">import</span> models admin.site.register(models.UserAdmin)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a12">
<a id="_2356"></a>分页查询</h2>


<p>内置分页函数</p>
<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^index.html$&#x27;</span>, views.index),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.core.paginator </span><br><span class="line"><span class="keyword">import</span> Paginator,Page,PageNotAnInteger,EmptyPage </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line">    user_list = models.UserInfo.objects.<span class="built_in">all</span>() </span><br><span class="line"><span class="comment">#获得所有数据库数据 </span></span><br><span class="line">paginator = Paginator(user_list,<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#设置每页显示的总条数 </span></span><br><span class="line">current_page = request.GET.get(<span class="string">&#x27;page&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得当前页数 </span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    <span class="comment">#设置当前页数对应的数据 </span></span><br><span class="line">    posts = paginator.page(current_page) </span><br><span class="line"><span class="keyword">except</span> PageNotAnInteger <span class="keyword">as</span> e: </span><br><span class="line">    <span class="comment">#当前页面数非整数 </span></span><br><span class="line">    posts = paginator.page(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">except</span> EmptyPage <span class="keyword">as</span> e: </span><br><span class="line">    <span class="comment">#当前页码数为空 </span></span><br><span class="line">    posts = paginator.page(<span class="number">1</span>) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,&#123;<span class="string">&#x27;posts&#x27;</span>:posts&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="a13">
<a id="ORM_2521"></a>ORM补充之基本操作（数据行高级操作）</h2>


<p>排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user_list = models.UserInfo.objects.<span class="built_in">all</span>().order_by(<span class="string">&#x27;-id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line"><span class="comment"># —id代表降序，id代表升序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models </span><br><span class="line"><span class="keyword">import</span> Count,Sum,Max,Min </span><br><span class="line">v =models.UserInfo.objects.values(<span class="string">&#x27;ut_id&#x27;</span>).annotate(xxxx=Count(<span class="string">&#x27;id&#x27;</span>)) </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">    SELECT </span><br><span class="line">        `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`<span class="built_in">id</span>`) AS `xxxx` </span><br><span class="line">    FROM </span><br><span class="line">        `app01_userinfo` </span><br><span class="line">    GROUP BY </span><br><span class="line">        `app01_userinfo`.`ut_id` </span><br><span class="line">    ORDER BY </span><br><span class="line">        NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 带有having 分组条件过滤 </span></span><br><span class="line">v =models.UserInfo.objects.values(<span class="string">&#x27;ut_id&#x27;</span>).annotate(xxxx=Count(<span class="string">&#x27;id&#x27;</span>)).<span class="built_in">filter</span>(xxxx__gt=<span class="number">2</span>) </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">    SELECT </span><br><span class="line">        `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`<span class="built_in">id</span>`) AS `xxxx` </span><br><span class="line">    FROM </span><br><span class="line">        `app01_userinfo` </span><br><span class="line">    GROUP BY </span><br><span class="line">        `app01_userinfo`.`ut_id` </span><br><span class="line">    HAVING </span><br><span class="line">        COUNT(`app01_userinfo`.`<span class="built_in">id</span>`) &gt; <span class="number">2</span> </span><br><span class="line">    ORDER BY </span><br><span class="line">        NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">v =models.UserInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">2</span>).values(<span class="string">&#x27;ut_id&#x27;</span>).annotate(xxxx=Count(<span class="string">&#x27;id&#x27;</span>)).<span class="built_in">filter</span>(xxxx__gt=<span class="number">2</span>) </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">    SELECT </span><br><span class="line">        `app01_userinfo`.`ut_id`, COUNT(`app01_userinfo`.`<span class="built_in">id</span>`) AS `xxxx` </span><br><span class="line">    FROM </span><br><span class="line">        `app01_userinfo` </span><br><span class="line">    WHERE </span><br><span class="line">        `app01_userinfo`.`<span class="built_in">id</span>` &gt; <span class="number">2</span> </span><br><span class="line">    GROUP BY </span><br><span class="line">        `app01_userinfo`.`ut_id` </span><br><span class="line">    HAVING </span><br><span class="line">        COUNT(`app01_userinfo`.`<span class="built_in">id</span>`) &gt; <span class="number">2</span> </span><br><span class="line">    ORDER BY </span><br><span class="line">        NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">分组格式：model.类名.objects.values(显示的字段名).annotate(作为字段查结结果的别名=Count(字段<span class="built_in">id</span>/<span class="number">1</span>)) </span><br><span class="line"><span class="comment"># annotate依赖于values</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>条件过滤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">1</span>) <span class="comment"># id&gt;1 </span></span><br><span class="line">……（id__lt=<span class="number">1</span>） <span class="comment"># id&lt;1 </span></span><br><span class="line">……(id__lte=<span class="number">1</span>) <span class="comment"># id&lt;=1 </span></span><br><span class="line">……(id__gte=<span class="number">1</span>) <span class="comment"># id&gt;=1 </span></span><br><span class="line">……(id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># id in [1,2,3] </span></span><br><span class="line">……(name__startswith=<span class="string">&#x27;xxxx&#x27;</span>) <span class="comment"># </span></span><br><span class="line">……(name__contains=<span class="string">&#x27;xxxx&#x27;</span>) <span class="comment"># </span></span><br><span class="line">……exclude(<span class="built_in">id</span>=<span class="number">1</span>) <span class="comment"># </span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> (<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>F,Q,extra方法</p>
<p>F</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F </span><br><span class="line">models.UserInfo.objects.<span class="built_in">all</span>().update(age=F(<span class="string">&quot;age&quot;</span>)+<span class="number">1</span>) </span><br><span class="line"><span class="comment"># F()用来取对象中某列值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q(构造复杂的查询条件)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 对象方式(不推荐) </span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q </span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(Q(id__gt=<span class="number">1</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(Q(<span class="built_in">id</span>=<span class="number">8</span>) | Q(<span class="built_in">id</span>=<span class="number">2</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># and</span></span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(Q(<span class="built_in">id</span>=<span class="number">8</span>) &amp; Q(<span class="built_in">id</span>=<span class="number">2</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q </span><br><span class="line">q1 = Q() </span><br><span class="line">q1.connector = <span class="string">&#x27;OR&#x27;</span> </span><br><span class="line">q1.children.append((<span class="string">&#x27;id__gt&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q1.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">10</span>)) </span><br><span class="line"><span class="comment"># 通过OR将3个条件进行连接组装 </span></span><br><span class="line">q2 = Q() </span><br><span class="line">q2.connector = <span class="string">&#x27;OR&#x27;</span> </span><br><span class="line">q2.children.append((<span class="string">&#x27;c1&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q2.children.append((<span class="string">&#x27;c1&#x27;</span>, <span class="number">10</span>)) </span><br><span class="line">q3 = Q() q3.connector = <span class="string">&#x27;AND&#x27;</span> </span><br><span class="line"><span class="comment">#通过AND将2个条件进行连接组装 </span></span><br><span class="line">q3.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q3.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>)) </span><br><span class="line">q1.add(q3,<span class="string">&#x27;OR&#x27;</span>) </span><br><span class="line"><span class="comment">#还可将q3嵌入到q1条件组中 </span></span><br><span class="line"><span class="comment"># 将q1和q2条件组通过AND汇总到一起，q1和q2内部分别用or组合条件 </span></span><br><span class="line">con = Q() </span><br><span class="line">con.add(q1, <span class="string">&#x27;AND&#x27;</span>) </span><br><span class="line">con.add(q2, <span class="string">&#x27;AND&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法方式实际应用（多条件组合查询时）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">condition_dict = &#123; <span class="comment">#用户将选择的条件组合成字典格式 </span></span><br><span class="line">    <span class="string">&#x27;k1&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], </span><br><span class="line">    <span class="string">&#x27;k2&#x27;</span>:[<span class="number">1</span>,], </span><br><span class="line">&#125; </span><br><span class="line">con = Q() </span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> condition_dict.items(): </span><br><span class="line">    q = Q() </span><br><span class="line">    q.connector = <span class="string">&#x27;OR&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v: </span><br><span class="line">    q.children.append((<span class="string">&#x27;id&#x27;</span>, i)) </span><br><span class="line">    con.add(q,<span class="string">&#x27;AND&#x27;</span>) </span><br><span class="line"></span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(con)</span><br><span class="line">*********************************************************************** </span><br><span class="line">q1 = Q() </span><br><span class="line">q1.connector = <span class="string">&#x27;OR&#x27;</span> </span><br><span class="line">q1.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q1.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">10</span>)) </span><br><span class="line">q1.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">9</span>)) </span><br><span class="line">q2 = Q() </span><br><span class="line">q2.connector = <span class="string">&#x27;OR&#x27;</span> </span><br><span class="line">q2.children.append((<span class="string">&#x27;c1&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q2.children.append((<span class="string">&#x27;c1&#x27;</span>, <span class="number">10</span>)) </span><br><span class="line">q2.children.append((<span class="string">&#x27;c1&#x27;</span>, <span class="number">9</span>)) </span><br><span class="line">q3 = Q() </span><br><span class="line">q3.connector = <span class="string">&#x27;AND&#x27;</span> </span><br><span class="line">q3.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)) </span><br><span class="line">q3.children.append((<span class="string">&#x27;id&#x27;</span>, <span class="number">2</span>)) </span><br><span class="line">q1.add(q3,<span class="string">&#x27;OR&#x27;</span>) </span><br><span class="line">con = Q() </span><br><span class="line">con.add(q1, <span class="string">&#x27;AND&#x27;</span>) </span><br><span class="line">con.add(q2, <span class="string">&#x27;AND&#x27;</span>) </span><br><span class="line"><span class="comment">#以上构造结果等介于(id=1 or id = 10 or id=9 or (id=1 and id=2)) and (c1=1 or c1=10 or c1=9)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>extra(添加额外的自定义sql语句)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">models.UserInfo.objects.extra(self, select=<span class="literal">None</span>, where=<span class="literal">None</span>, params=<span class="literal">None</span>, tables=<span class="literal">None</span>, order_by=<span class="literal">None</span>, select_params=<span class="literal">None</span>) </span><br><span class="line">a. 映射 </span><br><span class="line">    select </span><br><span class="line">    select_params=<span class="literal">None</span> </span><br><span class="line">    select 此处 <span class="keyword">from</span> 表 </span><br><span class="line"></span><br><span class="line">b. 条件 </span><br><span class="line">    where=<span class="literal">None</span> </span><br><span class="line">    params=<span class="literal">None</span>, </span><br><span class="line">    select * <span class="keyword">from</span> 表 where 此处 </span><br><span class="line"></span><br><span class="line">c. 表 </span><br><span class="line">tables select * <span class="keyword">from</span> 表,此处 </span><br><span class="line"></span><br><span class="line">c. 排序 </span><br><span class="line">order_by=<span class="literal">None</span> </span><br><span class="line">select * <span class="keyword">from</span> 表 order by 此处</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">v = models.UserInfo.objects.<span class="built_in">all</span>().extra( </span><br><span class="line">    select=&#123; </span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>:<span class="string">&quot;select count(1) from app01_usertype where id=%s or id=%s&quot;</span>, </span><br><span class="line">        <span class="string">&#x27;m&#x27;</span>:<span class="string">&quot;select count(1) from app01_usertype where id=%s or id=%s&quot;</span>, </span><br><span class="line">    &#125;, </span><br><span class="line">    select_params=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">) </span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> v: </span><br><span class="line">    print(obj.name,obj.<span class="built_in">id</span>,obj.n) </span><br><span class="line">    ---------- 等价于将查询结果作为字段显示列： </span><br><span class="line"><span class="comment"># select </span></span><br><span class="line"><span class="comment"># id, </span></span><br><span class="line"><span class="comment"># name, </span></span><br><span class="line"><span class="comment"># (select count(1) from tb) as n </span></span><br><span class="line"><span class="comment"># from xb where ....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">models.UserInfo.objects.extra( </span><br><span class="line">    select=&#123;</span><br><span class="line">        <span class="string">&#x27;newid&#x27;</span>:<span class="string">&#x27;select count(1) from app01_usertype where id&gt;%s&#x27;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    select_params=[<span class="number">1</span>,], </span><br><span class="line">    where = [<span class="string">&#x27;age&gt;%s&#x27;</span>], </span><br><span class="line">    params=[<span class="number">18</span>,], </span><br><span class="line">    order_by=[<span class="string">&#x27;-age&#x27;</span>], </span><br><span class="line">    tables=[<span class="string">&#x27;app01_usertype&#x27;</span>]</span><br><span class="line">) </span><br><span class="line">---------- 等价于原生sql语句如下： </span><br><span class="line">select </span><br><span class="line">    app01_userinfo.<span class="built_in">id</span>, </span><br><span class="line">    (select count(<span class="number">1</span>) <span class="keyword">from</span> app01_usertype where <span class="built_in">id</span>&gt;<span class="number">1</span>) <span class="keyword">as</span> newid </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    app01_userinfo,app01_usertype </span><br><span class="line">where </span><br><span class="line">    app01_userinfo.age &gt; <span class="number">18</span> </span><br><span class="line">order by </span><br><span class="line">    app01_userinfo.age </span><br><span class="line">desc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">result = models.UserInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">1</span>).extra( </span><br><span class="line">        where=[<span class="string">&#x27;app01_userinfo.id &lt; %s&#x27;</span>], </span><br><span class="line">        params=[<span class="number">100</span>,], </span><br><span class="line">        tables=[<span class="string">&#x27;app01_usertype&#x27;</span>], </span><br><span class="line">        order_by=[<span class="string">&#x27;-app01_userinfo.id&#x27;</span>], </span><br><span class="line">        select=&#123;</span><br><span class="line">            <span class="string">&#x27;uid&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;sw&#x27;</span>:<span class="string">&quot;select count(1) from app01_userinfo&quot;</span></span><br><span class="line">        &#125; <span class="comment">#添加查询字段 </span></span><br><span class="line">    ) </span><br><span class="line">    ---------- </span><br><span class="line">    SELECT (<span class="number">1</span>) AS <span class="string">&quot;uid&quot;</span>, </span><br><span class="line">        (select count(<span class="number">1</span>) <span class="keyword">from</span> app01_userinfo) AS <span class="string">&quot;sw&quot;</span>, </span><br><span class="line">        <span class="string">&quot;app01_userinfo&quot;</span>.<span class="string">&quot;id&quot;</span>, </span><br><span class="line">        <span class="string">&quot;app01_userinfo&quot;</span>.<span class="string">&quot;name&quot;</span>, </span><br><span class="line">        <span class="string">&quot;app01_userinfo&quot;</span>.<span class="string">&quot;age&quot;</span>, </span><br><span class="line">        <span class="string">&quot;app01_userinfo&quot;</span>.<span class="string">&quot;ut_id&quot;</span> </span><br><span class="line">    FROM </span><br><span class="line">        <span class="string">&quot;app01_userinfo&quot;</span> , </span><br><span class="line">        <span class="string">&quot;app01_usertype&quot;</span> </span><br><span class="line">    WHERE </span><br><span class="line">        (<span class="string">&quot;app01_userinfo&quot;</span>.<span class="string">&quot;id&quot;</span> &gt; <span class="number">1</span> AND (app01_userinfo.<span class="built_in">id</span> &lt; <span class="number">100</span>)) </span><br><span class="line">    ORDER BY </span><br><span class="line">        (<span class="string">&quot;app01_userinfo&quot;</span>.<span class="built_in">id</span>) </span><br><span class="line">    DESC</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>取特定字段值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">v = models.UserInfo.objects.<span class="built_in">all</span>().only(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>) </span><br><span class="line"><span class="comment"># 获取字段以外的字段会再发出第二次sql请求</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>取当前字段以外的所有值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">v = models.UserInfo.objects.<span class="built_in">all</span>().defer(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">v = models.UserInfo.objects.<span class="built_in">all</span>().order_by(<span class="string">&#x27;-id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>).reverse() </span><br><span class="line"><span class="comment"># 只有在order_by()方法时才有效果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用数据库引擎</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.UserInfo.objects.<span class="built_in">all</span>().using(<span class="string">&#x27;db2&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>聚合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#统计总数 </span></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count </span><br><span class="line">result = models.UserInfo.objects.aggregate(k=Count(<span class="string">&#x27;ut_id&#x27;</span>, distinct=<span class="literal">True</span>), n=Count(<span class="string">&#x27;id&#x27;</span>)) </span><br><span class="line"><span class="comment"># distinct代表去重 print(ruselt.query())</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以字典格式添加数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = models.UserType.objects.create(**&#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以关键字参数添加数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = models.UserType.objects.create(title=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>批量增加数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">objs = [ models.UserInfo(name=<span class="string">&#x27;r11&#x27;</span>), ] </span><br><span class="line">models.UserInfo.objects.bulk_create(objs, <span class="number">10</span>) </span><br><span class="line"><span class="comment"># 10为一次提交10次数据，建议不超过999</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建/获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">obj, created = models.UserInfo.objects.get_or_create( </span><br><span class="line">    <span class="comment">#如果存在数据则获取，否则直接创建 </span></span><br><span class="line">    username=<span class="string">&#x27;root1&#x27;</span>, </span><br><span class="line">    pwd=<span class="string">&#x27;ff&#x27;</span>, </span><br><span class="line">    defaults=&#123;<span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;1111111&#x27;</span>,<span class="string">&#x27;u_id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;t_id&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>条件范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">models.UserInfo.objects.in_bulk([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"><span class="comment">#根据主键进行查询 相当于</span></span><br><span class="line">models.UserInfo.objects.<span class="built_in">filter</span>(id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>raw(书写原生sql语句)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name_map = &#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;name&#x27;</span>&#125; </span><br><span class="line"><span class="comment"># 将下面的title转换为name </span></span><br><span class="line">v1 = models.UserInfo.objects.raw(<span class="string">&#x27;SELECT id,title FROM app01_usertype&#x27;</span>,translations=name_map) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v1: </span><br><span class="line">    print(i,<span class="built_in">type</span>(i))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>select_related:查询主动做连表，一次性获取所有连表中的数据（性能相关：数据量少的情况下使用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">q = models.UserInfo.objects.<span class="built_in">all</span>().select_related(<span class="string">&#x27;ut&#x27;</span>,<span class="string">&#x27;gp&#x27;</span>) </span><br><span class="line"><span class="comment">#等价于select * from userinfo inner join usertype on ... for row in q: print(row.name,row.ut.title) </span></span><br><span class="line"><span class="comment">#采用.的形式获取连表数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>prefetch_related：不做连表，但会做多次查询（性能相关：数据量多，查询频繁下使用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">q = models.UserInfo.objects.<span class="built_in">all</span>().prefetch_related(<span class="string">&#x27;ut&#x27;</span>) </span><br><span class="line"><span class="comment"># select * from userinfo; </span></span><br><span class="line"><span class="comment"># Django内部：ut_id = [2,4] </span></span><br><span class="line"><span class="comment"># select * from usertype where id in [2,4] for row in q: print(row.id,row.ut.title)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a14">
<a id="XSS_2863"></a>XSS攻击（跨站脚本攻击）</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">模拟攻击时：前提需要将对应设置注释 MIDDLEWARE = [ </span><br><span class="line"><span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, </span></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^index/&#x27;</span>, views.index), url(<span class="string">r&#x27;^comment/&#x27;</span>, views.comment),</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;comment.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        v = request.POST.get(<span class="string">&#x27;content&#x27;</span>) msg.append(v) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;comment.html&#x27;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,&#123;<span class="string">&#x27;msg&#x27;</span>:msg&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 同时也可在视图函数中添加safe： </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe </span><br><span class="line">    temp = <span class="string">&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;百度&lt;/a&gt;&quot;</span> </span><br><span class="line">    newtemp = mark_safe(temp) </span><br><span class="line">    <span class="comment">#将内容处理成safe安全数据 </span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;test.html&#x27;</span>,&#123;<span class="string">&#x27;temp&#x27;</span>:newtemp&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">黑客可通过伪造网站，进行xss攻击，获得用户访问正式网站中的cookies， 从而伪装该用户可到正式网站进行操作，所以cookies很重要，要xss要处于启动状态（默认xss为启用状态）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CSRF(跨站请求伪装攻击)</p>
<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 前提需要setting文件中crsf验证开启 url(r&#x27;^csrf1.html$&#x27;, views.csrf1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csrf1</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;csrf1.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>补充：csrf第二种处理方式：添加装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View </span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator </span><br><span class="line"><span class="comment"># CBV装饰器，无法将内置的@csrf_protect装饰器直接应用到函数上，而需手动写装饰器进行应用 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args,**kwargs</span>):</span> </span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs) </span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#在指定方法上添加装饰器 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">View</span>):</span></span><br><span class="line"><span class="meta">    @method_decorator(wrapper) </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span> </span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span> </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 在类上添加 </span></span><br><span class="line"><span class="meta">@method_decorator(wrapper,name=&#x27;XXX&#x27;) </span></span><br><span class="line"><span class="comment">#name表示应用的函数名称 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">View</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span> </span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span> </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csrf1</span>(<span class="params">request</span>):</span> </span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;csrf1.html&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a15">
<a id="ORMhtmlsimple_tag_3031"></a>ORM函数相关（html模版上使用函数）simple_tag</h2>

<p>setting注册程序块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [ …… <span class="string">&#x27;app01&#x27;</span>, ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- simple_filter - 最多两个参数,格式： &#123;&#123;第一个参数|函数名称:<span class="string">&quot;第二个参数&quot;</span>&#125;&#125; - 可以做条件判断 - simple_tag - 无限制: &#123;% 函数名 参数 参数%&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a16">
<a id="cookiesessionsession_3137"></a>cookie和session（推荐使用session）</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cookie是保存在客户端浏览器上的键值对， Session是保存在服务端的数据（本质是键值对） 因为单独使用cookies，它会保留用户具体的明文形式（不转化成字符串的敏感信息）发送给浏览器（不安全），所以推荐使用session， session发送的是随机字符串，不包含用户敏感信息（安全），其中session依赖于cookies,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    …… </span><br><span class="line">    url(<span class="string">r&#x27;^login/&#x27;</span>, views.login), </span><br><span class="line">    url(<span class="string">r&#x27;^index/&#x27;</span>, views.index),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        u = request.POST.get(<span class="string">&#x27;user&#x27;</span>) </span><br><span class="line">        p = request.POST.get(<span class="string">&#x27;pwd&#x27;</span>) </span><br><span class="line">        obj = models.UserAdmin.objects.<span class="built_in">filter</span>(username=u,password=p).first() </span><br><span class="line">        <span class="keyword">if</span> obj: </span><br><span class="line">            <span class="comment"># 1. 生成随机字符串 </span></span><br><span class="line">            <span class="comment"># 2. 通过cookie发送给客户端 </span></span><br><span class="line">            <span class="comment"># 3. 服务端保存 </span></span><br><span class="line">            <span class="comment"># &#123; # 随机字符串1: </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;alex&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;x&#x27;</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; </span><br><span class="line">            <span class="comment"># &#125; request.session[&#x27;username&#x27;] = obj.username </span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>,&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;用户名或密码错误&#x27;</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment"># 获取客户端cookies中的随机字符串，去session中查找有无该字符串， 再通过字符串去session对应key的value中查看是有username，并获得它对应的值 </span></span><br><span class="line">    v = request.session.get(<span class="string">&#x27;username&#x27;</span>) </span><br><span class="line">    <span class="comment"># v为username对应的具体值 </span></span><br><span class="line">    <span class="keyword">if</span> v:   </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;登录成功:%s&#x27;</span> %v) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login/&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>setting</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># SESSION_COOKIE_NAME = &quot;sessionid&quot; </span></span><br><span class="line"><span class="comment"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 </span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_PATH = &quot;/&quot; </span></span><br><span class="line"><span class="comment"># Session的cookie保存的路径 </span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_DOMAIN = None </span></span><br><span class="line"><span class="comment"># Session的cookie保存的域名 </span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_SECURE = False </span></span><br><span class="line"><span class="comment"># 是否Https传输cookie </span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_HTTPONLY = True </span></span><br><span class="line"><span class="comment"># 是否Session的cookie只支持http传输 </span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_AGE = 1209600 </span></span><br><span class="line"><span class="comment"># Session的cookie失效日期（2周） </span></span><br><span class="line"><span class="comment"># SESSION_EXPIRE_AT_BROWSER_CLOSE = False </span></span><br><span class="line"><span class="comment"># 是否关闭浏览器使得Session过期 </span></span><br><span class="line"><span class="comment"># SESSION_SAVE_EVERY_REQUEST = False（推荐True） </span></span><br><span class="line"><span class="comment"># 是否每次请求都保存Session，默认修改之后才保存 SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cashe&#x27; </span></span><br><span class="line"><span class="comment">#引擎，缓存+数据库，推荐使用 SESSION__CASHE_ALLAS =&#x27;default&#x27; </span></span><br><span class="line"><span class="comment"># 使用缓存别名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a17">
<a id="demo_3207"></a>用户登陆demo</h2>


<p>models</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db </span><br><span class="line"><span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    password = models.CharField(max_length=<span class="number">63</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    password = models.CharField(max_length=<span class="number">63</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2G</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    b = models.ForeignKey(to=<span class="string">&#x27;Boy&#x27;</span>, to_field=<span class="string">&#x27;id&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    g = models.ForeignKey(to=<span class="string">&#x27;Girl&#x27;</span>, to_field=<span class="string">&#x27;id&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    url(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls), </span><br><span class="line">    url(<span class="string">r&#x27;^login.html$&#x27;</span>, account.login), </span><br><span class="line">    url(<span class="string">r&#x27;^index.html$&#x27;</span>, love.index), </span><br><span class="line">    url(<span class="string">r&#x27;^loginout.html$&#x27;</span>,account.loginout), </span><br><span class="line">    url(<span class="string">r&#x27;^others.html$&#x27;</span>,love.others), </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views(创立文件夹的形式用来区分模块关系)</p>
<p>account模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse,redirect </span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment">#  用户登陆 </span></span><br><span class="line">        :param request: </span><br><span class="line">        :<span class="keyword">return</span>: </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        user = request.POST.get(<span class="string">&#x27;username&#x27;</span>) </span><br><span class="line">        pwd = request.POST.get(<span class="string">&#x27;password&#x27;</span>) </span><br><span class="line">        gender = request.POST.get(<span class="string">&#x27;gender&#x27;</span>) </span><br><span class="line">        rmb = request.POST.get(<span class="string">&#x27;rmb&#x27;</span>) </span><br><span class="line">    <span class="comment"># 性别判断 </span></span><br><span class="line">    <span class="keyword">if</span> gender == <span class="string">&quot;1&quot;</span>:   </span><br><span class="line">        obj = models.Boy.objects.<span class="built_in">filter</span>(username=user,password=pwd).first() </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        obj = models.Girl.objects.<span class="built_in">filter</span>(username=user,password=pwd).first() </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj: </span><br><span class="line">            <span class="comment"># 未登录 </span></span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>,&#123;<span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;用户名或密码错误&#x27;</span>&#125;) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            request.session[<span class="string">&#x27;user_info&#x27;</span>] = &#123;<span class="string">&#x27;user_id&#x27;</span>:obj.<span class="built_in">id</span>,<span class="string">&#x27;gender&#x27;</span>:gender,<span class="string">&#x27;username&#x27;</span>:user,<span class="string">&#x27;nickname&#x27;</span>:obj.nickname&#125; </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/index.html&#x27;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginout</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment">#  注销 :</span></span><br><span class="line">        param request: </span><br><span class="line">        :<span class="keyword">return</span>: </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">&#x27;user_info&#x27;</span>): </span><br><span class="line">        request.session.clear() </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除服务端数据库session（推荐） </span></span><br><span class="line">    <span class="comment"># request.session.delete(request.session.session_key) </span></span><br><span class="line">    <span class="comment">#清除客户端session return redirect(&#x27;/login.html&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>love模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,HttpResponse </span><br><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    首页信息展示 </span><br><span class="line">    :param request: </span><br><span class="line">    :<span class="keyword">return</span>: </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.session.get(<span class="string">&#x27;user_info&#x27;</span>): </span><br><span class="line">        <span class="comment"># 获取浏览器中的session随机字符串 </span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/login.html&#x27;</span>) <span class="keyword">else</span>: </span><br><span class="line">        <span class="comment"># 男：女生列表 </span></span><br><span class="line">        <span class="comment"># 女：男生列表 </span></span><br><span class="line">        gender = request.session.get(<span class="string">&#x27;user_info&#x27;</span>).get(<span class="string">&#x27;gender&#x27;</span>) </span><br><span class="line">        <span class="keyword">if</span> gender == <span class="string">&#x27;1&#x27;</span>: </span><br><span class="line">            user_list = models.Girl.objects.<span class="built_in">all</span>() </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            user_list = models.Boy.objects.<span class="built_in">all</span>() </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,&#123;<span class="string">&#x27;user_list&#x27;</span>:user_list&#125;) </span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">others</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    获取与当前用户有关系的异性 </span><br><span class="line">    :param request: </span><br><span class="line">    :<span class="keyword">return</span>: </span><br><span class="line">    <span class="comment">#  </span></span><br><span class="line">    current_user_id = request.session.get(<span class="string">&#x27;user_info&#x27;</span>).get(<span class="string">&#x27;user_id&#x27;</span>) </span><br><span class="line">    gender = request.session.get(<span class="string">&#x27;user_info&#x27;</span>).get(<span class="string">&#x27;gender&#x27;</span>) </span><br><span class="line">    <span class="keyword">if</span> gender == <span class="string">&#x27;1&#x27;</span>: </span><br><span class="line">        user_list = models.B2G.objects.<span class="built_in">filter</span>(b_id=current_user_id).values(<span class="string">&#x27;g__nickname&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        user_list = models.B2G.objects.<span class="built_in">filter</span>(g_id=current_user_id).values(<span class="string">&#x27;b__nickname&#x27;</span>) </span><br><span class="line">        print(<span class="string">&#x27;result&#x27;</span>, user_list) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;others.html&#x27;</span>,&#123;<span class="string">&#x27;user_list&#x27;</span>:user_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>建立html组件：user_header</p>
<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">urlpatterns = [ </span><br><span class="line">    …… </span><br><span class="line">    url(<span class="string">r&#x27;^login/$&#x27;</span>, views.login), </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> Form,fields </span><br><span class="line"><span class="comment"># -------定义Form验证规则类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    <span class="comment"># 正则验证: 不能为空,6-18 </span></span><br><span class="line">    username = fields.CharField( </span><br><span class="line">        max_length=<span class="number">18</span>, </span><br><span class="line">        min_length=<span class="number">6</span>, </span><br><span class="line">        required=<span class="literal">True</span>, </span><br><span class="line">        error_messages=&#123; </span><br><span class="line">            <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;用户名不能为空&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;太短了&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;太长了&#x27;</span>, </span><br><span class="line">        &#125; </span><br><span class="line">    ) </span><br><span class="line">    <span class="comment"># 正则验证: 不能为空，16+ </span></span><br><span class="line">    password = fields.CharField(min_length=<span class="number">16</span>,required=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="comment">#Form表单提交形式 </span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            obj = LoginForm(request.POST) </span><br><span class="line">        <span class="comment">#将提交的数据交给Form组件验证 </span></span><br><span class="line">        <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">            <span class="comment"># 用户输入格式正确 </span></span><br><span class="line">            print(obj.cleaned_data) </span><br><span class="line">            <span class="comment"># 字典类型,只包含Form组件校验后的字段数据 </span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;http://www.baidu.com&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="comment"># 用户输入格式错误 </span></span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Form验证流程分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一步：</span><br><span class="line">实例化，将字段转换为self.fields格式 LoginForm实例化时， </span><br><span class="line">self.fields=&#123; <span class="string">&#x27;user&#x27;</span>: 正则表达式 <span class="string">&#x27;pwd&#x27;</span>: 正则表达式 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第二步：</span><br><span class="line">循环self.fields，获得字段 </span><br><span class="line">flag = <span class="literal">True</span> errors cleaned_data <span class="keyword">for</span> k,v <span class="keyword">in</span> self.fields.items(): </span><br><span class="line">input_value = request.POST.get(k) </span><br><span class="line"><span class="comment"># 循环获得k字段的值（k需与前端字段名保持一致） </span></span><br><span class="line">校验input_value的值是否匹配正则表达式 </span><br><span class="line">flag = <span class="literal">False</span> <span class="keyword">return</span> flag </span><br><span class="line">--------------------------------------- </span><br><span class="line"><span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">    <span class="comment">#返回结果为True则通过验证 </span></span><br><span class="line">    print(obj.cleaned_data) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    print(obj.errors) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">…… </span><br><span class="line">url(<span class="string">r&#x27;^ajax_login/&#x27;</span>, views.ajax_login),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    <span class="comment">#定义Form组件类，用来验证请求数据 </span></span><br><span class="line">    user = fields.CharField(required=<span class="literal">True</span>,min_length=<span class="number">6</span>) </span><br><span class="line">    pwd = fields.CharField(min_length=<span class="number">18</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ajax_login</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="keyword">import</span> json </span><br><span class="line">        ret=&#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">True</span>,<span class="string">&#x27;msg&#x27;</span>:<span class="literal">None</span>&#125; </span><br><span class="line">        obj = LoginForm(request.POST) </span><br><span class="line">        <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">            print(obj.cleaned_data) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            ret[<span class="string">&#x27;status&#x27;</span>]=<span class="literal">False</span> </span><br><span class="line">            ret[<span class="string">&#x27;msg&#x27;</span>]=obj.errors </span><br><span class="line">        <span class="comment"># 获得字典，k为字段名，v为错误信息列表 </span></span><br><span class="line">        v=json.dumps(ret) </span><br><span class="line">        print(obj.errors) </span><br><span class="line">        <span class="comment">#print时，会自动调用__str__(),在该方法中将字典组装成了ul标签 </span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Form组件常用字段及参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    t1 = fields.CharField( </span><br><span class="line">        required=<span class="literal">True</span>, </span><br><span class="line">        max_length=<span class="number">8</span>, </span><br><span class="line">        min_length=<span class="number">2</span>, </span><br><span class="line">        error_messages=&#123; </span><br><span class="line">            <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;不能为空&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;max_length&#x27;</span>: <span class="string">&#x27;太长&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;min_length&#x27;</span>: <span class="string">&#x27;太短&#x27;</span>, </span><br><span class="line">        &#125; ) </span><br><span class="line">    t2 = fields.IntegerField( </span><br><span class="line">        min_value=<span class="number">10</span>, </span><br><span class="line">        max_value=<span class="number">1000</span>, </span><br><span class="line">        error_messages=&#123; </span><br><span class="line">            <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;t2不能为空&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;t2格式错误，必须是数字&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;min_value&#x27;</span>: <span class="string">&#x27;必须大于10&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;max_value&#x27;</span>: <span class="string">&#x27;必须小于1000&#x27;</span>, </span><br><span class="line">        &#125;, ) </span><br><span class="line">    t3 = fields.EmailField( </span><br><span class="line">        error_messages=&#123; </span><br><span class="line">            <span class="string">&#x27;required&#x27;</span>: <span class="string">&#x27;t3不能为空&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;invalid&#x27;</span>: <span class="string">&#x27;t3格式错误，必须是邮箱格式&#x27;</span>, </span><br><span class="line">        &#125; ) </span><br><span class="line"><span class="comment"># 为空，长度，格式，正则</span></span><br><span class="line">    t4=fields.URLField() </span><br><span class="line">    t5=fields.SlugField() </span><br><span class="line">    t6=fields.GenericIPAddressField() </span><br><span class="line">    t7=fields.DateField() </span><br><span class="line">    t8=fields.DateTimeField() </span><br><span class="line">    t9=fields.RegexField(<span class="string">&#x27;139\d+&#x27;</span>) </span><br><span class="line"><span class="comment"># 自定义正则表达式的字段验证规则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">生成HTML标签： </span><br><span class="line">widget=widgets.Select, </span><br><span class="line">******** 用于指定生成怎样的HTML，select，text,<span class="built_in">input</span>/. label=<span class="string">&#x27;用户名&#x27;</span>, </span><br><span class="line"><span class="comment"># obj.t1.label disabled=False, </span></span><br><span class="line"><span class="comment"># 是否可以编辑 label_suffix=&#x27;---&gt;&#x27;, </span></span><br><span class="line"><span class="comment"># Label内容后缀 需要在html模版中添加&#123;&#123; obj.as_p &#125;&#125;来显示出所有Form类中定义的字段 initial=&#x27;666&#x27;, </span></span><br><span class="line"><span class="comment"># 无用，猜测有问题应该在input框中显示默认值 help_text=&#x27;。。。。。。&#x27;, </span></span><br><span class="line"><span class="comment"># 提供帮助信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^register/&#x27;</span>, views.register),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegiterForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    user = fields.CharField(min_length=<span class="number">8</span>) </span><br><span class="line">    email = fields.EmailField() </span><br><span class="line">    password = fields.CharField() </span><br><span class="line">    phone = fields.RegexField(<span class="string">&#x27;139\d+&#x27;</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">            obj = RegiterForm() </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;register.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">        <span class="comment"># 只返回表单组件类的HTML文本，无数值返回 </span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            obj = RegiterForm(request.POST) </span><br><span class="line">        <span class="comment"># 因用户提交了数据，Form组件会返回带有输入框值的HTML文本 </span></span><br><span class="line">        <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">            print(obj.cleaned_data) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            print(obj.errors) </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;register.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a19">
<a id="Form_3648"></a>Form组件完成学员管理系统</h2>


<p>models</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classes</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line"><span class="comment">#默认生成id </span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span> </span><br><span class="line"><span class="comment"># 重载方法，打印对象时，打印的内容为对象包含的title属性 </span></span><br><span class="line">        <span class="keyword">return</span> self.title </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    email = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    age = models.IntegerField(max_length=<span class="number">32</span>) </span><br><span class="line">    cls = models.ForeignKey(<span class="string">&#x27;Classes&#x27;</span>,on_delete=<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">models.Model</span>):</span> </span><br><span class="line">    tname = models.CharField(max_length=<span class="number">32</span>) </span><br><span class="line">    c2t = models.ManyToManyField(<span class="string">&#x27;Classes&#x27;</span>) </span><br><span class="line"><span class="comment"># 自动生成第3张关联表，表中自动生成两张表的外键关联id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>班级管理</p>
<p>查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls url(r&#x27;^class_list/&#x27;,views.class_list),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">class_list</span>(<span class="params">request</span>):</span> </span><br><span class="line">    cls_list = models.Classes.objects.<span class="built_in">all</span>() </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;class_list.html&#x27;</span>,&#123;<span class="string">&#x27;cls_list&#x27;</span>:cls_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls url(r&#x27;^add_class/&#x27;,views.add_class),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    title = fields.RegexField(<span class="string">&#x27;全栈\d+&#x27;</span>) </span><br><span class="line"><span class="comment"># 定义From组件校验规则 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_class</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">            obj = ClassForm() </span><br><span class="line">            <span class="comment"># 用Form组件生成表单标签到页面上 </span></span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;add_class.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            obj = ClassForm(request.POST) </span><br><span class="line">            <span class="comment"># 通过Form组件进行校验 </span></span><br><span class="line">            <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">                models.Classes.objects.create(**obj.cleaned_data) </span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/class_list/&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;add_class.html&#x27;</span>, &#123;<span class="string">&#x27;obj&#x27;</span>: obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls url(r&#x27;edit_class/(\d+)&#x27;,views.edit_class),</span></span><br><span class="line"><span class="comment">#接收任意数字id的正则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line">…… 省略Form组件定义类 …… </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_class</span>(<span class="params">request, nid</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        row = models.Classes.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first() </span><br><span class="line">        <span class="comment"># 让页面显示初始值 </span></span><br><span class="line">        <span class="comment"># obj = ClassForm(data=&#123;&#x27;title&#x27;: row.title&#125;) </span></span><br><span class="line">        <span class="comment">#发送到前端时，Form组件会进行校验 </span></span><br><span class="line">        obj = ClassForm(initial=&#123;<span class="string">&#x27;title&#x27;</span>: row.title&#125;) </span><br><span class="line">        <span class="comment">#Form组件不会进行校验</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_class.html&#x27;</span>,&#123;<span class="string">&#x27;nid&#x27;</span>:nid,<span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        obj = ClassForm(request.POST) <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">        <span class="comment"># models.Classes.objects.filter(id=nid).update(title = obj.cleaned_data[&#x27;title&#x27;]) </span></span><br><span class="line">        models.Classes.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).update(**obj.cleaned_data) </span><br><span class="line">        <span class="comment"># 以字典格式插入数据 </span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/class_list/&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_class.html&#x27;</span>,&#123;<span class="string">&#x27;nid&#x27;</span>: nid,<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>学生管理</p>
<p>查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls url(r&#x27;^student_list/&#x27;, views.student_list),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student_list</span>(<span class="params">request</span>):</span> </span><br><span class="line">    stu_list = models.Student.objects.<span class="built_in">all</span>() </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;student_list.html&#x27;</span>, &#123;<span class="string">&#x27;stu_list&#x27;</span>:stu_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls url(r&#x27;add_student/&#x27;, views.add_student),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views # Form组件定义： </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    name = fields.CharField( </span><br><span class="line">        min_length=<span class="number">2</span>, </span><br><span class="line">        max_length=<span class="number">6</span>, </span><br><span class="line">        widget=widgets.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;) <span class="comment">#表单组件样式选择及属性设置，默认组件样式为text文本框 </span></span><br><span class="line">    ) </span><br><span class="line">    email = fields.EmailField(</span><br><span class="line">        widget=widgets.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;)</span><br><span class="line">    ) </span><br><span class="line">    age = fields.IntegerField(</span><br><span class="line">        min_value=<span class="number">18</span>,</span><br><span class="line">        max_value=<span class="number">25</span>,</span><br><span class="line">        widget=widgets.TextInput(attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;)</span><br><span class="line">    ) </span><br><span class="line">    cls_id = fields.IntegerField( <span class="comment"># widget=widgets.Select(choices=[(1,&#x27;上海&#x27;),(2,&#x27;北京&#x27;)]) </span></span><br><span class="line">        widget=widgets.Select(</span><br><span class="line">            choices=models.Classes.objects.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>),</span><br><span class="line">            attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;form-control&#x27;</span>&#125;</span><br><span class="line">        ) <span class="comment"># 获得单选下拉框 </span></span><br><span class="line">        <span class="comment"># 另外一种写法：</span></span><br><span class="line">    cls_id=fields.ChoiceField( </span><br><span class="line">        choices = models.Class.objests.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">        widget = widgets.Select(attr=&#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;&#x27;</span>form-control&#125;) ) </span><br><span class="line">    ) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">            obj = StudentForm() </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;add_student.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            obj = StudentForm(request.POST) </span><br><span class="line">            <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">                models.Student.objects.create(**obj.cleaned_data) </span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/student_list/&#x27;</span>) </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> render(request,<span class="string">&#x27;add_student.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls url(r&#x27;^edit_student/(\d+)/&#x27;, views.edit_student),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line">……省略Form组件…… </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_student</span>(<span class="params">request,nid</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        row = models.Student.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;cls_id&#x27;</span>).first() </span><br><span class="line">        <span class="comment">#如果不添加first会报错，错误为“要解压的值太多” </span></span><br><span class="line">        obj = StudentForm(initial=row) </span><br><span class="line">        <span class="comment"># 将数据封装至Form组件中，initial设置为不做数据验证 </span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_student.html&#x27;</span>,&#123;<span class="string">&#x27;nid&#x27;</span>:nid, <span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        obj = StudentForm(request.POST) </span><br><span class="line">        <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">            models.Student.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).update(**obj.cleaned_data) </span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/student_list/&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;/edit_student.html&#x27;</span>,&#123;<span class="string">&#x27;nid&#x27;</span>:<span class="built_in">id</span>, <span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>老师管理</p>
<p>查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls url(r&#x27;^teacher_list/&#x27;, views.teacher_list),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teacher_list</span>(<span class="params">request</span>):</span> </span><br><span class="line">    tea_list = models.Teacher.objects.<span class="built_in">all</span>() </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;teacher_list.html&#x27;</span>,&#123;<span class="string">&#x27;tea_list&#x27;</span>:tea_list&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls url(r&#x27;^add_teacher/&#x27;, views.add_teacher),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views #Form组件定义：（实现数据动态显示） </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeacherForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    tname=fields.CharField(min_length=<span class="number">2</span>) </span><br><span class="line">    cls_id = fields.MultipleChoiceField( </span><br><span class="line">        <span class="comment">#　多选模式，过滤出字典中包含的是列表格式数据&#123;&#x27;cls_id&#x27;: [&#x27;2&#x27;, &#x27;3&#x27;]&#125;，而非列表字符串格式&#123;&#x27;cls_id&#x27;: “[&#x27;2&#x27;, &#x27;3&#x27;]”&#125; </span></span><br><span class="line">        <span class="comment"># choices=models.Classes.objects.values_list(&#x27;id&#x27;,&#x27;title&#x27;), </span></span><br><span class="line">        <span class="comment"># 生成下拉框对应的值，有了__init__()构造方法后可以不用写choices关键字参数 widget=widgets.SelectMultiple </span></span><br><span class="line">        <span class="comment"># 多选下拉框表单组件 </span></span><br><span class="line">    ) </span><br><span class="line">    <span class="comment">#因From组件对象不会重新启动获得数据库的值， #所以需要每一次类加载实例化的构造方法来重新获取数据库的值,实现数据动态显示 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span> </span><br><span class="line">        <span class="built_in">super</span>(TeacherForm,self).__init__(*args,**kwargs) </span><br><span class="line">        <span class="comment"># 调用父类构造方法 </span></span><br><span class="line">        self.fields[<span class="string">&#x27;cls_id&#x27;</span>].widget.choices=models.Classes.objects.values_list(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>) </span><br><span class="line">        <span class="comment"># 获得字典中字段的插件widget中的choices </span></span><br><span class="line">        <span class="comment"># Form组件执行方式 </span></span><br><span class="line">        <span class="comment"># obj = TeacherForm() </span></span><br><span class="line">        <span class="comment"># 1. 找到所有字段 </span></span><br><span class="line">        <span class="comment"># 2. self.fields = &#123; </span></span><br><span class="line">            <span class="comment"># 加载字典中的所有字段 </span></span><br><span class="line">            <span class="comment"># tname: fields.CharField(min_length=2) </span></span><br><span class="line">            <span class="comment"># &#125; </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_teacher</span>(<span class="params">request</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> request == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">            obj = TeacherForm() <span class="keyword">return</span> render(request,<span class="string">&#x27;add_teacher.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            obj = TeacherForm(request.POST) </span><br><span class="line">            <span class="keyword">if</span> obj.is_valid(): </span><br><span class="line">                cls_id= obj.cleaned_data.pop(<span class="string">&#x27;cls_id&#x27;</span>) </span><br><span class="line">                <span class="comment"># 单独提取出cls_id的值 </span></span><br><span class="line">                row = models.Teacher.objects.create(**obj.cleaned_data) </span><br><span class="line">                <span class="comment"># **字典,会自动将字典格式&#123;&#x27;tname&#x27;: &#x27;tom&#x27;&#125;转换成tname=&#x27;tom&#x27;格式的数据 </span></span><br><span class="line">                row.c2t.add(*cls_id) </span><br><span class="line">                <span class="comment"># *代表列表格式插入 </span></span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/teacher_list/&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> render(request,<span class="string">&#x27;add_teacher.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls url(r&#x27;^edit_teacher/(\d+)/&#x27;, views.edit_teacher),</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># views </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_teacher</span>(<span class="params">request,nid</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>: </span><br><span class="line">        row = models.Teacher.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first() </span><br><span class="line">        class_ids = row.c2t.values_list(<span class="string">&#x27;id&#x27;</span>) </span><br><span class="line">        <span class="comment">#获得关联的班级id,值为[(3,),(1,)] </span></span><br><span class="line">        <span class="comment"># zip()将[(3,),(1,)]转换为[（3，1),] </span></span><br><span class="line">        id_list = <span class="built_in">list</span>(<span class="built_in">zip</span>(*class_ids))[<span class="number">0</span>] </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*class_ids)) <span class="keyword">else</span> [] </span><br><span class="line">        <span class="comment"># obj = TeacherForm(initial=&#123;&#x27;tname&#x27;:row.tname,&#x27;xx&#x27;:[1,2,3]&#125;) </span></span><br><span class="line">        obj = TeacherForm(initial=&#123;<span class="string">&#x27;tname&#x27;</span>:row.tname,<span class="string">&#x27;cls_id&#x27;</span>:id_list&#125;) </span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;edit_teacher.html&#x27;</span>,&#123;<span class="string">&#x27;obj&#x27;</span>:obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a20">
<a id="Form_4101"></a>Form常用组件定制</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    t1 = fields.MultipleChoiceField(  <span class="comment"># 验证多选框的值 </span></span><br><span class="line">        choices =[(<span class="number">1</span>,<span class="string">&#x27;篮球&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;足球&#x27;</span>)],  <span class="comment"># 制定显示值 </span></span><br><span class="line">        widget=widgets.CheckboxSelectMultiple  <span class="comment"># 生成多选框组件 </span></span><br><span class="line">    ) </span><br><span class="line">    t2 =fields.MultipleChoiceField( </span><br><span class="line">        choices=[(<span class="number">1</span>,<span class="string">&#x27;篮球&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;足球&#x27;</span>)], </span><br><span class="line">        widget=widgets.RadioSelect  <span class="comment"># 单选按钮组件 </span></span><br><span class="line">    ) </span><br><span class="line">    t3 = fields.FileField( </span><br><span class="line">        widget=widgets.FileInput  <span class="comment"># 文件输入框 </span></span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a21">
<a id="Form_4121"></a>Form组件中的钩子（扩展自定义函数）</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span>(<span class="params">Form</span>):</span> </span><br><span class="line">    user = fields.CharField( <span class="comment"># 添加自定义正则表达式 </span></span><br><span class="line">        validators=[RegexValidator(<span class="string">r&#x27;^[0-9]+$&#x27;</span>, <span class="string">&#x27;请输入数字&#x27;</span>), </span><br><span class="line">        RegexValidator(<span class="string">r&#x27;^159[0-9]+$&#x27;</span>, <span class="string">&#x27;数字必须以159开头&#x27;</span>)],</span><br><span class="line">    ) </span><br><span class="line">    email = fields.EmailField() </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_user</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="comment"># 常用于扩展用户名是否在数据库中存在,验证码是否匹配，传参request </span></span><br><span class="line">        v = self.cleaned_data[<span class="string">&#x27;user&#x27;</span>] </span><br><span class="line">        <span class="keyword">if</span> models.Student.<span class="built_in">object</span>.<span class="built_in">filter</span>(name=v).count(): </span><br><span class="line">            <span class="keyword">raise</span> ValuedationError(<span class="string">&#x27;用户已存在&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> self.cleaned_data[<span class="string">&#x27;user&#x27;</span>]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="comment"># 常用于字段的联合唯一判断 </span></span><br><span class="line">        user=self.cleaned_data.get(<span class="string">&#x27;user&#x27;</span>) </span><br><span class="line">        email=self.cleaned_data.get(<span class="string">&#x27;email&#x27;</span>) </span><br><span class="line">        <span class="keyword">if</span> models.Stuent.objects.<span class="built_in">filter</span>(user=user,email=email).count(): </span><br><span class="line">            <span class="keyword">raise</span> ValuedationError(<span class="string">&#x27;用户名和邮箱联合已经存在&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> self.cleaned_data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a22">
<a id="Ajax_4147"></a>Ajax提交数据部分</h2>

<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;upload.html&#x27;</span>) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        file_obj = request.FILES.get(<span class="string">&#x27;fafafa&#x27;</span>) </span><br><span class="line">        <span class="comment"># 获得浏览器发送的文件 </span></span><br><span class="line">        file_path = os.path.join(<span class="string">&#x27;static&#x27;</span>, file_obj.name) </span><br><span class="line">        <span class="comment"># 组装文件路径 </span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> file_obj.chunks(): </span><br><span class="line">        <span class="comment"># 把文件块以字节的形式写入文件 </span></span><br><span class="line">            f.write(chunk) </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(file_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>自定义API用作返回数据</p>
<p>urls</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^users/&#x27;</span>, views.users),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>views</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">users</span>(<span class="params">request</span>):</span> </span><br><span class="line">    print(<span class="string">&#x27;请求到来&#x27;</span>) </span><br><span class="line">    callback = request.GET.get(<span class="string">&#x27;funcname&#x27;</span>) </span><br><span class="line">    user_list=[ <span class="string">&#x27;leo&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span> ] </span><br><span class="line">    temp = <span class="string">&#x27;%s(%s)&#x27;</span>%(callback, user_list) </span><br><span class="line">    print(temp) </span><br><span class="line">    <span class="comment"># return HttpResponse(json.dumps(user_list)) </span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(temp) </span><br><span class="line">    <span class="comment"># 返回一个字符串对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setting配置‘</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">&#x27;www.s4.com&#x27;</span>] </span><br><span class="line"><span class="comment"># 允许访问的主机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本地PC配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc 往hosts文件中添加内容：<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> www.s4.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="a230">
<a id="CORS_4456"></a>CORS解决跨域问题（跨来源资源共享）（响应头添加值）</h2>


<p>第三方服务器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^new_users/&#x27;</span>, views.new_users),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_users</span>(<span class="params">request</span>):</span> </span><br><span class="line">    user_list = [ <span class="string">&#x27;lleo&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;jack&#x27;</span> ] </span><br><span class="line">    obj = HttpResponse(json.dumps(user_list)) </span><br><span class="line">    <span class="comment"># 添加令牌，添加响应头信息 </span></span><br><span class="line">    obj[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>]=<span class="string">&#x27;http://www.s5.com:8000&#x27;</span> </span><br><span class="line">    <span class="comment"># 允许跨站的数据响应返回，浏览器不设阻拦 </span></span><br><span class="line">    <span class="comment"># obj[&quot;Access-Control-Allow-Origin&quot;]=”*“ print(&#x27;请求&#x27;) </span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂请求</p>
<p>第三方服务器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 复杂请求的处理 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_users</span>(<span class="params">request</span>):</span> </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;OPTIONS&#x27;</span>: </span><br><span class="line">        obj = HttpResponse() </span><br><span class="line">        obj[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] =<span class="string">&#x27;*&#x27;</span> </span><br><span class="line">        obj[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] =<span class="string">&#x27;DELETE&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> obj </span><br><span class="line">    </span><br><span class="line">    obj = HttpResponse(<span class="string">&#x27;adsf&#x27;</span>) </span><br><span class="line">    obj[<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>] = <span class="string">&#x27;*&#x27;</span> </span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>CSS Masking Module Level 1</title>
    <url>/2020/11/19/doc/mask/</url>
    <content><![CDATA[<h3 id="CSS-Masking-Module-Level-1"><a href="#CSS-Masking-Module-Level-1" class="headerlink" title="CSS Masking Module Level 1"></a>CSS Masking Module Level 1</h3><p>—-W3C候选人推荐，2014年8月26日</p>
<p>此版本：</p>
<p><a href="http://www.w3.org/TR/2014/CR-css-masking-1-20140826/" target="_blank" rel="noopener noreferrer">http://www.w3.org/TR/2014/CR-css-masking-1-20140826/</a></p>
<p>最新版本：</p>
<p><a href="http://www.w3.org/TR/css-masking-1" target="_blank" rel="noopener noreferrer">http://www.w3.org/TR/css-masking-1</a></p>
<p>编辑草案：</p>
<p><a href="http://dev.w3.org/fxtf/css-masking-1/" target="_blank" rel="noopener noreferrer">http://dev.w3.org/fxtf/css-masking-1/</a></p>
<p>先前版本：</p>
<p><a href="http://www.w3.org/TR/2014/WD-css-masking-1 -20140522" target="_blank" rel="noopener noreferrer">http://www.w3.org/TR/2014/WD-css-masking-1 -20140522</a></p>
<p>反馈：</p>
<p><a href="mailto:&#x70;&#x75;&#x62;&#x6c;&#105;&#99;&#x2d;&#x66;&#x78;&#x40;&#119;&#51;&#x2e;&#x6f;&#x72;&#103;">&#x70;&#x75;&#x62;&#x6c;&#105;&#99;&#x2d;&#x66;&#x78;&#x40;&#119;&#51;&#x2e;&#x6f;&#x72;&#103;</a> with subject line “[css-masking] … message topic …”(archives)</p>
<p>测试套件：</p>
<p><a href="http://test.csswg.org/suites/css-masking/nightly-unstable/" target="_blank" rel="noopener noreferrer">http://test.csswg.org/suites/css-masking/nightly-unstable/</a></p>
<p>编辑：</p>
<p>Dirk Schulze（Adobe Systems Inc.）</p>
<p>Brian Birtles（Mozilla日本）</p>
<p>Tab Atkins Jr.（Google ）</p>
<p>翻译： 雪人</p>
<p>Copyright © 2014 W3C® (MIT, ERCIM, Keio, Beihang), All Rights Reserved. W3C liability, trademark and document use rules apply.</p>
<h3>摘要</h3>

<p>CSS Masking提供了两种方法来部分或完全隐藏可视元素的部分：掩蔽和剪切。 </p>
<p>Masking描述了如何使用另一个图形元素或图像作为亮度或alpha蒙版。通常，通过CSS或SVG渲染元素可以在概念上描述为将元素（包括其子元素）绘制到缓冲区中，然后将该缓冲区合成到元素的父元素中。亮度和alpha蒙版在合成阶段之前影响此缓冲区的透明度。</p>
<p>Clipping描述了视觉元素的可见区域。可以通过使用某些SVG图形元素或基本形状来描述该区域。此区域之外的任何内容都不会呈现。</p>
<p>CSS是一种语言，用于描述屏幕，纸上，演讲等结构化文档（如HTML和XML）的呈现。</p>
<h3>本文档的状态</h3>

<p>本节描述了本文档的状态。出版物。其他文件可能会取代本文件。有关当前W3C出版物的列表以及该技术报告的最新修订版，请参见W3C技术报告索引，网址为<a href="http://www.w3.org/TR/" target="_blank" rel="noopener noreferrer">http://www.w3.org/TR/</a></p>
<p>本文档由CSS工作组（样式活动的一部分）和SVG工作组（图形活动的一部分）作为候选推荐书制作。</p>
<p>本文档考虑了前一次呼叫期间的评论;请参阅最近最后一次通话的评论处理和之前的通话。还提供了初步实施报告。没有风险的功能。</p>
<p>候选推荐书是一份经过广泛审查并准备实施的文件。 W3C鼓励每个人实施此规范并将评论返回到（存档的）公共邮件列表<a href="mailto:&#x70;&#x75;&#x62;&#108;&#105;&#x63;&#45;&#x66;&#120;&#64;&#119;&#x33;&#x2e;&#x6f;&#x72;&#103;">&#x70;&#x75;&#x62;&#108;&#105;&#x63;&#45;&#x66;&#120;&#64;&#119;&#x33;&#x2e;&#x6f;&#x72;&#103;</a>（请参阅说明）。发送电子邮件时，请在主题中加入“css-masking”文本，最好是这样：“[css-masking] …评论摘要……”</p>
<p>作为候选推荐标准的出版并不意味着W3C会员资格的认可。这是一份草案文件，可能随时被其他文件更新，替换或废弃。除了正在进行的工作之外，引用此文档是不恰当的。 </p>
<p>本文件由根据2004年2月5日W3C专利政策运营的团体制作。 W3C维护任何专利公开（CSS）的公开列表以及与每个组的可交付成果相关的任何专利公开（SVG）的公开列表;这些页面还包括披露专利的说明。具有个人认为包含基本要求的专利的实际知识的个人必须根据W3C专利政策的第6节披露该信息。 </p>
<p>将在候选推荐阶段制定CSS屏蔽模块1级的测试套件和实施报告，该阶段将持续至少6个月，至少持续到2015年2月26日。有关详细信息，请参阅“CR退出标准”部分细节。</p>
<h3 id="a1">1. 简介</h3>

<p>本节不是规范性的。 </p>
<p>此规范定义了两个不同的图形操作，它们完全或部分隐藏了对象的部分：剪切和屏蔽。 </p>
<h4 id="a1-1">1.1. 剪切</h4>

<p>闭合矢量路径，形状或多边形定义了一个所谓的剪切路径。此剪切路径是一个区域（在没有抗锯齿的情况下），允许该区域“内部”的所有内容显示，但外部的所有内容都“被剪掉”，并且不会出现在画布上。</p>
<img src="https://www.w3.org/TR/css-masking-1/images/clipping-path.svg" alt=""/>

<p>clip-path属性可以使用指定的基本形状作为剪切路径，或者引用具有要用作剪切路径的图形元素的clipPath元素。 </p>
<h4 id="a1-2">1.2. Masking </h4>

<p>将蒙版应用于图形对象的效果就好像图形对象将通过蒙版绘制到背景上，从而完全或部分遮盖图形对象的某些部分。</p>
<img src="https://www.w3.org/TR/css-masking-1/images/luminance-mask.svg" alt=""/>

<p> 使用mask-image或mask-border-source属性应用蒙版。 </p>
<p>mask-image属性可以引用mask元素。掩模元素的内容用作掩模。</p>
<p>或者，对于许多简单的用途，mask-image属性可以直接引用要用作mask的图像，从而放弃对显式mask元素的需要。然后可以使用蒙版位置，蒙版大小和其他特征属性，像CSS背景图像一样调整和调整此蒙版的大小和位置。 </p>
<p>mask-border-source属性将一个mask分成9个部分。可以以各种方式对片进行切片，缩放和拉伸以适合掩模边界图像区域的大小。 mask-border属性用作mask-border-source和其他特征属性的简写属性。</p>
<p>mask属性用作所有mask-border和mask-image附属属性的简写属性。</p>
<p class="note">注意：虽然屏蔽为增强的图形效果提供了许多可能性，并且通常提供对内容的“可见部分”的更多控制，但剪切路径可以更好地执行并且基本形状更容易插值。
<h3 id="a2">2. 模块交互</h3>

<p>此规范定义了一组CSS属性，这些属性会影响应用这些属性的元素的可视化呈现。根据[CSS21]中的可视化格式模型确定元素的大小和位置后，将应用这些效果。这些属性的某些值导致创建堆叠上下文。此外，此规范取代了[CSS21]中的Clipping：clip属性部分。</p>
<p>合成模型遵循SVG合成模型[SVG11]：首先，在没有滤镜效果，遮罩，剪裁和不透明度的情况下对元素进行样式设置。然后在临时画布上绘制元素及其后代。在最后一步中，以下效果按顺序应用于元素：滤镜效果[FILTER-EFFECTS]，剪裁，蒙版和不透明度。</p>
<p>此规范允许使用CSS合成和混合[COMPOSITING-1]中定义的Porter Duff合成运算符合成多个遮罩层。</p>
<p>术语对象边界框遵循SVG 1.1 [SVG11]中的定义。</p>
<h3 id="a3">3. Values </h3>

<p>此规范遵循[CSS21]中的CSS属性定义约定。基本形状在CSS形状模块级别1 [CSS-SHAPES]中定义。未在这些规范中定义的值类型在CSS值和单位模块级别3 [CSS3VAL]中定义。 </p>
<p>除了定义中列出的特定于属性的值之外，本规范中定义的所有属性还接受CSS范围的关键字，例如inherit作为其属性值[CSS3VAL]。为了便于阅读，它没有明确重复。 </p>
<h3 id="a4">4. 术语</h3>

<p>本规范中CSS属性和值的定义类似于CSS背景和边框[CSS3BG]中的定义。为避免冗余，本规范依赖于CSS背景和边框的描述和定义。 CSS背景和边框中的以下术语在本规范中具有以下含义：</p>
<p>Term in CSS Masking    —– |—–Term in [CSS3BG]</p>
<p>mask layer image       —– |——-&gt;   background images</p>
<p>mask painting area       —– |——-&gt;   background painting area</p>
<p>mask-size               —– |——-&gt;   background-size</p>
<p>mask-position           —– |——-&gt;   background-position</p>
<p>mask positioning area  —– |——-&gt;     background positioning area</p>
<p>mask border image       —– |——-&gt;   border-image</p>
<p>mask border image area —– |——-&gt;   border image area</p>
<h3 id="a5">5. 剪切路径</h3>

<p>剪切路径限制可以应用绘制的区域，即所谓的剪切区域。从概念上讲，不绘制位于该区域之外的图形的任何部分。这包括应用剪切路径的元素的任何内容，背景，边框，文本修饰，轮廓和可见滚动机制，以及其后代的内容。 </p>
<p>元素的祖先也可以剪辑其内容的一部分（例如，通过它们自己的剪辑或剪辑路径属性和/或如果它们的溢出属性不可见）。渲染的是累积交叉点。 </p>
<p>如果剪辑区域超出了UA文档窗口的边界，则本机操作环境可能会将内容剪切到该窗口。 </p>
<p>剪切路径会影响元素的渲染。它不会影响元素的固有几何形状。剪切元素的几何形状（即通过clip-path属性引用clipPath元素的元素，或引用元素的子元素）必须保持与未剪裁的相同。 </p>
<p> 考虑由应用于祖先的剪切路径剪切的形状：</p>
<p>&lt;’g’ clip-path=”circle()”&gt;&lt;’path’ id=’shape’ d=”M0,0 L10,10, L 20,0 z”/&gt;&lt;/‘g’&gt;</p>
<p> The shape is referenced by a &lt;’use’&gt; element:</p>
<p>&lt;’use’ xlink:href=”#shape”/&gt;</p>
<p>几何形状不受圆形剪裁的影响路径。 </p>
<p>默认情况下，不能在不可见区域上调度指针事件。例如，尺寸为10px到10px的元素被剪裁为半径为5px的圆将不会在剪切区域外接收点击事件。</p>
<h3 id="a5-1">5.1. 剪切形状：剪辑路径属性</h3>

<p>名称：clip-path </p>
<p>Value： clip-source | [ basic-shape || geometry-box ] | none</p>
<p>Initial：none </p>
<p>适用于：所有元素。在SVG中，它适用于容器元素，不包括元素和所有图形元素</p>
<p>Inherited：no </p>
<p>Media：visual </p>
<p>Computed value：指定，但值为absolute </p>
<p>Percentages：指定为</p>
<p>Animatable：as为 [CSS-SHAPES]指定，否则为no</p>
<p> 指定基本形状或引用clipPath元素以创建clip-path。</p>
<h4>----clip-source = url</h4>
<h4>----geometry-box = shape-box | fill-box | stroke-box | view-box</h4>
<h4>basic-shape</h4>

<p>CSS Shapes模块[CSS-SHAPES]中定义的基本形状函数。基本形状使用指定的参考框来调整基本形状的大小和位置。如果未指定引用框，则边框将用作引用框。 </p>
<h4>geometry-box</h4>

<p>如果与组合指定，它将提供的参考框。 </p>
<p>如果由其自身指定，则使用指定框的边，包括任何边角（例如，由border-radius [CSS3BG]定义）作为剪切路径。另请参见“框值的形状”[CSS-SHAPES]。</p>
<h4>fill-box</h4>

<p>使用对象边界框作为参考框。</p>
<h4>stroke-box</h4>

<p>使用笔划边界框作为参考框。 </p>
<h4>view-box</h4>

<p>使用最近的SVG视口作为参考框。 </p>
<p>如果为SVG视口创建元素指定了’viewBox’属性：</p>
<p>—-引用框位于由’viewBox’属性建立的坐标系的原点。 </p>
<p>—-参考框的尺寸设置为’viewBox’属性的宽度和高度值。 </p>
<h4>none </h4>

<p>没有创建剪切路径。</p>
<p>对于没有关联CSS布局框的SVG元素，内容框，填充框，边框框和边框的使用值是填充框。</p>
<p>对于具有关联CSS布局框的元素，填充框，描边框和视图框的使用值是边框。 </p>
<p>计算值不是none会导致创建堆叠上下文[CSS21]，就像CSS不透明度[CSS3COLOR]对除1以外的值所做的那样。</p>
<p>如果URI引用无效（例如，它指向如果对象不存在或对象不是clipPath元素，则不应用裁剪。</p>
<p>此示例演示如何使用基本形状作为剪切路径。每个空格分隔的长度对代表多边形的一个点。可视化的剪切路径可以在介绍中看到。</p>
<p>clip-path: polygon(15px 99px, 30px 87px, 65px 99px, 85px 55px,</p>
<p>122px 57px, 184px 73px, 198px 105px, 199px 150px,</p>
<p>145px 159px, 155px 139px, 126px 120px, 112px 138px,</p>
<p>80px 128px, 39px 126px, 24px 104px);</p>
<p>.</p>
<p>在此示例中，clip-path属性引用SVG clipPath元素。每个逗号分隔的长度对表示多边形的一个点。对于前面的例子，可以在引言中看到可视化的剪切路径。</p>
<p>clip-path: url(“#clip1”);</p>
<p>&lt;’clipPath id=”clip1”&gt;</p>
<p>—-&lt;’polygon points=”15,99 30,87 65,99 85,55 122,57 184,73 198,105</p>
<p> ——99,150 145,159 155,139 126,120 112,138 80,128 39,126</p>
<p>——-24,104”/&gt;</p>
<p>&lt;’clipPath’&gt;</p>
<h3 id="a6">6. SVG剪切路径源</h3>
<h3 id="a6-1">6.1. The clipPath element</h3>
<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>clipPath</td>
    </tr>
    <tr>
        <td>Categories：</td>
        <td>无。</td>
    </tr>
    <tr>
        <td>Content model:</td>
        <td>

<pre><code>        以下任意数量的元素： 

        descriptive — &lt;&#39;desc&gt;, &lt;&#39;title&gt;, &lt;&#39;metadata&gt;

        animation — &lt;&#39;animate&gt;, &lt;&#39;animateColor&gt;, &lt;&#39;animateMotion&gt;, &lt;&#39;animateTransform&gt;, &lt;&#39;set&gt;

        descriptive — &lt;&#39;desc&gt;, &lt;&#39;title&gt;, &lt;&#39;metadata&gt;

        shape — &lt;&#39;circle&gt;, &lt;&#39;ellipse&gt;, &lt;&#39;line&gt;, &lt;&#39;path&gt;, &lt;&#39;polygon&gt;, &lt;&#39;polyline&gt;, &lt;&#39;rect&gt;

        &lt;&#39;text&gt;

        &lt;&#39;use&gt;

        &lt;&#39;script&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;Attributes:&lt;/td&gt;
    &lt;td&gt;

        conditional processing attributes — ‘requiredFeatures’, ‘requiredExtensions’, ‘systemLanguage’

        core attributes — ‘id’, ‘xml:base’, ‘xml:lang’, ‘xml:space’

        presentation attributes — alignment-baseline, baseline-shift, clip, clip-path, clip-rule, color, color-interpolation, color-interpolation-filters, color-profile, color-rendering, cursor, direction, display, dominant-baseline, enable-background, fill, fill-opacity, fill-rule, filter, flood-color, flood-opacity, font, font-family, font-size, font-size-adjust, font-stretch, font-style, font-variant, font-weight, glyph-orientation-horizontal, glyph-orientation-vertical, image-rendering, kerning, letter-spacing, lighting-color, marker, marker-end, marker-mid, marker-start, mask, opacity, overflow, pointer-events, shape-rendering, stop-color, stop-opacity, stroke, stroke-dasharray, stroke-dashoffset, stroke-linecap, stroke-linejoin, stroke-miterlimit, stroke-opacity, stroke-width, text-anchor, text-decoration, text-rendering, unicode-bidi, visibility, word-spacing, writing-mode

        ‘class’

        ‘style’

        ‘externalResourcesRequired’

        ‘transform’

        ‘clipPathUnits’
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;DOM Interfaces:&lt;/td&gt;
    &lt;td&gt;SVGClipPathElement&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</tbody>
</table>


<p>属性定义：</p>
<p>clipPathUnits =“userSpaceOnUse | objectBoundingBox”</p>
<p>–定义clipPath内容的坐标系。 </p>
<p>–userSpaceOnUse </p>
<p>—-clipPath的内容表示当引用clipPath元素时当前用户坐标系中的值（即，通过clip-path属性引用clipPath元素的元素的用户坐标系）。</p>
<p>–objectBoundingBox </p>
<p>–坐标系的原点位于剪切路径所适用的元素的边界框的左上角，以及此边界框的相同宽度和高度。用户坐标的大小等同于CSS px单元。 </p>
<p>–如果未指定属性clipPathUnits，则效果就像指定了userSpaceOnUse的值一样。 </p>
<p>–Animatable: yes.</p>
<p>CSS属性从其祖先继承到clipPath元素;属性不会从引用clipPath元素的元素继承。 </p>
<p>clipPath元素永远不会直接呈现;它们的唯一用法是可以使用clip-path属性引用的东西。 display属性不适用于clipPath元素;因此，即使将display属性设置为none以外的值，也不会直接呈现clipPath元素，即使clipPath元素或其任何祖先的display属性设置为none，也可以使用clipPath元素进行引用。 </p>
<p>clipPath元素可以包含元素，元素，基本形状（如）或元素。如果元素是clipPath元素的子元素，则它必须直接引用，或基本形状元素。间接引用是一个错误，必须忽略clipPath元素。</p>
<p>每个子元素的原始几何体（不包括渲染属性，例如clipPath中的填充，笔触，笔触宽度）在概念上定义了1位蒙版（可能除了沿着几何体边缘的抗锯齿），它代表了轮廓与该元素关联的图形。对象轮廓之外的任何东西都被掩盖了。如果通过显示或可见性使子元素不可见，则它对剪切路径没有贡献。当clipPath元素包含多个子元素时，子元素的轮廓在逻辑上被“或”在一起以创建单个轮廓，然后用于限制可以应用油漆的区域。因此，如果一个点位于clipPath的任何子节点内，则它位于剪切路径内。</p>
<p>对于给定的图形元素，使用的实际剪切路径将是其剪辑路径属性（如果有）指定的剪切路径与其祖先上的任何剪切路径的交集，由剪辑路径属性指定。建立新视口的元素。 （参见[SVG11]）</p>
<p>一些新增内容：</p>
<ol>
<li><p>clipPath元素本身及其子元素不会从clipPath元素的祖先继承剪切路径。</p>
</li>
<li><p>clipPath元素或其任何子元素都可以指定属性clip-path。 </p>
</li>
</ol>
<p>如果有效的剪辑路径引用放在clipPath元素上，则生成的剪切路径是clipPath元素的内容与引用的剪切路径的交集。 </p>
<p>如果有效的剪辑路径引用放在clipPath元素的其中一个子元素上，则在将子元素的轮廓与其他子元素的轮廓进行OR运算之前，会通过引用的剪切路径剪切给定的子元素。 </p>
<ol start="3">
<li>空剪切路径将完全剪掉已应用剪辑路径属性的元素。<h3 id="a6-2">6.2. 绕组规则：clip-rule属性</h3>



</li>
</ol>
<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>clip-rule </td>
    </tr>
    <tr>
        <td>Value</td>
        <td>非零| evenodd </td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>nonzero </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>适用于SVG图形元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>yes</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>指定</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>clip-rule属性指示用于确定给定点是否在用图形元素创建的剪切区域的形状内的算法。算法的定义和剪辑规则值遵循fill-rule属性的定义。请参阅SVG 1.1 [SVG11]中的“填充属性”部分。 </p>
<h4>nonzero</h4>

<p>请参阅fill-rule属性[SVG11]的说明。</p>
<h4>evenodd </h4>

<p>请参阅fill-rule属性[SVG11]的说明。</p>
<p>clip-rule属性仅适用于clipPath元素中包含的图形元素。 </p>
<p class="note">注意：clip-rule属性不适用于。

<p>下图说明了非零规则：</p>
<img src="https://www.w3.org/TR/css-masking-1/images/cliprule-nonzero.svg" alt=""/>

<p>下图说明了偶数规则：</p>
<img src="https://www.w3.org/TR/css-masking-1/images/cliprule-evenodd.svg" alt=""/>

<p>以下代码片段将导致奇数剪切规则应用于剪切路径，因为在规则上指定了剪辑规则定义剪裁形状的元素：</p>
<p>下面的代码片段将导致奇偶剪切规则应用于剪切路径，因为在定义裁剪形状的元素上指定了剪辑规则：</p>
<p>&lt;’g clip-rule=”nonzero”&gt;</p>
<p>  &lt;’clipPath id=”MyClip”&gt;</p>
<pre><code>&lt;&#39;path d=&quot;...&quot; clip-rule=&quot;evenodd&quot; /&gt;</code></pre>
<p>  &lt;/‘clipPath&gt;</p>
<p>  &lt;’rect clip-path=”url(#MyClip)” … /&gt;</p>
<p>&lt;/‘g&gt;</p>
<p>而下面的代码片段不会导致应用evenodd剪切规则，因为剪辑规则是在引用元素上指定的，而不是在定义剪裁形状的对象上：</p>
<p>&lt;’g clip-rule=”nonzero”&gt;</p>
<p>  &lt;’clipPath id=”MyClip”&gt;</p>
<pre><code>&lt;&#39;path d=&quot;...&quot; /&gt;</code></pre>
<p>  &lt;/‘clipPath&gt;</p>
<p>  &lt;’rect clip-path=”url(#MyClip)” clip-rule=”evenodd” … /&gt;</p>
<p>&lt;/‘g&gt;</p>
<h3 id="a7">7. 定位Mask</h3>
<h3 id="a7-1">7.1. Mask Image Source：mask-image属性</h3>
<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-image  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'mask-reference></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>none  </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>如指定的那样，但是URI为绝对值</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>此属性设置元素的遮罩层图像。其中：</p>
<p>mask-reference = none | &lt;‘image&gt; | &lt;’mask-source&gt;</p>
<p>mask-source = url</p>
<h4><'url></h4>

<p>–对&lt;’mask&gt;元素（例如url（commonmasks.svgmask））或CSS映像的URL引用。 </p>
<h4>none </h4>

<p>–值为none将计为透明黑色图像层</p>
<p>除非之外的计算值导致创建堆叠上下文[CSS21]，就像CSS不透明度[CSS3COLOR]对除1以外的值所做的那样。</p>
<p>作为空图像的mask引用（零宽度或零）高度），无法下载，不是对mask元素的引用，不存在，或者无法显示（例如因为它不是支持的图像格式）仍然被视为透明黑色的图像层。 </p>
<p>有关如何处理遮罩层图像的信息，请参阅“遮罩处理”部分。</p>
<p class="note">注意：列表中的值none可能会影响屏蔽操作，具体取决于mask-composite指定的使用的合成运算符
<p class="note">注意：计为遮罩层，可以与或其他列表项组合在一个可重复的列表中
<p class="note">注意：元素也可以使用mask-border-source进行mask。有关该属性与mask-image的交互，请参阅mask-border-source。

<p>Examples for mask references:</p>
<p>body { mask-image: linear-gradient(black 0%, transparent 100%) }<br>p { mask-image: none }<br>div { mask-image: url(resources.svg#mask2) }</p>
<p>有关mask-image如何与其他逗号分隔的遮罩属性进行交互以形成每个遮罩层，请参阅“分层多个遮罩层图像”一节。</p>
<h3 id="a7-2">7.2. Mask Image Interpretation: the mask-mode property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-mode  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'mask-mode></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>auto  </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>mask-mode属性指示 mask-reference是被视为亮度 mask还是alpha mask。 （参见蒙版处理。）</p>
<p>–masking-mode = alpha | luminance | auto</p>
<h4>alpha</h4>

<p>alpha值表示mask图层图像的alpha值应该用作mask值。请参见计算蒙版值。 </p>
<h4>luminance</h4>

<p>亮度值表示掩模层图像的亮度值应该用作掩模值。请参见计算蒙版值。</p>
<h4>auto</h4>

<p>如果mask-image属性的属于类型，则应使用掩模层图像的亮度值作为mask值。 </p>
<p>如果mask-image属性的是类型，则应使用遮罩层图像的alpha值作为遮罩值。 </p>
<p>在下面的示例中，mask-type属性将mask元素的mask类型值设置为alpha。 mask-image属性具有对此mask元素的引用，mask-mode属性具有brightness值。 mask-mode属性会将mask-type的定义覆盖为亮度。 </p>
<p>mask-mode属性不得影响mask-border-source的mask模式。</p>
<p>&lt;’mask id=”SVGMask” mask-type=”alpha” maskContentUnits=”objectBoundingBox”&gt;</p>
<p>  &lt;’radialGradient id=”radialFill”&gt;</p>
<pre><code>&lt;&#39;stop stop-color=&quot;white&quot; offset=&quot;0&quot;/&gt;

&lt;&#39;stop stop-color=&quot;black&quot; offset=&quot;1&quot;/&gt;</code></pre>
<p>  &lt;/‘radialGradient&gt;</p>
<p>  &lt;’circle fill=”url(#radialFill)” cx=”0.5” cy=”0.5” r=”0.5”/&gt;</p>
<p>&lt;/‘mask&gt;</p>
<p>&lt;’style&gt;</p>
<p>  rect {</p>
<pre><code>mask-image: url(#SVGMask);

mask-mode: luminance;</code></pre>
<p>  }</p>
<p>&lt;/‘style&gt;</p>
<p>&lt;’rect width=”200” height=”200” fill=”green”/&gt;</p>
<p>有关掩模模式如何与其他逗号分隔的mask属性进行交互以形成每个遮罩层，请参阅“分层多个遮罩层图像”一节。</p>
<h3 id="a7-3">7.3. Tiling Mask Images: The mask-repeat property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-repeat  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'repeat-style></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>no-repeat  </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>Consists of: two keywords, one per dimension</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>指定在调整大小和位置后，如何平铺遮罩层图像。 </p>
<p>请参阅background-repeat属性[CSS3BG]以获取属性值的定义。</p>
<p>body {</p>
<pre><code>background-color: blue;

mask-image: url(dot-mask.png) luminance;

mask-repeat: space;</code></pre>
<p>}</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-repeat.svg" alt=""/>

<p>有关mask-repeat如何与其他逗号分隔的遮罩属性进行交互以形成每个遮罩层，请参阅“分层多个遮罩层图像”一节。</p>
<h3 id="a7-4">7.4. Positioning Mask Images: the mask-position property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-position  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'position></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>no-repeat  </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>由以下两个关键字组成：表示原点的两个关键字和来自该原点的两个偏移量，每个关键字以绝对长度（如果给定）给出，否则以百分比形式给出。 </td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>百分比：指掩模绘制区域的大小减去掩模层图像的大小;看文本背景位置[CSS3BG] </td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>作为长度，百分比或计算的简单列表的可重复列表</td>
    </tr>
</tbody>
</table>


<p>有关属性值的定义，请参阅background-position属性[CSS3BG]。</p>
<p>在下面的示例中，（单个）图像位于视口的右下角。 </p>
<p>body {</p>
<p>mask-image：url（“logo.png”）; </p>
<p>mask-position：100％100％; </p>
<p>mask-repeat：no-repeat; </p>
<p>} </p>
<p>面具位置也可以相对于左上角的其他角落。例如，下面将背景图像从底部放置10px，从右边放置3em：</p>
<p>mask-position：right 3em bottom 10px </p>
<p>请参阅“分层多个遮罩层图像”部分，了解掩模位置如何与其他逗号分隔的交互掩模属性以形成每个遮罩层。</p>
<h3 id="a7-5">7.5. Masking Area: the mask-clip property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-clip  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td>[ <'geometry-box> | no-clip ]</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>border-box </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p> 确定蒙版绘制区域，该区域确定受蒙版影响的区域。元素的绘制内容必须限制在此区域。 </p>
<p>Values具有以下含义：</p>
<h4>content-box </h4>

<p>绘制的内容仅限于（剪切到）content-box框。</p>
<h4>padding-box </h4>

<p>绘制的内容仅限于（剪裁到）padding-box框。</p>
<h4>border-box </h4>

<p>绘制的内容仅限于（剪切到）边框框。 </p>
<h4>margin-box </h4>

<p>绘制的内容仅限于（剪切到）margin外边框。</p>
<h4>fill-box</h4>

<p>绘制的内容仅限于（剪切到）fill-box边界框。 </p>
<h4>stroke-box </h4>

<p>绘制的内容仅限于（剪裁到）stroke-box边界框。 </p>
<h4>view-box </h4>

<p>使用最近的SVG视口作为参考框。</p>
<p>如果为SVG视口创建元素指定了’viewBox’属性：</p>
<p>–引用框位于由’viewBox’属性建立的坐标系的原点。</p>
<p>–参考框的尺寸设置为’viewBox’属性的宽度和高度值。 </p>
<h4>no-clip </h4>

<p>绘制的内容不受限制（未剪裁）。</p>
<p>对于没有关联CSS布局框的SVG元素，值content-box，padding-box，border-box和margin-box计算到填充框。 </p>
<p>对于具有关联CSS布局框的元素，值fill-box，stroke-box和view-box计算为mask-clip的初始值。</p>
<p>请参阅“分层多个遮罩层图像”一节，了解遮罩剪辑如何与其他逗号分隔的遮罩属性交互以形成每个遮罩层。</p>
<h3 id="a7-6">7.6. Positioning Area: the mask-origin property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-origin  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td>[ <'geometry-origin> ]</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>border-box </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>对于呈现为单个框的元素，指定蒙版定位区域。对于呈现为多个框的元素（例如，几行上的内联框，多个页面上的框）指定框装饰中断操作的框以确定掩模定位区域。 </p>
<h4>content-box </h4>

<p>该位置相对于content-box框。</p>
<h4>padding-box </h4>

<p>该位置相对于padding-box框。 （对于单个框0 0是填充边缘的左上角，100％100％是右下角。）</p>
<h4>padding-box </h4>

<p>该位置相对于padding-box框。</p>
<h4>margin-box</h4>

<p>该位置相对于margin外边。</p>
<h4>fill-box </h4>

<p>该位置相对于fill-box边界框。 </p>
<h4></h4>
<h4>stroke-box </h4>

<p>该位置相对于stroke-box边界框。 </p>
<h4></h4>
<h4>view-box </h4>

<p>使用最近的SVG视口作为参考框。 </p>
<p>如果为SVG视口创建元素指定了’viewBox’属性：</p>
<p>–引用框位于由’viewBox’属性建立的坐标系的原点。 </p>
<p>–参考框的尺寸设置为’viewBox’属性的宽度和高度值。</p>
<p>对于没有关联CSS布局框的SVG元素，值content-box，padding-box，border-box和margin-box计算到填充框。 </p>
<p>对于具有关联CSS布局框的元素，值fill-box，stroke-box和view-box计算为mask-origin的初始值。</p>
<p class="note"> 注意：如果mask-clip是padding-box，mask-origin是border-box，mask-position是左上角（初始值），元素有一个非零边框，那么mask层的顶部和左边图像将被剪裁。 

<p>请参阅“分层多个遮罩层图像”部分，了解遮罩原点如何与其他逗号分隔的遮罩属性进行交互以形成每个遮罩层。</p>
<h3 id="a7-7">7.7. Sizing Mask Images: the mask-size property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-size  </td>
    </tr>
    <tr>
        <td>Value</td>
        <td> <'bg-size></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>auto </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified, but with lengths made absolute</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>作为长度，百分比或计算的简单列表的可重复列表（这意味着关键字值不可动画。）</td>
    </tr>
</tbody>
</table>


<p>指定遮罩层图像的大小。 </p>
<p>请参阅background-size属性[CSS3BG]以获取属性值的定义。 </p>
<p>请参阅“分层多个遮罩层图像”部分，了解遮罩大小如何与其他逗号分隔的遮罩属性交互以形成每个遮罩层。</p>
<h3 id="a7-8">7.8. Compositing mask layers: the mask-composite property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-composite </td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'compositing-operator></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>add </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>compositing-operator = add | subtract | intersect | exclude</p>
<p>每个关键字代表一个Porter-Duff合成操作符[COMPOSITING-1]，它定义了当前遮罩层上使用的合成操作以及它下面的遮罩层。 </p>
<p>在下面，当前的mask层被称为source，它下面的所有mask层（应用了相应的合成运算符）都被引用到destination。 </p>
<h4>add </h4>

<p>源位于目的地之上。 （有关详细信息，请参阅Porter-Duff合成运算符源。）</p>
<h4>subtract </h4>

<p>放置源，它位于目标之外。 （有关详细信息，请参阅Porter-Duff合成操作符源。）</p>
<h4>intersect </h4>

<p>与目标重叠的源部分，替换目标。 （请参阅Porter-Duff合成运算符源。）</p>
<h4>exclude </h4>

<p>组合源和目标的非重叠区域。 （请参阅Porter-Duff合成运算符XOR。）</p>
<p>如果没有其他mask图层，则必须忽略合成运算符。遮罩层不能与元素的内容或元素后面的内容合成，而是必须将它们表现为渲染到隔离组中。 </p>
<p>在应用当前遮罩层的合成操作之前，必须合成当前遮罩层下面的所有遮罩层。 </p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-source-destination.svg" alt=""/>

<p>两个遮罩层图像都是具有mask-image属性的引用：</p>
<p>mask-image：circle.svg，rect.svg; </p>
<p>带有rect.svg的遮罩层位于使用circle.svg的遮罩层下方。这意味着circle.svg比rect.svg更接近用户。 </p>
<p>使用属性mask-composite，作者可以选择不同的方法来组合多个遮罩层。 </p>
<p>–add在rect.svg上绘制circle.svg。该行为由合成运算符源描述。 </p>
<p>—–mask-composite：add;</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-composite-add.svg" alt=""/>

<p>—–mask-composite: subtract;</p>
<hr>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-composite-subtract.svg" alt=""/>

<p>—–mask-composite: intersect;</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-composite-intersect.svg" alt=""/>

<p>—–mask-composite: exclude;</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-composite-exclude.svg" alt=""/>

<p>以下示例指定了两个遮罩层和两个合成运算符。 </p>
<p>mask-image：rect.svg，circle.svg; </p>
<p>mask-composite：add，exclude; </p>
<p>rect.svg和circle.svg使用add compositing运算符。没有其他遮罩层可以使用排除，因此会忽略exclude。 </p>
<p>这是具有不同合成运算符的3个遮罩层的示例。 </p>
<p>mask-image：trapeze.svg，circle.svg，rect.svg; </p>
<p>mask-composite：减去，加; </p>
<p>首先，circle.svg被“添加”到rect.svg。在第二步中，从前两层“减去”trapeze.svg。</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-composite-subtract-add.svg" alt=""/>

<p>有关mask-composite如何与其他逗号分隔的遮罩属性进行交互以形成每个遮罩层，请参阅“分层多个遮罩层图像”一节。</p>
<h3 id="a7-9">7.9.  Mask Shorthand: the mask property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask</td>
    </tr>
    <tr>
        <td>Value</td>
        <td><'mask-layer></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>see individual properties </td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>see individual properties</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>see individual properties</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>see individual properties</td>
    </tr>
</tbody>
</table>


<p>mask-layer = &lt;’mask-reference&gt; &lt;’masking-mode&gt;? || &lt;’position&gt; [ / &lt;’bg-size&gt; ]? ||<br>&lt;’repeat-style&gt; || &lt;’geometry-box&gt; || [ &lt;’geometry-box&gt; | no-clip ] || &lt;’compositing-operator&gt;</p>
<p>如果存在一个值，则它将mask-origin和mask-clip都设置为该值。如果存在两个值，则第一个设置mask-origin和第二个mask-clip。 </p>
<p>如果引用了mask元素，则属性mask-repeat，mask-position，mask-clip，mask-origin和mask-size的使用值必须无效。在这种情况下，元素定义掩模层图像的位置，大小和剪裁。 </p>
<p>mask速记也会将mask-border重置为其初始值。因此，建议作者使用mask速记而不是其他短号或单个属性来覆盖级联中较早的任何mask设置。这将确保mask边框也已重置，以允许新样式生效。 </p>
<h3 id="a7-10">7.10. mask图像渲染模型</h3>

<p>对于使用CSS框模型格式化的元素，将mask-image属性应用于none以外的值将以与CSS不透明度[CSS3COLOR]相同的方式建立堆叠上下文，并且所有元素的后代作为一个组一起呈现，并将整个屏蔽应用于组。 </p>
<p>mask-image属性对任何元素的CSS框的几何或命中测试没有影响。</p>
<h3 id="a7-10-1">7.10.1. Mask processing</h3>

<p>在下一节中，蒙版图像指的是蒙版图层图像或蒙版边框图像。关于计算将与目标α值相乘的掩模值，可以使用两种不同方法中的一种来解释掩模图像。 </p>
<p>计算mask值的第一个也是最简单的方法是使用mask图像的alpha通道。在这种情况下，给定点处的mask值只是该点处的alpha通道的值。颜色通道对掩模值没有贡献。 </p>
<p>计算掩模值的第二种方法是使用掩模图像的亮度。在这种情况下，使用以下过程从颜色通道值和alpha通道值计算给定点处的掩模值。 </p>
<p>1、根据颜色通道值计算亮度值。 </p>
<p>—–如果mask元素上的颜色插值的计算值是linearRGB，则将原始图像颜色值（可能在sRGB颜色空间中）转换为linearRGB颜色空间。 </p>
<p>—–然后，使用非预乘RGB颜色值，应用亮度到alpha系数（如滤镜原语[SVG11]中所定义）将RGB颜色值转换为亮度值。 </p>
<p>2、将计算出的亮度值乘以相应的alpha值，以产生遮罩值。 </p>
<p>无论使用何种方法，计算mask值的过程都假定mask的内容是四通道RGBA图形对象。对于其他类型的图形对象，需要进行如下特殊处理。 </p>
<p>对于在掩模中使用的三通道RGB图形对象（例如，当引用三通道图像文件时），效果就好像对象被转换为具有alpha通道的四通道RGBA图像一致设置为1. </p>
<p>对于掩模中使用的单通道图像（例如，当引用单通道灰度图像文件时），效果就好像对象被转换为四通道RGBA图像，其中引用对象的单个通道用于计算三个颜色通道，alpha通道统一设置为1。</p>
<p class="note">注意：引用灰度图像文件时，在计算颜色通道时必须考虑将编码灰度值与线性光值相关联的传输曲线。 
<p class="note">注意：出于屏蔽操作的目的，SVG图形元素（例如，或）都被视为四通道RGBA图像。 

<p>mask的效果与没有mask时发生的效果相同，而是给定对象的alpha通道与mask的结果mask值相乘。 </p>
<p>未被遮罩图像覆盖的区域被视为透明黑色。mask值为0. </p>
<p class="note">注意：具有重复mask图像切片的mask可能彼此偏移。掩模图像之间的空间被视为透明的黑色掩模。 
<h3 id="a7-10-2">7.10.2. 分层多个蒙版图像</h3>

<p>盒子的蒙版可以有多个图层。层数由mask-image属性的逗号分隔值数决定。具有其他的值列表中的值none仍会创建一个图层。 </p>
<p>请参阅分层多个背景图像[CSS3BG]。 </p>
<p>所有遮罩层图像都转换为alpha蒙版（如果需要，请参见遮罩处理），并通过合成将mask-composite指定的合成运算符考虑在内。</p>
<h3 id="a8">8. Border-Box Mask</h3>

<p>使用蒙版边框，图像可以分为九个部分：四个角，四个边和中间部分，如下图所示。</p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-box-image-mask.svg" alt=""/>

<p>可以以各种方式对这些片进行切片，缩放和拉伸以适合掩模边界图像区域的尺寸。然后将该失真图像用作掩模。 mask-border的语法对应于CSS Background和Borders [CSS3BG]的border-image属性。 </p>
<p>以下示例中的蒙版边框图像被分割为四个角，尺寸为75像素，四个边以及拉伸和缩放的中间部分。 </p>
<img src="https://www.w3.org/TR/css-masking-1/images/mask-box-image.svg" alt=""/>

<p>掩码边框示例。左侧的对象是要屏蔽的对象。第二个图像是alpha蒙版，最后一个图像是蒙版对象。 </p>
<p>div {</p>
<p>background：线性渐变（底部，F27BAA 0％，FCC8AD 100％）; </p>
<p>mask-border-slice：25填充; </p>
<p>mask-border-repeat：stretch; </p>
<p>mask-border-source：url（mask.png）; </p>
<p>}</p>
<h3 id="a8-1">8.1.  Mask Border Image Source: the mask-border-source property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-source</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>none | <'image></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>none</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>无或带有URI的图像是绝对的</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>指定要用作蒙版边框图像的图像。 </p>
<p>无法下载，不存在或无法显示（例如，因为它不是支持的图像格式）的空图像（零宽度或零高度）的图像被忽略。它仍然计为遮罩边框图像，但不会遮盖该元素。 </p>
<p>有关如何处理蒙版边框图像的信息，请参阅“蒙版处理”。 </p>
<p>除非之外的计算值导致创建堆叠上下文[CSS21]，就像CSS不透明度[CSS3COLOR]对除1以外的值所做的那样。</p>
<p>mask-border-source和mask-image可以指定相互独立。如果两个属性都具有非none值，则该元素将被两个屏蔽操作一个接一个地屏蔽。 </p>
<p class="note">注意：如果在mask-border-source之前或之后将mask-image应用于元素并不重要。两个操作顺序都会导致相同的渲染。
<h3 id="a8-2">8.2. Mask Border Image Interpretation: the mask-border-mode property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-mode</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>luminance | alpha</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>alpha</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>无或带有URI的图像是绝对的</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>指定要用作蒙版边框图像的图像。 </p>
<p>无法下载，不存在或无法显示（例如，因为它不是支持的图像格式）的空图像（零宽度或零高度）的图像被忽略。它仍然计为遮罩边框图像，但不会遮盖该元素。 </p>
<p>有关如何处理蒙版边框图像的信息，请参阅“蒙版处理”。 </p>
<p>除非之外的计算值导致创建堆叠上下文[CSS21]，就像CSS不透明度[CSS3COLOR]对除1以外的值所做的那样。</p>
<p>mask-border-source和mask-image可以指定相互独立。如果两个属性都具有非none值，则该元素将被两个屏蔽操作一个接一个地屏蔽。 </p>
<p class="note">注意：如果在mask-border-source之前或之后将mask-image应用于元素并不重要。两个操作顺序都会导致相同的渲染。
<h3 id="a8-3">8.3. Mask Border Image Slicing: the mask-border-slice property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-slice</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>[<number> | <percentage>]{1,4} fill?</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>0</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>指掩模边框图像的大小</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>此属性指定蒙版边​​框图像的顶部，右侧，底部和左侧边缘的向内偏移，将其分为九个区域：四个角，四个边和一个中间。除非存在fill关键字，否则丢弃中间图像部分并将其视为完全不透明的白色（中间部分覆盖的内容不会被遮盖并照亮）。 </p>
<p>请参阅border-image-slice属性[CSS3BG]以获取属性值的定义</p>
<h3 id="a8-4">8.4. Masking Areas: the mask-border-width property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-width</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>[ <length> | <percentage> | <number> | auto ]{1,4}</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>auto</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>所有 'length>s为绝对值，否则为指定</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>相对于掩码边框图像区域的宽度/高度</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>掩模边框图像绘制在称为掩模边框图像区域的区域内。这是一个默认边界对应边框的区域，请参阅mask-border-outset。 </p>
<p>有关属性值的定义，请参阅border-image-width属性[CSS3BG]。 </p>
<p class="note">注意：对于没有关联布局框的SVG元素，border-width被视为0。
<h3 id="a8-5">8.5. Edge Overhang: the mask-border-outset property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-outset</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>    [ <length> | <number> ]{1,4}</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>0</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>所有 'length>s为绝对值，否则为指定</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>这些值指定蒙版边​​框图像区域延伸到边框之外的量。如果它有四个值，则按顺序设置顶部，右侧，底部和左侧的开始。如果左侧缺失，则与右侧相同;如果底部缺失，则与顶部相同;如果缺少权利，则与顶部相同。 </p>
<p>与mask-border-width一样，表示相应border-width的倍数。任何mask-border-outset值都不允许使用负值。 </p>
<p class="note">注意：对于没有关联布局框的SVG元素，边框宽度被视为0。
<h3 id="a8-6">8.6.  Mask Border Image Tiling: the mask-border-repeat property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border-repeat</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>[ stretch | repeat | round | space ]{1,2}</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>    stretch</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>所有元素。在SVG中，它适用于除元素和所有图形元素之外的容器元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>此属性指定如何缩放和平铺蒙版边框图像的边和中间部分的图像。第一个关键字适用于水平边，第二个关键字适用于垂直边。如果第二个关键字不存在，则假定它与第一个相同。 </p>
<p>请参阅border-image-repeat属性[CSS3BG]以获取属性值的定义。 </p>
<p>使用蒙版边框图像蒙版部分中给出了缩放和平铺蒙版边框图像部分的确切过程</p>
<h3 id="a8-7">8.7.Mask Border Image Shorthand: the mask-border property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-border</td>
    </tr>
    <tr>
        <td>Value</td>
        <td><‘mask-border-source’> || <‘mask-border-slice’> [ / <‘mask-border-width’>? [ / <‘mask-border-outset’> ]? ]? || <‘mask-border-repeat’> || <‘mask-border-mode’></td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>See individual properties</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>See individual properties</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>See individual properties</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>指掩模边框图像的大小</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>See individual properties</td>
    </tr>
</tbody>
</table>


<p>这是设置mask-border-source，mask-border-slice，mask-border-width，mask-border-outset和mask-border-repeat的简写属性。省略的值设置为其初始值。 </p>
<p class="note">注意：蒙版速记重置属性mask-border，mask-border-source，mask-border-mode，mask-border-slice，mask-border-width，mask-border-outset和mask-border-repeat。 
<h3 id="a8-8">8.8. 使用蒙版边框图像蒙版</h3>

<p>在蒙版边框切片给出的蒙版边框图像被蒙版边框切片值切片后，生成的九个图像被缩放，定位并平铺到相应的蒙版边框图像中如绘制边框图像[CSS3BG]一节中所述的四个步骤中的区域。 </p>
<p>将mask-border-source属性应用于使用CSS框模型格式化的元素，以与CSS不透明[CSS3COLOR]相同的方式建立堆叠上下文，并将所有元素的后代一起渲染为一个组。掩蔽应用于整个群体。 </p>
<p>mask-border-source属性对任何元素的CSS框的几何或命中测试没有影响。</p>
<h3 id="a9">9. SVG Mask Sources</h3>
<h3 id="a9-1">9.1 The mask element</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask</td>
    </tr>
    <tr>
        <td>类别：</td>
        <td>容器元素</td>
    </tr>
    <tr>
        <td>内容模型</td>
        <td>

<pre><code>        任意数量的以下元素，按任何顺序：

        animation — &lt;&#39;animate&gt;, &lt;&#39;animateColor&gt;, &lt;&#39;animateMotion&gt;, &lt;&#39;animateTransform&gt;, &lt;&#39;set&gt;

        descriptive — &lt;&#39;desc&gt;, &lt;&#39;title&gt;, &lt;&#39;metadata&gt;

        shape — &lt;&#39;circle&gt;, &lt;&#39;ellipse&gt;, &lt;&#39;line&gt;, &lt;&#39;path&gt;, &lt;&#39;polygon&gt;, &lt;&#39;polyline&gt;, &lt;&#39;rect&gt;

        structural — &lt;&#39;defs&gt;, &lt;&#39;g&gt;, &lt;&#39;svg&gt;, &lt;&#39;symbol&gt;, &lt;&#39;use&gt;

        gradient — &lt;&#39;linearGradient&gt;, &lt;&#39;radialGradient&gt;

        &lt;&#39;a&gt;

        &lt;&#39;clipPath&gt;

        &lt;&#39;color-profile&gt;

        &lt;&#39;cursor&gt;

        &lt;&#39;filter&gt;

        &lt;&#39;font&gt;

        &lt;&#39;font-face&gt;

        &lt;&#39;foreignObject&gt;

        &lt;&#39;image&gt;

        &lt;&#39;marker&gt;

        &lt;&#39;mask&gt;

        &lt;&#39;pattern&gt;

        &lt;&#39;script&gt;

        &lt;&#39;style&gt;

        &lt;&#39;switch&gt;

        &lt;&#39;view&gt;

        &lt;&#39;text&gt;

        &lt;&#39;altGlyphDef&gt;












    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;适用于&lt;/td&gt;
    &lt;td&gt;See individual properties&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;属性：&lt;/td&gt;
    &lt;td&gt;

        conditional processing attributes — ‘requiredFeatures’, ‘requiredExtensions’, ‘systemLanguage’

        core attributes — ‘id’, ‘xml:base’, ‘xml:lang’, ‘xml:space’

        presentation attributes — alignment-baseline, baseline-shift, clip, clip-path, clip-rule, color, color-interpolation, color-interpolation-filters, color-profile, color-rendering, cursor, direction, display, dominant-baseline, enable-background, fill, fill-opacity, fill-rule, filter, flood-color, flood-opacity, font, font-family, font-size, font-size-adjust, font-stretch, font-style, font-variant, font-weight, glyph-orientation-horizontal, glyph-orientation-vertical, image-rendering, kerning, letter-spacing, lighting-color, marker, marker-end, marker-mid, marker-start, mask, opacity, overflow, pointer-events, shape-rendering, stop-color, stop-opacity, stroke, stroke-dasharray, stroke-dashoffset, stroke-linecap, stroke-linejoin, stroke-miterlimit, stroke-opacity, stroke-width, text-anchor, text-decoration, text-rendering, unicode-bidi, visibility, word-spacing, writing-mode

        ‘class’

        ‘style’

        ‘x’

        ‘y’

        ‘width’

        ‘height’

        ‘maskUnits’

        ‘maskContentUnits’
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;DOM Interfaces:    &lt;/td&gt;
    &lt;td&gt;SVGMaskElement &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</tbody>
</table>


<p>属性定义：</p>
<h4>maskUnits =“userSpaceOnUse | objectBoundingBox”</h4>

<p>–定义属性x，y，宽度和高度的坐标系。 </p>
<h4>--userSpaceOnUse </h4>

<p>—-x，y，width和height表示当前用户坐标系[CSS3-TRANSFORMS]中引用掩码元素时的值（即，通过掩码元素引用的元素的用户坐标系）面具属性）。 </p>
<h4>--objectBoundingBox </h4>

<p>—-x，y，width和height表示应用蒙版的元素的对象边界框的分数或百分比。用户坐标的大小等同于CSS px单元。 </p>
<p>–如果未指定属性maskUnits，则效果就像指定了objectBoundingBox的值一样。 </p>
<p>–Animatable：yes。 </p>
<h4>maskContentUnits =“userSpaceOnUse | objectBoundingBox”</h4>

<p>–定义掩码内容的坐标系。 </p>
<h4>--userSpaceOnUse </h4>

<p>—-mask元素内容的用户坐标系是引用mask元素时的当前用户坐标系（即，通过mask属性引用mask元素的元素的用户坐标系） ）。 </p>
<h4>--objectBoundingBox </h4>

<p>—-坐标系的原点位于剪切路径所适用的元素的边界框的左上角，以及此边界框的相同宽度和高度。用户坐标的大小等同于CSS px单元。 </p>
<p>–如果未指定属性maskContentUnits，则效果就像指定了userSpaceOnUse的值一样。 </p>
<p>–Animatable：yes。 </p>
<p>x = &lt;’length&gt; | &lt;’percentage&gt;</p>
<p>矩形一角的x轴坐标，用于最大可能的屏幕外缓冲区。如果未指定属性但指定了y，width或height属性中的至少一个，则效果就好像指定了-10％的值。 </p>
<p>–Animatable：yes。 </p>
<p>y = &lt;’length&gt; | &lt;’percentage&gt;</p>
<p>矩形的一个角的y轴坐标，用于最大可能的屏幕外缓冲区。 </p>
<p>如果未指定属性但指定了属性x，width或height中的至少一个，则效果就好像指定了-10％的值。</p>
<p>–Animatable：yes。 </p>
<p>width = &lt;’length&gt; | &lt;’percentage&gt;</p>
<p>最大可能的屏幕外缓冲区的宽度。负值或零值禁用元素的渲染。</p>
<p>如果未指定属性但指定了属性x，y或height中的至少一个，则效果就好像指定了120％的值。</p>
<p>–Animatable：yes。 </p>
<p>height = &lt;’length&gt; | &lt;’percentage&gt;</p>
<p>最大可能的屏幕外缓冲区的高度。 </p>
<p>最大可能的屏幕外缓冲区的高度。 </p>
<p>如果未指定属性但指定了属性x，y或宽度中的至少一个，则效果就好像指定了120％的值。</p>
<p>–Animatable：yes。 </p>
<p>如果指定了属性x，y，宽度或高度中的至少一个，则给定对象和由x，y，宽度和高度定义的矩形建立当前剪切路径。必须通过此当前剪切路径剪切蒙版的渲染内容。 </p>
<p>CSS属性从其祖先继承到mask元素;属性不会从引用mask元素的元素继承。 </p>
<p>mask元素永远不会直接渲染;它们的唯一用法是可以使用mask属性引用的东西。不透明度，滤镜和显示属性不适用于蒙版元素;因此，即使将display属性设置为none以外的值，也不会直接呈现mask元素，即使mask元素或其任何祖先的display属性设置为none，mask元素也可用于引用。</p>
<h3 id="a9-2">9.2 Mask Source Interpretation: the mask-type property</h3>

<table class="code">
<tbody>
    <tr>
        <td>名称：</td>
        <td>mask-type</td>
    </tr>
    <tr>
        <td>Value</td>
        <td>luminance | alpha</td>
    </tr>
    <tr>
        <td>Initial</td>
        <td>luminance</td>
    </tr>
    <tr>
        <td>适用于</td>
        <td>mask元素</td>
    </tr>
    <tr>
        <td>Inherited：</td>
        <td>no</td>
    </tr>
    <tr>
        <td>Media：</td>
        <td>visual </td>
    </tr>
    <tr>
        <td>Computed value:</td>
        <td>as specified</td>
    </tr>
    <tr>
        <td>Percentages:</td>
        <td>n/a</td>
    </tr>
    <tr>
        <td>Animatable:</td>
        <td>no</td>
    </tr>
</tbody>
</table>


<p>mask-type属性定义是否将mask元素的内容视为亮度掩码或alpha掩码，如计算掩码值中所述。 </p>
<p>值具有以下含义：</p>
<h4>luminance </h4>

<p>–表示应使用掩码的亮度值。 </p>
<h4>alpha </h4>

<p>–表示应使用掩码的alpha值。 </p>
<p>mask-type属性允许mask元素的作者指定首选的屏蔽模式。但是，作者可以通过将掩码模式值设置为与掩码内容上的auto不同的值来覆盖此首选项。 </p>
<p>在下面的例子中，mask-type的计算值是亮度，mask-mode的计算值是auto。 UA必须遵循掩码元素上定义的首选掩码模式。</p>
<p>&lt;’svg&gt;</p>
<p>  &lt;’mask style=”mask-type: luminance;” id=”mask”&gt;</p>
<pre><code>...</code></pre>
<p>  &lt;/‘mask&gt;</p>
<p>&lt;/‘svg&gt;</p>
<p>&lt;’p style=”mask-image: url(#mask); mask-mode: auto;”&gt;</p>
<p>  This is the masked content.</p>
<p>&lt;/‘p&gt;</p>
<p>在下一个示例中，掩模模式的计算值是alpha，并覆盖对亮度计算的掩码元素的首选项。掩模层图像用作alpha掩模。</p>
<p>&lt;’svg&gt;</p>
<p>  &lt;’mask style=”mask-type: luminance;” id=”mask2”&gt;</p>
<pre><code>...</code></pre>
<p>  &lt;/‘mask&gt;</p>
<p>&lt;/‘svg&gt;</p>
<p>&lt;’p style=”mask-image: url(#mask2); mask-mode: alpha;”&gt;</p>
<p>  This is the masked content.</p>
<p>&lt;/‘p&gt;</p>
<p>mask-type属性是SVG元素的表示属性。</p>
<h3 id="a10">10. Security</h3>

<p>重要的是，屏蔽操作的定时独立于源像素和目标像素。必须以这样的方式实现掩蔽操作：无论像素值如何，它们总是花费相同的时间。如果不遵循此规则，攻击者可以推断信息并进行定时攻击。 </p>
<p>定时攻击是一种获取有关内容的信息的方法，这些内容受到其他方面的保护，基于研究操作发生所需的时间。例如，如果红色像素比绿色像素花费的时间更长，则可能能够重建正在渲染的元素的粗略图像，而无需访问元素的内容。 </p>
<p>&lt;’mask-source&gt;s and &lt;’clip-source&gt;s对获取资源有特殊要求。 </p>
<p>UA必须使用[HTML5]规范定义的 potentially CORS-enabled fetch方法，操作所有的在mask-image，mask-border-source和clip-path上的mask-source,clip-source,image的值。When fetching，UA必须使用“匿名”模式，将引用来源设置为样式表的URL，并将原点设置为包含文档的URL。如果这导致网络错误，则效果就像没有指定值none一样。</p>
<h3 id="a11">11. 致谢</h3>

<p>感谢Elika J. Etemad，Cameron McCormack，Liam R. E. Quin，BjörnHöhrmann，Alan Stearns和Sara Soueidan的细心评论，评论和更正。特别感谢CJ Gammon提供的图形资产。</p>
<table>
    <thead>
        <tr><th>Name</th><th>Value</th><th>Initial</th><th>Applies to</th><th>Inh.</th><th>%ages</th><th>Media</th><th>Animatable</th><th>Computed value</th></tr>
    </thead>
    <tbody>
        <tr><th><a href="#a5-1" title="clip-path">clip-path</a></th><td>&lt;clip-source&gt; | [ &lt;basic-shape&gt; || &lt;geometry-box&gt; ] | none</td><td>none</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>as specified</td><td>visual</td><td>as specified for &lt;basic-shape&gt; [CSS-SHAPES], otherwise no</td><td>as specified, but with &lt;url&gt; values made absolute
        </td></tr><tr><th><a href="#a6-2" title="clip-rule">clip-rule</a></th><td>nonzero | evenodd</td><td>nonzero</td><td>Applies to SVG graphics elements</td><td>yes</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a7-1" title="mask-image">mask-image</a></th><td>&lt;mask-reference&gt;#</td><td>none</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified, but with URIs made absolute
        </td></tr><tr><th><a href="#a7-2" title="mask-mode">mask-mode</a></th><td>&lt;masking-mode&gt;#</td><td>auto</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a7-3" title="mask-repeat">mask-repeat</a></th><td>&lt;repeat-style&gt;#</td><td>no-repeat</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>Consists of: two keywords, one per dimension
        </td></tr><tr><th><a href="#a7-4" title="mask-position">mask-position</a></th><td>&lt;position&gt;#</td><td>center</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>refer to size of mask painting area minus size of mask layer image; see text background-position [CSS3BG]</td><td>visual</td><td>as repeatable list of simple list of length, percentage, or calc</td><td>Consisting of: two keywords representing the origin and two offsets from that origin, each given as an absolute length (if given a &lt;length&gt;), otherwise as a percentage.
        </td></tr><tr><th><a href="#a7-5" title="mask-clip">mask-clip</a></th><td>[ &lt;geometry-box&gt; | no-clip ]#</td><td>border-box</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a7-6" title="mask-origin">mask-origin</a></th><td>&lt;geometry-box&gt;#</td><td>border-box</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a7-7" title="mask-size">mask-size</a></th><td>&lt;bg-size&gt;#</td><td>auto</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>as repeatable list of simple list of length, percentage, or calc (This means keyword values are not animatable.)</td><td>as specified, but with lengths made absolute
        </td></tr><tr><th><a href="#a7-8" title="mask-composite">mask-composite</a></th><td>&lt;compositing-operator&gt;#</td><td>add</td><td>All elements. In SVG, it applies to container elements without the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a7-9" title="mask">mask</a></th><td>&lt;mask-layer&gt;#</td><td>see individual properties</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>see individual properties</td><td>visual</td><td>see individual properties</td><td>see individual properties
        </td></tr><tr><th><a href="#a8-1" title="mask-border-source">mask-border-source</a></th><td>none | &lt;image&gt;</td><td>none</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>none or the image with its URI made absolute
        </td></tr><tr><th><a href="#a8-2" title="mask-border-mode">mask-border-mode</a></th><td>luminance | alpha</td><td>alpha</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a8-3" title="mask-border-slice">mask-border-slice</a></th><td>[&lt;number&gt; | &lt;percentage&gt;]{1,4} fill?</td><td>0</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>refer to size of the mask border image</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a8-4" title="mask-border-width">mask-border-width</a></th><td>[ &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]{1,4}</td><td>auto</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>relative to width/height of the mask border image area</td><td>visual</td><td>no</td><td>all &lt;length&gt;s made absolute, otherwise as specified
        </td></tr><tr><th><a href="#a8-5" title="mask-border-outset">mask-border-outset</a></th><td>[ &lt;length&gt; | &lt;number&gt; ]{1,4}</td><td>0</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>all &lt;length&gt;s made absolute, otherwise as specified
        </td></tr><tr><th><a href="#a8-6" title="mask-border-repeat">mask-border-repeat</a></th><td>[ stretch | repeat | round | space ]{1,2}</td><td>stretch</td><td>All elements. In SVG, it applies to container elements excluding the &lt;defs&gt; element and all graphics elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a8-7" title="mask-border">mask-border</a></th><td>&lt;‘mask-border-source’&gt; || &lt;‘mask-border-slice’&gt; [ / &lt;‘mask-border-width’&gt;? [ / &lt;‘mask-border-outset’&gt; ]? ]? || &lt;‘mask-border-repeat’&gt; || &lt;‘mask-border-mode’&gt;</td><td>See individual properties</td><td>See individual properties</td><td>no</td><td>n/a</td><td>visual</td><td>See individual properties</td><td>See individual properties
        </td></tr><tr><th><a href="#a9-2" title="mask-type">mask-type</a></th><td>luminance | alpha</td><td>luminance</td><td>mask elements</td><td>no</td><td>n/a</td><td>visual</td><td>no</td><td>as specified
        </td></tr><tr><th><a href="#a10" title="clip">clip</a></th><td>&lt;rect()&gt; | auto</td><td>auto</td><td>Absolutely positioned elements. In SVG, it applies to elements which establish a new viewport, &lt;pattern&gt; elements and mask elements.</td><td>no</td><td>n/a</td><td>visual</td><td>as rectangle</td><td>as specified</td></tr>
    </tbody>
</table>

]]></content>
  </entry>
  <entry>
    <title>Media Source Extensions</title>
    <url>/2020/11/19/doc/mse/</url>
    <content><![CDATA[<h3 id="Media-Source-Extensions™"><a href="#Media-Source-Extensions™" class="headerlink" title="Media Source Extensions™"></a>Media Source Extensions™</h3><p>—-W3C编辑的草案2016年11月8日</p>
<p><a href="http://w3c.github.io/media-source/" target="_blank" rel="noopener noreferrer">http://w3c.github.io/media-source/</a></p>
<p>最新发布的版本：</p>
<p><a href="https://www.w3.org/TR/media-source/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/media-source/</a></p>
<p>最新编辑的草稿：</p>
<p><a href="http://w3c.github.io/media-source/" target="_blank" rel="noopener noreferrer">http://w3c.github.io/media-source/</a></p>
<p> 实施报告：</p>
<p><a href="http://tidoust.github.io/media-source-testcoverage/" target="_blank" rel="noopener noreferrer">http://tidoust.github.io/media-source-testcoverage/</a></p>
<p>编辑：</p>
<p>Matthew Wolenetz，Google Inc.; Jerry Smith，微软公司; Mark Watson，Netflix Inc.; Aaron Colwell（2015年4月），Google Inc.; Adrian Bateman（2015年4月），Microsoft Corporation </p>
<p>Repository: </p>
<p><a href="https://github.com/w3c/media-source/"  target="_blank" rel="noopener noreferrer">We are on GitHub</a></p>
<p><a href="https://github.com/w3c/media-source/issues" target="_blank" rel="noopener noreferrer">File a bug</a></p>
<p><a href="https://github.com/w3c/media-source/commits/gh-pages/media-source-respec.html" target="_blank" rel="noopener noreferrer">Commit history</a></p>
<p>Mailing list:</p>
<p><a href="https://lists.w3.org/Archives/Public/public-html-media/" target="_blank" rel="noopener noreferrer">public-html-media@w3.org</a></p>
<p>Implementation:</p>
<p><a href="https://caniuse.com/#feat=mediasource" target="_blank" rel="noopener noreferrer">Can I use Media Source Extensions?</a></p>
<p><a href="http://w3c-test.org/media-source/" target="_blank" rel="noopener noreferrer">Test Suite</a></p>
<p><a href="https://github.com/web-platform-tests/wpt/tree/master/media-source" target="_blank" rel="noopener noreferrer">Test Suite repository</a></p>
<p>Copyright © 2016 W3C® (MIT, ERCIM, Keio, Beihang). W3C liability, trademark and document use rules apply.</p>
<h3>摘要</h3>

<p>此规范扩展了HTMLMediaElement [HTML51]，允许JavaScript生成用于回放的媒体流。允许JavaScript生成流有助于各种用例，如自适应流和时移实时流。 </p>
<p>如果您希望以编辑跟踪的方式对本文档发表评论或提出错误，请通过我们的公共错误数据库提交。</p>
<p>文档状态</p>
<p>本节介绍本文档发布时的状态。其他文件可能会取代本文件。可以在W3C技术报告索引（<a href="https://www.w3.org/TR/" target="_blank" rel="noopener noreferrer">https://www.w3.org/TR/</a>）中找到当前W3C出版物列表和本技术报告的最新版本。 </p>
<p>工作组维护编辑尚未尝试解决的所有错误报告的列表;在之前的bug跟踪器中可能还存在漏洞。该草案强调了工作组仍有待讨论的一些悬而未决的问题。尚未就这些问题的结果作出决定，包括它们是否有效。 </p>
<p>Implementors应该知道这个规范不稳定。没有参与讨论的实施者可能会发现规范以不兼容的方式从它们下面改变。有兴趣在最终达到候选推荐阶段之前实施本规范的供应商应加入下面提到的邮件列表并参与讨论。</p>
<p>为了使该规范退出候选推荐阶段，将需要两个独立的实现，如CR退出标准（公共许可版本3）文档中所详述，以通过由HTML Media Extensions WG开发的MSE测试套件中的每个测试。 </p>
<p>本文档由HTML Media Extensions Working Group作为编辑草案发布。如果您想对本文档发表评论，请发送至public-html-media</p>
<p>w3.org（订阅，存档）。欢迎所有评论。 </p>
<p>请参阅工作组的实施报告。 </p>
<p>作为编辑草案的出版并不意味着W3C会员资格的认可。这是一份草案文件，可能随时被其他文件更新，替换或废弃。除了正在进行的工作之外，引用此文档是不恰当的。</p>
<p>本文件由一个在2004年2月5日的W3C专利政策下运营的集团制作。 W3C维护一份与该集团可交付成果有关的任何专利披露的公开名单;该页面还包括披露专利的说明。具有个人认为包含基本要求的专利的实际知识的个人必须根据W3C专利政策的第6部分披露信息。 </p>
<p>本文档受2015年9月1日W3C流程文档的约束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">    UA: userAgent</span><br><span class="line">    -- : 回车</span><br></pre></td></tr></table></figure>

<h3 id="a1">1. 简介</h3>

<p> 本节不具有规范性。 </p>
<p>这规范允许javascript为”audio“和”video“动态构建媒体流。它定义了一个MediaSource对象，可以作为HTMLMediaElement的媒体数据源。 MediaSource对象具有一个或多个SourceBuffer对象。应用程序将数据段附加到SourceBuffer对象，并可以根据系统性能和其他因素调整附加数据的质量。来自SourceBuffer对象的数据被管理为用于解码和播放的音频，视频和文本数据的轨道缓冲区。与这些扩展一起使用的字节流规范在字节流格式注册表[MSE-REGISTRY]中可用。</p>
<img src="https://w3c.github.io/media-source/pipeline_model.svg" alt=""/>

<h4 id="a1-1">1.1. 目标</h4>

<p>本规范的设计考虑了以下目标：</p>
<p>–允许JavaScript构建媒体流，而与提取媒体的方式无关。</p>
<p>–定义拼接和缓冲模型，以促进自适应流，广告插入，时移和视频编辑等用例。 </p>
<p>–最小化JavaScript中媒体解析的需要。 </p>
<p>–尽可能地利用浏览器缓存。 </p>
<p>–提供字节流格式规范的要求。 </p>
<p>–不需要支持任何特定的媒体格式或编解码器。 </p>
<p>此规范定义：</p>
<p>–UA的规范行为，用于在处理媒体数据时启用UA和Web应用程序之间的互操作性。 </p>
<p>–规范要求，以使其他规范能够定义在本规范中使用的媒体格式。</p>
<h4 id="a1-2"> 1.2. 定义</h4>

<p>Active Track Buffers </p>
<p>–轨道缓冲区，为启用的audioTracks，选定的videoTracks以及“显示”或“隐藏”textTracks提供编码帧。所有这些轨道都与activeSourceBuffers列表中的SourceBuffer对象相关联。</p>
<p>Append Window </p>
<p>–用于在附加时过滤出编码帧的演示时间戳范围。追加窗口表示单个连续时间范围，具有单个开始时间和结束时间。允许将具有此范围内的呈现时间戳的编码帧附加到SourceBuffer，同时过滤掉该范围之外的编码帧。追加窗口的开始和结束时间分别由appendWindowStart和appendWindowEnd属性控制。</p>
<p>Coded Frame </p>
<p>–具有显示时间戳，解码时间戳和编码帧持续时间的媒体数据单元。</p>
<p>编码帧持续时间</p>
<p>–编码帧的持续时间。对于视频和文本，持续时间表示视频帧或文本应显示多长时间。对于音频，持续时间表示编码帧内包含的所有样本的总和。例如，如果音频帧包含441个样本44100Hz，则帧持续时间将是10毫秒。 </p>
<p>Coded Frame End Timestamp </p>
<p>–编码帧呈现时间戳及其编码帧持续时间的总和。它表示紧跟在编码帧之后的表示时间戳。</p>
<p>Coded Frame Group</p>
<p>–一组编码帧，它们相邻并具有单调增加的解码时间戳，没有任何间隙。由编码帧处理算法和abort（）调用检测到的不连续性触发新编码帧组的开始。</p>
<p>Decode Timestamp</p>
<p>–解码时间戳指示帧的最新时间，假设对此帧和任何相关帧进行即时解码和渲染（这等于最早帧的呈现时间戳，按呈现顺序，即取决于这个框架）。如果帧可以从呈现顺序解码，则解码时间戳必须存在于字节流中或者可以从字节流中导出。如果不是这种情况，则UA必须运行追加错误算法。如果帧不能从呈现顺序解码并且字节流中不存在解码时间戳，则解码时间戳等于呈现时间戳。</p>
<p>Initialization Segment</p>
<p>–一个字节序列，包含解码一系列媒体段所需的所有初始化信息。这包括编解码器初始化数据，多路复用段的轨道ID映射和时间戳偏移（例如，编辑列表）。</p>
<blockquote>
<p>字节流格式注册表[MSE-REGISTRY]中的字节流格式规范包含格式特定示例。</p>
</blockquote>
<p>Media Segment </p>
<p>–一个字节序列，包含媒体时间轴的一部分的打包和带时间戳的媒体数据。媒体段始终与最近附加的初始化段相关联。</p>
<blockquote>
<p>字节流格式注册表[MSE-REGISTRY]中的字节流格式规范包含格式特定示例。</p>
</blockquote>
<p>MediaSource object URL</p>
<p>–A MediaSource对象URL是由createObjectURL（）创建的唯一Blob URI [FILE-API]。它用于将MediaSource对象附加到HTMLMediaElement。 </p>
<p>–这些URL与Blob URI相同，除了引用File和Blob对象的该功能定义中的任何内容在此扩展为也适用于MediaSource对象。 </p>
<p>–MediaSource对象URL的原点是在调用createObjectURL（）期间的相关设置对象。</p>
<blockquote>
<p>例如，MediaSource对象URL的来源会影响画布使用媒体元素的方式。</p>
</blockquote>
<p> Parent Media Source</p>
<p>–SourceBuffer对象的父媒体源是创建它的MediaSource对象。</p>
<p>Presentation Start Time </p>
<p>–演示开始时间是演示文稿中最早的时间点，指定初始播放位置和最早可能的位置。使用此规范创建的所有演示文稿的演示文稿开始时间均为0</p>
<blockquote>
<p>为了确定HTMLMediaElement.buffered是否包含包含当前播放位置的TimeRange，实现可以选择允许在演示时或之后的当前播放位置开始时间和第一个TimeRange播放第一个TimeRange之前，如果TimeRange在一个相当短的时间内开始，比如1秒，在演示开始时间之后。这种容差适应了这样的现实：多路复用流通常不会在演示开始时精确地开始所有轨道。无论此容差如何，实现都必须报告实际缓冲范围。 </p>
</blockquote>
<p>Presentation Interval </p>
<p>–编码帧的表示间隔是从其表示时间戳到表示时间戳加上编码帧的持续时间的时间间隔。例如，如果编码帧具有10秒的呈现时间戳和100毫秒的编码帧持续时间，则呈现间隔将是[10-10.1]。请注意，范围的起点是包含的，但范围的结尾是独占的。</p>
<p>Presentation Order </p>
<p>–编码帧在演示文稿中呈现的顺序。通过按照其呈现时间戳以单调递增的顺序对编码帧进行排序来实现呈现顺序。</p>
<p>Presentation Timestamp</p>
<p>–对演示文稿中特定时间的引用。编码帧中的呈现时间戳指示何时应该呈现帧。</p>
<p>Random Access Point </p>
<p>–媒体片段中的一个位置，可以在不依赖片段中任何先前数据的情况下开始解码和连续播放。对于视频，这往往是I帧的位置。在音频的情况下，大多数音频帧可以被视为随机接入点。由于视频轨道往往具有更稀疏的随机接入点分布，因此这些点的位置通常被认为是多路复用流的随机接入点。</p>
<p>SourceBuffer字节流格式规范</p>
<p>–特定的字节流格式规范，描述SourceBuffer实例接受的字节流的格式。根据传递给创建对象的addSourceBuffer（）调用的类型，选择SourceBuffer对象的字节流格式规范。</p>
<p>SourceBuffer configuration</p>
<p>–一个特定的一组轨道，分布在一个或多个由单个MediaSource实例拥有的SourceBuffer对象上。</p>
<p>–Implementations必须支持至少1个具有以下配置的MediaSource对象：</p>
<p>—-单个SourceBuffer，带有1个音轨和/或1个视</p>
<p>—-Two SourceBuffers，其中一个处理单个音轨，另一个处理单个视频轨道。</p>
<p>–MediaSource对象必须支持上述每个配置，但它们一次只需要支持一个配置。一次支持多个配置或其他配置是实施质量问题。</p>
<p>Track Description</p>
<p>–字节流格式特定结构，为单个轨道提供Track ID，编解码器配置和其他元数据。单个初始化段内的每个轨道描述都具有唯一的轨道ID。如果Track ID在初始化段中不唯一，则UA必须运行追加错误算法。 </p>
<p>Track ID </p>
<p>–Track ID是一种字节流格式特定的标识符，它将字节流的各部分标记为特定轨道的一部分。轨道描述中的轨道ID标识媒体段的哪些部分属于该轨道。</p>
<h3 id="a2"> 2. MediaSource对象</h3>

<p>MediaSource对象表示HTMLMediaElement的媒体数据源。它跟踪此源的readyState以及可用于将媒体数据添加到演示文稿的SourceBuffer对象列表。 MediaSource对象由Web应用程序创建，然后附加到HTMLMediaElement。应用程序使用sourceBuffers中的SourceBuffer对象将媒体数据添加到此源。在播放期间需要时，HTMLMediaElement从MediaSource对象中提取此媒体数据。 </p>
<p>每个MediaSource对象都有一个实时可搜索范围变量，用于存储规范化的TimeRanges对象。创建MediaSource对象时，此变量初始化为空的TimeRanges对象，由setLiveSeekableRange（）和clearLiveSeekableRange（）维护，并在HTMLMediaElement Extensions中用于修改HTMLMediaElement.seekable行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">enum ReadyState &#123;</span><br><span class="line">    <span class="string">&quot;closed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ended&quot;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>closed:</p>
<p>表示源当前未附加到媒体元素。</p>
<p>open:</p>
<p>open源已由媒体元素打开，可以将数据附加到sourceBuffers中的SourceBuffer对象。</p>
<p>ended:</p>
<p>ends源仍然附加到媒体元素，但是已经调用了endOfStream（）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">enum EndOfStreamError &#123;</span><br><span class="line">    <span class="string">&quot;network&quot;</span>,</span><br><span class="line">    <span class="string">&quot;decode&quot;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>network:</p>
<p>终止播放并发出网络错误信号。</p>
<blockquote>
<p>JavaScript应用程序应使用此状态代码终止播放时出现网络错误。例如，如果在获取媒体数据时发生网络错误。</p>
</blockquote>
<p>decode:</p>
<p>终止播放并发出解码错误信号。</p>
<blockquote>
<p>JavaScript应用程序应使用此状态代码终止播放并出现解码错误。例如，如果在处理带外媒体数据时发生解析错误。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[Constructor]</span><br><span class="line">interface MediaSource : EventTarget &#123;</span><br><span class="line">    readonly attribute SourceBufferList sourceBuffers;</span><br><span class="line">    readonly attribute SourceBufferList activeSourceBuffers;</span><br><span class="line">    readonly attribute ReadyState       readyState;</span><br><span class="line">             attribute unrestricted double duration;</span><br><span class="line">             attribute EventHandler  onsourceopen;</span><br><span class="line">             attribute EventHandler  onsourceended;</span><br><span class="line">             attribute EventHandler  onsourceclose;</span><br><span class="line">    SourceBuffer addSourceBuffer(DOMString type);</span><br><span class="line">    <span class="keyword">void</span>         removeSourceBuffer(SourceBuffer sourceBuffer);</span><br><span class="line">    <span class="keyword">void</span>         endOfStream(optional EndOfStreamError error);</span><br><span class="line">    <span class="keyword">void</span>         setLiveSeekableRange(double start, double end);</span><br><span class="line">    <span class="keyword">void</span>         clearLiveSeekableRange();</span><br><span class="line">    <span class="keyword">static</span> boolean isTypeSupported(DOMString type);</span><br></pre></td></tr></table></figure>
<h4 id="a2-1"> 2.1. 属性</h4>
<h5>sourceBuffers of type SourceBufferList, readonly</h5>

<p>包含与此MediaSource关联的SourceBuffer对象列表。当readyState等于“已关闭”时，此列表将为空。一旦readyState转换为“open”，可以使用addSourceBuffer（）将SourceBuffer对象添加到此列表中。</p>
<h5>activeSourceBuffers of type SourceBufferList, readonly</h5>

<p>包含提供所选视频轨道的sourceBuffers子集，启用的音频轨道以及“显示”或“隐藏”文本轨道。</p>
<p>此列表中的SourceBuffer对象必须以与它们在sourceBuffers属性中出现的顺序相同的顺序出现;例如，如果只有sourceBuffers [0]和sourceBuffers [3]在activeSourceBuffers中，那么activeSourceBuffers [0]必须等于sourceBuffers [0]，而activeSourceBuffers [1]必须等于sourceBuffers [3]。 </p>
<blockquote>
<p>对选定/启用的跟踪状态部分的更改描述了如何更新此属性。</p>
</blockquote>
<h5>readyState of type ReadyState, readonly</h5>

<p>指示MediaSource对象的当前状态。创建MediaSource时，readyState必须设置为“closed”。</p>
<h5>duration of type unrestricted double</h5>

<p>允许Web应用程序设置演示文稿持续时间。创建MediaSource对象时，持续时间最初设置为NaN。</p>
<p>在获取时，运行以下步骤：</p>
<p>1.如果readyState属性为“closed”，则返回NaN并中止这些步骤。</p>
<p>2.返回属性的当前值。</p>
<p>On设置，运行以下步骤：</p>
<p>1.如果设置的值为负或NaN，则抛出TypeError异常并中止这些步骤。</p>
<p>2.如果readyState属性不是“打开”，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.如果sourceBuffers中的任何SourceBuffer上的更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>4.运行持续时间更改算法，并将新持续时间设置为分配给此属性的值。</p>
<blockquote>
<p>如果存在具有较高结束时间的任何当前缓冲的编码帧，则持续时间改变算法将调整新的持续时间。<br>appendBuffer（）和endOfStream（）可以在某些情况下更新持续时间。 EventHandler类型的</p>
</blockquote>
<h5>onsourceopen of type EventHandler</h5>

<p>sourceopen事件的事件处理程序。</p>
<h5>onsourceended of type EventHandler</h5>

<p>sourceended事件的事件处理程序。</p>
<h5>onsourceclose of type EventHandler</h5>

<p>sourceclose事件的事件处理程序。</p>
<h4 id="a2-2">2.2. 方法</h4>
<h5>addSourceBuffer</h5>

<p>向sourceBuffers添加新的SourceBuffer。</p>
<p>Parameter:</p>
<p>type: DOMString</p>
<p>返回类型：SourceBuffer </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果type是空字符串，则抛出TypeError异常并中止这些步骤。</p>
<p>2.如果type包含不受支持的MIME类型或包含在sourceBuffers中为其他SourceBuffer对象指定的类型不支持的MIME类型，则抛出NotSupportedError异常并中止这些步骤。</p>
<p>3.如果UA无法处理任何更多SourceBuffer对象，或者如果基于类型创建SourceBuffer将导致不支持的SourceBuffer配置，则抛出QuotaExceededError异常并中止这些步骤。</p>
<blockquote>
<p>例如，如果媒体元素已到达HAVE_METADATA readyState，则UA可能会抛出QuotaExceededError异常。如果UA的媒体引擎不支持在播放期间添加更多曲目，则会发生这种情况。 </p>
</blockquote>
<p>4.如果readyState属性未处于“打开”状态，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>5.创建一个新的SourceBuffer对象和相关资源。</p>
<p>6.将新对象上的generate timestamps标志设置为与type关联的字节流格式注册表[MSE-REGISTRY]条目的“Generate Timestamps Flag”列中的值。 </p>
<p>7.如果generate timestamps标志等于true：</p>
<p>—-将新对象的mode属性设置为“sequence”。</p>
<p>–否则：</p>
<p>—-将新对象的mode属性设置为“segments”。 </p>
<p>8.将新对象添加到sourceBuffers并将任务排队以在sourceBuffers上触发名为addsourcebuffer的简单事件。</p>
<p>9.返回新对象。</p>
<h5>removeSourceBuffer</h5>

<p>向sourceBuffers添加新的SourceBuffer。</p>
<p>Parameter:</p>
<p>type: DOMString</p>
<p>返回类型：SourceBuffer </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果sourceBuffer指定了不在sourceBuffers中的对象，则抛出NotFoundError异常并中止这些步骤。</p>
<p>2.如果sourceBuffer.updating属性等于true，则运行以下步骤：</p>
<p>2.1.如果缓冲区附加算法正在运行，则中止该算法。</p>
<p>2.2.将sourceBuffer.updating属性设置为false。</p>
<p>2.3.Queue一个任务，在sourceBuffer上触发一个名为abort的简单事件。</p>
<p>2.4.Queue一个任务，在sourceBuffer上触发一个名为updateend的简单事件。</p>
<p>3.让SourceBuffer audioTracks列表等于sourceBuffer.audioTracks返回的AudioTrackList对象。 </p>
<p>4.如果SourceBuffer audioTracks列表不为空，则运行以下步骤：</p>
<p>4.1.让HTMLMediaElement audioTracks列表等于HTMLMediaElement上audioTracks属性返回的AudioTrackList对象。</p>
<p>4.2.对于SourceBuffer audioTracks列表中的每个AudioTrack对象，请运行以下步骤：</p>
<p>4.2.1.将AudioTrack对象上的sourceBuffer属性设置为null。</p>
<p>4.2.2.从HTMLMediaElement audioTracks列表中删除AudioTrack对象。</p>
<blockquote>
<p>这应该触发AudioTrackList [HTML51]逻辑，将任务排队以激活名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为AudioTrack对象，at HTMLMediaElement audioTracks列表。如果AudioTrack对象的enabled属性在此删除步骤开始时为true，那么这也应该触发AudioTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement audioTracks列表中触发名为change的简单事件</p>
</blockquote>
<p>4.2.3.从SourceBuffer audioTracks列表中删除AudioTrack对象。</p>
<blockquote>
<p>这应该触发AudioTrackList [HTML51]逻辑，将任务排队以激活名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为AudioTrack对象，at SourceBuffer audioTracks列表。如果AudioTrack对象的enabled属性在此删除步骤开始时为true，那么这也应该触发AudioTrackList [HTML51]逻辑来排队任务以在SourceBuffer audioTracks列表中触发名为change的简单事件</p>
</blockquote>
<p>5.Let SourceBuffer videoTracks list等于sourceBuffer.videoTracks返回的VideoTrackList对象。</p>
<p>6.如果SourceBuffer videoTracks列表不为空，则运行以下步骤：</p>
<p>6.1.让HTMLMediaElement videoTracks列表等于HTMLMediaElement上videoTracks属性返回的VideoTrackList对象。</p>
<p>6.2.对于SourceBuffer videoTracks列表中的每个VideoTrack对象，请运行以下步骤：</p>
<p>6.2.1.将VideoTrack对象上的sourceBuffer属性设置为null。</p>
<p>6.2.2.从HTMLMediaElement videoTracks列表中删除VideoTrack对象。</p>
<blockquote>
<p>这应该触发VideoTrackList [HTML51]逻辑，将任务排队以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为VideoTrack对象，at HTMLMediaElement videoTracks列表。如果在此删除步骤开始时VideoTrack对象上的所选属性为true，那么这也应该触发VideoTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement videoTracks列表中触发名为change的简单事件</p>
</blockquote>
<p>6.2.3.删除VideoTrack对象来自SourceBuffer videoTracks列表。</p>
<blockquote>
<p>这应该触发VideoTrackList [HTML51]逻辑来排队任务以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为VideoTrack对象，位于SourceBuffer videoTracks名单。如果在此删除步骤开始时VideoTrack对象上的所选属性为true，那么这也应该触发VideoTrackList [HTML51]逻辑，将任务排队以在SourceBuffer videoTracks列表中触发名为change的简单事件</p>
</blockquote>
<p>7.Let SourceBuffer textTracks list等于sourceBuffer.textTracks返回的TextTrackList对象。</p>
<p>8.如果SourceBuffer textTracks列表不为空，则运行以下步骤：</p>
<p>8.1.让HTMLMediaElement textTracks列表等于HTMLMediaElement上textTracks属性返回的TextTrackList对象。</p>
<p>8.2.对于SourceBuffer textTracks列表中的每个TextTrack对象，请运行以下步骤：</p>
<p>8.2.1.将TextTrack对象上的sourceBuffer属性设置为null。</p>
<p>8.2.2.从HTMLMediaElement textTracks列表中删除TextTrack对象。 </p>
<blockquote>
<p>这应该触发TextTrackList [HTML51]逻辑，将任务排队以激活名为removetrack的可信事件，该事件不会冒泡且不可取消，并使用TrackEvent接口，并将track属性初始化为TextTrack对象，at HTMLMediaElement textTracks列表。如果TextTrack对象上的mode属性在此删除步骤开始时“显示”或“隐藏”，那么这也应该触发TextTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement textTracks列表中触发名为change的简单事件。 </p>
</blockquote>
<p>8.2.3.从SourceBuffer textTracks列表中删除TextTrack对象。</p>
<blockquote>
<p>这应该触发TextTrackList [HTML51]逻辑来排队任务以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为TextTrack对象，位于SourceBuffer textTracks名单。如果TextTrack对象上的mode属性在此删除步骤开始时“显示”或“隐藏”，那么这也应该触发TextTrackList [HTML51]逻辑来排队任务以在SourceBuffer textTracks列表中触发名为change的简单事件。 </p>
</blockquote>
<p>9.如果sourceBuffer在activeSourceBuffers中，则从activeSourceBuffers中删除sourceBuffer并对任务进行排队，以在activeSourceBuffers返回的SourceBufferList中触发名为removedourcebuffer的简单事件。</p>
<p>10.从sourceBuffers中删除sourceBuffer并对任务进行排队，以在SourceBuffers返回的SourceBufferList中触发名为removedourcebuffer的简单事件。</p>
<p>11.销毁sourceBuffer的所有资源。</p>
<h5>endOfStream</h5>

<p>表示流的结尾。</p>
<p>Parameter:</p>
<p>error: EndOfStreamError</p>
<p>返回类型：void  </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果readyState属性未处于“打开”状态，则抛出一个InvalidStateError异常并中止这些步骤。</p>
<p>2.如果sourceBuffers中的任何SourceBuffer上的更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.运行流算法结束，并将error参数设置为error。</p>
<h5>setLiveSeekableRange</h5>

<p>更新HTMLMediaElement Extensions中使用的实时可搜索范围变量，以修改HTMLMediaElement.seekable行为。 。</p>
<p>Parameter:</p>
<p>start: double</p>
<p>范围的开始，以演示开始时间为单位的秒数。设置时，如果持续时间等于正无穷大，HTMLMediaElement.seekable将返回一个非空的TimeRanges对象，其最低范围的开始时间戳不大于start。 </p>
<p>end: double</p>
<p>范围的结束，以演示开始时间为单位的秒数。设置时，如果持续时间等于正无穷大，HTMLMediaElement.seekable将返回一个非空的TimeRanges对象，其最大范围结束时间戳不小于end。 </p>
<p>返回类型：void  </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果readyState属性不是“open”，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>2.如果start为负或大于end，则抛出TypeError异常并中止这些步骤。</p>
<p>3.将实时可搜索范围设置为新的标准化TimeRanges对象，该对象包含单个范围，其起始位置为开始，结束位置为结束。</p>
<h5>clearLiveSeekableRange</h5>

<p>更新HTMLMediaElement Extensions中使用的实时可搜索范围变量，以修改HTMLMediaElement.seekable行为。 </p>
<p>没有参数。</p>
<p>返回类型：void  </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果readyState属性不是“open”，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>2.如果实时可搜索范围包含范围，则将实时可搜范范围设置为新的空TimeRanges对象。</p>
<h5>isTypeSupported, static</h5>

<p>检查MediaSource是否能够为指定的MIME类型创建SourceBuffer对象。 </p>
<blockquote>
<p>如果从此方法返回true，则仅表示MediaSource实现能够为指定的MIME类型创建SourceBuffer对象。如果没有足够的资源来支持添加新的SourceBuffer，则addSourceBuffer（）调用仍然会失败。<br>此方法返回true表示HTMLMediaElement.canPlayType（）将返回“可能”或“可能”，因为对于MediaSource来说，支持HTMLMediaElement知道它无法播放的类型是没有意义的。 </p>
</blockquote>
<p>向sourceBuffers添加新的SourceBuffer。</p>
<p>Parameter:</p>
<p>type: DOMString</p>
<p>返回类型：boolean </p>
<p>调用此方法时，UA必须运行以下步骤：</p>
<p>1.如果type为空字符串，则返回false。</p>
<p>2.如果type不包含有效的MIME类型字符串，则返回false。</p>
<p>3.如果type包含MediaSource不支持的媒体类型或媒体子类型，则返回false。</p>
<p>4.如果type包含MediaSource不支持的编解码器，则返回false。</p>
<p>5.如果MediaSource不支持指定的媒体类型，媒体子类型和编解码器组合，则返回false。</p>
<p>6.返回true。</p>
<h4 id="a2-3">2.3. 事件摘要</h4>

<p>sourceopen:</p>
<p>readyState transitions from “closed” to “open” or from “ended” to “open”.</p>
<p>sourceended:</p>
<p>readyState transitions from “open” to “ended”.</p>
<p>sourceclose:</p>
<p>readyState transitions from “open” to “closed” or “ended” to “closed”.</p>
<h3 id="a2-4">2.4. 算法</h3>
<h4 id="a2-41">2.4.1. 附加到媒体元素</h4>

<p> 通过将MediaSource对象URL分配给media元素src属性或media元素内的src属性，可以将MediaSource对象附加到媒体元素。通过将MediaSource对象传递给createObjectURL（）来创建MediaSource对象URL。</p>
<p> 如果使用作为MediaSource对象的媒体提供程序对象或其对象是MediaSource对象的URL记录调用资源获取算法，则让模式为本地,跳过资源获取算法中的第一步（否则可以将模式设置为远程）并将下面的步骤和说明添加到资源获取算法的“其他（模式是本地）”部分。</p>
<blockquote>
<p>资源获取算法的第一步预计最终与为对象为媒体提供者对象的URL记录选择本地模式一致。目的是，如果HTMLMediaElement的src属性或选定的子的src属性是一个blob：在上次更改相应的src属性时匹配MediaSource对象URL的URL，则该MediaSource对象将用作媒体提供程序对象，资源获取算法中本地模式逻辑中的当前媒体资源。这也意味着当附加MediaSource对象时，将跳过包含遵守任何preload属性的远程模式逻辑。即使最终更改为[HTML51]，当前媒体资源是MediaSource对象时，仍然需要在本地模式逻辑开头执行以下步骤。</p>
</blockquote>
<blockquote>
<p>相对于触发媒体元素的资源选择算法的动作，这些步骤是异步的。在允许调用资源选择算法的任务继续并且达到稳定状态之后运行资源获取算法。实现可能会延迟下面“OTHER”子句中的步骤，直到MediaSource对象可以使用。</p>
</blockquote>
<p>如果readyState未设置为“关闭”</p>
<p>运行“如果根本无法获取媒体数据，由于网络错误，导致UA放弃尝试获取资源”资源获取算法的媒体数据处理步骤的步骤名单。</p>
<p>否则</p>
<p>1.将media元素的delaying-the-load-event-flag设置为false。</p>
<p>2.将readyState属性设置为“open”。</p>
<p>3.Queue一项任务是在MediaSource上触发一个名为sourceopen的简单事件。</p>
<p>4.通过运行剩余的“其他（模式是本地）”步骤继续资源获取算法，并进行以下说明：</p>
<p>4.1资源获取算法中的文本或引用“下载”，“接收的字节”的媒体数据处理步骤列表或“当当前媒体资源的新数据变得可用时”指的是通过appendBuffer（）传入的数据。</p>
<p>4.2资源获取算法中的HTTP引用和媒体数据处理步骤列表不适用，因为HTMLMediaElement在附加MediaSource时不通过HTTP获取媒体数据。</p>
<blockquote>
<p>附加的MediaSource不使用资源获取算法中的远程模式步骤，因此media元素不会触发“挂起”事件。虽然此规范的未来版本可能会从具有附加MediaSource的媒体元素中删除“进度”和“停顿”事件，但符合此版本规范的UA仍可能触发这两个事件，因为这些[HTML51]引用在实现后发生了更改本规范的稳定性。</p>
</blockquote>
<h4 id="a2-42"> 2.4.2. 从媒体元素中分离</h4>

<p>在媒体元素将转换为NETWORK_EMPTY并将任务排队以在media元素上触发名为emptied的简单事件的任何情况下，都会运行以下步骤。这些步骤应该在转换之前运行。</p>
<p>1.将readyState属性设置为“closed”。 </p>
<p>2.更新NaN的持续时间。</p>
<p>3.从activeSourceBuffers中删除所有SourceBuffer对象。</p>
<p>4.Queue一个任务，用于在activeSourceBuffers中触发一个名为removedourcebuffer的简单事件</p>
<p>5.从sourceBuffers中删除所有SourceBuffer对象。</p>
<p>6.Queue一个任务，在sourceBuffers上触发一个名为removedourcebuffer的简单事件。</p>
<p>7.Queue任务在MediaSource上触发一个名为sourceclose的简单事件。</p>
<blockquote>
<p>接下来，该算法旨在从外部调用并在任何必须从媒体元素分离附加的MediaSource如果有的话）的情况下运行。当媒体元素转换为NETWORK_EMPTY时，除了或代替，还可以在HTMLMediaElement[HTML51]操作（如load（）和资源获取算法失败）上调用它。资源获取算法失败是中止资源获取算法或资源选择算法的失败，除了“最终步骤”[HTML51]不被视为触发分离的失败。</p>
</blockquote>
<h4 id="a2-43">2.4.3. Seeking</h4>

<p> 运行以下步骤作为“等待UA确定新播放位置的媒体数据是否可用，以及是否可用，直到它已解码足够的数据以播放该位置”的一部分“寻道算法：</p>
<blockquote>
<ol>
<li>media元素在activeSourceBuffers中的每个SourceBuffer对象中查找包含新播放位置的媒体段。TimeMedn中HTMLChiaElement.buffered属性当前值中的任何位置都具有为该位置缓冲的所有必要媒体段。</li>
</ol>
</blockquote>
<p> 如果新的播放位置不在HTMLMediaElement.buffered的任何TimeRange中</p>
<p>1.1如果HTMLMediaElement.readyState属性大于HAVE_METADATA，则将HTMLMediaElement.readyState属性设置为HAVE_METADATA。</p>
<blockquote>
<p>根据HTMLMediaElement就绪状态[HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<p>1.2.media元素一直等到appendBuffer（）调用导致编码的帧处理算法将HTMLMediaElement.readyState属性设置为大于HAVE_METADATA的值。</p>
<blockquote>
<p>Web应用程序可以使用buffered和HTMLMediaElement.buffered来确定媒体元素恢复播放所需的内容。</p>
</blockquote>
<p>否则</p>
<p>Continue</p>
<blockquote>
<p>如果readyState属性为“已结束”且新播放位置在当前HTMLMediaElement.buffered中的TimeRange内，则即使当前选定或启用的一个或多个轨道缓冲区的最大范围结束时间戳较小，搜索操作也必须在此处继续完成比新的播放位置。只有当readyState“结束”时缓冲中的逻辑才会发生这种情况。</p>
</blockquote>
<p>2.媒体元素重置所有解码器并用来自适当初始化段的数据初始化每个解码器。</p>
<p>3.媒体元件将来自活动轨道缓冲器的编码帧从新播放位置之前的最接近的随机访问点开始馈送到解码器。</p>
<p>4.在“等待稳定状态”步骤中恢复搜索算法</p>
<h4 id="a2-44">2.4.4 SourceBuffer监控</h4>

<p>在播放期间定期运行以下步骤，以确保activeSourceBuffers中的所有SourceBuffer对象都具有足够的数据以确保不间断的播放。对activeSourceBuffers的更改也会导致这些步骤运行，因为它们会影响触发状态转换的条件</p>
<p>具有足够的数据以确保不间断的回放是一种特定于实现的条件，其中UA确定它当前具有足够的数据来播放该呈现而不会拖延一段有意义的时间。不断评估此条件以确定何时将媒体元素转换为HAVE_ENOUGH_DATA就绪状态和从HAVE_ENOUGH_DATA就绪状态转换出来。这些转换指示UA何时认为其具有足够的数据缓冲或分别需要更多数据</p>
<blockquote>
<p>实现可以选择使用缓冲的字节，时间缓冲，附加速率或它认为适合的任何其他度量来确定何时具有足够的数据。使用的指标可能会在播放期间发生变化，因此Web应用程序应仅依赖HTMLMediaElement.readyState的值来确定是否需要更多数据。<br>当媒体元素需要更多数据时，UA应尽早将其从HAVE_ENOUGH_DATA转换为HAVE_FUTURE_DATA，以使Web应用程序能够响应而不会导致播放中断。例如，当当前播放位置在缓冲数据结束之前500ms时转换为应用程序提供大约500ms以在播放停顿之前附加更多数据。</p>
</blockquote>
<p>如果HTMLMediaElement.readyState属性等于HAVE_NOTHING：</p>
<p>中止这些步骤。</p>
<p>如果 HTMLMediaElement.buffered不包含当前播放位置的TimeRange：</p>
<p>1.将HTMLMediaElement.readyState属性设置为HAVE_METADATA。</p>
<blockquote>
<p>根据HTMLMediaElement就绪状态[HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<p>2.中止这些步骤。</p>
<p>如果HTMLMediaElement.buffered包含一个TimeRange，它包含当前播放位置和足够的数据以确保不间断播放：</p>
<p>1将HTMLMediaElement.readyState属性设置为HAVE_ENOUGH_DATA。</p>
<blockquote>
<p>根据HTMLMediaElement就绪状态[HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件</p>
</blockquote>
<p>2.如果先前通过转换到HAVE_CURRENT_DATA暂停播放，则此时可以恢复播放。</p>
<p>3.中止这些步骤。</p>
<p>如果HTMLMediaElement.buffered包含一个TimeRange，其中包含当前播放位置和超出当前播放位置的时间，然后运行以下步骤</p>
<p>1.将HTMLMediaElement.readyState属性设置为HAVE_FUTURE_DATA。</p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<p>2.Playback如果之前因过渡到HAVE_CURRENT_DATA而暂停，则可能会在此时恢复。</p>
<p>3.中止这些步骤。</p>
<p>如果HTMLMediaElement.buffered包含一个TimeRange，它以当前播放位置结束，并且没有覆盖当前位置之后的时间范围：</p>
<p>1.将HTMLMediaElement.readyState属性设置为HAVE_CURRENT_DATA</p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<p>Playback此时暂停，因为媒体元素没有足够的数据来推进媒体时间线</p>
<p>3.中止这些步骤。</p>
<h4 id="a2-45">2.4.5更改选定/启用的跟踪状态</h4>

<p>在播放期间，如果所选视频轨道，启用的音频轨道或文本轨道模式发生变化，则需要更新activeSourceBuffers。当发生这些变化中的一个或多个时，需要遵循以下步骤</p>
<p>如果选定的视频轨道更改，然后运行以下步骤：</p>
<p>1.如果与先前选择的视频轨道关联的SourceBuffer未与任何其他启用的轨道关联，请运行以下步骤：</p>
<p>1.1从activeSourceBuffers中删除SourceBuffer。 </p>
<p>1.2Queue在activeSourceBuffers 上触发名为removedourcebuffer的简单事件的任务</p>
<p>2.如果与新选择的视频轨道关联的SourceBuffer尚未在activeSourceBuffers中，请运行以下步骤：</p>
<p>2.1将SourceBuffer添加到activeSourceBuffers</p>
<p>2.2Queue一个任务，在activeSourceBuffers中触发一个名为addsourcebuffer的简单事件</p>
<p>如果音频轨道被禁用且与此轨道关联的SourceBuffer未与任何其他启用或选定的轨道相关联，则执行以下步骤：</p>
<p>1从activeSourceBuffers Queue移除与音频轨道关联的SourceBuffer，以触发一个简单事件</p>
<p>2.在activeSourceBuffers 上命名removedourcebuffer</p>
<p>如果音频轨道已启用且与此轨道关联的SourceBuffer尚未在activeSourceBuffers中，则执行以下步骤：</p>
<p>1.将与音频轨道关联的SourceBuffer添加到activeSourceBuffers </p>
<p>2.Queue任务以触发简单事件在activeSourceBuffers 中命名为addsourcebuffer</p>
<p>如果文本跟踪模式变为“禁用”且与此轨道关联的SourceBuffer未与任何其他启用或选定的轨道关联，则运行以下步骤：</p>
<p>1.从activeSourceBuffers 中删除与文本轨道关联的SourceBuffer</p>
<p>2.将任务队列化以在activeSourceBuffers中触发名为removedourcebuffer的简单事件</p>
<p>如果文本跟踪模式变为“显示”或“隐藏”且与此轨道关联的SourceBuffer尚未在activeSourceBuffers中，则执行以下步骤：</p>
<p>1.将与文本轨道关联的SourceBuffer添加到activeSourceBuffers </p>
<p>2.Queue任务以触发在activeSourceBuffers中名为addsourcebuffer的简单事件</p>
<h4 id="a2-46">2.4.6持续时间的变化</h4>

<p>当持续时间需要更改为新的持续时间时，请执行以下步骤。</p>
<p>1.如果持续时间的当前值等于新的持续时间，则返回。</p>
<p>2.如果新持续时间小于sourceBuffers中所有SourceBuffer对象的任何缓冲编码帧的最高显示时间戳，则抛出InvalidStateError异常并中止这些步骤。</p>
<blockquote>
<p>不允许截断当前缓冲媒体的持续时间减少。如果需要截断，请在更新持续时间之前使用remove（）减少缓冲范围。</p>
</blockquote>
<p>3.让最高结束时间为源缓冲区中所有SourceBuffer对象上所有轨道缓冲区的最大轨道缓冲区范围结束时间。</p>
<p>4.如果新的持续时间小于最高结束时间，那么</p>
<blockquote>
<p>出现这种情况是因为编码帧移除算法保留了在移除范围开始之前开始的编码帧</p>
</blockquote>
<p>4.1将新持续时间更新为最高结束时间。</p>
<p>5.更新持续时间到新的持续时</p>
<p>6.将媒体持续时间更新为新持续时间并运行HTMLMediaElement持续时间更改算法</p>
<h4 id="a2-47">2.4.7流结束算法</h4>

<p>当应用程序通过endOfStream（）调用发出流的结束信号或算法需要发出解码错误信号时，将调用此算法。此算法采用一个错误参数，指示是否将发出错误信号。</p>
<p>1.将readyState属性值更改为“已结束”</p>
<p>2.Queue一个任务，用于在MediaSource上触发一个名为sourceended的简单事件。</p>
<p>3.如果未设置错误</p>
<p>3.1运行持续时间更改算法，并将新持续时间设置为跨源所有SourceBuffer对象中所有轨道缓冲区的最大跟踪缓冲区范围结束时间。</p>
<blockquote>
<p>这允许持续时间适当地反映附加媒体段的结束。例如，如果持续时间明确设置为10秒，并且在调用endOfStream（）之前仅追加0到5秒的媒体段，则持续时间将更新为5秒。</p>
</blockquote>
<p>3.2通知媒体元素它现在拥有所有媒体数据。</p>
<p>4.如果错误设置为“network”</p>
<p>4.1如果HTMLMediaElement.readyState属性等于HAVE_NOTHING </p>
<p>运行“如果根本无法获取媒体数据，由于网络错误，导致UA放弃尝试获取资源”步骤资源获取算法的媒体数据处理步骤列表。</p>
<p>4.2如果HTMLMediaElement.readyState属性大于HAVE_NOTHING </p>
<p>运行“如果在收到某些媒体数据后连接中断，导致UA放弃尝试获取资源”资源获取算法的媒体数据处理步骤步骤列表。</p>
<p>5.如果错误设置为“decode”</p>
<p>5.1如果HTMLMediaElement.readyState属性等于HAVE_NOTHING </p>
<p>运行“如果可以获取媒体数据但是通过检查发现它是不支持的格式，或者根本不能渲染”步骤资源获取算法的媒体数据处理步骤列表。 </p>
<p>5.2如果HTMLMediaElement.readyState属性大于HAVE_NOTHING </p>
<p>运行，则媒体数据是资源获取算法的媒体数据处理步骤列表的损坏步骤。</p>
<h3 id="a3">3. SourceBuffer对象</h3>
<figure class="highlight javascript"><figcaption><span>enum AppendMode &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    <span class="string">&quot;segments&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sequence&quot;</span></span><br><span class="line">&#125;;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">segments:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">媒体段中的时间戳确定编码帧在演示中的放置位置。媒体片段可以按任何顺序附加</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sequence:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">媒体片段将被视为与时间相邻，与媒体片段中的时间戳无关。新媒体片段中的编码帧将紧接在先前媒体片段中的编码帧之后。如果需要新的偏移量以使新媒体段与先前媒体段相邻，则将更新timestampOffset属性。在“序列”模式下设置timestampOffset属性允许将媒体段放置在时间线中的特定位置，而不需要知道媒体段中的时间戳</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line">    interface SourceBuffer : EventTarget &#123;</span><br><span class="line">        attribute AppendMode          mode; </span><br><span class="line">        readonly attribute boolean             updating;</span><br><span class="line">        readonly attribute TimeRanges          buffered;</span><br><span class="line">        attribute double              timestampOffset;</span><br><span class="line">        readonly attribute AudioTrackList      audioTracks;</span><br><span class="line">        readonly attribute VideoTrackList      videoTracks;</span><br><span class="line">        readonly attribute TextTrackList       textTracks;</span><br><span class="line">        attribute double              appendWindowStart;</span><br><span class="line">        attribute unrestricted double appendWindowEnd;</span><br><span class="line">        attribute EventHandler        onupdatestart;</span><br><span class="line">        attribute EventHandler        onupdate;</span><br><span class="line">        attribute EventHandler        onupdateend;</span><br><span class="line">        attribute EventHandler        onerror;</span><br><span class="line">        attribute EventHandler        onabort;</span><br><span class="line">        <span class="keyword">void</span> appendBuffer(BufferSource data);</span><br><span class="line">        <span class="keyword">void</span> abort();</span><br><span class="line">        <span class="keyword">void</span> remove(double start, unrestricted double end);</span><br></pre></td></tr></table></figure>
<h3 id="a3-1">3.1. 属性</h3>
<h5>mode of type AppendMode:</h5>

<p>控制如何处理媒体片段序列。创建对象后，此属性最初由addSourceBuffer（）设置。</p>
<p>On getting，返回初始值或成功设置的最后一个值。 </p>
<p>在设置中，运行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>2.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.让新模式等于分配给此属性的新值。</p>
<p>4.如果生成timestamps标志等于true，新模式等于“segments”，则抛出TypeError异常并中止这些步骤。</p>
<p>5.如果父媒体源的readyState属性处于“已结束”状态，则执行以下步骤：</p>
<p>5.1将父媒体源的readyState属性设置为“open”</p>
<p>5.2</p>
<p>6.如果append状态等于PARSING_MEDIA_SEGMENT，则抛出InvalidStateError并中止这些步骤。</p>
<p>7.如果新模式等于“sequence”，则将组开始时间戳设置为组结束时间戳。</p>
<p>8.将属性更新为新模式。</p>
<h5>updating of type boolean, readonly</h5>

<p>指示是否仍在处理appendBuffer（）或remove（）操作的异步延续。创建对象时，此属性最初设置为false</p>
<h5>buffered of type TimeRanges, readonly</h5>

<p>指示SourceBuffer中缓冲的TimeRanges。创建对象时，此属性最初设置为空TimeRanges对象。</p>
<p>读取属性时，必须执行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>2.最高结束时间是此SourceBuffer对象管理的所有跟踪缓冲区中最大的跟踪缓冲区范围结束时间。</p>
<p>3.令交集范围等于TimeRange对象，该对象包含从0到最高结束时间的单个范围。</p>
<p>4.对于此SourceBuffer管理的每个音频和视频轨道缓冲区，请运行以下步骤：</p>
<blockquote>
<p>文本跟踪缓冲区包含在上面的最高结束时间的计算中，但在此处从缓冲范围计算中排除。它们不一定是连续的，当其他媒体轨道在相同时间范围内连续时，它们内的任何不连续性也不会触发播放停顿。</p>
</blockquote>
<p>4.1.让跟踪范围等于当前跟踪缓冲区的跟踪缓冲区范围。</p>
<p>4.2.如果readyState为“已结束”，则将轨道范围中最后一个范围的结束时间设置为最高结束时间。</p>
<p>4.3.设新的交叉点范围等于交叉点范围和轨道范围之间的交点。</p>
<p>4.4.用新的交叉点范围替换交叉点范围内的范围。</p>
<p>5.如果交集范围不包含与此属性的当前值完全相同的范围信息，则将此属性的当前值更新为交集范围。</p>
<p>6.返回此属性的当前值</p>
<h5>timestampOffset of type double</h5>

<p>控制应用于附加到此SourceBuffer的后续媒体段内的时间戳的偏移量。 timestampOffset最初设置为0，表示没有应用偏移量。</p>
<p>On getting，返回初始值或成功设置的最后一个值。</p>
<p>在设置中，运行以下步骤：</p>
<p>1.让新时间戳偏移量等于分配给此属性的新值。 </p>
<p>2.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>4.如果父媒体源的readyState属性处于“已结束”状态，则执行以下步骤：</p>
<p>4.1.将父媒体源的readyState属性设置为“open”</p>
<p>4.2.Queue任务以触发名为sourceopen的简单事件at父媒体来源。</p>
<p>5.如果append状态等于PARSING_MEDIA_SEGMENT，则抛出InvalidStateError并中止这些步骤。</p>
<p>6.如果mode属性等于“sequence”，则将组开始时间戳设置为新的时间戳偏移量。</p>
<p>7.将属性更新为新的时间戳偏移量。</p>
<h5>audioTracks of type AudioTrackList, readonly</h5>

<p>此对象创建的AudioTrack对象列表。</p>
<h5>videoTracks of type VideoTrackList, readonly</h5>

<p>此对象创建的VideoTrack对象列表。 </p>
<h5>textTracks of type TextTrackList, readonly</h5>

<p>此对象创建的TextTrack对象列表。</p>
<h5>appendWindowStart of type double</h5>

<p>附加窗口开始的显示时间戳。该属性最初设置为演示开始时间。</p>
<p>On getting，返回初始值或成功设置的最后一个值。</p>
<p>在设置中，运行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>2.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤.</p>
<p>3.如果新值小于0或大于或等于appendWindowEnd，则抛出TypeError异常并中止这些步骤。</p>
<p>4.将属性更新为新值。</p>
<h5>appendWindowEnd of type unrestricted double</h5>

<p>追加窗口结束的显示时间戳。此属性最初设置为正无穷大。</p>
<p>On getting，返回初始值或成功设置的最后一个值。 </p>
<p>在设置中，运行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>2.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.如果新值等于NaN，则抛出TypeError并中止这些步骤。</p>
<p>4.如果新值小于或等于appendWindowStart，则抛出TypeError异常并中止这些步骤。</p>
<p>5.将属性更新为新值。</p>
<h5>onupdatestart of type EventHandler</h5>

<p>updatestart事件的事件处理程序。 </p>
<h5>onupdate of type EventHandler</h5>

<p> update事件的事件处理程序。 </p>
<h5>onupdateend of type EventHandler</h5>

<p>updateend事件的事件处理程序。 </p>
<h5>onerror of type EventHandler</h5>

<p>error事件的事件处理程序。 </p>
<h5>onabort of type EventHandler</h5>

<p>abort事件的事件处理程序。 </p>
<h3 id="a3-2">3.2. 方法</h3>
<h5>appendBuffer</h5>

<p>将段数据在BufferSource [WEBIDL]中追加到源缓冲区。</p>
<p>data: BufferSource</p>
<p>Return type: void</p>
<p>调用此方法时，UA会执行以下步骤：</p>
<p>1.运行prepare append算法。</p>
<p>2.将数据添加到输入缓冲区的末尾。</p>
<p>3.将更新属性设置为true。</p>
<p>4.Queue一个任务，在这个SourceBuffer对象上触发一个名为updatestart的简单事件。</p>
<p>5.异步运行缓冲区附加算法。</p>
<h5>abort</h5>

<p>中止当前段并重置段解析器。 </p>
<p>No parameters.</p>
<p>Return type: void</p>
<p>调用此方法时，UA会执行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>2.如果父媒体源的readyState属性未处于“打开”状态，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>3.如果范围删除算法正在运行，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>4.如果更新属性等于true，则执行以下步骤：</p>
<p>4.1.如果缓冲区附加算法正在运行，则中止该算法。 </p>
<p>4.2.将更新属性设置为false。</p>
<p>4.3.Queue一个任务，在这个SourceBuffer对象上触发一个名为abort的简单事件。</p>
<p>4.4.Queue一个任务，在这个SourceBuffer对象上触发一个名为updateend的简单事件。 </p>
<p>5.运行重置解析器状态算法。 </p>
<p>6.将appendWindowStart设置为演示文稿的开始时间。</p>
<p>7.设置appendWindowEnd到正无限。</p>
<h5>remove</h5>

<p> 删除特定时间范围内的媒体。</p>
<p>Parameter: </p>
<p>start: double</p>
<p>删除范围的开始，以演示开始时间为单位的秒数。</p>
<p>end: double 无限制</p>
<p>移除范围的结束，以演示开始时间为单位的秒数。</p>
<p>Return type: void</p>
<p>调用此方法时，UA会执行以下步骤：</p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除此对象，则抛出InvalidStateError异常并中止这些步骤。 </p>
<p>2.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.如果duration等于NaN，则抛出TypeError异常并中止这些步骤。 </p>
<p>4.如果start为负或大于duration，则抛出TypeError异常并中止这些步骤</p>
<p>5.如果end小于或等于start或end等于NaN，则抛出TypeError异常并中止这些步骤。</p>
<p>6.如果父媒体源的readyState属性处于“已结束”状态，则执行以下步骤：</p>
<p>6.1.将父媒体源的readyState属性设置为“open”</p>
<p>6.2.Queue任务以触发名为sourceopen的简单事件at父媒体来源。 </p>
<p>7.运行范围删除算法，将start和end作为删除范围的开始和结束。</p>
<h3 id="a3-3">3.3. Track Buffers</h3>

<p>轨道缓冲器存储单个轨道的轨道描述和编码帧。当初始化段和媒体段附加到SourceBuffer时，轨道缓冲区被更新。 </p>
<p>每个轨道缓冲区具有最后一个解码时间戳变量，该变量存储附加在当前编码帧组中的最后一个编码帧的解码时间戳。最初未设置该变量以指示尚未附加编码帧。 </p>
<p>每个轨道缓冲器具有最后帧持续时间变量，其存储附加在当前编码帧组中的最后编码帧的编码帧持续时间。最初未设置该变量以指示尚未附加编码帧。</p>
<p>每个轨道缓冲区具有最高结束时间戳变量，该变量存储当前编码帧组中附加到该轨道缓冲区的所有编码帧的最高编码帧结束时间戳。最初未设置该变量以指示尚未附加编码帧。</p>
<p>每个跟踪缓冲区都需要一个随机访问点标志变量，用于跟踪跟踪缓冲区是否在等待随机访问点编码帧。该变量最初设置为true，表示在将任何内容添加到轨道缓冲区之前需要随机访问点编码帧。 </p>
<p>每个轨道缓冲区都有一个轨道缓冲区范围变量，表示当前存储在轨道缓冲区中的编码帧占用的显示时间范围。</p>
<blockquote>
<p>对于跟踪缓冲区范围，这些显示时间范围基于呈现时间戳，帧持续时间以及跨多个源缓冲区中的跟踪缓冲区中的编码帧组的潜在编码帧组开始时间。 </p>
</blockquote>
<p>出于规范目的，此信息被视为存储在规范化的TimeRanges对象中。相交的跟踪缓冲区范围用于报告HTMLMediaElement.buffered，因此必须支持HTMLMediaElement.buffered的每个范围内的不间断回放。</p>
<blockquote>
<p>这些编码帧组开始时间与编码帧处理算法中提到的略有不同，因为它们是不连续后所有轨道缓冲区中最早的表示时间戳。不管模式如何，不连续性可以在编码帧处理算法内发生，或者由编码帧移除算法产生。用于确定跟踪缓冲区范围的不相交性的阈值是特定于实现的。例如，为了减少意外的回放停顿，实现可以通过合并由小于目前在该轨道缓冲器中缓冲的最大帧持续时间的2倍的间隙分开的相邻范围来近似编码帧处理算法的不连续性检测逻辑。实现还可以使用编码的帧组开始时间作为跨越多路径SourceBuffer中的轨道缓冲器的范围开始时间，以进一步减少意外的播放停顿。</p>
</blockquote>
<h3 id="a3-4">3.4. Event Summary</h3>

<p>updatestart:</p>
<p>updating从false转换为true。</p>
<p>update</p>
<p>追加或删除已成功完成。updating从true转换为false。</p>
<p>updateend</p>
<p>追加或删除已结束。</p>
<p>error</p>
<p>附加期间发生错误。updating从true转换为false。</p>
<p>abort</p>
<p>通过abort（）调用中止追加或删除。updating从true到false的转换。</p>
<h3 id="a3-5"> 3.5. 算法</h3>
<h4 id="a3-51">3.5.1. 段分析器循环</h4>

<p>所有SourceBuffer对象都有一个内部追加状态变量，用于跟踪高级段解析状态。它最初设置为WAITING_FOR_SEGMENT，并且可以在附加数据时转换为以下状态。</p>
<p>追加状态名称描述:</p>
<p>WAITING_FOR_SEGMENT：等待要追加的初始化段或媒体段的开始。</p>
<p>PARSING_INIT_SEGMENT：目前正在解析初始化段。</p>
<p>PARSING_MEDIA_SEGMENT：目前正在解析媒体片段。</p>
<p>输入缓冲区是一个字节缓冲区，用于在appendBuffer（）调用中保存未解析的字节。创建SourceBuffer对象时，缓冲区为空。 </p>
<p>缓冲区满标志跟踪是否允许appendBuffer（）接受更多字节。创建SourceBuffer对象时将其设置为false，并在添加和删除数据时进行更新。</p>
<p>组启动时间戳变量在“序列”模式下跟踪新编码帧组的起始时间戳。创建SourceBuffer对象时未设置，并且当mode属性等于“sequence”并且设置了timestampOffset属性或运行编码的帧处理算法时更新。 </p>
<p>组结束时间戳变量存储当前编码帧组中所有编码帧的最高编码帧结束时间戳。创建SourceBuffer对象时将其设置为0，并通过编码的帧处理算法进行更新。</p>
<blockquote>
<p>组结束时间戳存储SourceBuffer中所有轨道缓冲区的最高编码帧结束时间戳。因此，在添加时间戳未跨轨道对齐的多路复用段时，应注意设置mode属性。</p>
</blockquote>
<p>生成时间戳标志是一个布尔变量，用于跟踪是否需要为传递给编码帧处理算法的编码帧生成时间戳。创建SourceBuffer对象时，此标志由addSourceBuffer（）设置。 </p>
<p>调用段解析器循环算法时，请运行以下步骤：</p>
<p>1.循环顶部：如果输入缓冲区为空，则跳转到下面需要更多数据步骤。 </p>
<p>2.如果输入缓冲区包含违反SourceBuffer字节流格式规范的字节，则运行追加错误算法并中止此算法。 </p>
<p>3，删除字节流格式规范所说的必须从输入缓冲区的开头忽略的任何字节。 </p>
<p>4.如果append状态等于WAITING_FOR_SEGMENT，则运行以下步骤：</p>
<p>4.1.如果输入缓冲区的开头指示初始化段的开始，则将追加状态设置为PARSING_INIT_SEGMENT。 </p>
<p>4.2.如果输入缓冲区的开头指示媒体段的开始，请将附加状态设置为PARSING_MEDIA_SEGMENT。 </p>
<p>4.3.跳到上面的循环顶部。 </p>
<p>5.如果append状态等于PARSING_INIT_SEGMENT，则运行以下步骤：</p>
<p>5.1.如果输入缓冲区尚未包含完整的初始化段，则跳转到下面需要更多数据步骤。 </p>
<p>5.2.运行初始化段接收算法。 </p>
<p>5.3.从输入缓冲区的开头删除初始化段字节。 </p>
<p>5.4.将状态添加到WAITING_FOR_SEGMENT。</p>
<p>5.5.跳到上面的循环顶部。 </p>
<p>6.如果append状态等于PARSING_MEDIA_SEGMENT，则执行以下步骤：</p>
<p>6.1.如果第一个初始化段接收标志为false，则运行追加错误算法并中止此算法。</p>
<p>6.2.如果输入缓冲区包含一个或多个完整的编码帧，则运行编码帧处理算法。</p>
<blockquote>
<p>编码帧处理算法运行的频率是特定于实现的。当输入缓冲器包含完整媒体段时可以调用编码帧处理算法，或者可以在将完整编码帧添加到输入缓冲器时多次调用它。</p>
</blockquote>
<p>6.3.如果此SourceBuffer已满并且无法接受更多媒体数据，则将buffer full标志设置为true。</p>
<p>6.4.如果输入缓冲区不包含完整的媒体段，则跳转到下面需要更多数据步骤。 </p>
<p>6.5.从输入缓冲区的开头删除媒体段字节。 </p>
<p>6.6.将状态添加到WAITING_FOR_SEGMENT。</p>
<p>6.7.跳到上面的循环顶部。 </p>
<p>7.需要更多数据：将控制权返回给调用算法。</p>
<h4 id="a3-52"> 3.5.2. 重置解析器状态</h4>

<p>当需要重置解析器状态时，运行以下步骤：</p>
<p>1.如果追加状态等于PARSING_MEDIA_SEGMENT并且输入缓冲区包含一些完整的编码帧，则运行编码帧处理算法，直到处理完所有这些完整编码帧。 </p>
<p>2.取消设置所有轨道缓冲区的最后一个解码时间戳。</p>
<p>3.取消设置所有轨道缓冲区的最后一帧持续时间。</p>
<p>4.取消设置所有轨道缓冲区的最高结束时间戳。</p>
<p>5.将所有轨道缓冲区上的需要随机访问点标志设置为true。</p>
<p>6.如果mode属性等于“sequence”，则将组开始时间戳设置为组结束时间戳</p>
<p>7.从输入缓冲区中删除所有字节</p>
<p>8.将状态添加到WAITING_FOR_SEGMENT。</p>
<h4 id="a3-53">3.53. 追加错误算法</h4>

<p>在附加期间发生错误时调用此算法。 </p>
<p>1.运行重置解析器状态算法。</p>
<p>2.将更新属性设置为false。</p>
<p>3.Queue一个任务，在这个SourceBuffer对象上触发一个名为error的简单事件。</p>
<p>4.Queue一个任务，在这个SourceBuffer对象上触发一个名为updateend的简单事件。 </p>
<p>5.运行流算法结束，并将error参数设置为“decode”</p>
<h4 id="a3-54">3.5.4. 准备附加算法</h4>

<p> 当追加操作开始时，运行以下步骤以验证和准备SourceBuffer。 </p>
<p>1.如果已从父媒体源的sourceBuffers属性中删除SourceBuffer，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>2.如果更新属性等于true，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>3.如果HTMLMediaElement.error属性不为null，则抛出InvalidStateError异常并中止这些步骤。</p>
<p>4.如果父媒体源的readyState属性处于“已结束”状态，则执行以下步骤：</p>
<p>4.1.将父媒体源的readyState属性设置为“open”</p>
<p>4.2.Queue任务以触发名为sourceopen的简单事件at父媒体来源。</p>
<p>5.运行编码帧驱逐算法。 </p>
<p>6.如果缓冲区满标志等于true，则抛出QuotaExceededError异常并中止这些步骤。</p>
<blockquote>
<p>这是执行无法驱逐足够数据以容纳附加信号或附加信息过大的信号。 Web应用程序应使用remove（）显式释放空间和/或减小追加的大小。</p>
</blockquote>
<h4 id="a3-55">3.5.5. 缓冲附加算法</h4>

<p>调用appendBuffer（）时，将运行以下步骤来处理附加数据。 </p>
<p>1.运行段解析器循环算法。</p>
<p>2.如果上一步中的段解析器循环算法被中止，则中止该算法。 </p>
<p>3.将更新属性设置为false。</p>
<p>4.Queue一个任务，在这个SourceBuffer对象上触发一个名为update的简单事件。 </p>
<p>5.Queue一个任务，在这个SourceBuffer对象上触发一个名为updateend的简单事件。</p>
<h4 id="a3-56"> 3.5.6. 范围去除</h4>

<p>当调用者需要启动阻止其他SourceBuffer更新的JavaScript可见范围删除操作时，请遵循以下步骤：</p>
<p>1.让start等于删除范围的起始显示时间戳，以演示文稿开始时间为单位，以秒为单位。 </p>
<p>2.结束等于删除范围的结束呈现时间戳，以演示开始时间为单位的秒数。</p>
<p>3.将更新属性设置为true。</p>
<p>4.Queue一个任务，在这个SourceBuffer对象上触发一个名为updatestart的简单事件。</p>
<p>5.将控制权返回给调用者并异步运行其余步骤。</p>
<p>6.运行编码帧删除算法，将start和end作为删除范围的开始和结束。</p>
<p>7.将更新属性设置为false</p>
<p>8.Queue一个任务，在这个SourceBuffer对象上触发一个名为update的简单事件。</p>
<p>9.Queue一个任务，在这个SourceBuffer对象上触发一个名为updateend的简单事件。</p>
<h4 id="a3-57">3.5.7. 收到初始化段</h4>

<p>当段解析器循环成功解析完整的初始化段时，将运行以下步骤：</p>
<p>每个SourceBuffer对象都有一个内部的第一个初始化段接收标志，用于跟踪该算法是否附加和接收了第一个初始化段。当SourceBuffer由下面的算法创建和更新时，此标志设置为false。 </p>
<p>1.如果当前等于NaN，则更新持续时间属性：</p>
<p>1.1.如果初始化段包含持续时间：</p>
<p>运行持续时间更改算法，并将新持续时间设置为初始化段中的持续时间。</p>
<p>1.2.否则：</p>
<p>运行持续时间更改算法，将新持续时间设置为正无穷大。</p>
<p>2.如果初始化段没有音频，视频或文本轨道，则运行追加错误算法并中止这些步骤。 </p>
<p>3.如果第一个初始化段接收标志为true，则运行以下步骤：</p>
<p>3.1.验证以下属性。如果任何检查失败，则运行追加错误算法并中止这些步骤。</p>
<p>音频，视频和文本轨道的数量与第一个初始化段中的相匹配。 </p>
<p>每个轨道的编解码器匹配第一个初始化段中指定的内容。</p>
<p>如果存在单个类型的多个轨道（例如，2个音频轨道），则轨道ID与第一初始化段中的轨道ID匹配。</p>
<p>3.2.将此初始化段中的相应轨道描述添加到每个轨道缓冲区。 </p>
<p>3.3.将所有轨道缓冲区上的需要随机访问点标志设置为true。</p>
<p>4.让活动跟踪标志等于false。</p>
<p>5.如果第一个初始化段接收标志为false，则执行以下步骤</p>
<p>5.1.如果初始化段包含UA不支持的带编解码器的轨道，则运行追加错误算法并中止这些步骤。</p>
<p>5.如果第一个初始化段接收标志为false，则执行以下步骤</p>
<blockquote>
<p>如果未在传递给addSourceBuffer（）的type参数中指定编解码器，则UA可以将此处支持的编解码器视为“不支持”。 例如，MediaSource.isTypeSupported（’video / webm; codecs =“vp8，vorbis”’）可能返回true，但是如果使用’video / webm; codecs =“vp8”’调用addSourceBuffer（）并且出现Vorbis轨道在初始化段中，UA可以使用该步骤来触发解码错误。</p>
</blockquote>
<p>5.2.对于初始化段中的每个音频轨道，请执行以下步骤：</p>
<p>5.2.1.让音频字节流轨道ID成为正在处理的当前轨道的轨道ID。</p>
<p>5.2.2.让音频语言成为此轨道初始化段中指定语言的BCP 47语言标记，如果不存在语言信息，则为空字符串。 </p>
<p>5.2.3.如果音频语言等于’und’BCP 47值，则将空字符串分配给音频语言。</p>
<p>5.2.4.允许音频标签是在此轨道的初始化段中指定的标签，如果没有标签信息，则为空字符串</p>
<p>5.2.5.允许音频种类是在该轨道的初始化段中指定的一系列种类字符串，或者如果没有提供种类信息则在其中具有单个空字符串元素的序列。 </p>
<p>5.2.6.对于音频类型中的每个值，请运行以下步骤：</p>
<p>5.2.6.1.让当前音频类型等于循环迭代的音频种类的值。 </p>
<p>5.2.6.2.让新的音轨成为新的AudioTrack对象。</p>
<p>5.2.6.3.生成唯一ID并将其分配给新音频轨道上的id属性。 </p>
<p>5.2.6.4.将音频语言分配给新音频轨道上的语言属性。 </p>
<p>5.2.6.5.将音频标签分配给新音频轨道上的label属性。</p>
<p>5.2.6.6.将当前音频类型分配给新音频轨道上的kind属性。</p>
<p>5.2.6.7.如果audioTracks.length等于0，则运行以下步骤：</p>
<p>5.2.6.7.1.将新音频轨道上的enabled属性设置为true。 </p>
<p>5.2.6.7.2.将活动跟踪标志设置为true</p>
<p>5.2.6.8.将新音频轨道添加到此SourceBuffer对象上的audioTracks属性。</p>
<blockquote>
<p>这应触发AudioTrackList [HTML51]逻辑，将任务排队，以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且在AudioTrackList对象上使用TrackEvent接口，并将track属性初始化为新音频轨道由此SourceBuffer对象上的audioTracks属性引用。 </p>
</blockquote>
<p>5.2.6.9.将新音轨添加到HTMLMediaElement上的audioTracks属性。 </p>
<blockquote>
<p>这应该触发AudioTrackList [HTML51]逻辑，将任务排队以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为新的音频轨道，at HTMLMediaElement上的audioTracks属性引用的AudioTrackList对象。</p>
</blockquote>
<p>5.2.7.创建一个新的轨道缓冲区来存储该轨道的编码帧。</p>
<p>5.2.8.将此曲目的曲目描述添加到曲目缓冲区。</p>
<p>5.3.对于初始化段中的每个视频轨道，请运行以下步骤 </p>
<p>5.3.1.让视频字节流轨道ID成为正在处理的当前轨道的轨道ID。 </p>
<p>5.3.2.让视频语言成为此轨道初始化段中指定语言的BCP 47语言标记，如果不存在语言信息，则为空字符串。</p>
<p>5.3.3.如果视频语言等于’und’BCP 47值，则将空字符串分配给视频语言。 </p>
<p>5.3.4.允许视频标签是在此轨道的初始化段中指定的标签，如果没有标签信息，则为空字符串。</p>
<p>5.3.5.允许视频种类是在该轨道的初始化段中指定的种类字符串序列，或者如果没有提供种类信息则在其中具有单个空字符串元素的序列</p>
<p>5.3.6.对于视频类型中的每个值，请运行以下步骤：</p>
<p>5.3.6.1.让当前视频类型等于循环迭代的视频种类的值。 </p>
<p>5.3.6.2.让新视频轨道成为新的VideoTrack对象。 </p>
<p>5.3.6.3.生成唯一ID并将其分配给新视频轨道上的id属性。</p>
<p>5.3.6.4.将视频语言分配给新视频轨道上的语言属性。</p>
<p>5.3.6.5.将视频标签分配给新视频轨道上的label属性。</p>
<p>5.3.6.6.将当前视频类型分配给新视频轨道上的kind属性。 </p>
<p>5.3.6.7.如果videoTracks.length等于0，则运行以下步骤：</p>
<p>5.3.6.7.1.将新视频轨道上的selected属性设置为true。 </p>
<p>5.3.6.7.2.将活动跟踪标志设置为true。  </p>
<p>5.3.6.8.将新视频轨添加到此SourceBuffer对象上的videoTracks属性。 </p>
<blockquote>
<p>这应触发VideoTrackList [HTML51]逻辑，将任务排队，以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且在VideoTrackList对象中使用TrackEvent接口，并将track属性初始化为新视频轨道由此SourceBuffer对象上的videoTracks属性引用。</p>
</blockquote>
<p>5.3.6.9.将新视频曲目添加到HTMLMediaElement上的videoTracks属性。</p>
<blockquote>
<p>这应该触发VideoTrackList [HTML51]逻辑，将任务排队以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为新的视频轨道，at HTMLMediaElement上videoTracks属性引用的VideoTrackList对象。</p>
</blockquote>
<p>5.3.7.创建一个新的轨道缓冲区来存储该轨道的编码帧。</p>
<p>5.3.8.将此曲目的曲目描述添加到曲目缓冲区。</p>
<p>5.4.对于初始化段中的每个文本轨道，执行以下步骤：</p>
<p>5.4.1.让文本字节流轨道ID成为正在处理的当前轨道的轨道ID。</p>
<p>5.4.2.允许文本语言为此轨道的初始化段中指定的语言的BCP 47语言标记，如果不存在语言信息，则为空字符串。 </p>
<p>5.4.3.如果文本语言等于’und’BCP 47值，则将空字符串分配给文本语言。 </p>
<p>5.4.4.let text label是在此轨道的初始化段中指定的标签，如果没有标签信息，则为空字符串。</p>
<p>5.4.5.let text types是在此轨道的初始化段中指定的类型字符串序列，或者如果没有提供类型信息则在其中包含单个空字符串元素的序列。 </p>
<p>5.4.6.对于文本类型中的每个值，请运行以下步骤：</p>
<p>5.4.6.1.让当前文本类型等于循环迭代的文本种类的值。</p>
<p>5.4.6.2.让新文本轨道成为新的TextTrack对象。</p>
<p>5.4.6.3.生成唯一ID并将其分配给新文本轨道上的id属性。</p>
<p>5.4.6.4.将文本语言分配给新文本轨道上的语言属性。</p>
<p>5.4.6.5.将文本标签分配给新文本轨道上的label属性。</p>
<p>5.4.6.6.将当前文本类型分配给新文本轨道上的kind属性。</p>
<p>5.4.6.7.使用初始化段中的相应信息填充新文本轨道上的其余属性。</p>
<p>5.4.6.8.如果新文本轨道上的mode属性等于“shows”或“hidden”，则将active track flag设置为true。 </p>
<p>5.4.6.9.将新文本轨道添加到此SourceBuffer对象上的textTracks属性。</p>
<blockquote>
<p>这应该触发TextTrackList [HTML51]逻辑，将任务排队，以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且在TextTrackList对象中使用TrackEvent接口，并将track属性初始化为新文本轨道由此SourceBuffer对象上的textTracks属性引用。</p>
</blockquote>
<p>5.4.6.10.将新文本轨道添加到HTMLMediaElement上的textTracks属性。</p>
<blockquote>
<p>这应该触发TextTrackList [HTML51]逻辑，将任务排队以触发名为addtrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为新文本轨道，at HTMLMediaElement上的textTracks属性引用的TextTrackList对象。 </p>
</blockquote>
<p>5.4.7.创建一个新的轨道缓冲区来存储该轨道的编码帧。</p>
<p>5.4.8.将此曲目的曲目描述添加到曲目缓冲区。</p>
<p>5.5.如果活动跟踪标志等于true，则运行以下步骤：</p>
<p>5.5.1.将此SourceBuffer添加到activeSourceBuffers。</p>
<p>5.5.2.Queue一个任务，在activeSourceBuffers</p>
<p>5.6.中触发一个名为addsourcebuffer的简单事件。将第一个初始化段接收标志设置为true。</p>
<p>6.如果HTMLMediaElement.readyState属性为HAVE_NOTHING，则运行以下步骤：</p>
<p>6.1.如果sourceBuffers中的一个或多个对象将第一个初始化段接收标志设置为false，则中止这些步骤。 </p>
<p>6.2.将HTMLMediaElement.readyState属性设置为HAVE_METADATA。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。此特定转换应触发HTMLMediaElement逻辑，以对任务进行排队，以在media元素处触发名为loadedmetadata的简单事件。 </p>
</blockquote>
<p>7.如果活动跟踪标志等于true且HTMLMediaElement.readyState属性大于HAVE_CURRENT_DATA，则将HTMLMediaElement.readyState属性设置为HAVE_METADATA。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<h4 id="a3-58"> 3.5.8. 编码帧处理</h4>

<p>当段解析器循环解析完整的编码帧后，运行以下步骤：</p>
<p>1.对于媒体段中的每个编码帧，运行以下步骤：</p>
<p>1.1.Loop Top：</p>
<p>如果生成timestamps标志等于true：</p>
<p>Let presentation时间戳等于0. </p>
<p>令解码时间戳等于0. </p>
<p>否则：</p>
<p>表示时间戳是编码帧的显示时间戳的双精度浮点表示，以秒为单位。</p>
<blockquote>
<p>可能需要特殊处理来确定定时文本帧的呈现和解码时间戳，因为该信息可能未明确地存在于基础格式中或者可能取决于帧的顺序。某些元数据文本轨道（如MPEG2</p>
</blockquote>
<p>令解码时间戳是编码帧的解码时间戳的双精度浮点表示，以秒为单位。</p>
<blockquote>
<p>Implementations不必在双精度浮点表示中内部存储时间戳。此处使用此表示形式，因为它是HTML规范中时间戳的表示。这里的目的是使行为清晰，而不会给算法增加不必要的复杂性，以处理添加timestampOffset可能导致字节流格式使用的基础时间戳表示中的时间戳翻转的事实。实现可以使用他们希望的任何内部时间戳表示，但是添加timestampOffset的行为应该与使用双精度浮点表示时的情况类似。</p>
</blockquote>
<p>1.2.设帧持续时间是编码帧的持续时间的双精度浮点表示，以秒为单位。</p>
<p>1.3.如果mode等于“sequence”并且设置了group start timestamp，则运行以下步骤：</p>
<p>1.3.1.set timestampOffset等于group start timestamp - presentation timestamp。 </p>
<p>1.3.2.设置组结束时间戳等于组开始时间戳。 </p>
<p>1.3.3.将所有轨道缓冲区上的需要随机访问点标志设置为true。 </p>
<p>1.3.4.Unset组开始时间戳。 </p>
<p>1.4.如果timestampOffset不为0，则运行以下步骤：</p>
<p>1.4.1.将timestampOffset添加到演示文稿时间戳。 </p>
<p>1.4.2.将timestampOffset添加到解码时间戳。</p>
<p>1.5.让跟踪缓冲区等于编码帧将被添加到的轨道缓冲区。</p>
<p>1.6.如果设置了跟踪缓冲区的最后一个解码时间戳并且解码时间戳小于上一个解码时间戳：</p>
<p>or</p>
<p>如果设置了跟踪缓冲区的最后一个解码时间戳，并且解码时间戳和最后一个解码时间戳之间的差异大于最后帧持续时间的2倍：</p>
<p>–如果mode等于“segments”：</p>
<p>—-将组结束时间戳设置为显示时间戳。 </p>
<p>–如果mode等于“sequence”：</p>
<p>—-将组开始时间戳设置为等于组结束时间戳。 </p>
<p>–取消设置所有轨道缓冲区的最后一个解码时间戳。 </p>
<p>–取消设置所有轨道缓冲区的最后一帧持续时间。 </p>
<p>–取消设置所有轨道缓冲区的最高结束时间戳。 </p>
<p>–将所有轨道缓冲区上的需要随机访问点标志设置为true。 </p>
<p>–跳到上面的Loop Top步骤重新开始处理当前编码帧。</p>
<p>否则：</p>
<p>–继续。</p>
<p>1.7.令帧结束时间戳等于呈现时间戳和帧持续时间的总和。</p>
<p>1.8.如果表示时间戳小于appendWindowStart，则将需要随机访问点标志设置为true，删除编码帧，并跳转到循环顶部以开始处理下一个编码帧。</p>
<blockquote>
<p>某些实现可能会选择收集其中一些编码帧，其显示时间戳小于appendWindowStart，并使用它们在第一个编码帧生成拼接，该拼接帧的显示时间戳大于或等于appendWindowStart，即使该帧不是随机接入点。支持这一点需要多个解码器或比实时解码更快，所以现在这种行为不是规范要求。</p>
</blockquote>
<p>1.9.如果帧结束时间戳大于appendWindowEnd，则将需要随机访问点标志设置为true，删除编码帧，并跳转到循环顶部以开始处理下一个编码帧。</p>
<blockquote>
<p>一些实现可以选择收集编码帧，其显示时间戳小于appendWindowEnd，帧结束时间戳大于appendWindowEnd，并且使用它们在收集时在追加窗口内的收集的编码帧的部分上生成拼接，并且开始部分后来处理的帧只与收集的编码帧的末尾部分重叠。支持这一点需要多个解码器或比实时解码更快，所以现在这种行为不是规范要求。结合收集跨越appendWindowStart的编码帧，实现可以因此支持无间隙音频拼接。</p>
</blockquote>
<p>1.10.如果轨道缓冲区上需要随机访问点标志等于true，则执行以下步骤：</p>
<p>–如果编码帧不是随机访问点，则删除编码帧并跳转到循环顶部以开始处理下一个编码帧。</p>
<p>–将轨道缓冲区上的需要随机访问点标志设置为false。</p>
<p>1.11.Let拼接音频帧是用于保存音频拼接信息的未设置变量</p>
<p>1.12.Let拼接定时文本帧是用于保存定时文本拼接信息的未设置变量</p>
<p>1.13.如果未设置跟踪缓冲区的最后一个解码时间戳并且呈现时间戳落在跟踪缓冲区中编码帧的呈现间隔内，则执行以下步骤：</p>
<p>1.13.1.将重叠帧作为跟踪缓冲区中与上述条件匹配的编码帧。</p>
<p>1.13.2.如果轨道缓冲区包含音频编码帧：</p>
<p>–运行音频拼接帧算法，如果返回拼接帧，则将其分配给拼接音频帧。</p>
<p>如果轨道缓冲区包含视频编码帧：</p>
<p>–删除窗口时间戳等于重叠帧显示时间戳加1微秒。 </p>
<p>–如果演示文稿时间戳小于删除窗口时间戳，则从轨道缓冲区中删除重叠帧。</p>
<blockquote>
<p>这是为了补偿在双精度浮点数和有理数之间来回转换时出现的帧时间戳计算中的微小错误。只要在现有帧的开始时间的1微秒内，该容差允许帧替换现有帧。在现有帧之前略微出现的帧由下面的删除步骤处理。</p>
</blockquote>
<p>如果轨道缓冲区包含定时文本编码帧：</p>
<p>–运行文本拼接帧算法，如果返回拼接帧，则将其分配给拼接定时文本帧。</p>
<p>1.14.删除轨道缓冲区中的现有编码帧：</p>
<p>1.14.1.如果未设置轨道缓冲区的最高结束时间戳：</p>
<p>–从轨道缓冲区中删除所有具有大于或等于显示时间戳且小于帧结束时间戳的显示时间戳的编码帧。</p>
<p>1.14.2.如果设置了跟踪缓冲区的最高结束时间戳并且小于或等于显示时间戳：</p>
<p>–从轨道缓冲区中删除所有具有大于或等于最高结束时间戳且小于帧结束时间戳的表示时间戳的编码帧</p>
<p>1.15.删除所有可能的通过从在前两个步骤中移除的那些帧与在那些移除的帧之后的下一个随机访问点之间的轨道缓冲器中移除所有编码帧，解码对前两个步骤中移除的编码帧的依赖性。</p>
<blockquote>
<p>删除所有编码帧，直到下一个随机访问点是解码依赖关系的保守估计，因为它假设删除的帧和下一个随机访问点之间的所有帧都取决于被删除的帧。</p>
</blockquote>
<p>1.16.如果设置了拼接音频帧：</p>
<p>–将拼接音频帧添加到轨道缓冲区。</p>
<p>如果设置了拼接定时文本框：</p>
<p>–将拼接定时文本框添加到轨道缓冲区。</p>
<p>otherwise：</p>
<p>–将带有演示时间戳，解码时间戳和帧持续时间的编码帧添加到轨道缓冲区。</p>
<p>1.17.设置跟踪缓冲区的最后解码时间戳以解码时间戳。</p>
<p>1.18.将轨道缓冲区的最后帧持续时间设置为帧持续时间。</p>
<p>1.19.如果未设置跟踪缓冲区的最高结束时间戳或帧结束时间戳大于最高结束时间戳，则将跟踪缓冲区的最高结束时间戳设置为帧结束时间戳。</p>
<blockquote>
<p>需要大于检查，因为编码帧之间的双向预测可能导致呈现时间戳不单调增加，即使解码时间戳单调增加。</p>
</blockquote>
<p>1.20.如果帧结束时间戳大于组结束时间戳，则将组结束时间戳设置为等于帧结束时间戳。</p>
<p>1.21.如果生成timestamps标志等于true，则将timestampOffset设置为等于帧结束时间戳。</p>
<p>2.如果HTMLMediaElement.readyState属性为HAVE_METADATA，并且新编码的帧导致HTMLMediaElement.buffered具有当前播放位置的TimeRange，则将HTMLMediaElement.readyState属性设置为HAVE_CURRENT_DATA。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。 </p>
</blockquote>
<p>3.如果HTMLMediaElement.readyState属性为HAVE_CURRENT_DATA，并且新编码的帧导致HTMLMediaElement.buffered具有包含当前播放位置和超出当前播放位置的时间的TimeRange，则将HTMLMediaElement.readyState属性设置为HAVE_FUTURE_DATA。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。 </p>
</blockquote>
<p>4.如果HTMLMediaElement.readyState属性为HAVE_FUTURE_DATA，并且新编码的帧导致HTMLMediaElement.buffered具有包含当前播放位置的TimeRange和足以确保不间断播放的数据，则将HTMLMediaElement.readyState属性设置为HAVE_ENOUGH_DATA。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。</p>
</blockquote>
<p>5.如果媒体段包含超出当前持续时间的数据，则运行持续时间更改算法，并将新持续时间设置为当前持续时间和组结束时间戳的最大值。</p>
<h4 id="a3-59">3.5.9编码帧删除算法</h4>

<p>当需要从SourceBuffer中删除特定时间范围的编码帧时，请遵循以下步骤：</p>
<p>1.让start为删除范围的起始显示时间戳。</p>
<p>2.Let end是删除范围的结束演示时间戳。</p>
<p>3.对于此源缓冲区中的每个跟踪缓冲区，请运行以下步骤：</p>
<p>3.1.let remove endstamp是duration </p>
<p>3.2.的当前值如果此跟踪缓冲区的随机访问点时间戳大于或等于end，则更新删除到该随机访问点时间戳的结束时间戳。 </p>
<blockquote>
<p>随机访问点时间戳可以跨轨道不同，因为轨道内编码帧之间的依赖关系通常不同于另一轨道中的依赖关系。 </p>
</blockquote>
<p>3.3.从此跟踪缓冲区中删除包含大于或等于start且小于remove end timestamp的起始时间戳的所有媒体数据。</p>
<p>3.3.1.对于每个删除的帧，如果帧的解码时间戳等于帧轨道的最后一个解码时间戳，请运行以下步骤</p>
<p>If mode equals “segments”:</p>
<p>–将组结束时间戳设置为显示时间戳。 </p>
<p>如果mode等于“sequence”：</p>
<p>–将组开始时间戳设置为等于组结束时间戳。 </p>
<p>3.3.3.取消设置所有轨道缓冲区的最后一帧持续时间。</p>
<p>3.3.4.取消设置所有轨道缓冲区的最高结束时间戳。 </p>
<p>3.3.5.将所有轨道缓冲区上的需要随机访问点标志设置为true。</p>
<p>3.4.删除在上一步骤中删除的编码帧上的所有可能的解码依赖性，方法是删除在前一步骤中删除的帧与删除帧之后的下一个随机访问点之间的此轨道缓冲区中的所有编码帧。</p>
<blockquote>
<p>删除所有编码帧直到下一个随机访问点是解码依赖性的保守估计，因为它假设移除的帧与下一个随机访问点之间的所有帧都取决于被移除的帧。 </p>
</blockquote>
<p>3.5.如果此对象位于activeSourceBuffers中，则当前播放位置大于或等于start并小于remove end timestamp，并且HTMLMediaElement.readyState大于HAVE_METADATA，然后将HTMLMediaElement.readyState属性设置为HAVE_METADATA并停止播放。 </p>
<blockquote>
<p>Per HTMLMediaElement ready states [HTML51]逻辑，HTMLMediaElement.readyState更改可能会触发HTMLMediaElement上的事件。<br>发生此转换是因为当前位置的媒体数据已被删除。在附加当前播放位置的媒体或所选/启用的曲目改变之前，播放无法进行。 </p>
</blockquote>
<p>4.如果缓冲区满标志等于true，并且此对象已准备好接受更多字节，则将缓冲区满标志设置为false。</p>
<h4 id="a3-510"> 3.5.10. 编码帧驱逐算法</h4>

<p>运行此算法以在附加新数据时释放此源缓冲区中的空间。</p>
<p>1.让新数据等于即将附加到此SourceBuffer的数据。</p>
<p>2.如果缓冲区满标志等于false，则中止这些步骤。</p>
<p>3.让删除范围等于可以从演示文稿中逐出的演示时间范围列表，以便为新数据腾出空间。</p>
<blockquote>
<p>Implementations可能使用不同的方法来选择删除范围，因此Web应用程序不应该依赖于特定的行为。 Web应用程序可以使用buffered属性来观察缓冲数据的某些部分是否已被驱逐。 </p>
</blockquote>
<p>4.对于移除范围中的每个范围，运行编码帧移除算法，其开始和结束分别等于移除范围开始和结束时间戳。</p>
<h4 id="a3-511">3.5.11. 音频拼接帧算法</h4>

<p>当编码帧处理算法需要为两个重叠的音频编码帧生成拼接帧时，请遵循以下步骤：</p>
<p>1.让轨道缓冲区成为将包含拼接的轨道缓冲区。</p>
<p>2.让新的编码帧成为新的编码帧，将其添加到轨道缓冲区，从而触发了对拼接的需求。</p>
<p>3.令演示时间戳是新编码帧的表示时间戳</p>
<p>4.Let解码时间戳是新编码帧的解码时间戳。</p>
<p>5.令帧持续时间是新编码帧的编码帧持续时间。</p>
<p>6.令重叠帧为轨道缓冲区中的编码帧，其呈现间隔包含呈现时间戳。</p>
<p>7.根据重叠帧中音频的采样率，更新演示时间戳并将时间戳解码为最近的音频采样时间戳。如果时间戳与两个音频采样时间戳等距，则使用更高的时间戳（例如，floor（x * sample_rate + 0.5）/ sample_rate）。</p>
<blockquote>
<p>例如，给定以下值：重叠帧的显示时间戳等于10. 重叠帧的采样率等于8000 Hz .显示时间戳等于10.01255 .decode timestamp等于10.01255 .presentation timestamp和decode timestamp更新为10.0125 10.01255比10 + 101/8000（10.012625）更接近10 + 100/8000（10.0125）</p>
</blockquote>
<p>8.如果UA不支持交叉淡化，则执行以下步骤：</p>
<p>8.1.从轨道缓冲区中删除重叠帧</p>
<p>8.2.使用以下属性添加静音帧以跟踪缓冲区：</p>
<p>–将显示时间戳设置为重叠的帧显示时间戳。 </p>
<p>–解码时间戳设置为重叠帧解码时间戳。 </p>
<p>–编码帧持续时间设置为显示时间戳和重叠帧显示时间戳之间的差异。 </p>
<blockquote>
<p>某些实现可能会对插入静音两侧的静音到编码帧应用淡入淡出，以使转换不那么刺耳。</p>
</blockquote>
<p>8.3.返回呼叫者而不提供拼接框架。</p>
<blockquote>
<p>这是为了允许将新的编码帧添加到轨道缓冲区，就好像重叠帧没有在轨道缓冲区中开始一样。</p>
</blockquote>
<p>9.让帧结束时间戳等于表示时间戳和帧持续时间的总和。</p>
<p>10.let splice end timestamp等于表示时间戳和5毫秒的拼接持续时间之和。 </p>
<p>11.淡出编码帧等于重叠帧以及轨道缓冲区中任何其他帧，其显示时间戳大于显示时间戳并小于拼接结束时间戳。</p>
<p>12.从轨道缓冲区中删除淡出编码帧中包含的所有帧。 </p>
<p>13.返回具有以下属性的拼接框架</p>
<p>–演示文稿时间戳设置为重叠的框架演示文稿时间戳。</p>
<p>–解码时间戳设置为重叠帧解码时间戳。</p>
<p>–编码帧持续时间设置为帧结束时间戳和重叠帧显示时间戳之间的差异。</p>
<p>–淡出编码帧等于淡出编码帧。</p>
<p>–淡入编码帧等于新编码帧。</p>
<blockquote>
<p>如果新编码帧的持续时间小于5毫秒，则需要在新编码帧之后附加的编码帧才能正确渲染拼接。</p>
</blockquote>
<p>–拼接时间戳等于表示时间戳。</p>
<blockquote>
<p>有关如何渲染此拼接帧的详细信息，请参阅音频拼接渲染算法</p>
</blockquote>
<h4 id="a3-512">3.5.12. 音频拼接渲染算法</h4>

<p>当由音频拼接帧算法生成的拼接帧需要由媒体元素渲染时，运行以下步骤：</p>
<p>1.让淡出编码的帧是在拼接期间淡出的编码帧。</p>
<p>2.让编码帧中的淡入淡出是在拼接期间淡入的编码帧。</p>
<p>3.Let presentation timestamp是淡出编码帧中第一个编码帧的表示时间戳。</p>
<p>4.令结束时间戳是呈现时间戳和编码帧中淡入淡出中最后一帧的编码帧持续时间的总和。</p>
<p>5.let splice timestamp是拼接开始的演示时间戳。这与编码帧中淡入淡出中第一帧的呈现时间戳相对应。</p>
<p>6.让splice结束时间戳等于拼接时间戳加上5毫秒。</p>
<p>7.淡出样本是通过解码淡出编码帧产生的样本。</p>
<p>8.Trim淡出样本，使其仅包含演示时间戳和拼接结束时间戳之间的样本。</p>
<p>9.淡化样本是通过解码编码帧中的淡入淡出而产生的样本。</p>
<p>10.如果淡出样本并且淡入样本没有共同的采样率和通道布局，则转换淡出样本并将样本淡入到常见的采样率和通道布局。</p>
<p>11.让输出样本成为保存输出样本的缓冲区。</p>
<p>12.对淡出样本中的拼接时间戳和拼接结束时间戳之间的样本应用线性增益淡出，起始增益为1，结束增益为0。</p>
<p>13.对样本中淡入淡出的拼接时间戳和拼接结束时间戳之间的样本应用线性增益淡入，起始增益为0，结束增益为1。</p>
<p>14.在演示时间戳之间复制样本，以将时间戳从淡出样本拼接到输出样本中。</p>
<p>15.对于拼接时间戳和拼接结束时间戳之间的每个样本，计算淡出样本的样本和淡入样本中的相应样本的总和，并将结果存储在输出样本中。</p>
<p>16.将样本淡入到输出样本的拼接结束时间戳到结束时间戳之间的样本复制。</p>
<p>17.渲染输出样本。</p>
<blockquote>
<p>以下是此算法的图形表示。<br><img src="https://w3c.github.io/media-source/audio_splice.png" alt=""></p>
</blockquote>
<h4 id="a3-513">3.5.13. 文本拼接帧算法</h4>

<p>当编码帧处理算法需要为两个重叠的定时文本编码帧生成拼接帧时，请遵循以下步骤：</p>
<p>1.让跟踪缓冲区成为包含接头的跟踪缓冲区。</p>
<p>2.让新的编码帧成为新的编码帧，将其添加到轨道缓冲区，从而触发了对拼接的需求。</p>
<p>3.令演示时间戳是新编码帧的表示时间戳</p>
<p>4.Let解码时间戳是新编码帧的解码时间戳。</p>
<p>5.令帧持续时间是新编码帧的编码帧持续时间。</p>
<p>6.令帧结束时间戳等于表示时间戳和帧持续时间的总和。</p>
<p>7.让第一个重叠的帧是轨道缓冲区中的编码帧，其中包含一个包含表示时间戳的表示间隔。</p>
<p>8.Let重叠的表示时间戳是第一个重叠帧的表示时间戳。</p>
<p>9.让重叠的帧等于第一个重叠的帧以及轨道缓冲区中的任何其他帧，它们的表示时间戳大于表示时间戳并小于帧结束时间戳。</p>
<p>10.从轨道缓冲区中删除重叠帧中包含的所有帧。</p>
<p>11.将第一个重叠帧的编码帧持续时间更新为演示时间戳 - 重叠的演示时间戳。 </p>
<p>12.将第一个重叠帧添加到轨道缓冲区。</p>
<p>13.返回调用者而不提供拼接框架。</p>
<blockquote>
<p>这是为了允许将新的编码帧添加到轨道缓冲区，就好像它没有重叠轨道缓冲区中的任何帧一样。</p>
</blockquote>
<h3 class="4">4. SourceBufferList对象</h3>

<p>SourceBufferList是SourceBuffer对象的简单容器对象。它在修改列表时提供只读数组访问和触发事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface SourceBufferList : EventTarget &#123;</span><br><span class="line">    readonly&amp;nbsp; attribute&amp;nbsp; &amp;nbsp; &amp;nbsp; unsigned long length;</span><br><span class="line">    attribute&amp;nbsp; &amp;nbsp; &amp;nbsp; EventHandler  onaddsourcebuffer;</span><br><span class="line">    attribute&amp;nbsp; &amp;nbsp; &amp;nbsp; EventHandler  onremovesourcebuffer;</span><br><span class="line">    getter&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;SourceBuffer (unsigned long index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="a4-1">4.1. Attributes</h4>
<h5>length of type unsigned long, readonly</h5>

<p>指示列表中SourceBuffer对象的数量。 </p>
<h5>onaddsourcebuffer of type EventHandler</h5>

<p>addsourcebuffer事件的事件处理程序。</p>
<h5>onremovesourcebuffer of type EventHandler</h5>

<p>removedourcebuffer事件的事件处理程序。</p>
<h4 id="a4-2">4.2. 方法</h4>

<p>getter</p>
<p>–允许使用数组运算符（即[]）访问列表中的SourceBuffer对象。</p>
<p>Parameter:</p>
<p>index: unsigned long</p>
<p>返回类型：SourceBuffer</p>
<p>调用此方法时，UA必须执行以下步骤：</p>
<p>–如果index大于或等于length属性，则返回undefined并中止这些步骤。</p>
<p>–返回列表中索引的SourceBuffer对象。</p>
<h4 id="a4-3">4.3. 事件摘要</h4>

<p>addsourcebuffer:</p>
<p>–将SourceBuffer添加到列表中时。</p>
<p>removesourcebuffer</p>
<p>–从列表中删除SourceBuffer时</p>
<h3 id="a5">5. URL对象扩展</h3>

<p>本节指定URL [FILE-API]对象定义的扩展。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[Exposed=Window]</span><br><span class="line">partial interface URL &#123;</span><br><span class="line">    <span class="keyword">static</span> DOMString createObjectURL(MediaSource mediaSource);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="a5-1"> 5.1. 方法</h4>

<p>createObjectURL, static</p>
<p>为MediaSource对象创建URL。</p>
<blockquote>
<p>此算法旨在镜像createObjectURL（）[FILE-API]方法的行为，该方法不会自动撤消创建的URL。建议Web作者对附加到媒体元素不再需要的任何MediaSource对象URL使用revokeObjectURL（）[FILE-API]。</p>
</blockquote>
<p>Parameter:</p>
<p>mediaSource: MediaSource</p>
<p>Return type: DOMString</p>
<p>调用此方法时，UA必须执行以下步骤：</p>
<p>–返回可用于取消引用mediaSource参数的唯一MediaSource对象URL。</p>
<h3 id="a6">6. HTMLMediaElement扩展</h3>

<p>此部分指定将MediaSource附加到元素时HTMLMediaElement上的现有属性必须返回的内容。</p>
<p>HTMLMediaElement.seekable属性返回基于以下步骤创建的新的静态规范化TimeRanges对象：</p>
<p>–如果duration等于NaN：</p>
<p>—-返回一个空的TimeRanges对象。</p>
<p>–如果持续时间等于正无穷大：</p>
<p>—-如果实时可搜索范围不为空：</p>
<p>——允许联合范围是实时可搜索范围和HTMLMediaElement.buffered属性的并集</p>
<p>——返回单个范围，其开始时间等于联合范围中的最早开始时间，结束时间等于联合范围中的最高结束时间，并中止这些步骤。</p>
<p>—-如果HTMLMediaElement.buffered属性返回空TimeRanges对象，则返回空TimeRanges对象并中止这些步骤。</p>
<p>——返回单个范围，其开始时间为0，结束时间等于HTMLMediaElement.buffered属性报告的最高结束时间。</p>
<p>–否则：</p>
<p>—-返回单个范围，开始时间为0，结束时间等于持续时间</p>
<p>HTMLMediaElement.buffered属性根据以下步骤返回静态规范化的TimeRanges对象。</p>
<p>1.让交集范围等于空TimeRanges对象。</p>
<p>2.如果activeSourceBuffers.length不等于0，则运行以下步骤：</p>
<p>2.1.设置活动范围是activeSourceBuffers中每个SourceBuffer对象缓冲返回的范围。</p>
<p>2.2.让最高结束时间成为有效范围内的最大范围结束时间。</p>
<p>2.3.令交集范围等于TimeRange对象，该对象包含从0到最高结束时间的单个范围</p>
<p>2.4.对于activeSourceBuffers中的每个SourceBuffer对象，运行以下步骤：</p>
<p>2.4.1.let source range等于当前SourceBuffer上buffered属性返回的范围。 </p>
<p>2.4.2.如果readyState为“已结束”，则将源范围中最后一个范围的结束时间设置为最高结束时间。 </p>
<p>2.4.3.设新的交点范围等于交点范围和源范围之间的交点。</p>
<p>2.4.4.用新的交叉点范围替换交叉点范围内的范围。</p>
<p>3.如果此算法未设置此属性的当前值，或者交集范围不包含与此属性的当前值完全相同的范围信息，则将此属性的当前值更新为交集范围。</p>
<p>4.返回此属性的当前值。</p>
<h3 id="a7"> 7. AudioTrack扩展</h3>

<p>本节指定HTML AudioTrack定义的扩展。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">partial interface AudioTrack &#123;</span><br><span class="line">    readonly attribute SourceBuffer? sourceBuffer;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h5>sourceBuffer of type SourceBuffer, readonly , nullable</h5>

<p>返回创建此轨道的SourceBuffer。如果此轨道不是由SourceBuffer创建的，或者SourceBuffer已从其父媒体源的sourceBuffers属性中删除，则返回null。</p>
<h3 id="a8"> 8. VideoTrack扩展</h3>

<p>本节指定HTML VideoTrack定义的扩展。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">partial interface VideoTrack &#123;</span><br><span class="line">    readonly attribute SourceBuffer? sourceBuffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5>sourceBuffer of type SourceBuffer, readonly , nullable</h5>

<p>返回创建此轨道的SourceBuffer。如果此轨道不是由SourceBuffer创建的，或者SourceBuffer已从其父媒体源的sourceBuffers属性中删除，则返回null。</p>
<h3 id="a9">9. TextTrack扩展</h3>

<p>本节指定HTML VideoTrack定义的扩展。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">partial interface TextTrack &#123;</span><br><span class="line">    readonly attribute SourceBuffer? sourceBuffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5>sourceBuffer of type SourceBuffer, readonly , nullable</h5>

<p>返回创建此轨道的SourceBuffer。如果此轨道不是由SourceBuffer创建的，或者SourceBuffer已从其父媒体源的sourceBuffers属性中删除，则返回null。</p>
<h3 id="a10">10. 字节流格式</h3>

<p>通过appendBuffer（）为SourceBuffer提供的字节形成逻辑字节流。这些字节流的格式和语义以字节流格式规范定义。字节流格式注册表[MSE-REGISTRY]提供可以传递给addSourceBuffer（）或isTypeSupported（）的MIME类型与使用该MIME类型创建的SourceBuffer所期望的字节流格式之间的映射。鼓励实现注册它们支持的字节流格式的映射，以促进互操作性。字节流格式注册表[MSE-REGISTRY]是这些映射的权威来源。如果实现声称支持注册表中列出的MIME类型，则其SourceBuffer实现必须符合注册表项中列出的字节流格式规范。 </p>
<blockquote>
<p>注册表中的字节流格式规范不用于定义新的存储格式。它们只是概述了本规范实现可接受的现有存储格式结构的子集。<br>Byte流格式解析和验证在段解析器循环算法中实现。</p>
</blockquote>
<p>本节提供了所有字节流格式规范的一般要求：</p>
<p>–字节流格式规范必须定义初始化段和媒体段。</p>
<p>–字节流格式应提供从初始化段中的数据中获取AudioTrack，VideoTrack和TextTrack属性值的参考。</p>
<blockquote>
<p>如果字节流格式覆盖类似于带内轨道规范[INBANDTRACKS]中所覆盖的格式，那么它应该尝试使用相同的属性映射，以便Media Source Extensions播放和非媒体源扩展回放提供相同的赛道信息。 </p>
</blockquote>
<p>–必须能够通过单独检查字节流来识别段边界和段类型（初始化或介质）。</p>
<p>–当满足以下任何条件时，UA必须运行追加错误算法：</p>
<p>1.轨道的数量和类型不一致。</p>
<blockquote>
<p>例如，如果第一个初始化段有2个音轨和1个视频轨，那么字节流中跟随它的所有初始化段必须描述2个音轨和1个视频轨。对于描述单个类型的多个轨道（例如，2个音轨）的段，</p>
</blockquote>
<p>2.轨道ID在初始化段之间是不同的。</p>
<p>3.Codecs在初始化段之间发生变化。</p>
<blockquote>
<p>例如，不允许以初始化段开始的字节流，该初始化段指定单个AAC轨道，并且稍后包含指定单个AMR-WB轨道的初始化段。使用多个SourceBuffer对象处理对多个编解码器的支持。 </p>
</blockquote>
<p>–UA必须支持以下内容：</p>
<p>1.如果段仅描述每种类型的一个轨道，则跟踪在初始化段之间更改的ID。</p>
<p>2.视频帧尺寸变化。UA必须支持无缝播放。</p>
<blockquote>
<p>如果Web应用程序不使用CSS或HTML属性（宽度/高度）来约束元素大小，这将导致显示区域的大小发生变化。</p>
</blockquote>
<p>3.音频通道数变化。UA可以无缝地支持它并且可以触发缩混。</p>
<blockquote>
<p>这是一个实施质量问题，因为更改频道数可能需要重新初始化音频设备，重采样器和通道混音器，这些音频设备往往是听得见的。</p>
</blockquote>
<p>–以下规则适用于字节流中的所有媒体段。UA必须：</p>
<p>1.将所有时间戳映射到同一媒体时间轴。</p>
<p>2.支持无缝播放时间戳间隔小于音频帧大小的媒体段。UA不得在缓冲属性中反映这些间隙。</p>
<blockquote>
<p>这是为了简化音频流之间的切换，其中帧边界并不总是在编码之间排列（例如，Vorbis）。</p>
</blockquote>
<p>–当初始化段和任何连续的媒体段序列的任何组合满足以下条件时，UA必须运行追加错误算法：</p>
<p>1.媒体段中所有轨道的数量和类型（音频，视频，文本等）没有确定。</p>
<p>2.未提供解码每个轨道所需的解码能力（即，编解码器和编解码器参数）。</p>
<p>3.不为所有加密轨道提供解密内容所需的加密参数（加密密钥本身除外）。</p>
<p>4.不提供解码和呈现媒体段序列中最早的随机访问点和序列中的所有子序列样本（在呈现时间中）所需的所有信息。这尤其包括</p>
<p>—-信息，用于确定视频的固有宽度和高度（具体而言，这需要图片或像素长宽比以及编码分辨率）。</p>
<p>—-将视频解码器输出转换为适合于显示的格式所必需的信息</p>
<p>5.未提供计算媒体段序列中每个样本的全局呈现时间戳所需的信息。</p>
<p>例如，如果I1与M1，M2，M3相关联，则上述必须适用于所有组合I1 + M1，I1 + M2，I1 + M1 + M2，I1 + M2 + M3等。</p>
<p>Byte流规格必须至少定义确保上述要求成立的约束条件。可以定义附加约束，例如以简化实现。</p>
<h3 id="a11">11. 一致性</h3>

<p>除了标记为非规范性的部分外，本规范中的所有创作指南，图表，示例和注释都是非规范性的。本规范中的其他所有内容都是规范性的。 关键词可以，必须，不得，应该，也不应该按照[RFC2119]中的描述进行解释。</p>
<h3 id="a12">12. Examples</h3>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSourceOpen</span>(<span class="params">videoTag, e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> mediaSource = e.target;</span><br><span class="line">   <span class="keyword">if</span> (mediaSource.sourceBuffers.length &gt; <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">var</span> sourceBuffer = mediaSource.addSourceBuffer(<span class="string">&#x27;video/webm; codecs=&quot;vorbis,vp8&quot;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   videoTag.addEventListener(<span class="string">&#x27;seeking&#x27;</span>, onSeeking.bind(videoTag, mediaSource));</span><br><span class="line">   videoTag.addEventListener(<span class="string">&#x27;progress&#x27;</span>, onProgress.bind(videoTag, mediaSource));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> initSegment = GetInitializationSegment();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (initSegment == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">// Error fetching the initialization segment. Signal end of stream with an error.</span></span><br><span class="line">     mediaSource.endOfStream(<span class="string">&quot;network&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Append the initialization segment.</span></span><br><span class="line">   <span class="keyword">var</span> firstAppendHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> sourceBuffer = e.target;</span><br><span class="line">     sourceBuffer.removeEventListener(<span class="string">&#x27;updateend&#x27;</span>, firstAppendHandler);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Append some initial media data.</span></span><br><span class="line">     appendNextMediaSegment(mediaSource);</span><br><span class="line">   &#125;;</span><br><span class="line">   sourceBuffer.addEventListener(<span class="string">&#x27;updateend&#x27;</span>, firstAppendHandler);</span><br><span class="line">   sourceBuffer.appendBuffer(initSegment);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">appendNextMediaSegment</span>(<span class="params">mediaSource</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mediaSource.readyState == <span class="string">&quot;closed&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we have run out of stream data, then signal end of stream.</span></span><br><span class="line">   <span class="keyword">if</span> (!HaveMoreMediaSegments()) &#123;</span><br><span class="line">     mediaSource.endOfStream();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure the previous append is not still pending.</span></span><br><span class="line">   <span class="keyword">if</span> (mediaSource.sourceBuffers[<span class="number">0</span>].updating)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> mediaSegment = GetNextMediaSegment();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mediaSegment) &#123;</span><br><span class="line">     <span class="comment">// Error fetching the next media segment.</span></span><br><span class="line">     mediaSource.endOfStream(<span class="string">&quot;network&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">NOTE:</span> If mediaSource.readyState == “ended”, this appendBuffer() call will</span></span><br><span class="line">   <span class="comment">// cause mediaSource.readyState to transition to &quot;open&quot;. The web application</span></span><br><span class="line">   <span class="comment">// should be prepared to handle multiple “sourceopen” events.</span></span><br><span class="line">   mediaSource.sourceBuffers[<span class="number">0</span>].appendBuffer(mediaSegment);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">onSeeking</span>(<span class="params">mediaSource, e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> video = e.target;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mediaSource.readyState == <span class="string">&quot;open&quot;</span>) &#123;</span><br><span class="line">     <span class="comment">// Abort current segment append.</span></span><br><span class="line">     mediaSource.sourceBuffers[<span class="number">0</span>].abort();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Notify the media segment loading code to start fetching data at the</span></span><br><span class="line">   <span class="comment">// new playback position.</span></span><br><span class="line">   SeekToMediaSegmentAt(video.currentTime);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Append a media segment from the new playback position.</span></span><br><span class="line">   appendNextMediaSegment(mediaSource);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">onProgress</span>(<span class="params">mediaSource, e</span>) </span>&#123;</span><br><span class="line">   appendNextMediaSegment(mediaSource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;v&quot;</span> <span class="attr">autoplay</span>&gt;</span> <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;v&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> mediaSource = <span class="keyword">new</span> MediaSource();</span></span><br><span class="line"><span class="javascript">  mediaSource.addEventListener(<span class="string">&#x27;sourceopen&#x27;</span>, onSourceOpen.bind(<span class="built_in">this</span>, video));</span></span><br><span class="line"><span class="javascript">  video.src = <span class="built_in">window</span>.URL.createObjectURL(mediaSource);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>H.264视频的RTP有效负载格式</title>
    <url>/2020/11/19/doc/h264/</url>
    <content><![CDATA[<h2 id="H-264视频的RTP有效负载格式"><a href="#H-264视频的RTP有效负载格式" class="headerlink" title="H.264视频的RTP有效负载格式"></a>H.264视频的RTP有效负载格式</h2><p>Version 10.1</p>
<p>备忘</p>
<p>该文件为因特网社区规定了因特网标准跟踪协议，并提出了改进建议和讨论。Please refer to the current edition of the“Internet official Protocol standards”（STD 1）for the standardization state and status of this Protocol.这个MEMO的分布是无限的。</p>
<p>Copyright Notice</p>
<p>Copyright (C) The Internet Society (2005).</p>
<p>摘要</p>
<p>本备忘录描述了ITU-T建议H.264视频编解码器的RTP有效载荷格式和技术上相同的ISO/IEC国际标准14496-10视频编解码器。RTP有效负载格式允许对每个RTP有效负载中由H.264视频编码器生成的一个或多个网络抽象层单元（NALU）进行打包。有效载荷格式具有广泛的适用性，因为它支持从简单的低比特率会话使用，到Internet视频流与交错传输，到高比特率视频点播的应用。</p>
<h3 id="a1">1. 介绍</h3>
<h4 id="a1-1">1.1. H.264编解码器的</h4>

<p>本备忘录规定了称为ITU-T建议H.264[1]和ISO/IEC国际标准14496第10部分[2]的视频编码标准的RTP有效载荷规范（两者都称为高级视频编码或AVC）。建议H.264于2003年5月获得ITU-T的批准，已批准的规范草案可供公众审查[8]。在本备忘录中，H.264首字母缩写用于编解码器和标准，但备忘录同样适用于编码标准的ISO/IEC对应物。</p>
<p>H.264视频编解码器的应用范围非常广泛，涵盖了各种形式的数字压缩视频，从低比特率的互联网流媒体应用到高清晰度电视广播和具有几乎无损编码的数字电影应用。与目前的技术状态相比，H.264的总体性能可以节省50%或更多的比特率。例如，据报道，数字卫星电视的质量可以达到1.5 Mbit/s，而MPEG 2视频的当前操作点大约为3.5 Mbit/s[9]。</p>
<p>编解码器规范[1]本身在概念上区分了视频编码层（VCL）和网络抽象层（NAL）。VCL包含编解码器的信号处理功能、转换、量化和运动补偿指令等机制以及循环滤波器。它遵循了当今大多数视频编解码器的一般概念，这是一种基于宏块的编码器，使用运动补偿和残余信号的变换编码进行图像预测。VCL编码器输出切片：包含整数个宏块的宏块数据和切片头信息（包含切片中第一个宏块的空间地址、初始量化参数和类似信息）的位串。除非使用所谓的灵活宏块排序语法指定了不同的宏块分配，否则宏块inslices按扫描顺序排列。图片内预测仅用于一个切片内。更多信息见[9]。</p>
<p>网络抽象层（NAL）编码器将VCL编码器的片输出封装成网络抽象层单元（NAL单元），适用于分组网络传输或在面向分组的多路复用环境中使用。H.264的附录B定义了一个封装过程，通过面向字节流的网络传输这些NAL单元。在本备忘录范围内，附件B不相关。</p>
<p>在内部，NAL使用NAL单位。NAL单元由一个字节头和有效负载字节字符串组成。报头指示NAL单元的类型、NAL单元有效负载中存在（可能）的位错误或语法冲突，以及有关NAL单元对解码过程的相对重要性的信息。该RTP有效载荷规范旨在不知道NAL单元有效载荷中的位串。</p>
<p>H.264的主要特性之一是传输时间、解码时间以及切片和图片的采样或显示时间的完全解耦。H.264中指定的解码过程不知道时间，H.264语法不携带跳过帧的数量等信息（在早期视频压缩标准中，时间引用的形式很常见）。此外，还有影响许多图片的NAL单元，因此，它们本身是永恒的。因此，RTP时间戳的处理需要对NAL单元进行一些特殊考虑，因为NAL单元没有定义采样或表示时间，或者在传输时未知。</p>
<h4 id="a1-2">1.2. 参数集的概念</h4>

<p>H.264的一个非常基本的设计概念是生成自包含的数据包，使诸如RFC2429[10]或MPEG-4的头扩展代码（HEC）[11]的头复制等机制变得不必要。这是通过从媒体流中分离与多个切片相关的信息来实现的。更高层的元信息应该从包含切片数据包的RTP数据包流中可靠、异步地提前发送。（对于没有适合的带外传输通道的应用程序，也可以在带内发送此信息。）更高级别参数的组合称为参数集。H.264规范包括两种类型的参数集：序列参数集和图片参数集。在编码视频序列中，活动序列参数集保持不变，而在编码图像中，活动图像参数集保持不变。序列和图片参数集结构包含图片大小、使用的可选编码模式以及宏块到切片组映射等信息。</p>
<p>为了能够改变图片参数（如图片大小），而不必将参数集更新同步传输到切片包流，编码器和解码器可以维护一个以上序列和图片参数集的列表。每个切片头包含一个代码字，指示要使用的序列和图片参数集。</p>
<p>该机制允许将参数集与包流的传输分离，并通过外部手段（例如，作为能力交换的副作用）或通过（可靠或不可靠）控制协议进行传输。甚至可能它们从未被传输，而是由应用程序设计规范固定。</p>
<h4 id="a1-3">1.3. 网络abstraction层单元类型</h4>

<p>有关NAL设计的教程信息可以在[12]、[13]和[14]中找到。</p>
<p>所有NAL单元都由一个单一的NAL单元类型octet组成，它也作为这个RTP有效负载格式的有效负载头。NAL装置的有效载荷立即跟随。</p>
<p>Nal单元类型octet的语法和语义在[1]中指定，但Nal单元类型octet的基本属性总结如下。NAL单元类型octet具有以下格式：</p>
<pre>
      +---------------+
      |0|1|2|3|4|5|6|7|
      +-+-+-+-+-+-+-+-+
      |F|NRI|  Type   |
      +---------------+
</pre>

<p>下文简要介绍了H.264规范中规定的NAL单元类型octet组件的语义。</p>
<p>F:1位</p>
<p>禁止零位。H.264规范将1的值声明为语法冲突。</p>
<p>NRI:2位</p>
<p>国际数据中心。数值00表示NAL单元的内容不用于重建图像间预测的参考图像。这样的NAL单元可以丢弃，而不会危及参考图片的完整性。大于00的值表示需要对NAL单元进行解码，以保持参考图片的完整性。</p>
<p>Type：5位</p>
<p>NAL单元类型。此组件指定了NAL单位有效载荷类型，如[1]表7-1中所定义，稍后在本备忘录中定义。有关当前定义的所有NAL单元类型及其语义的参考，请参考[1]中的第7.4.1节。</p>
<p>本备忘录介绍了第5.2节中介绍的新NAL装置类型。本备忘录中定义的NAL单元类型在[1]中标记为未指定。此外，如第5.3节所述，本规范扩展了F和NRI的语义。</p>
<h3 id="a2">2. Conventions</h3>

<p>本文件中的关键词”MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”应按照BCP 14、RFC 2119[3]的说明进行解释。</p>
<p>本规范使用了在处理位字段时设置和清除位的概念。设置位与将该位的值指定为1（开）相同。清除一个位与将该位的值指定为0（关）相同。</p>
<h3 id="a3">3. 范围</h3>

<p>本有效载荷规范只能用于在RTP上承载“裸”H.264 NAL单元流，而不能用于H.264附录B中讨论的比特流格式。很可能，本规范的第一个应用是会话多媒体领域、视频电话或视频会议，但有效载荷格式也涵盖其他应用，如互联网流和IP电视。</p>
<h3 id="a4">4. Definitions and Abbreviations</h3>
<h4 id="a4-1">4.1. Definitions</h4>

<p>本文件使用了[1]的定义。为了方便起见，总结了[1]中定义的以下术语：</p>
<p>访问单元：一组NAL单元，通常包含一个主编码图片。除了主编码图片外，访问单元还可以包含一个或多个冗余编码图片或其他不包含编码图片切片或切片数据分区的NAL单元。一个存取单元的解码总是产生一个解码的图像。</p>
<p>编码视频序列：按解码顺序，由一个瞬时解码刷新（IDR）接入单元和零个或多个非IDR接入单元组成的接入单元序列，包括所有后续接入单元，但不包括任何后续的IDR接入单元。</p>
<p>IDR访问单元：主要编码图片是IDR图片的访问单元。</p>
<p>IDR图片：一种编码图片，只包含在解码过程中导致“重置”的I或SI切片类型的切片。在对IDR图像进行解码后，可以对解码顺序如下的所有编码图像进行解码，而无需对在IDR图像之前解码的任何图像进行相互预测。</p>
<p>主编码图片：解码过程对符合H.264的比特流使用的图片的编码表示。主编码图片包含图片的所有宏块。</p>
<p>冗余编码图片：图片或部分图片的编码表示。对于符合H.264的比特流，解码过程不得使用冗余编码图像的内容。冗余编码图片的内容可由解码过程用于包含错误或丢失的比特流。</p>
<p>VCL NAL单元：用于指编码切片和编码数据分区NAL单元的集合术语。</p>
<p>此外，以下定义适用：</p>
<p>解码顺序号（DON）：有效载荷结构中的一个字段，或指示NAL单元解码顺序的派生变量。Don的值在0到65535（包括0和65535）之间。在达到最大值后，don的值将环绕为0。</p>
<p>NAL单元解码顺序：符合[1]第7.4.1.2节给出的NAL单元顺序限制的NAL单元顺序。</p>
<p>传输顺序：包按RTP序列号升序的顺序（模算术）。在聚合包中，NAL单元传输顺序与包中NAL单元的出现顺序相同。</p>
<p>媒体感知网络元素（mane）：一种网络元素，如中间箱或应用层网关，能够解析RTP有效负载头或RTP有效负载的某些方面并对内容作出反应。</p>
<p>信息提示：mane的概念超越了普通的路由器或网关，因为mane必须知道信号（例如，了解媒体流的有效负载类型映射），并且在使用srtp时必须信任它。使用mane的优点是，它们允许根据媒体编码的需要丢弃数据包。例如，如果一个mane由于某个链路上的拥塞而不得不丢弃数据包，那么它可以识别那些数据包。</p>
<p>其下降对用户体验的负面影响最小，并将其移除，以消除拥塞和/或降低延迟。</p>
<p>缩写</p>
<pre>
DON:        Decoding Order Number
DONB:       Decoding Order Number Base
DOND:       Decoding Order Number Difference
FEC:        Forward Error Correction
FU:         Fragmentation Unit
IDR:        Instantaneous Decoding Refresh
IEC:        International Electrotechnical Commission
ISO:        International Organization for Standardization
ITU-T:      International Telecommunication Union,
            Telecommunication Standardization Sector
MANE:       Media Aware Network Element
MTAP:       Multi-Time Aggregation Packet
MTAP16:     MTAP with 16-bit timestamp offset
MTAP24:     MTAP with 24-bit timestamp offset
NAL:        Network Abstraction Layer
NALU:       NAL Unit
SEI:        Supplemental Enhancement Information
STAP:       Single-Time Aggregation Packet
STAP-A:     STAP type A
STAP-B:     STAP type B
TS:         Timestamp
VCL:        Video Coding Layer
</pre>
<h3 id="a5">5. payload RTP格式</h3>
<h4 id="a5-1">5.1. RTP报头usage</h4>

<p>RTP报头的格式在RFC3550[4]中指定，为了方便起见，在图1中重新打印。此有效负载格式以与该规范一致的方式使用头字段。</p>
<p>当每个RTP包封装一个NAL单元时，建议的RTP有效载荷格式在第5.6节中指定。聚合数据包和碎片单元的RTP有效负载（以及某些RTP头位的设置）分别在第5.7节和第5.8节中指定。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |V=2|P|X|  CC   |M|     PT      |       sequence number         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           timestamp                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           synchronization source (SSRC) identifier            |
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      |            contributing source (CSRC) identifiers             |
      |                             ....                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 1.  RTP header according to RFC 3550
</pre>

<p>要根据此RTP有效负载格式设置的RTP头信息设置如下：</p>
<p>标记位（m）：1位</p>
<p>根据视频格式中M位的正常使用，为RTP时间戳指示的访问单元的最后一个数据包设置，以允许有效的播放缓冲区处理。对于聚合数据包（STAP和MTAP），RTP头中的标记位必须设置为聚合数据包的最后一个NAL单元的标记位如果在自己的RTP数据包中传输时的值。解码器可以使用此位作为访问单元最后一个数据包的早期指示，但不能依赖此属性。</p>
<p>信息提示：只有一个M位与携带多个NAL单元的聚合包相关联。因此，如果一个网关已经将一个聚合数据包重新打包成多个数据包，那么它就不能可靠地设置这些数据包的M位。</p>
<p>有效载荷类型（pt）：7位</p>
<p>此新数据包格式的RTP有效负载类型的分配超出了本文档的范围，将不会在此处指定。有效负载类型的分配必须通过使用的配置文件或以动态方式执行。</p>
<p>序列号（sn）：16位</p>
<p>根据RFC 3550设置和使用。对于单NALU和非交错分组方式，序列号用于确定NALU的解码顺序。</p>
<p>时间戳：32位</p>
<p>RTP时间戳设置为内容的采样时间戳。必须使用90 kHz的时钟频率。</p>
<p>如果NAL单元本身没有时间属性（例如，参数集和序列单元），则根据[1]第7.4.1.2节，RTP时间戳设置为包含NAL单元的访问单元的主要编码图片的RTP时间戳。</p>
<p>MTAP的RTP时间戳设置在第5.7.2节中定义。</p>
<p>接收器应该忽略包含在只有一个显示时间戳的访问单元中的任何图片定时SEI消息。相反，接收器应该使用RTP时间戳来同步显示过程。</p>
<p>对于不应显示为多个字段的图片，RTP发送方不应发送图片定时SEI消息。</p>
<p>如果一个接入单元在一个图像定时SEI报文中携带有多个显示时间戳，那么SEI报文中的信息应被视为相对于RTP时间戳的信息，最早的事件发生在RTP时间戳给出的时间，随后的事件则由SEI报文图像定时V中的差异给出。铝。让tsei1，tsei2，…，tsein作为一个接入单元的SEI报文中携带的显示时间戳，其中tsei1是所有这些时间戳中最早的一个。让tmadjst（）是一个将SEI消息时间刻度调整为90 kHz时间刻度的函数。让ts成为RTP时间戳。然后，与tsei1相关的事件的显示时间为ts。与tseix相关的事件的显示时间，其中x为[2..n]为ts+tmadjst（tseix-tsei1）。</p>
<p>提示性说明：在3:2下拉操作中，通常需要将编码帧显示为字段，在该操作中，由编码帧组成的胶片内容将使用隔行扫描显示在显示器上。picture timing sei消息可以为同一编码图片传输多个时间戳，因此3:2下拉过程是完全控制的。图片定时SEI消息机制是必要的，因为RTP时间戳中每个编码帧只能传递一个时间戳。</p>
<p>提示性说明：由于H.264允许解码顺序与显示顺序不同，RTP时间戳的值不能作为RTP序列号的函数单调地非递减。此外，rtcp报告中报告的时间间隔抖动值可能不是网络性能的可靠指标，因为时间间隔抖动的计算规则（RFC 3550第6.4.1节）假设数据包的rtp时间戳与其传输时间成正比。</p>
<h4 id="a5-2">5.2. 常见结构的payload RTP格式</h4>
有效载荷格式定义了三种不同的基本有效载荷结构。接收器可以通过RTP有效载荷的第一个字节来识别有效载荷结构，该字节co用作RTP有效载荷头，在某些情况下，作为有效载荷的第一个字节。这个字节总是作为NAL单元头结构。“NAL单位类型”字段指示存在的结构。可能的结构如下：
单NAL单元包：有效载荷中只包含一个NAL单元。NAL报头类型字段将等于原始NAL单元类型，即在1到23（包括1和23）范围内。第5.6节规定。
聚合数据包：用于将多个NAL单元聚合为单个RTP负载的数据包类型。此数据包有四个版本：单时间聚合数据包类型A（STAP-A）、单时间聚合数据包类型B（STAP-B）、16位偏移量的多时间聚合数据包（MTAP）和24位偏移量的多时间聚合数据包（MTAP）。分配给STAP-A、STAP-B、MTAP16和MTAP24的NAL单元类型号分别为24、25、26和27。第5.7节规定。
分段单元：用于在多个RTP包上对单个NAL单元进行分段。存在两个版本，fu-a和fu-b，分别用NAL单元类型编号28和29标识。第5.8节规定。

<p> Table 1.  Summary of NAL unit types and their payload structures</p>
<pre>
      Type   Packet    Type name                        Section
      ---------------------------------------------------------
      0      undefined                                    -
      1-23   NAL unit  Single NAL unit packet per H.264   5.6
      24     STAP-A    Single-time aggregation packet     5.7.1
      25     STAP-B    Single-time aggregation packet     5.7.1
      26     MTAP16    Multi-time aggregation packet      5.7.2
      27     MTAP24    Multi-time aggregation packet      5.7.2
      28     FU-A      Fragmentation unit                 5.8
      29     FU-B      Fragmentation unit                 5.8
      30-31  undefined      
</pre>

<p>资料性说明：本规范不限制封装在单个NAL单元包和碎片单元中的NAL单元的大小。封装在任何聚合数据包中的NAL单元的最大大小为65535字节。</p>
<h4 id="a5-3">5.3. NAL单元octet usage</h4>

<p>第1.3节介绍了NAL单元八位字节的结构和语义。为方便起见，以下重新打印了NAL单元类型octet的格式：</p>
<pre>
      +---------------+
      |0|1|2|3|4|5|6|7|
      +-+-+-+-+-+-+-+-+
      |F|NRI|  Type   |
      +---------------+
</pre>

<p>本节根据本规范规定了F和NRI的语义。</p>
<p>F:1位</p>
<p>禁止零位。值0表示NAL单元类型octet和有效负载不应包含位错误或其他语法冲突。值1表示NAL单元类型octet和有效负载可能包含位错误或其他语法冲突。</p>
<p>Manes应设置F位以指示NAL单元中检测到的位错误。H.264规范要求F位等于0。设置F位时，建议解码器在有效负载或NAL单元类型octet中可能存在位错误或任何其他语法冲突。译码器对NAL单元的最简单反应是丢弃这样一个NAL单元，并将丢失的数据隐藏在丢弃的NAL单元中。</p>
<p>NRI:2位</p>
<p>国际数据中心。值00和非零值的语义与H.264规范保持不变。换句话说，值为00表示NAL单元的内容不用于重建图像间预测的参考图像。这样的NAL单元可以丢弃，而不会危及参考图片的完整性。大于00的值表示需要对NAL单元进行解码，以保持参考图片的完整性。</p>
<p>除上述规范外，根据本RTP有效载荷规范，NRI大于00的值表示编码器确定的相对传输优先级。鬃毛</p>
<p>可以使用此信息更好地保护更重要的NAL单元，而不是它们所做的不重要的NAL单元。最高的传输优先级是11，其次是10，然后是01；最后，00是最低的。</p>
<p>说明：NRI的任何非零值在H.264解码器中处理相同。因此，在将NAL单元传递给解码器时，接收器不需要操纵NRI的值。</p>
<p>当Nal_Unit_类型的值在1到12（包括1和12）范围内时，H.264编码器必须根据H.264规范（子条款7.4.1）设置NRI的值。特别是，H.264规范要求，对于所有NAL单元（NAL单元类型等于6、9、10、11或12）的NRI值应等于0。</p>
<p>对于Nal_Unit_类型等于7或8（分别表示序列参数集或图片参数集）的Nal单元，H.264编码器应将NRI值设置为11（二进制格式）。对于Nal_Unit_类型等于5（表示属于IDR图片的编码切片）的主编码图片的编码切片Nal单元，H.264编码器应将NRI值设置为11（二进制格式）。</p>
<p>对于剩余的NAL单元类型到NRI值的映射，可以使用以下示例，并且已经证明在特定环境中是有效的[13]。其他映射也可能是可取的，这取决于应用程序和使用中的H.264/AVC附录A概要。</p>
<p>提示性说明：数据分区在某些配置文件中不可用；例如，在主配置文件或基线配置文件中。因此，只有当视频比特流符合允许数据分区的配置文件，而不是符合主配置文件或基线配置文件的流时，才能出现NAL单元类型2、3和4。</p>
<p>表2.主要编码参考图片的编码切片和编码切片数据分区的NRI值示例</p>
<pre>
       NAL Unit Type     Content of NAL unit              NRI (binary)
      ----------------------------------------------------------------
       1              non-IDR coded slice                         10
       2              Coded slice data partition A                10
       3              Coded slice data partition B                01
       4              Coded slice data partition C                01
</pre>

<p>说明：如前所述，非参考图片的NRI值为H.264/AVC规定的00。</p>
<p>H.264编码器应将冗余编码参考图片的编码切片和编码切片数据分区NAL单位的NRI值设置为01（二进制格式）。</p>
<p>本备忘录第5.7节和第5.8节给出了NAL装置类型24至29（含）的NRI值定义。</p>
<p>对于NAL-U单元类型在13至23（包括13至23）范围内的NAL单元，没有给出NRI值的建议，因为这些值是为ITU-T和ISO/IEC保留的。由于本备忘录中未规定这些值的语义，因此对于Nal_Unit_类型等于0或在30至31（含30至31）范围内的Nal单元，未给出NRI值的建议。</p>
<h4 id="a5-4">5.4. 打包模式</h4>

<p>本备忘录规定了三种打包模式：</p>
<p>o单NAL单元模式</p>
<p>o非交错模式</p>
<p>o交错模式</p>
<p>单NAL单元模式针对符合ITU-T建议H.241[15]的会话系统（见第12.1节）。非交织模式针对的是可能不符合ITU-T建议H.241的会话系统。在非交织模式下，NAL单元按NAL单元解码顺序传输。交错模式针对的是不需要非常低的端到端延迟的系统。交错模式允许NAL单元的传输超出NAL单元解码顺序。</p>
<p>使用中的打包模式可以通过可选打包模式mime参数的值或通过外部方法发出信号。使用的打包模式控制RTP有效负载中允许哪些NAL单元类型。表3总结了每个打包模式允许的NAL单元类型。一些NAL单位类型值（在表3中表示为未定义）保留用于将来的扩展。这些类型的NAL单元不应该由发送方发送，并且必须被接收方忽略。例如，类型1-23与相关的数据包类型“NAL单元”在“单个NAL单元模式”和“非交错模式”中是允许的，但在“交错模式”中是不允许的。第6节将更详细地解释打包模式。</p>
<p>表3.每个打包模式允许的NAL单元类型摘要（是=允许，否=不允许，ig=忽略）</p>
<pre>
      Type   Packet    Single NAL    Non-Interleaved    Interleaved
                       Unit Mode           Mode             Mode
      -------------------------------------------------------------

      0      undefined     ig               ig               ig
      1-23   NAL unit     yes              yes               no
      24     STAP-A        no              yes               no
      25     STAP-B        no               no              yes
      26     MTAP16        no               no              yes
      27     MTAP24        no               no              yes
      28     FU-A          no              yes              yes
      29     FU-B          no               no              yes
      30-31  undefined     ig               ig               ig
</pre>
<h4 id="a5-5">5.5. 解码顺序号（DON）</h4>

<p>在交错打包模式下，允许NAL单元的传输顺序不同于NAL单元的解码顺序。解码顺序号（DON）是有效载荷结构中的一个字段或指示NAL单元解码顺序的派生变量。第13节给出了解码顺序外传输和DON使用用例的基本原理和示例。</p>
<p>传输和解码顺序的耦合由可选的sprop交织深度mime参数控制，如下所示。当可选sprop交织深度mime参数的值等于0（显式或按默认值）或通过外部方式不允许NAL单元超出其解码顺序的传输时，NAL单元的传输顺序必须符合NAL单元解码顺序。当可选sprop交织深度mime参数的值大于0或允许通过外部方式传输非解码顺序的NAL单元时，</p>
<p>o MTAP16和MTAP24中的NAL单元顺序不需要是NAL单元解码顺序，以及</p>
<p>o将两个连续数据包中的stap bs、mtaps和fus解封装后生成的nal单元的顺序不需要是nal单元的解码顺序。</p>
<p>单个NAL单元包、STAP-A和FU-A的RTP有效载荷结构不包括DON。STAP-B和FU-B结构包括DON，MTAPS的结构允许按照第5.7.2节的规定推导DON。</p>
<p>提示：当一个fu-a以交错模式出现时，它总是跟随一个fu-b，它设置了它的don。</p>
<p>提示性说明：如果发送器想要封装每个数据包的单个NAL单元，并按照解码顺序发送数据包，则可以使用STAP-B数据包类型。</p>
<p>在单NAL单元封装模式下，由RTP序列号确定的NAL单元的传输顺序必须与它们的NAL单元解码顺序相同。在非交错分组方式下，NAL单元在单个NAL单元包、STAP AS和FU AS中的传输顺序必须与它们的NAL单元解码顺序相同。STAP中的NAL单元必须按NAL单元解码顺序出现。因此，解码顺序首先通过STAP内的隐式顺序提供，其次通过RTP序列号提供STAP、FUS和单个NAL单元包之间的顺序。</p>
<p>第5.7.1、5.7.2和5.8节分别规定了STAP-B、MTAP和以FU-B开头的一系列碎片单元的DON值信号。传输顺序中第一个NAL单元的DON值可以设置为任何值。Don的值在0到65535（包括0和65535）之间。在达到最大值后，don的值将环绕为0。</p>
<p>任何STAP-B、MTAP或以FU-B开头的一系列碎片单元中包含的两个NAL单元的解码顺序如下所示。设don（i）为传输顺序中具有索引i的NAL单元的解码顺序号。函数don_diff（m，n）指定如下：</p>
<pre>
    If DON(m) == DON(n), don_diff(m,n) = 0
    If (DON(m) < DON(n) and DON(n) - DON(m) < 32768),
    don_diff(m,n) = DON(n) - DON(m)
    If (DON(m) > DON(n) and DON(m) - DON(n) >= 32768),
    don_diff(m,n) = 65536 - DON(m) + DON(n)
    If (DON(m) < DON(n) and DON(n) - DON(m) >= 32768),
    don_diff(m,n) = - (DON(m) + 65536 - DON(n))
    If (DON(m) > DON(n) and DON(m) - DON(n) < 32768),
    don_diff(m,n) = - (DON(m) - DON(n))
</pre>

<p>Don_diff（m，n）的正值表示具有传输顺序索引n的NAL单元按照解码顺序跟随具有传输顺序索引m的NAL单元。当Don_diff（m，n）等于0时，</p>
<p>然后，两个NAL单元的NAL单元解码顺序可以是任意顺序。Don_diff（m，n）的负值表示具有传输顺序索引n的NAL单元在解码顺序中先于具有传输顺序索引m的NAL单元。</p>
<p>DON相关字段的值（DON、DONB和DOND；见第5.7节）必须使由DON值确定的解码顺序符合NAL单元解码顺序。如果切换NAL单元解码顺序中两个NAL单元的顺序，并且新顺序不符合NAL单元解码顺序，则NAL单元不得具有相同的DON值。如果NAL单元流中两个连续NAL单元的顺序被切换，并且新的顺序仍然符合NAL单元解码顺序，则NAL单元可能具有相同的DON值。例如，当使用的视频编码配置文件允许任意的切片顺序时，编码图片的所有编码切片NAL单元都允许具有相同的DON值。因此，具有相同DON值的NAL单元可以按任何顺序解码，并且两个具有不同DON值的NAL单元应按上述指定顺序传递给解码器。当NAL单元解码顺序中的两个连续NAL单元的DON值不同时，解码顺序中的第二个NAL单元的DON值应为第一个NAL单元的DON值，递增1。</p>
<p>第7节给出了恢复NAL单元解码顺序的去封装过程的示例。</p>
<p>提示性说明：接收器不应期望NAL单元解码顺序中两个连续NAL单元的DON值的绝对差等于1，即使在无错误传输中也是如此。不需要一个增量，因为在将don的值与nal单位关联时，可能不知道是否所有nal单位都已交付给接收者。例如，当数据包转发到的网络中的比特率不足时，网关可能无法转发非参考图片的编码片单元或序列单元。在另一个例子中，实时广播不时被预先编码的内容（如广告）中断。预先编码的片段的第一幅内部图像是预先传输的，以确保它在接收器中随时可用。在传输第一幅内部图像时，发起者并不确切知道在预编码片段的第一幅内部图像按照解码顺序进行编码之前，将编码多少个NAL单元。因此，当预编码片段的第一张内部图像的NAL单位的DON值被传输时，必须对其进行估计，并且DON值可能出现间隙。</p>
<h4 id="a5-6">5.6. 单NAL单元包</h4>

<p>此处定义的单个NAL单元数据包只能包含一个NAL单元，其类型在[1]中定义。这意味着聚合包和碎片单元都不能在单个NAL单元包中使用。由以RTP序列号顺序对单个NAL单元数据包进行去封装构成的NAL单元流必须符合NAL单元解码顺序。单个NAL单元包的结构如图2所示。</p>
<p>提示性说明：NAL单元co的第一个字节用作RTP有效载荷头。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |F|NRI|  type   |                                               |
      +-+-+-+-+-+-+-+-+                                               |
      |                                                               |
      |               Bytes 2..n of a Single NAL unit                 |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图2.单NAL单元包的RTP有效载荷格式</p>
<h4 id="a5-7">5.7. 聚合数据包</h4>

<p>聚合数据包是本有效负载规范的NAL单元聚合方案。引入该方案是为了反映两个关键目标网络的MTU大小显著不同：有线IP网络（MTU大小通常受以太网MTU大小限制；大约1500字节）和基于IP或非IP（例如，ITU-T H.324/M）的无线通信系统，首选传输单元大小为254字节或更小。为了防止媒体在两个世界之间转码，避免不必要的打包开销，引入了一种NAL单元聚合方案。</p>
<p>本规范定义了两种类型的聚合数据包：</p>
<p>o单时间聚合包（STAP）：聚合具有相同NALU时间的NAL单元。定义了两种类型的stap，一种没有don（stap-a），另一种包括don（stap-b）。</p>
<p>o多时间聚合包（MTAP）：聚合具有不同NALU时间的NAL单元。定义了两个不同的MTAP，NAL单位时间戳偏移量的长度不同。</p>
<p>术语NALU时间定义为RTP时间戳的值，如果NAL单元将在其自己的RTP包中传输，则该值将具有。</p>
<p>在聚合包中携带的每个NAL单元封装在聚合单元中。请参阅下面四个不同的聚合单元及其特性。</p>
<p>聚合数据包的RTP有效负载格式的结构如图3所示。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |F|NRI|  type   |                                               |
      +-+-+-+-+-+-+-+-+                                               |
      |                                                               |
      |             one or more aggregation units                     |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图3.聚合数据包的RTP负载格式</p>
<p>MTAP和STAP共享以下打包规则：RTP时间戳必须设置为要聚合的所有NAL单元的NALU时间中最早的一个。NAL单元类型octet的类型字段必须设置为适当的值，如表4所示。如果聚合NAL单元的所有F位都为零，则必须清除F位；否则，必须设置F位。NRI的值必须是聚合数据包中携带的所有NAL单元的最大值。</p>
<p>表4.staps和mtap的类型字段</p>
<pre>
      Type   Packet    Timestamp offset   DON related fields
                       field length       (DON, DONB, DOND)
                       (in bits)          present
      --------------------------------------------------------
      24     STAP-A       0                 no
      25     STAP-B       0                 yes
      26     MTAP16      16                 yes
      27     MTAP24      24                 yes
</pre>

<p>RTP头中的标记位被设置为聚合数据包的最后一个NAL单元的标记位如果在自己的RTP数据包中传输的话所具有的值。</p>
<p>聚合数据包的有效负载由一个或多个聚合单元组成。四种不同类型的聚合单元见第5.7.1节和第5.7.2节。聚合数据包可以根据需要携带尽可能多的聚合单元；但是，聚合数据包中的数据总量显然必须适合于一个IP数据包，并且应选择大小，以便生成的IP数据包小于MTU大小。聚合数据包不得包含第5.8节中指定的碎片单元。聚合数据包不得嵌套；即，聚合数据包不得包含其他聚合数据包。</p>
<h5 id="a5-7-1">5.7.1. Single-Time Aggregation Packet</h5>

<p>每当NAL单元聚合时，都应使用一次性聚合数据包（STAP），所有这些单元共享相同的NALU时间。STAP-A的有效负载不包括DON，并且至少由一个单时间聚合单元组成，如图4所示。STAP-B的有效负载由16位无符号解码顺序号（DON）（按网络字节顺序）和至少一个单时间聚合单元组成，如图5所示。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      :                                               |
      +-+-+-+-+-+-+-+-+                                               |
      |                                                               |
      |                single-time aggregation units                  |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 4.  Payload format for STAP-A

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      :  decoding order number (DON)  |               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
      |                                                               |
      |                single-time aggregation units                  |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 5.  Payload format for STAP-B
</pre>

<p>DON字段按传输顺序指定STAP-B中第一个NAL单元的DON值。对于STAP-B中外观顺序的每个连续NAL单元，DON值等于（STAP-B中前一个NAL单元的DON值+1）%65536，其中“%”表示模运算。</p>
<p>单个时间聚合单元由16位无符号大小信息（按网络字节顺序）组成，该信息以字节表示以下NAL单元的大小（不包括这两个八位字节，但包括NAL单元的NAL单元类型八位字节），然后是NAL单元本身，包括其NAL单元类型字节。单个时间聚合单元在RTP负载内是字节对齐的，但它可能不会在32位字边界上对齐。图6显示了单时间聚合单元的结构。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      :        NAL unit size          |               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
      |                                                               |
      |                           NAL unit                            |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 6.  Structure for single-time aggregation unit
</pre>

<p>图7给出了一个包含STAP-A的RTP包的示例。STAP包含两个单时间聚合单元，图中标记为1和2。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          RTP Header                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |STAP-A NAL HDR |         NALU 1 Size           | NALU 1 HDR    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         NALU 1 Data                           |
      :                                                               :
      +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               | NALU 2 Size                   | NALU 2 HDR    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         NALU 2 Data                           |
      :                                                               :
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图7.一个RTP包的例子，包括一个STAP-A和两个单时间聚合单元</p>
<p>图8给出了一个包含STAP-B的RTP包的示例。STAP包含两个单时间聚合单元，图中标记为1和2。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          RTP Header                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |STAP-B NAL HDR | DON                           | NALU 1 Size   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | NALU 1 Size   | NALU 1 HDR    | NALU 1 Data                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
      :                                                               :
      +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               | NALU 2 Size                   | NALU 2 HDR    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       NALU 2 Data                             |
      :                                                               :
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图8.一个RTP包的例子，包括一个STAP-B和两个单时间聚合单元</p>
<h5 id="a5-7-2">5.7.2. Multi-Time Aggregation Packets (MTAPs)</h5>

<p>MTAPS的NAL单元有效载荷由一个16位无符号解码顺序基数（DONB）（按网络字节顺序）和一个或多个多时间聚合单元组成，如图9所示。DONB必须在MTAP的NAL单元之间包含NAL单元解码顺序中第一个NAL单元的DON值。</p>
<p>提示性说明：NAL单元解码顺序中的第一个NAL单元不一定是NAL单元封装在MTAP中的顺序中的第一个NAL单元。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      :  decoding order number base   |               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
      |                                                               |
      |                 multi-time aggregation units                  |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图9.MTAP的NAL单位有效载荷格式</p>
<p>本规范中定义了两个不同的多时间聚合单元。这两个单元都由以下NAL单元的16位无符号大小信息（按网络字节顺序）、8位无符号解码顺序号差（DOND）和N位（按网络字节顺序）组成，其中N可以是16或24。不同MTAP类型（MTAP16和MTAP24）之间的选择取决于应用程序：时间戳偏移量越大，MTAP的灵活性越高，但开销也越高。</p>
<p>MTAP16和MTAP24的多时间聚合单元的结构分别如图10和11所示。数据包中聚合单元的起始或结束位置不需要位于32位字边界上。下列NAL单位的DON等于（DONB+DOND）%65536，其中%表示模运算。本备忘录未规定如何订购MTAP中的NAL单元，但在大多数情况下，应使用NAL单元解码顺序。</p>
<p>时间戳偏移量字段必须设置为等于以下公式的值：如果NALU时间大于或等于数据包的RTP时间戳，则时间戳偏移量等于（NAL单元的NALU时间-数据包的RTP时间戳）。如果NALU时间小于数据包的RTP时间戳，则时间戳偏移量等于NALU时间+（2^32-数据包的RTP时间戳）。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :        NAL unit size          |      DOND     |  TS offset    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  TS offset    |                                               |
      +-+-+-+-+-+-+-+-+              NAL unit                         |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图10.MTAP16的多时间聚合单元</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :        NALU unit size         |      DOND     |  TS offset    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         TS offset             |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                              NAL unit                         |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图11.用于MTAP24的多时间聚合单元</p>
<p>对于MTAP中的“最早”多时间聚合单元，时间戳偏移量必须为零。因此，mtap本身的rtp时间戳与最早的nalu时间相同。</p>
<p>提示：如果聚合单元封装在单个NAL单元包中，“最早”的多时间聚合单元将在MTAP的所有聚合单元中具有最小的扩展RTP时间戳。扩展时间戳是一个具有超过32位的时间戳，它能够计算时间戳字段的环绕，从而使人能够确定时间戳缠绕时的最小值。这种“最早的”聚合单元可能不是按聚合单元封装在MTAP中的顺序排列的第一个聚合单元。“最早”NAL单元也不需要与NAL单元解码顺序中的第一个NAL单元相同。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          RTP Header                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |MTAP16 NAL HDR |  decoding order number base   | NALU 1 Size   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  NALU 1 Size  |  NALU 1 DOND  |       NALU 1 TS offset        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  NALU 1 HDR   |  NALU 1 DATA                                  |
      +-+-+-+-+-+-+-+-+                                               +
      :                                                               :
      +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               | NALU 2 SIZE                   |  NALU 2 DOND  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       NALU 2 TS offset        |  NALU 2 HDR   |  NALU 2 DATA  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
      :                                                               :
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图12显示了一个RTP数据包的示例，该数据包包含一个MTAP16类型的多时间聚合数据包，该数据包包含两个多时间聚合单元，图中标记为1和2。</p>
<p>图12。一种RTP包，包括MTAP16型的多时间聚合包和两个多时间聚合单元。</p>
<p>图13展示了一个RTP数据包的示例，该数据包包含一个MTAP24类型的多时间聚合数据包，该数据包包含两个多时间聚合单元，图中标记为1和2。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          RTP Header                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |MTAP24 NAL HDR |  decoding order number base   | NALU 1 Size   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  NALU 1 Size  |  NALU 1 DOND  |       NALU 1 TS offs          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |NALU 1 TS offs |  NALU 1 HDR   |  NALU 1 DATA                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
      :                                                               :
      +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               | NALU 2 SIZE                   |  NALU 2 DOND  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       NALU 2 TS offset                        |  NALU 2 HDR   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  NALU 2 DATA                                                  |
      :                                                               :
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图13。一种RTP包，包括MTAP24型的多时间聚合包和两个多时间聚合单元。</p>
<h4 id="a5-8">5.8. 碎片单位（fus）</h4>

<p>这种有效载荷类型允许将一个NAL单元分割成几个RTP包。在应用层上这样做而不是依赖较低层的碎片（例如，通过IP）具有以下优点：</p>
<p>o有效载荷格式能够通过可能存在于预录视频中的IPv4网络传输大于64千字节的NAL单元，尤其是在高清晰度格式中（每个图片的片数有限制，这导致每个图片的NAL单元数限制，这可能导致NAL单元数大）。</p>
<p>o碎片机制允许对单个图片进行碎片化，并应用第12.5节中所述的一般正向错误纠正。</p>
<p>只为单个NAL单元定义碎片，而不为任何聚合数据包定义碎片。NAL单元的一个片段由该NAL单元的连续八位字节的整数组成。NAL单元的每个八位字节必须是该NAL单元的一个片段的一部分。同一NAL单元的片段必须以递增的RTP序列号连续发送（在第一个和最后一个片段之间发送的同一RTP包流中没有其他RTP包）。同样，NAL装置必须按照RTP序列号顺序重新组装。</p>
<p>当一个NAL单元被分割并在分割单元（fus）内传送时，它被称为一个分割的NAL单元。STAP和MTAP不得分割。fus不能嵌套；即fu不能包含另一个fu。</p>
<p>携带fu的rtp包的rtp时间戳设置为碎片NAL单元的NALU时间。</p>
<p>图14显示了fu as的rtp有效负载格式。FU-A由一个八位字节的碎片单元指示器、一个八位字节的碎片单元头和一个碎片单元有效载荷组成。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | FU indicator  |   FU header   |                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
      |                                                               |
      |                         FU payload                            |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图14.fu-a的rtp有效载荷格式</p>
<p>图15显示了fu bs的rtp有效负载格式。fu-b由一个八位字节的碎片单元指示器、一个八位字节的碎片单元头、解码顺序号（don）（按网络字节顺序）和碎片单元有效载荷组成。换言之，除了附加唐场外，傅B的结构与傅A的结构相同。</p>
<pre>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | FU indicator  |   FU header   |               DON             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
      |                                                               |
      |                         FU payload                            |
      |                                                               |
      |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               :...OPTIONAL RTP padding        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>图15。fu-b的rtp有效载荷格式</p>
<p>对于分散的NAL单元的第一个分段单元，必须在交错打包模式中使用类型为FU-B的NAL单元。在任何其他情况下，不得使用NAL FU-B型装置。换句话说，在交错打包模式中，每个被分割的NALU都有一个fu-b作为第一个片段，后面跟着一个或多个fu-a片段。</p>
<p>fu指示符八位字节的格式如下：</p>
<pre>
      +---------------+
      |0|1|2|3|4|5|6|7|
      +-+-+-+-+-+-+-+-+
      |F|NRI|  Type   |
      +---------------+
</pre>

<p>在fu指示符八位字节的类型字段中，值等于28和29分别标识fu-a和fu-b。第5.3节描述了F位的使用。NRI字段的值必须根据碎片NAL单位中的NRI字段的值进行设置。</p>
<p>fu头的格式如下：</p>
<pre>
      +---------------+
      |0|1|2|3|4|5|6|7|
      +-+-+-+-+-+-+-+-+
      |S|E|R|  Type   |
      +---------------+
</pre>

<p>S:1位</p>
<p>当设置为1时，起始位表示分段NAL单元的开始。当以下fu有效载荷不是分段NAL单元有效载荷的起始时，起始位设置为零。</p>
<p>E:1位</p>
<p>当设置为1时，结束位表示分段NAL单元的结束，即有效负载的最后一个字节也是分段NAL单元的最后一个字节。当下面的fu有效载荷不是一个分段的nal单元的最后一个片段时，结束位被设置为零。</p>
<p>R:1位</p>
<p>保留位必须等于0，并且必须被接收器忽略。</p>
<p>类型：5位</p>
<p>[1]表7-1中定义的NAL单位有效载荷类型。</p>
<p>根据第5.5节所述，选择Fu Bs中的Don值。</p>
<p>信息提示：fu-bs中的don字段允许网关将NAL单元拆分为fu-bs，而不将传入的NAL单元组织为NAL单元解码顺序。</p>
<p>一个分段的NAL单元不能在一个FU中传输；即，起始位和结束位不能同时设置为同一个FU头中的一个。</p>
<p>FU有效载荷由碎片化NAL单元的有效载荷的碎片组成，因此，如果连续FUS的碎片化单元有效载荷按顺序连接，则可以重建碎片化NAL单元的有效载荷。碎片化NAL单元的NAL单元类型八位字节不包括在碎片化单元有效载荷中，而是碎片化NAL单元的NAL单元类型八位字节的信息在碎片化单元的FU指示八位字节的F和NRI字段以及FU头的类型字段中传送。一个fu负载可以有任意数量的八位字节，并且可以是空的。</p>
<p>信息提示：允许空的fus在几乎无损的环境中减少某类发送者的延迟。这些发送者的特点是，他们在NALU完全生成之前打包NALU片段，因此，在NALU大小已知之前。如果不允许使用零长度的NALU片段，发送方必须生成以下片段的至少一位数据，然后才能发送当前片段。由于H.264的特点，有时</p>
<p>几个宏块占用零位，这是不需要的，可以增加延迟。但是，应仔细权衡零长度NALU的（潜在）使用，以防由于用于其传输的额外数据包而增加NALU丢失的风险。</p>
<p>如果碎片单元丢失，接收器应按照与同一碎片单元对应的传输顺序丢弃以下所有碎片单元。</p>
<p>端点或mane中的接收器可以将NAL单元的第一个n-1片段聚合为（不完整的）NAL单元，即使未接收到该NAL单元的片段n。在这种情况下，NAL单元的禁止零位必须设置为1，以指示语法冲突。</p>
<h3 id="a6">6. 包装规则</h3>

<p>第5.2节介绍了包装模式。第6.1节规定了多个打包模式通用的打包规则。单NAL单元模式、非交错模式和交错模式的打包规则分别在第6.2、6.3和6.4节中规定。</p>
<h4 id="a6-1">6.1. 通用包装规则</h4>

<p>无论使用何种打包模式，所有发送方都必须强制执行以下打包规则：</p>
<p>o属于同一编码图片的编码片NAL单元或编码片数据分区NAL单元（因此共享相同的RTP时间戳值）可以按照[1]中定义的适用配置文件允许的任何顺序发送；但是，对于延迟关键系统，应按照其原始编码顺序发送，以尽量减少延迟。注意，编码顺序不一定是扫描顺序，但是NAL包对RTP堆栈可用的顺序。</p>
<p>o参数集按照第8.4节给出的规则和建议进行处理。</p>
<p>o由于本备忘录和H.264规范均未提供识别重复NAL单元的方法，因此，除序列或图片参数设置NAL单元外，Manes不得复制任何NAL单元。序列和图片参数集NAL单元可以被复制，以使其正确接收更为可能，但任何此类复制不得影响任何活动序列或图片参数集的内容。重复应该是</p>
<p>在应用层上执行，而不是通过复制RTP数据包（具有相同的序列号）。</p>
<p>使用非交错模式和交错模式的发件人必须强制执行以下打包规则：</p>
<p>在RTP转换器中，许多人可以将单个NAL单元数据包转换为一个聚合数据包，将聚合数据包转换为多个单个NAL单元数据包，或者混合这两个概念。RTP转换器应至少考虑以下参数：路径MTU大小、不平等的保护机制（例如，根据RFC 2733[18]通过基于包的FEC，尤其是序列和图片参数集NAL单元和编码切片数据分区NAL单元）、系统可承受的延迟和缓冲能力F接收器。</p>
<p>提示性说明：根据RFC3550，需要一个RTP转换器来处理RTCP。</p>
<h4 id="a6-2">6.2. 单NAL单元模式</h4>

<p>当可选打包模式mime参数的值等于0、打包模式不存在或没有其他打包模式通过外部方式发出信号时，将使用此模式。所有接收器必须支持此模式。它主要用于与使用ITU-T建议H.241[15]的系统兼容的低延迟应用（见第12.1节）。此模式中只能使用单个NAL单元数据包。不能使用staps、mtaps和fus。单个NAL单元包的传输顺序必须符合NAL单元解码顺序。</p>
<h4 id="a6-3">6.3. 非交错模式</h4>

<p>当可选打包模式mime参数的值等于1或通过外部方式打开模式时，将使用此模式。应支持此模式。主要用于低延迟应用。此模式中只能使用单个NAL单元包、STAP AS和FU AS。不得使用stap bs、mtaps和fu bs。NAL单元的传输顺序必须符合NAL单元解码顺序。</p>
<h4 id="a6-4">6.4. 交错模式</h4>

<p>当可选打包模式mime参数的值等于2或通过外部方式打开模式时，将使用此模式。有些接收器可能支持此模式。可以使用stap bs、mtaps、fu as和fu bs。不得使用STAP AS和单NAL单元数据包。包和NAL单元的传输顺序受第5.5节规定的限制。</p>
<h3 id="a7">7. 去包装过程（资料性的)</h3>

<p>解包过程依赖于实现。因此，下面的描述应该被视为适当实现的示例。也可采用其他方案。与所述算法相关的优化可能是可行的。第7.1节介绍了单个NAL单元和非交错打包模式的去打包过程，而第7.2节描述了交错模式的过程。第7.3节包括智能接收器的附加去封装指南。</p>
<p>所有与缓冲区管理相关的正常RTP机制都适用。尤其是，重复或过时的RTP包（如RTP序列号和RTP时间戳所示）被删除。要确定解码的确切时间，必须考虑到可能的故意延迟等因素，以允许适当的流间同步。</p>
<h4 id="a7-1">7.1. 单NAL单元和非交错模式</h4>

<p>接收器包括用于补偿传输延迟抖动的接收器缓冲器。接收器按接收顺序将传入的数据包存储到接收器缓冲区中。数据包按RTP序列号顺序去封装。如果未封装的数据包是单个NAL单元数据包，则数据包中包含的NAL单元将直接传递给解码器。如果未封装的数据包是STAP-A，则数据包中包含的NAL单元将按封装在数据包中的顺序传递给解码器。如果一个去封装的包是一个fu-a，那么将断开的nal单元的所有片段连接起来并传递给解码器。</p>
<p>信息提示：如果解码器支持任意的切片顺序，则不管图像的接收和传输顺序如何，都可以按任意顺序将图像的编码切片传递给解码器。</p>
<h4 id="a7-2">7.2. 交错模式</h4>

<p>这些去封装规则背后的一般概念是将NAL单元从传输顺序重新排序到NAL单元解码顺序。</p>
<p>接收器包括一个接收器缓冲区，用于补偿传输延迟抖动，并将数据包从传输顺序重新排序到NAL单元解码顺序。在本节中，接收器操作是在没有传输延迟抖动的假设下描述的。为了与实际的接收器缓冲区（也用于补偿传输延迟抖动）有所不同，接收器缓冲区在本节中称为逐行扫描缓冲区之后。接收器还应准备传输延迟抖动；即，为传输延迟抖动缓冲和逐行缓冲预留单独的缓冲区，或者为传输延迟抖动和逐行缓冲同时使用接收器缓冲区。此外，在缓冲操作中，接收器应考虑传输延迟抖动；例如，在开始解码和回放之前，通过附加的初始缓冲。</p>
<p>本节组织如下：第7.2.1小节介绍了如何计算逐行扫描缓冲区的大小。第7.2.2小节规定了接收程序如何将接收到的NAL单元组织为NAL单元解码顺序。</p>
<h4 id="a7-2-1">7.2.1. 逐行扫描缓冲区的大小</h4>

<p>当会话设置中使用SDP提供/应答模型或任何其他功能交换过程时，接收流的属性应确保不超过接收器的能力。在sdp provide/answer模型中，接收器可以指示其使用deint-buf cap mime参数分配逐行扫描缓冲区的能力。发送方用sprop deint buf req mime参数指示逐行输入缓冲区大小的要求。因此，建议按字节数设置逐行扫描缓冲区大小，等于或大于sprop deint buf req mime参数的值。有关设计buf cap和sprop设计buf req mime参数的更多信息，请参见第8.1节；有关在SDP提供/应答模型中使用这些参数的更多信息，请参见第8.2.2节。</p>
<p>当在会话设置中使用声明性会话描述时，sprop deint buf req mime参数表示需要逐行输入缓冲区大小。因此，建议按字节数设置逐行扫描缓冲区大小，等于或大于sprop deint buf req mime参数的值。</p>
<h4 id="a7-2-2">7.2.2. 逐行扫描</h4>

<p>接收器中有两种缓冲状态：初始缓冲和播放时缓冲。初始化RTP会话时会发生初始缓冲。初始缓冲后，开始解码和回放，使用播放时缓冲模式。</p>
<p>不管缓冲状态如何，接收器按照接收顺序将传入的NAL单元存储在逐行缓冲区中，如下所示。聚合数据包的NAL单元单独存储在逐行扫描缓冲区中。计算并存储所有NAL单位的DON值。</p>
<p>在以下功能和常量的帮助下，接收器操作描述如下：</p>
<p>o第8.1节规定了ABSDON功能。</p>
<p>o第5.5节中规定了函数don_diff。</p>
<p>o constant n是可选sprop交织深度mime类型参数（见第8.1节）的值，递增1。</p>
<p>初始缓冲持续到满足以下条件之一：</p>
<p>o去隔行缓冲区中有n个VCL NAL单元。</p>
<p>o如果存在sprop max don diff，则don_diff（m，n）大于sprop max don diff的值，其中n对应接收到的NAL单位中absdon值最大的NAL单位，m对应接收到的NAL单位中absdon值最小的NAL单位。</p>
<p>o初始缓冲持续时间等于或大于可选sprop init buf time mime参数的值。</p>
<p>要从逐行扫描缓冲区中删除的NAL单位确定如下：</p>
<p>o如果逐行缓冲区包含至少n个VCL NAL单元，则NAL单元将从逐行缓冲区中删除，并按下面指定的顺序传递给解码器，直到缓冲区包含n-1个VCL NAL单元为止。</p>
<p>o如果存在sprop max don diff，则从逐行扫描缓冲区中删除所有don diff（m，n）大于sprop max don diff的NAL单元m，并按下面指定的顺序传递给解码器。在这里，n对应于接收到的nal单位中absdon值最大的nal单位。</p>
<p>NAL单元传递给解码器的顺序如下：</p>
<p>o让pdon成为在RTP会话开始时初始化为0的变量。</p>
<p>o对于与DON值相关的每个NAL单位，DON距离计算如下。如果NAL单位的don值大于pdon值，则don距离等于don-pdon。否则，don距离等于65535-pdon+don+1。</p>
<p>所有单元按数据距离的升序传送到解码器。如果几个NAL单元共享同一个DON距离值，它们可以以任何顺序传递给解码器。</p>
<p>o当向解码器传递了所需数量的NAL单元时，PDON的值设置为最后一个传递给解码器的NAL单元的DON值。</p>
<h4 id="a7-3">7.3. 额外的去包装指南</h4>

<p>可以使用以下附加的解包规则来实现可操作的H.264解包器：</p>
<p>o智能RTP接收器（例如，在网关中）可以识别丢失的编码切片数据分区A（DPA）。如果发现丢失的DPA，网关可能会决定不发送相应的编码切片数据分区B和C，因为它们的信息对于H.264解码器没有意义。通过这种方式，mane可以通过丢弃无用的数据包而不解析复杂的比特流来减少网络负载。</p>
<p>o智能RTP接收器（例如，在网关中）可识别丢失的保险丝。如果发现丢失的fu，网关可能会决定不发送相同碎片单元的以下fus，因为它们的信息对H.264解码器没有意义。通过这种方式，mane可以通过丢弃无用的数据包而不解析复杂的比特流来减少网络负载。</p>
<p>o必须丢弃数据包或NALU的智能接收器应首先丢弃所有数据包/NALU，其中NAL单元类型八位字节的NRI字段值等于0。这将最小化对用户体验的影响，并保持参考图片的完整性。如果需要丢弃更多的数据包，那么NRI值数值较低的数据包应该在NRI值数值较高的数据包之前丢弃。然而，丢弃任何NRI大于0的数据包很可能导致解码器漂移，应避免。</p>
<h3 id="a8">8. 有效载荷格式参数</h3>

<p>本节指定可用于选择有效负载格式的可选功能和位流的某些功能的参数。此处指定的参数是ITU-T H.264_ISO/IEC 14496-10编解码器的mime子类型注册的一部分。还为使用SDP的应用程序提供了会话描述协议（SDP）[5]中参数的映射。可在其他地方定义等效参数，用于不使用mime或sdp的控制协议。</p>
<p>一些参数为接收器提供将要发送的流的属性。所有这些参数的名称都以流属性的“sprop”开头。其中一些“sprop”参数受其他有效负载或编解码器配置参数的限制。例如，sprop参数集参数由profile level id参数约束。媒体发送器选择所有“sprop”参数，而不是接收器。“sprop”参数的这种不常见特性可能与某些信令协议概念不兼容，在这种情况下，应避免使用这些参数。</p>
<h4 id="a8-1">8.1. MIME注册</h4>

<p>ITU-T H.264_ISO/IEC 14496-10编解码器的mime子类型从ietf树中分配。</p>
<p>接收器必须忽略任何未指定的参数。</p>
<p>媒体类型名称：视频</p>
<p>媒体子类型名称：h264</p>
<p>所需参数：无</p>
<p>可选参数：</p>
<p>profile-level-id:</p>
<p>在[1]中指定的序列参数集合NAL单元中，以下三个字节的base16[6]（十六进制）表示：1）profile_idc，2）这里称为profile iop的字节，由constraint_set0_flag、constraint_set1_flag、constraint_set2_flag和reserved_zero_5bits的值按位显著性顺序组成，从最高有效位和3）级别_idc。请注意，在[1]中保留的“零位”必须等于0，但ITU-T或ISO/IEC以后可能会指定它的其他值。</p>
<p>如果profile level id参数用于指示NAL单元流的属性，则它指示解码器解码流时必须支持的配置文件和级别，以便符合[1]。profile iop字节指示NAL单元流是否也遵守以下所示配置文件的所有约束。如果剖面IOP的位7（最高有效位）、位6或位5等于1，则NAL单元流中分别遵守基线剖面、主剖面或扩展剖面的所有约束。</p>
<p>如果配置文件级别ID参数用于功能交换或会话设置过程，则表示编解码器支持的配置文件和信号配置文件支持的最高级别。profile iop字节表示编解码器是否有其他限制，因此编解码器仅支持用profile iop字节表示的profile和profile_idc指示的profile的算法特征和限制的公共子集。例如，如果编解码器仅支持基线配置文件和2.1级及以下主配置文件编码工具的公共子集，则配置文件级别ID将变为42e0 15，其中42表示基线配置文件，e0表示仅支持所有配置文件的公共子集，15表示2.1级。</p>
<p>信息提示：功能交换和会话设置过程应提供分别列出每个支持的编解码器配置文件的功能的方法。例如，可以使用SDP提供/应答模型的one-of-n编解码器选择过程（第10.2节，共[7]节）。</p>
<p>如果不存在配置文件级别ID，则必须隐含在级别1没有附加约束的基线配置文件。</p>
<p>max-mbps, max-fs, max-cpb, max-dpb, and max-br:</p>
<p>这些参数可以用来表示接收器实现的能力。这些参数不能用于任何其他目的。配置文件级别ID参数必须存在于包含任何这些参数的同一接收器功能描述中。在配置文件级别ID参数值中传递的级别必须使接收器完全能够支持。max-mbps、max-fs、max-cpb、max-dpb和max-br可用于指示接收器扩展信号电平所需能力的能力，如下所述。</p>
<p>当集合中存在多个参数（max mbps、max fs、max cpb、max dpb、max br）时，接收器必须同时支持所有信号能力。例如，如果同时存在最大Mbps和最大Br，则支持帧速率和比特率扩展的信号电平。也就是说，接收器能够解码NAL单元流，其中宏块处理速率高达最大Mbps（含），比特率高达最大Br（含），编码的图片缓冲区大小根据下面的max Br参数的语义推导，其他属性符合prof值中指定的级别。文件级ID参数。</p>
<p>接收器不得发出满足更高级别要求的最大Mbps、最大fs、最大cpb、最大dpb和最大br的信号值，</p>
<p>这里称为A级，与profile-level id参数值中指定的级别相比，如果接收器可以支持A级的所有属性。</p>
<p>提示性说明：当可选的mime类型参数用于信号NAL单元流的属性时，不存在max mbps、max fs、max cpb、max dpb和max br，并且配置文件级别ID的值必须始终使NAL单元流完全符合指定的配置文件和级别。</p>
<p>max-mbps:</p>
<p>max-mbps的值是一个整数，以每秒宏块的单位表示最大宏块处理速率。max mbps参数表示接收器能够以高于配置文件级别ID参数值中所传输信号级别所需的速率解码视频。当发出最大Mbps信号时，接收器必须能够解码符合信号电平的NAL单元流，除非信号电平的表A-1中的最大Mbps值被最大Mbps值替换。对于[1]的表A-1中给出的级别，max mbps的值必须大于或等于maxmbps的值。发送方可以使用此知识以高于信号级别指示的图片速率发送给定大小的图片。</p>
<p>max-fs：</p>
<p>max-fs的值是一个整数，以宏块为单位表示最大帧大小。max fs参数表示接收器能够解码比配置文件级别id参数值中所传输的信号级别所需的更大的图片大小。当发出max fs信号时，接收器必须能够解码符合信号电平的NAL单元流，除非[1]表A-1中信号电平的maxfs值替换为max fs值。对于[1]的表A-1中给出的级别，max fs的值必须大于或等于maxfs的值。发件人可以使用此知识在</p>
<p>成比例地比信号电平中所示的低帧速率。</p>
<p>最大cpb最大cpb值是一个整数，表示VCL HRD参数的最大编码图片缓冲区大小，单位为1000位（见[1]的A.3.1第i项），NAL HRD参数的单位为1200位（见[1]的A.3.1第j项）。max cpb参数表示接收器的内存大于profile level id参数值中传输的信号级别所需的最小编码图片缓冲内存量。当发出max cpb信号时，接收器必须能够解码符合信号电平的NAL单元流，除非信号电平的表A-1中的maxcpb值被max cpb值替换。对于[1]的表A-1中给出的级别，max cpb的值必须大于或等于maxcpb的值。发送方可以利用这一知识来构造编码视频流，其比特率变化比[1]表A-1中的maxcpb值所能实现的变化大。</p>
<p>说明：编码图片缓冲区用于H.264的假设参考解码器（附录C）。建议在H.264编码器中使用假设的参考解码器，以验证生成的比特流是否符合标准并控制输出比特率。因此，编码图片缓冲区在概念上独立于接收器中的任何其他潜在缓冲区，包括去交织和去抖动缓冲区。编码图片缓冲区不需要按照H.264附录C的规定在解码器中实现，但是，如果符合标准的解码器能够解码符合标准的比特流，那么它们可以有任何缓冲安排。因此，在实际应用中，视频解码器的输入缓冲区可以与接收机的去交织和去抖动缓冲区相结合。</p>
<p>max-dpb：</p>
<p>max-dpb的值是一个整数，表示最大解码图片缓冲区大小，单位为1024字节。max dpb参数表示接收器的内存大于配置文件级别id参数值中传输的信号级别所需的最小解码图像缓冲内存量。当发出max dpb信号时，接收器必须能够解码符合信号电平的NAL单元流，除非信号电平的表A-1中的maxdpb值被max dpb值替换。因此，信号最大dpb的接收器必须能够在其解码图像缓冲区中存储以下数量的解码帧、互补字段对和非配对字段：</p>
<p>最小（1024<em>max dpb/（picWidthinmbs</em>frameHeightinmbs<em>256</em>chromaFormatfor），16）</p>
<p>picwidthinmbs、frameheightinmbs和chromaFormatfort在[1]中定义。</p>
<p>对于[1]的表A-1中给出的级别，max dpb的值必须大于或等于maxdpb的值。发送者可以利用这一知识来构造具有改进压缩的编码视频流。</p>
<p>提示性说明：该参数主要是为了补充ITU-T建议H.245中类似的代码点，以便于信令网关设计。解码后的图片缓冲区存储重建的样本，并且仅为视频解码器的属性。解码图像缓冲区的大小与RTP中使用的缓冲区没有关系，特别是去交织和去抖动缓冲区。</p>
<p>max-br：</p>
<p>max-br的值是一个整数，表示VCL HRD参数的最大视频比特率，单位为每秒1000位（见[1]的A.3.1第i项），单位为1200位。</p>
<p>NAL HRD参数每秒（见[1]的A.3.1第j项）。</p>
<p>max-br参数表示接收器的视频解码器能够以高于profile level id参数值中传输的信号电平所需的比特率解码视频。对于[1]的表A-1中给出的级别，max-br的值必须大于或等于maxbr的值。</p>
<p>当发出max-br信号时，接收器的视频编解码器必须能够解码符合信号电平的NAL单元流，该电平在profile level id参数中传输，但在该电平指定的限值中有以下例外：</p>
<p>o max-br值代替信号电平的maxbr值（见[1]表A-1）。</p>
<p>o当max cpb参数不存在时，以下公式的结果将替换[1]表A-1中maxcpb的值：（信号电平的maxcpb）*信号电平的max br/（maxbr）。</p>
<p>例如，如果1.2级接收器信号能力的最大Br等于1550，则表示VCL hrd参数的最大视频比特率为1550 kbits/sec，NAL hrd参数的最大视频比特率为1860 kbits/sec，CPB大小为4036458位（1550000/384000<em>1000</em>1000）。</p>
<p>对于[1]表A-1中给出的信号电平，max-br的值必须大于或等于maxbr。</p>
<p>发送方可以使用此知识发送H.264附录A级别定义中允许的更高比特率视频，以提高视频质量。</p>
<p>提示性说明：该参数主要是为了补充ITU-T建议H.245中类似的代码点，以便于信令网关设计。不能从</p>
<p>网络能够在任何给定时间处理这种比特率的参数。特别是，不能得出在拥塞控制约束下信号比特率是可能的结论。</p>
<p>redundant-pic-cap:</p>
<p>此参数表示接收器实现的能力。当等于0时，该参数表示接收器没有尝试使用冗余编码图片来纠正错误解码的主编码图片。当等于0时，接收器不能使用冗余片；因此，发送方应避免发送冗余片以节省带宽。当等于1时，接收器能够解码覆盖主解码图像中损坏区域的任何冗余片（至少部分），因此发送方可以发送冗余片。当参数不存在时，必须将0值用于冗余PIC CAP。当存在时，冗余pic cap的值必须为0或1。</p>
<p>当配置文件级别ID参数与冗余pic cap参数在相同的能力信令中存在，并且配置文件级别ID中指示的配置文件不允许使用冗余编码图片（例如主配置文件）时，冗余pic cap的值必须等于0。当接收器指示冗余的pic cap等于0时，接收的流不应包含冗余的编码图片。</p>
<p>提示：即使冗余pic cap等于0，解码器也可以忽略冗余的编解码器图片，前提是解码器支持这样一个配置文件（基线、扩展），其中允许冗余的编码图片。</p>
<p>提示性说明：即使冗余pic cap等于1，接收器也可以选择其他错误隐藏策略来</p>
<p>替换或补充冗余片的解码。</p>
<p>sprop-parameter-sets:</p>
<p>此参数可用于传输任何序列和图像参数集NAL单元（此处称为初始参数集NAL单元），该序列和图像参数集NAL单元必须在解码顺序中位于任何其他NAL单元之前。参数不能用于指示任何功能交换过程中的编解码器功能。参数值是初始参数集NAL单位的base64[6]表示，如[1]第7.3.2.1和7.3.2.2节所规定。参数集按解码顺序传输，不发生参数集NAL单元的帧。逗号用于分隔列表中的任何一对参数集。请注意，参数集NAL单元中的字节数通常小于10，但图片参数集NAL单元可以包含数百个字节。</p>
<p>提示性说明：当在SDP提供/应答模型中提供多个有效载荷类型时，每个类型都有自己的sprop参数-集参数，那么接收器不能假定这些参数集不使用冲突的存储位置（即参数集标识符的相同值）。因此，接收器应该对所有sprop参数集进行双重缓冲，并使它们对解码某一负载类型的解码器实例可用。</p>
<p>parameter-add:</p>
<p>此参数可用于指示是否允许此参数的接收器使用sprop参数sets mime参数在其信号响应中添加参数集。此参数的值为0或1。0等于false，即不允许添加参数集。1等于真，即允许增加参数集。如果参数不存在，则其值必须为1。</p>
<p>packetization-mode:</p>
<p>此参数表示RTP有效负载类型的属性或接收器实现的能力。只能指示一个配置点；因此，当声明支持多个打包模式的功能时，必须使用多个配置点（RTP负载类型）。</p>
<p>当打包模式的值等于0或不存在打包模式时，必须使用RFC 3984第6.2节中定义的单一NAL模式。该模式在使用ITU-T建议H.241[15]的标准中使用（见第12.1节）。当打包模式的值等于1时，必须使用RFC 3984第6.3节中定义的非交错模式。当打包模式的值等于2时，必须使用RFC 3984第6.4节中定义的交错模式。打包模式的值必须是0到2（包括0和2）范围内的整数。</p>
<p>sprop-interleaving-depth:</p>
<p>当不存在打包模式或打包模式的值等于0或1时，此参数不能存在。当打包模式的值等于2时，此参数必须存在。</p>
<p>此参数表示NAL单元流的属性。它以传输顺序指定NAL单元流中任何VCL NAL单元之前的VCL NAL单元的最大数目，并按照解码顺序跟随VCL NAL单元。因此，当NAL单元解码顺序恢复的缓冲区大小至少为SPROP-交织深度+1的VCL NAL单元值时，接收机可以重建NAL单元解码顺序。</p>
<p>sprop交织深度的值必须是0到32767（含）范围内的整数。</p>
<p>sprop-deint-buf-req:</p>
<p>当不存在打包模式或打包模式的值等于0或1时，此参数不能存在。当打包模式的值等于2时，它必须存在。</p>
<p>sprop deint buf req向NAL单元流的逐行扫描缓冲区的所需大小发出信号。参数值必须大于或等于RFC 3984第7.2节中规定的这种逐行缓冲区所需的最大缓冲区占用率（以字节为单位）。当逐行缓冲区大小至少为sprop-deint-buf-req的字节值时，保证接收机可以将交错的NAL单元逐行逐行转换为NAL单元解码顺序。</p>
<p>sprop deint buf req的值必须是0到4294967295（含）范围内的整数。</p>
<p>提示性说明：sprop deint buf req仅指示逐行缓冲区的所需大小。当网络抖动可能发生时，还必须为其提供适当大小的抖动缓冲区。</p>
<p>deint-buf-cap:</p>
<p>此参数表示接收器实现的能力，并指示接收器可用于重建NAL单元解码顺序的以字节为单位的逐行输入缓冲区空间量。接收器能够处理sprop deint buf req参数值小于或等于此参数的任何流。</p>
<p>如果参数不存在，则必须将值0用于除盐缓冲罐盖。Deint Buf Cap的值必须是0到4294967295（含）范围内的整数。</p>
<p>提示性说明：Deint Buf Cap仅指示接收器的逐行缓冲区的最大可能大小。</p>
<p>当网络抖动可能发生时，还必须为其提供适当大小的抖动缓冲区。</p>
<p>sprop-init-buf-time:</p>
<p>此参数可用于向NAL单元流的属性发送信号。如果打包模式的值等于0或1，则参数不能存在。</p>
<p>该参数表示接收器在开始解码之前必须缓冲的初始缓冲时间，以从传输顺序恢复NAL单元解码顺序。参数是（NAL单元的传输时间-NAL单元的解码时间）的最大值，假设传输可靠且瞬时，传输和解码的时间线相同，并且在第一个数据包到达时开始解码。</p>
<p>下面是指定sprop init buf time值的示例。NAL单元流按以下交错顺序发送，其中值对应解码时间，传输顺序从左到右：</p>
<p>0 2 1 3 5 4 6 8 7…</p>
<p>假设NAL装置的传输速率稳定，则传输时间为：</p>
<p>0 1 2 3 4 5 6 7 8…</p>
<p>从“传输时间”列中减去解码时间将得到以下序列：</p>
<p>0-1 1 0-1 1 0-1 1…</p>
<p>因此，根据NAL单位传输时间的间隔，本例中sprop init buf time的值为1。</p>
<p>该参数被编码为非负的base10整数表示，以90-kHz时钟的时钟周期为单位。如果参数不存在，则不定义初始缓冲时间值。否则，sprop init-buf time的值必须是0到4294967295（包括0和4294967295）之间的整数。</p>
<p>除了发出信号的sprop init buf时间外，接收器还应考虑传输延迟抖动缓冲，包括混音器、翻译器、网关、代理、流量整形器和其他网络元素引起的延迟抖动的缓冲。</p>
<p>sprop-max-don-diff:</p>
<p>此参数可用于向NAL单元流的属性发送信号。它不能用于信号发送器或接收器或编解码器功能。如果打包模式的值等于0或1，则参数不能存在。sprop max don diff是一个介于0到32767（含）之间的整数。如果sprop max don diff不存在，则参数值未指定。sprop max-don diff计算如下：</p>
<p>sprop max don diff=max absdon（i）-absdon（j），对于任何i和任何j&gt;i，</p>
<p>其中i和j表示NAL单元在传输顺序中的索引，absdon表示NAL单元的解码顺序号，该编号在65535之后不为0。换言之，absdon的计算如下：让m和n为传输顺序中的连续nal单位。对于传输顺序中的第一个NAL单元（其索引为0），absdon（0）=don（0）。对于其他NAL装置，ABSDON的计算如下：</p>
<p>If DON(m) == DON(n), AbsDON(n) = AbsDON(m)</p>
<p>If (DON(m) &lt; DON(n) and DON(n) - DON(m) &lt; 32768),</p>
<p>AbsDON(n) = AbsDON(m) + DON(n) - DON(m)</p>
<p>If (DON(m) &gt; DON(n) and DON(m) - DON(n) &gt;=32768),</p>
<p>AbsDON(n) = AbsDON(m) + 65536 - DON(m) + DON(n)</p>
<p>If (DON(m) &lt; DON(n) and DON(n) - DON(m) &gt;=32768),</p>
<p>AbsDON(n) = AbsDON(m) - (DON(m) + 65536 -DON(n))</p>
<p>If (DON(m) &gt; DON(n) and DON(m) - DON(n) &lt;32768),</p>
<p>AbsDON(n) = AbsDON(m) - (DON(m) - DON(n))</p>
<p>其中，don（i）是在传输顺序中具有索引i的NAL单元的解码顺序号。解码顺序号见RFC 3984第5.5节。</p>
<p>信息提示：接收器可以使用sprop max don diff触发接收器缓冲区中哪些NAL单元可以传递给解码器。</p>
<p>max-rcmd-nalu-size:</p>
<p>此参数可用于信号接收器的能力。参数不能用于任何其他目的。参数值表示接收器可以有效处理的最大NALU大小（字节）。参数值是建议值，而不是严格的上限。发送方可以创建更大的NALU，但必须注意，处理这些NALU的成本可能高于符合限制的NALU。</p>
<p>最大Rcmd Nalu大小的值必须是0到4294967295（含）范围内的整数。如果未指定此参数，则不存在对NALU大小的已知限制。发送方仍然必须考虑发送方和接收方之间可用的MTU大小，并为此目的运行MTU发现。</p>
<p>例如，这个参数的动机是IP到H.223视频电话网关，其中Nalus小于H.223传输数据。</p>
<p>单位效率会更高。网关可能会终止IP；因此，MTU发现通常不会在网关之外工作。</p>
<p>提示性说明：将此参数设置为低于必要值可能会产生负面影响。</p>
<p> Encoding considerations:</p>
<p>此类型仅为通过RTP（RFC 3550）传输而定义。</p>
<p>[29]中定义了H.264/AVC视频的文件格式。此定义由其他文件格式使用，例如3gpp多媒体文件格式（mime-type-video/3gpp）[30]或mp4文件格式（mime-type-video/mp4）。</p>
<p>Security considerations:</p>
<p>See section 9 of RFC 3984.</p>
<p>Public specification:</p>
<p>Please refer to RFC 3984 and its section 15.</p>
<p>Additional information:</p>
<p>None</p>
<p>File extensions:     none</p>
<p>Macintosh file type code: none</p>
<p>Object identifier or OID: none</p>
<p>Person &amp; email address to contact for further information: <a href="mailto:&#115;&#x74;&#101;&#119;&#101;&#x40;&#115;&#116;&#x65;&#x77;&#x65;&#x2e;&#x6f;&#x72;&#x67;">&#115;&#x74;&#101;&#119;&#101;&#x40;&#115;&#116;&#x65;&#x77;&#x65;&#x2e;&#x6f;&#x72;&#x67;</a></p>
<p>Intended usage:      COMMON</p>
<p>Author: <a href="mailto:&#x73;&#x74;&#x65;&#x77;&#x65;&#64;&#x73;&#x74;&#101;&#119;&#x65;&#x2e;&#111;&#114;&#x67;">&#x73;&#x74;&#x65;&#x77;&#x65;&#64;&#x73;&#x74;&#101;&#119;&#x65;&#x2e;&#111;&#114;&#x67;</a></p>
<p>Change controller: IETF Audio/Video Transport working group delegated from the IESG.</p>
<h4 id="a8-2">8.2. SDP参数</h4>
<h4 id="a8-2-1">8.2.1. 将mime参数映射到sdp</h4>

<p>mime media type video/h264字符串映射到会话描述协议（sdp）[5]中的字段，如下所示：</p>
<p>o SDP“m=”行中的媒体名称必须是视频。</p>
<p>o sdp的“a=rtpmap”行中的编码名称必须是h264（mime子类型）。</p>
<p>o“a=rtpmap”行中的时钟速率必须为90000。</p>
<p>o可选参数”profile-level-id”, “max-mbps”, “max-fs”, “max-cpb”, “max-dpb”, “max-br”, “redundant-pic-cap”, “sprop- parameter-sets”, “parameter-add”, “packetization-mode”, “sprop- interleaving-depth”, “deint-buf-cap”, “sprop-deint-buf-req”, “sprop-init-buf-time”, “sprop-max-don-diff”, and “max-rcmd-nalu-size”在出现时必须为包含在SDP的“a=fmtp”行中。这些参数表示为一个mime媒体类型字符串，格式为参数=值对的分号分隔列表。</p>
<p>SDP中的媒体表示示例如下（基线配置文件，3.0级，可能不遵守主配置文件的某些约束）：</p>
<p>m=video 49170 RTP/AVP 98</p>
<p>a=rtpmap:98 H264/90000</p>
<p>a=fmtp:98 profile-level-id=42A01E;</p>
<p>sprop-parameter-sets=Z0IACpZTBYmI,aMljiA==</p>
<h4 id="a8-2-2">8.2.2. 使用SDP提供/应答模型</h4>

<p>当H.264通过使用SDP在提供/应答模型[7]中的RTP提供用于协商单播使用时，以下限制和规则适用</p>
<p>o标识H.264媒体格式配置的参数为“配置文件级别ID”、“打包模式”，如果“打包模式”有要求，“sprop deint buf req”。这三个参数必须对称使用；即，如果一个或多个参数值不受支持，应答器必须维护所有配置参数或完全删除媒体格式（有效负载类型）。</p>
<p>提示性说明：对称使用的要求仅适用于上述三个参数，而不适用于其他流属性和能力参数。</p>
<p>为了简化这些配置的处理和匹配，如[7]中所述，应答中还应使用报价中使用的相同RTP有效负载类型号。除非配置（“配置文件级别ID”、“打包模式”，如果存在，“sprop deint buf req”）与报价中的配置相同，否则答案不得包含报价中使用的有效负载类型号。</p>
<p>提示性说明：报价人在收到答复时，必须根据媒体类型（即视频/H264）和上述三个参数，将报价中未声明的有效载荷类型与报价中已声明的任何有效载荷类型进行比较，以确定所讨论的配置是新配置还是与已提供的配置等效。</p>
<p>o参数”sprop-parameter-sets”, “sprop-deint-buf-req”, “sprop-interleaving-depth”, “sprop-max-don-diff”, and “sprop-init-buf-time”描述了提供方或应答方为该介质格式配置发送的NAL单元流的属性。这与通常使用的offer/answer参数不同：通常，这些参数声明提供方或应答方能够接收的流的属性。在处理H.264时，提供方假设应答方能够接收使用所提供配置编码的媒体。</p>
<p>提示性说明：上述参数适用于由具有相同配置的声明实体发送的任何流，即它们依赖于它们的源。这些值在发送时可能必须应用于另一种有效负载类型，而不是绑定到有效负载类型，因为它们适用于配置。</p>
<p>o能力参数（”max-mbps”, “max-fs”, “max-cpb”, “max-dpb”, “max-br”, ,”redundant-pic-cap”, “max-rcmd-nalu-size”)可用于声明进一步的能力。它们的解释取决于方向属性。当direction属性为sendOnly时，参数描述了RTP包和发送方能够生成的NAL单元流的限制。当direction属性为sendrecv或recvoonly时，参数描述了接收器接受的限制。</p>
<p>o如上所述，对于交错的H.264流，提供程序必须在提供中包含逐行缓冲区的大小。为了使报价人和应答人相互了解他们的逐行缓冲能力，建议双方都包括“逐行缓冲容量”。当在第二轮报价和应答中选择了“sprop deint buf req”的值时，可以使用此信息。对于交错流，还建议在接收器的能力未知时，考虑提供具有不同缓冲要求的多个有效负载类型。</p>
<p>o如上文所述，使用“sprop参数集”参数。此外，应答者必须在应答中维护报价中收到的所有参数集。根据“参数添加”参数的值，应用不同的规则：如果“参数-添加”为假（0），则答案不得添加任何其他参数集。如果“参数添加”为真（1），则应答器在其答案中可以向“sprop-参数集”参数添加其他参数集。回答者还必须接受使用答案中声明的sprop参数集接收视频流，而不受“参数添加”值的影响。</p>
<p>提示性说明：添加参数集时必须小心，不要使用冲突的参数集标识符覆盖已传输的参数集。</p>
<p>对于通过多播传递的流，还应用以下规则：</p>
<p>o流属性参数(“sprop-parameter-sets”, “sprop-deint-buf-req”, “sprop-interleaving-depth”, “sprop-max-don-diff”,and “sprop-init-buf-time”)不得由应答器更改。因此，一个有效载荷类型既可以被接受，也可以被删除。</p>
<p>o对于声明为sendrecv或recvoonly的所有流，应答器必须支持接收器功能参数”max-mbps”, “max-fs”, “max-cpb”, “max-dpb”, “max-br”, and “max-rcmd-nalu-size”；否则，必须执行以下操作之一：删除媒体格式或拒绝会话。</p>
<p>o对于声明为sendrecv或recvoonly的所有流，应答器应支持接收能力参数冗余pic cap，如下所示：如果提供程序指示冗余pic cap等于0，应答器不应在传输流中包含冗余编码图片。否则（当冗余图片上限等于1时），建议回答者如何使用冗余编码图片超出本备忘录的范围。</p>
<p>以下是在不同的报价或回答和方向属性组合中如何解释不同参数的完整列表。</p>
<p>o在使用“a=sendrecv”或“no direction”属性的报价和应答中，或在使用“a=recvoonly”的报价和应答中，必须使用以下参数解释。</p>
<p>声明接收的实际配置或属性：</p>
<ul>
<li><p>profile-level-id</p>
</li>
<li><p>packetization-mode</p>
</li>
</ul>
<p>声明要发送的流的实际属性（适用仅当“a=sendrecv”或不使用direction属性时）：</p>
<ul>
<li><p>sprop-deint-buf-req</p>
</li>
<li><p>sprop-interleaving-depth</p>
</li>
<li><p>sprop-parameter-sets</p>
</li>
<li><p>sprop-max-don-diff</p>
</li>
<li><p>sprop-init-buf-time</p>
</li>
</ul>
<p>声明接收器实现功能：</p>
<ul>
<li><p>max-mbps</p>
</li>
<li><p>max-fs</p>
</li>
<li><p>max-cpb</p>
</li>
<li><p>max-dpb</p>
</li>
<li><p>max-br</p>
</li>
<li><p>redundant-pic-cap</p>
</li>
<li><p>deint-buf-cap</p>
</li>
<li><p>max-rcmd-nalu-size</p>
</li>
</ul>
<p>宣布如何进行报价/应答谈判：</p>
<ul>
<li>parameter-add</li>
</ul>
<p>o在媒体流包含方向属性“a=sendOnly”的报价或回答中，必须使用以下参数解释：</p>
<p>声明拟发送流的实际配置和属性：</p>
<ul>
<li><p>profile-level-id</p>
</li>
<li><p>packetization-mode</p>
</li>
<li><p>sprop-deint-buf-req</p>
</li>
<li><p>sprop-max-don-diff</p>
</li>
<li><p>sprop-init-buf-time</p>
</li>
<li><p>sprop-parameter-sets</p>
</li>
<li><p>sprop-interleaving-depth</p>
</li>
</ul>
<p>声明发送方在接收流时的功能：</p>
<ul>
<li><p>max-mbps</p>
</li>
<li><p>max-fs</p>
</li>
<li><p>max-cpb</p>
</li>
<li><p>max-dpb</p>
</li>
<li><p>max-br</p>
</li>
<li><p>redundant-pic-cap</p>
</li>
<li><p>deint-buf-cap</p>
</li>
<li><p>max-rcmd-nalu-size</p>
</li>
</ul>
<p>宣布如何进行报价/应答谈判：</p>
<ul>
<li>parameter-add</li>
</ul>
<p>此外，还需要考虑以下因素：</p>
<p>o用于声明接收器功能的参数通常是可降级的；即，它们表示发送者可能行为的上限。因此，发送方可以选择仅使用这些参数的较低/较小或相等值来设置其编码器。”sprop参数集“不能在发送方的能力声明中使用，因为参数集内携带的值的限制与使用的配置文件和级别是隐式的。</p>
<p>o声明配置点的参数不可降级，但“profile level id”参数的级别部分除外。这表示接收者期望使用的值，并且必须在发送方逐字使用。</p>
<p>o当一个发送者的能力被声明，并且在这个声明中使用了不可降级的参数时，这些参数表示一个可接受的配置。为了实现高互操作性级别，通常建议提供多种可选配置，例如，对于打包模式。在一种有效载荷类型中不可能提供多种配置。因此，当进行多个配置提供时，每个提供都需要与其相关联的RTP有效负载类型。</p>
<p>o接收器应该理解所有的mime参数，即使它只支持有效负载格式功能的一个子集。这确保了接收者能够理解何时一个接收介质的提议可以被降级到该提议的接收者所支持的内容。</p>
<p>o回答者可以通过附加的媒体格式配置扩展报价。但是，为了实现它们的使用，在大多数情况下，需要从提供方提供第二个提供，以提供媒体发送方将使用的流属性参数。这也影响到报价人必须能够接收这种媒体格式配置，而不仅仅是发送它。</p>
<p>o如果要约人希望在发送和接收之间具有非对称能力，要约人必须提供不同的RTP会话，即分别声明为“recvoonly”和“sendOnly”的不同媒体行。这可能对系统有进一步的影响。</p>
<h4 id="a8-2-3">8.2.3. 声明性会话描述中的用法</h4>

<p>当H.264 over RTP以声明性的方式与SDP一起提供时，如RTSP[27]或SAP[28]中所述，需要考虑以下因素。</p>
<p>o所有能够指示NAL单元流和接收器属性的参数都用于指示NAL单元流的属性。例如，在这种情况下，参数“profile level id”声明流使用的值，而不是发送者的功能。这导致必须使用以下参数解释：</p>
<p>声明实际配置或属性：</p>
<ul>
<li><p>profile-level-id</p>
</li>
<li><p>sprop-parameter-sets</p>
</li>
<li><p>packetization-mode</p>
</li>
<li><p>sprop-interleaving-depth</p>
</li>
<li><p>sprop-deint-buf-req</p>
</li>
<li><p>sprop-max-don-diff</p>
</li>
<li><p>sprop-init-buf-time</p>
</li>
</ul>
<p>Not usable:</p>
<ul>
<li><p>max-mbps</p>
</li>
<li><p>max-fs</p>
</li>
<li><p>max-cpb</p>
</li>
<li><p>max-dpb</p>
</li>
<li><p>max-br</p>
</li>
<li><p>redundant-pic-cap</p>
</li>
<li><p>max-rcmd-nalu-size</p>
</li>
<li><p>parameter-add</p>
</li>
<li><p>deint-buf-cap</p>
</li>
</ul>
<p>o要求SDP的接收者支持所提供参数的所有参数和值；否则，接收者必须拒绝（RTSP）或不参与（SAP）会话。它取决于会话的创建者使用接收应用程序预期支持的值。</p>
<h4 id="a8-3">8.3. 示例</h4>

<p>预期双方同时发送和接收的SIP提供/应答交换如下所示。仅显示SDP的媒体编解码器特定部分。由于文本约束，某些行被换行。</p>
<p>报价人-&gt;应答SDP消息：</p>
<p>上面提供了三种不同的打包格式中相同的编解码器配置。pt 98表示单NALU模式，pt 99表示非交织模式；pt 100表示交织模式。在交错模式的情况下，如果答案表明支持Pt100，报价人将使用的交错参数也包括在内。在这三种情况下，参数“sprop parameter sets”表示当从提供方接收流时，应答方需要的初始参数集。</p>
<p>（配置文件级别ID和打包模式）被接受。请注意，“sprop参数集”的值尽管在上面的示例中相同，但对于每种有效载荷类型可能不同。</p>
<p>answer-&gt;offer sdp消息：</p>
<pre> m=video 49170 RTP/AVP 100 99 97
     a=rtpmap:97 H264/90000
     a=fmtp:97 profile-level-id=42A01E; packetization-mode=0;
               sprop-parameter-sets=Z0IACpZTBYmI,aMljiA==,As0DEWlsIOp==,
               KyzFGleR
     a=rtpmap:99 H264/90000
     a=fmtp:99 profile-level-id=42A01E; packetization-mode=1;
               sprop-parameter-sets=Z0IACpZTBYmI,aMljiA==,As0DEWlsIOp==,
               KyzFGleR; max-rcmd-nalu-size=3980
     a=rtpmap:100 H264/90000
     a=fmtp:100 profile-level-id=42A01E; packetization-mode=2;
               sprop-parameter-sets=Z0IACpZTBYmI,aMljiA==,As0DEWlsIOp==,
               KyzFGleR; sprop-interleaving-depth=60;
               sprop-deint-buf-req=86000; sprop-init-buf-time=156320;
               deint-buf-cap=128000; max-rcmd-nalu-size=3980
</pre>

<p>由于要约/应答协商包括发送流和接收流，因此要约表示要约人愿意接收的确切参数，而应答表示应答人接受接收的相同参数。在这种情况下，报价人声明愿意接受98型有效载荷。应答器通过声明等效的有效负载类型97来接受这一点；即，它对于三个参数“profile level id”、“packetization mode”和“sprop deint buf req”具有相同的值。这对要约人和回答人都具有以下关于声明属性的参数的含义。报价人最初在pt=98的有效载荷定义中声明了“sprop参数集”的某个值。然而，由于应答者接受此为pt=97，当报价人发送pt=97时，必须使用pt=98中“sprop参数集”的值。同样，当应答者向报价者发送pt=98时，它必须使用pt=97中声明的属性参数。</p>
<p>应答器还接受负载类型99和100表示的两种配置的接收。它为应答器提供初始参数集，以提供应答器方向，并缓冲相关参数，以用于发送有效负载类型。它还通过提供一个“deint buf cap”参数，向提供方提供其逐行操作的内存限制。只有当发盘人决定第二次发盘时，这一点才有用，因为它可以考虑到新的价值。“最大RCMD NALU-尺寸”表示应答器可以有效地处理NALU多达</p>
<p>大小为3980字节。但是，不能保证网络支持这种大小。</p>
<p>请注意，上面示例中的参数集并不代表H.264编解码器的合法操作点。base64字符串仅用于说明。</p>
<h4 id="a8-4">8.4. 参数设置注意事项</h4>

<p>H.264参数集是视频编解码器的基本组成部分，对其操作至关重要；请参见第1.2节。由于它们的特点和对解码过程的重要性，丢失或错误传输的参数集很难在接收机本地隐藏。对损坏参数集的引用通常会对解码过程产生致命的结果。例如，由于参数集数据结构的错误传输或丢失，以及由于参数集更新的不及时传输，可能会发生损坏。因此，以下建议是为RTP发送方的实施者提供的指南。</p>
<p>参数集Nalus可以使用三种不同的原则进行传输：</p>
<p>a.在实际RTP会话之前使用会话控制协议（带外）。</p>
<p>b.在正在进行的RTP会话期间使用会话控制协议（带外）。</p>
<p>c.在正在进行的RTP会话期间，在有效负载（带内）中的RTP流中。</p>
<p>有必要在会话控制协议中实现原则A和原则B。SIP和SDP可按照SDP提供/应答模型和本备忘录前几节中的描述使用。本节包含如何在会话控制协议中实现原则A和原则B的指南。它独立于所使用的特定协议。原则C由本规范中定义的RTP有效负载格式支持。</p>
<p>除非为RTP提供可靠的传输，否则不应在RTP负载中传输图片和序列参数集NALU，因为任何一种类型的参数集丢失都可能会阻止对相应RTP流的相当一部分进行解码。因此，建议使用可靠的会话控制协议（即使用上述原理A或B）传输参数集。</p>
<p>在本节的其余部分，假设带外信令提供参数集NALU的可靠传输，而带内信令则不提供。如果使用参数集的带内信令，发送方应考虑到错误特性，并使用机制为正确传递参数集提供高概率。提高正确接收概率的机制包括包重复、FEC和重传。使用不可靠的带外控制协议与带内信令（可能丢失）有相似的缺点，此外，还可能导致同步困难（见下文）。因此，不建议这样做。</p>
<p>在会话的生命周期内，可以使用原则B和C添加或更新参数集。要求参数集在引用它们的NAL单元之前存在于解码器中。更新或添加参数集可能会导致进一步的问题，因此应考虑以下建议。</p>
<p>-当添加或更新参数集时，原则C容易受到上述传输错误的影响，因此建议采用原则B。</p>
<p>-在添加或更新参数集时，应注意确保在使用任何参数集之前传递该参数集。带外信令和带内信令之间通常不存在同步。如果使用带外信令，建议发送方在确认信令协议的发送之前，不要开始发送需要更新参数集的NALU。</p>
<p>-更新参数集时，应考虑以下同步问题。当覆盖接收器上的参数集时，发送方必须确保网络或接收器缓冲区中的任何NALU都不需要有问题的参数集。否则，可能会使用错误的参数集进行解码。为了减少这个问题，建议只覆盖那些没有使用足够长时间的参数集（以确保所有相关的Nalus已被消耗），或者添加一个新的参数集（这可能会对视频编码的效率产生负面影响）。</p>
<p>-添加新参数集时，将使用以前未使用的参数集标识符。这样就避免了上一段中指出的问题。但是，在多方会话中，除非使用同步控制协议，否则多个实体可能会尝试为同一标识符添加不同的参数集，这是必须避免的。</p>
<p>-在同一个RTP会话中同时使用B和C原则添加或修改参数集可能会导致参数集不一致，因为控件和RTP通道之间缺乏同步。因此，除非能够提供足够的同步，否则原则B和C不能在同一会话中同时使用。</p>
<p>在某些情况下（例如，只有该有效载荷格式规范的子集对应</p>
<h3 id="a9">9. 安全注意事项</h3>

<p>使用本规范中定义的有效负载格式的RTP数据包受RTP规范[4]和任何适当的RTP配置文件（例如[16]）中讨论的安全考虑的影响。这意味着媒体流的机密性是通过加密实现的；例如，通过应用SRTP[26]。由于与此有效负载格式一起使用的数据压缩是端到端应用的，因此需要在压缩之后执行任何加密。</p>
<p>对于使用具有非均匀接收端计算负载的压缩技术的数据编码，存在潜在的拒绝服务威胁。攻击者可以将病理数据报注入到复杂的流中进行解码，从而导致接收器过载。H.264特别容易受到此类攻击，因为生成包含NAL单元的数据报非常简单，这些单元会影响未来许多NAL单元的解码过程。因此，建议至少使用RTP包的数据源身份验证和数据完整性保护；例如，使用SRTP[26]。</p>
<p>请注意，确保RTP包及其有效负载的机密性和完整性的适当机制非常依赖于应用程序以及所使用的传输和信令协议。因此，尽管上面给出了SRTP的例子，但也存在其他可能的选择。</p>
<p>解码器必须谨慎处理用户数据SEI消息，尤其是当它们包含活动元素时，并且必须限制其适用于包含流的表示的领域。</p>
<p>具有身份验证、完整性或机密性保护的端到端安全性将阻止mane执行媒体感知操作，而不是丢弃完整数据包。在保密保护的情况下，它甚至会被阻止以媒体感知的方式执行丢弃数据包的操作。为了允许任何mane执行其操作，它将被要求是安全上下文建立中包含的可信实体。</p>
<h3 id="a10">10. 拥塞控制</h3>

<p>RTP的拥塞控制应根据RFC 3550[4]和任何适用的RTP配置文件使用；例如，RFC 3551[16]。如果使用的是尽力而为的服务，则另一个要求是：此有效负载格式的用户必须监视数据包丢失，以确保数据包丢失率在可接受的参数范围内。如果在相同的网络路径上的TCP流，并且经历相同的网络条件，将达到在合理的时间尺度上测量的平均吞吐量，即不小于RTP流所达到的吞吐量，则认为数据包丢失是可以接受的。这种情况可以通过实施拥塞控制机制来适应传输速率（或为分层多播会话订阅的层数），或者在丢失率不可接受的情况下安排接收器离开会话来满足。</p>
<p>采用实时编码时，很容易实现满足拥塞控制原理所需的比特率自适应。但是，在传输预编码内容时，带宽适应要求以不同的比特率对相同内容提供多个编码表示，或在比特流中存在非参考图片或子序列[22]。不同表示之间的切换通常可以在同一个RTP会话中执行；例如，通过使用扩展配置文件的一个称为si/sp切片的概念，或通过在IDR图片边界处切换流来执行。只有当需要更改不可降级的参数（如配置文件/级别ID的配置文件部分）时，才需要终止并重新启动媒体流。这可以通过使用不同的RTP有效负载类型来实现。</p>
<p>Manes可以遵循第7.3节中概述的建议，并在数据流因以前的数据包丢失而损坏时从数据包流中删除某些不可用的数据包。在某些特殊情况下，这有助于减少网络负载。</p>
<h3 id="a11">11. IANA注意事项</h3>

<p>IANA注册了一个新的mime类型；请参见第8.1节。</p>
<h3 id="a12">12. 应用实例</h3>

<p>为了覆盖H.264预期的非常宽的应用空间，该有效载荷规范的使用非常灵活。然而，这种巨大的灵活性也使得实现人员很难决定一个合理的打包方案。在不久的将来，有关如何将此规范应用于现实场景的一些信息可能会以学术出版物和测试模型软件的形式出现，并进行描述。然而，这里也描述了一些初步的使用场景。</p>
<h4 id="a12-1">12.1. 符合ITU-T建议H.241附录A的视频电话</h4>

<p>要求使用H.264作为可选视频压缩方案的基于H.323的视频电话系统支持H.241附录A[15]作为打包方案。本附录中定义的包装机制在技术上与本规范的一小部分相同。</p>
<p>当系统按照H.241附录A运行时，参数设置NAL单位以带内方式发送。仅使用单个NAL单元数据包。许多这样的系统不定期发送IDR图像，但仅在用户交互或通过控制协议手段需要时才发送；例如，在多点控制单元中的视频通道之间切换或反馈请求的错误恢复时。</p>
<h4 id="a12-2">12.2. 视频电话，无切片数据分区，无NAL单元聚合</h4>

<p>该方案的RTP部分是实现和测试的（尽管不是控制协议部分；见下文）。</p>
<p>在大多数真实的视频电话应用程序中，图片参数（如图片大小或可选模式）在连接的生命周期内不会发生变化。因此，所有必要的参数集（通常只有一个）作为能力交换/发布过程的副作用发送，例如，根据本文档第8.2节中指定的SDP语法。由于所有必需的参数集信息都是在RTP会话开始之前建立的，因此不需要发送任何参数集NAL单元。切片数据分区也不使用。因此，RTP包流基本上由携带单个编码片的NAL单元组成。</p>
<p>编码器选择编码片NAL单元的大小，以提供最佳性能。通常，这是通过将编码的切片大小调整为IP网络的MTU大小来完成的。对于较小的图片大小，这可能导致每一个包策略一张图片。内部刷新算法可以清除数据包的丢失以及由此产生的与漂移相关的伪影。</p>
<h4 id="a12-3">12.3. 视频电话，使用NAL单元聚合的交错打包</h4>

<p>此方案允许更好的错误隐藏，并用于基于H.263的设计中，使用RFC 2429打包[10]。已经实施，取得了良好的效果[12]。</p>
<p>VCL编码器对源图片进行编码，以便将一个MB行的所有宏块（MBS）分配给一个切片。所有具有偶数MB行地址的切片合并到一个stap中，所有具有奇数MB行地址的切片合并到另一个stap中。这些STAP以RTP包的形式传输。如上文所述，建立参数集。</p>
<p>请注意，在这里使用staps是非常重要的，因为大量的单个切片（对于CIF图片为18）将导致不可接受的高IP/UDP/RTP头开销（除非使用了源代码工具fmo，这在本场景中没有假设）。此外，一些无线视频传输系统，如H.324M和3GPP中指定的基于IP的视频电话，可能使用相对较小的传输包大小。例如，H.223 AL3 SDU的典型MTU大小约为100字节[17]。根据这种打包方案对单个片进行编码，在有线和无线网络之间的通信中提供了进一步的优势，因为单个片可能小于无线系统的首选最大包大小。因此，网关可以将有线网络中使用的STAP转换为只有一个NAL单元的多个RTP数据包，这在无线网络中是首选的，反之亦然。</p>
<h4 id="a12-4">12.4. 带数据分区的视频电话</h4>

<p>该方案已得到实施，并显示出良好的性能，尤其是在较高的包丢失率下[12]。</p>
<p>只有在某种形式的不平等错误保护可用时，数据分区才是有用的。通常，在单会话RTP环境中，甚至假定错误特征；即，会话中所有数据包的数据包丢失概率在统计上是相同的。但是，有一些方法可以降低RTP会话中单个数据包的数据包丢失概率。例如，根据RFC2733[18]的一个fec包指定了哪些媒体包与fec包相关联。</p>
<p>在所有情况下，产生的开销都是巨大的，但其数量级与用于内部信息的位的数量相同。但是，这种机制不会给系统增加任何延迟。</p>
<p>再次，通过控制协议手段完成参数集的建立。</p>
<h4 id="a12-52">12.5. 视频电话或带fus的流媒体和转发错误更正</h4>

<p>该方案已得到实施，并已证明具有良好的性能，尤其是在较高的包丢失率下[19]。</p>
<p>在重传不适用的情况下，最有效的方法是前向纠错（FEC）。尽管应用层，FEC的端到端使用通常比基于FEC的单个链路保护效率低（尤其是当不同特性的链路位于传输路径中时），但应用层、端到端FEC在某些情况下是不可避免的。RFC2733[18]提供了在丢包环境中使用通用应用层端到端FEC的方法。二进制前向纠错码是通过将XOR操作应用于不同数据包中相同位位置的位而产生的。二进制代码可以由参数（n，k）指定，其中k是连接中使用的信息包数，n是为k信息包生成的数据包总数；即，为k信息包生成n-k奇偶校验包。</p>
<p>当代码与RFC2733框架内的参数（n，k）一起使用时，以下属性是众所周知的：</p>
<p>a）如果应用于一个RTP包，则RFC2733仅提供包重复。</p>
<p>b）如果XOR连接的数据包长度相等，那么RFC2733是最高效的比特率。</p>
<p>c）在相同的丢包概率p和固定k下，n值越大，剩余误差概率越小。例如，对于10%、k=1和n=2的数据包丢失概率，残差概率约为1%，而对于n=3，残差概率约为0.1%。</p>
<p>d）在相同的丢包概率p下，对于固定码率k/n，n值越大，残差概率越小。例如，在丢包概率为p=10%、k=1和n=2时，残差率约为1%，而对于k=12和n=24的扩展golay码，残差率约为0.01%。</p>
<p>对于在不使用fus的情况下结合H.264基线编码视频应用RFC2733，可以考虑以下几个选项：</p>
<p>1）视频编码器产生NAL单元，每个视频帧在一个切片中编码。应用FEC，可以使用一个简单的代码；例如（n=2，k=1）。也就是说，每个NAL单元基本上都是重复的。缺点很明显是根据d），上面的代码性能不好，灵活性低，因为只能使用（n，k=1）代码。</p>
<p>2）视频编码器产生NAL单元，每个视频帧编码在一个或多个连续切片中。应用FEC，可以在一系列NAL单元上使用更好的代码，例如（n=24，k=12）。根据每帧RTP数据包的数量，丢失可能会导致显著的延迟，当每帧使用更多的RTP数据包时，延迟会减少。完全不同长度的数据包也可能被连接起来，这会降低上面b）所述的比特率效率。但是，在一定程度上，对于大于或等于1KB的片，可能会产生类似的长度（100-200字节的差异），这不会灾难性地降低比特效率。</p>
<p>3）视频编码器产生NAL单元，对于该单元，某个帧包含可能几乎相等长度的K片。然后，应用FEC，一个更好的代码，例如（n=24，k=12），可以在每个帧的NAL单元序列上使用。与上面的2）相比，延迟可以减少，但有几个缺点是显而易见的。首先，编码视频的编码效率显著降低，因为片结构编码降低了帧内预测，需要额外的片开销。第二，预先编码的内容，或者在网关上操作时，通常不使用k片对视频进行适当编码，这样就可以应用fec。最后，产生等长k片的视频的编码并不简单，可能需要一个以上的编码过程。</p>
<p>通过将fus与fec结合使用，可以避免上述许多缺点。每个NAL单元可以分割成任意数量的基本相等长度的fus；因此，即使编码器不努力生产相同长度的切片，也可以应用具有合理k和n的fec。例如，包含一个完整帧的编码片NAL单元可以拆分为K fus，并且可以应用奇偶校验码（n=k+1，k）。但是，这样做的缺点是，除非所有创建的片段都可以恢复，否则整个切片将丢失。因此，如果将帧分割成多个切片，则会丢失一个更大的部分。</p>
<p>该技术使得即使不存在额外的源编码层冗余（如周期帧内），也能获得良好的传输误差容限。因此，相同的编码视频序列可用于在无差错传输和在易出错网络上传输时实现最大的压缩效率和质量。此外，该技术允许在不增加延迟的情况下将FEC应用于预编码序列。在这种情况下，没有为易出错网络编码的预编码序列仍然可以几乎可靠地传输，而不会增加大量的延迟。此外，相同长度的fus导致了RFC2733的比特率有效使用。</p>
<p>如果错误概率取决于传输数据包的长度（例如，在移动传输的情况下[14]），那么将fus与fec结合使用的好处就更加明显。基本上，fus大小的灵活性允许对每个nal单元应用适当的fec，以及对nal单元进行不平等的错误保护。</p>
<p>当使用fus和fec时，产生的开销是巨大的，但与如果不应用fec，则必须用于内部编码宏块的位数的数量级相同。在[19]中，研究表明，当使用相同的错误率和相同的总比特率（包括开销）时，基于FEC的方法的总体性能提高了质量。</p>
<h4 id="a12-6">12.6. 低比特率流</h4>

<p>该方案采用H.263和非标准RTP封装技术实现，取得了良好的效果[20]。没有技术上的原因可以解释为什么H.264也不能达到同样好的效果。</p>
<p>在当今的互联网流媒体中，一些提供的比特率相对较低，以允许具有拨号调制解调器的终端访问内容。在有线IP网络中，相对较大的数据包（如500-1500字节）比较小且更频繁发生的数据包更受欢迎，以减少网络拥塞。此外，使用大数据包可以减少RTP/UDP/IP头开销。对于低比特率的视频，大数据包的使用意味着有时多达几个图片应该封装在一个数据包中。</p>
<p>然而，包含许多编码图片的数据包丢失将对视觉质量产生巨大影响，因为实际上没有其他方法可以掩盖整个图片的丢失，而不是重复上一个图片。构建相对较大的数据包并保持成功隐藏丢失的可能性的一种方法是构建包含来自多个图片的交错切片的MTAP。MTAP不应包含来自同一图片的空间相邻切片或来自任何图片的空间重叠切片。如果数据包丢失，则丢失的切片很可能被同一图片的空间相邻切片以及时间上一个和后续图片的空间对应切片包围。因此，隐藏丢失的切片可能比较成功。</p>
<h4 id="a12-7">12.7. 视频流中的鲁棒分组调度</h4>

<p>利用MPEG-4第2部分实现了鲁棒分组调度，并在无线流环境中进行了仿真[21]。没有技术上的原因可以解释为什么H.264不能达到类似或更好的结果。</p>
<p>流客户机通常有一个能够存储相对大量数据的接收器缓冲区。最初，当建立流会话时，客户机不会立即开始播放流。相反，它通常会将传入的数据缓冲几秒钟。这种缓冲有助于保持连续播放，因为在偶尔增加传输延迟或网络吞吐量下降的情况下，客户机可以解码和播放缓冲数据。否则，在没有初始缓冲的情况下，客户机必须冻结显示、停止解码并等待传入数据。缓冲对于任何协议级别的自动或选择性重传都是必要的。如果图片的任何部分丢失，可以使用重新传输机制重新发送丢失的数据。如果在预定的解码或回放时间之前接收到重新传输的数据，则会完全恢复丢失。编码图像可以根据其在解码序列主观质量中的重要性进行排序。例如，非参考图片，例如传统的B图片，在主观上是最不重要的，因为它们的缺失不会影响任何其他图片的解码。除了非参考图片外，ITU-T H.264_ISO/IEC 14496-10标准还包括一种称为子序列的时间可伸缩性方法[22]。主观排序也可以在编码切片数据分区或切片组的基础上进行。主观上最重要的编码片和编码片数据分区可以在其解码顺序指示之前发送，而主观上最不重要的编码片和编码片数据分区可以在其自然编码顺序指示之后发送。因此，与最不重要的切片和切片数据分区相比，最重要的切片和编码切片数据分区的任何重新传输部分在其预定解码或播放时间之前更容易收到。</p>
<h3 id="a13">13. 解码原理</h3>
<h4 id="a13-1">13.1. 引言</h4>

<p>引入解码顺序号（DON）概念主要是为了实现高效的多图像片交织（见第12.6节）和健壮的分组调度（见第12.7节）。在这两种应用中，NAL单元都是按解码顺序传输的。don表示NAL单元的解码顺序，应在接收器中用于恢复解码顺序。第13.2节和第13.3节分别给出了高效多图像片交织和鲁棒分组调度的示例用例。第13.4节描述了DON概念在通过冗余编码图片实现的容错性方面的好处。第13.5节总结了DON的备选方案，并解释了为何根据该RTP有效载荷规范选择DON。</p>
<h4 id="a13-2">13.2. 多图像片交织示例</h4>

<p>下面是一个多图像片交织的例子。编码视频序列的子集以输出顺序描述如下。R表示参考图片，N表示非参考图片，数字表示相对输出时间。</p>
<p>…R1 N2 R3 N4 R5…</p>
<p>这些图片从左到右的解码顺序如下：</p>
<p>…R1 R3 N2 R5 N4…</p>
<p>图r1、r3、n2、r5和n4的Nal单位分别用1、2、3、4和5的Don标记。</p>
<p>每个参考图片由以下分散的三个切片组组成（一个数字表示QCIF帧中每个宏块的切片组编号）：</p>
<pre>
      0 1 2 0 1 2 0 1 2 0 1
      2 0 1 2 0 1 2 0 1 2 0
      1 2 0 1 2 0 1 2 0 1 2
      0 1 2 0 1 2 0 1 2 0 1
      2 0 1 2 0 1 2 0 1 2 0
      1 2 0 1 2 0 1 2 0 1 2
      0 1 2 0 1 2 0 1 2 0 1
      2 0 1 2 0 1 2 0 1 2 0
      1 2 0 1 2 0 1 2 0 1 2
</pre>

<p>为了简单起见，我们假设一个切片组的所有宏块都包含在一个切片中。三个mtap由三个连续的参考图片构成，因此每个mtap包含三个聚合单元，每个聚合单元包含来自一个切片组的所有宏块。第一个mtap包含图片r1的切片组0、图片r3的切片组1和图片r5的切片组2。第二个mtap包含图片r1的切片组1、图片r3的切片组2和图片r5的切片组0。第三个mtap包含图片r1的切片组2、图片r3的切片组0和图片r5的切片组1。每个非参考图片封装在一个STAP-B中。</p>
<p>因此，NAL装置的传输顺序如下：</p>
<pre>
      R1, slice group 0, DON 1, carried in MTAP,   RTP SN: N
      R3, slice group 1, DON 2, carried in MTAP,   RTP SN: N
      R5, slice group 2, DON 4, carried in MTAP,   RTP SN: N
      R1, slice group 1, DON 1, carried in MTAP,   RTP SN: N+1
      R3, slice group 2, DON 2, carried in MTAP,   RTP SN: N+1
      R5, slice group 0, DON 4, carried in MTAP,   RTP SN: N+1
      R1, slice group 2, DON 1, carried in MTAP,   RTP SN: N+2
      R3, slice group 1, DON 2, carried in MTAP,   RTP SN: N+2
      R5, slice group 0, DON 4, carried in MTAP,   RTP SN: N+2
      N2,                DON 3, carried in STAP-B, RTP SN: N+3
      N4,                DON 5, carried in STAP-B, RTP SN: N+4
</pre>

<p>接收器能够根据与每个NAL单元相关联的DON值按解码顺序组织NAL单元。</p>
<p>如果其中一个MTAP丢失，则接收到空间上相邻和时间上共同定位的宏块，并可用于有效地隐藏丢失。如果其中一个staps丢失，则丢失的效果不会暂时传播。</p>
<h4 id="a13-3">13.3. 鲁棒分组调度示例</h4>

<p>下面是一个健壮的包调度示例。本例中使用的通信系统由以下组件组成，按照视频从源到接收的顺序进行处理：</p>
<p>o camera and capturing</p>
<p>o pre-encoding buffer</p>
<p>o encoder</p>
<p>o encoded picture buffer</p>
<p>o transmitter</p>
<p>o transmission channel</p>
<p>o receiver</p>
<p>o receiver buffer</p>
<p>o decoder</p>
<p>o decoded picture buffer</p>
<p>o display</p>
<p>示例中使用的视频通信系统操作如下。请注意，在系统的所有组件中，视频流的处理都是逐步进行的，同时进行的。源视频序列被拍摄并捕获到预编码缓冲区。例如，预编码缓冲区可用于将图片从采样顺序排序到编码顺序，或分析多个未压缩帧以进行比特率控制。在某些情况下，预编码缓冲区可能不存在，而是立即对采样图片进行编码。编码器对来自预编码缓冲区的图片进行编码，并将输出（即编码图片）存储到编码图片缓冲区。发送器将编码后的图片从编码后的图片缓冲区封装到传输包中，并通过传输通道发送给接收器。接收器将接收到的数据包存储到接收器缓冲区。接收器缓冲过程通常包括传输延迟抖动的缓冲。接收缓冲器还可用于恢复编码数据的正确解码顺序。解码器从接收缓冲区读取编码数据，并将解码后的图片作为输出输出输出到解码后的图片缓冲区。解码后的图片缓冲区用于恢复图片的输出（或显示）顺序。最后，显示图片。</p>
<p>在下面的示例图中，i表示IDR图片，r表示参考图片，n表示非参考图片，i、r或n之后的数字表示相对于前一个IDR图片的解码顺序的采样时间。图片序列下方的值表示按比例缩放的系统时钟时间戳。在这个例子中，系统时钟是任意初始化的，时间从左到右运行。与上一个处理步骤（如果有）相比，每个I、R和N图片都映射到相同的时间线上，假设编码、传输和解码不需要时间。因此，在所有示例图中，同时发生的事件都位于同一列中。</p>
<p>下面以采样顺序描述了一系列编码图片的子集。</p>
<pre>
    ...  N58 N59 I00 N01 N02 R03 N04 N05 R06 ... N58 N59 I00 N01 ...
    ... --|---|---|---|---|---|---|---|---|- ... -|---|---|---|- ...
    ...  58  59  60  61  62  63  64  65  66  ... 128 129 130 131 ...
</pre>

<p>图16。按采样顺序排列的图片序列</p>
<p>采样图像在预编码缓冲区中进行缓冲，以按编码顺序排列。在本例中，我们假设非参考图片是按照输出顺序从上一个和下一个参考图片预测出来的，除了紧接着在IDR图片之前的非参考图片，这些图片是按照输出顺序从上一个参考图片预测出来的。因此，预编码缓冲区必须包含至少两张图片，并且缓冲导致两个图片间隔的延迟。预编码缓冲过程的输出和图片的编码（解码）顺序如下：</p>
<pre>
    ... N58 N59 I00 R03 N01 N02 R06 N04 N05 ...
    ... -|---|---|---|---|---|---|---|---|- ...
    ... 60  61  62  63  64  65  66  67  68  ...
</pre>

<p>图17。在预编码缓冲区中重新排序图片</p>
<p>编码器或发送器可以按解码顺序将每张图片的don值设置为前一张图片的don值加上一张。</p>
<p>为了简单起见，我们假设：</p>
<p>o序列的帧速率是恒定的，</p>
<p>o每张图片仅由一个切片组成，</p>
<p>o每个切片封装在一个NAL单元包中，</p>
<p>o无传输延迟，以及</p>
<p>o图像以恒定的间隔传输（即1/帧率）。</p>
<p>当图像按解码顺序传输时，接收如下：</p>
<pre>
    ... N58 N59 I00 R03 N01 N02 R06 N04 N05 ...
    ... -|---|---|---|---|---|---|---|---|- ...
    ... 60  61  62  63  64  65  66  67  68  ...
</pre>

<p>图18。按解码顺序接收的图片</p>
<p>可选的sprop交织深度mime类型参数设置为0，因为传输（或接收）顺序与解码顺序相同。</p>
<p>解码器必须在其解码后的图片缓冲区中缓冲一个图片间隔，以组织从解码顺序到输出顺序的图片，如下所示：</p>
<pre>
    ... N58 N59 I00 N01 N02 R03 N04 N05 R06 ...
    ... -|---|---|---|---|---|---|---|---|- ...
    ... 61  62  63  64  65  66  67  68  69  ...
</pre>

<p>图19。输出顺序</p>
<p>解码后的图片缓冲区中所需的初始缓冲量可在缓冲期SEI消息或H.264视频可用性信息的num_reorder_frames语法元素中发出信号。num_reorder_frames表示序列中任何帧、互补字段对或非成对字段之前的最大帧数、互补字段对或非成对字段数，按解码顺序排列，然后按输出顺序排列。为了简单起见，我们假设num_reorder_frames用于指示解码图片缓冲区中的初始缓冲区。在本例中，num_reorder_frames等于1。</p>
<p>可以观察到，如果在传输过程中IDR图像I00丢失，并且在系统时钟值为62时发出重新传输请求，则有一个图像时间间隔（直到系统时钟达到时间戳63）来接收重新传输的IDR图像I00。</p>
<p>然后我们假设IDR图像比其解码位置提前两个帧间隔发送，即图像按如下方式发送：</p>
<pre>
   ...  I00 N58 N59 R03 N01 N02 R06 N04 N05 ...
   ... --|---|---|---|---|---|---|---|---|- ...
   ...  62  63  64  65  66  67  68  69  70  ...
</pre>

<p>图20。交错：早期IDR图片发送顺序</p>
<p>可选的sprop交织深度mime类型参数根据其定义设置为1。（本例中sprop-交织深度的值可推导如下：图I00是传输顺序中图N58或N59之前和解码顺序中的唯一图片。除图片I00、N58和N59外，传输顺序与图片解码顺序相同。由于编码图片被封装到一个NAL单元中，sprop交织深度的值等于传输顺序中任何图片前面和解码顺序中图片后面的最大图片数。）</p>
<p>接收器缓冲过程根据sprop交织深度参数的值一次包含两张图片，并根据与每个图片相关联的don值将图片从接收顺序排序到正确的解码顺序。接收器缓冲过程的输出如下：</p>
<pre>
    ... N58 N59 I00 R03 N01 N02 R06 N04 N05 ...
    ... -|---|---|---|---|---|---|---|---|- ...
    ... 63  64  65  66  67  68  69  70  71  ...
</pre>

<p>图21。交错：接收缓冲器</p>
<p>同样，需要一个图片间隔的初始缓冲延迟来组织从解码顺序到输出顺序的图片，如下所示：</p>
<pre>
   ... N58 N59 I00 N01 N02 R03 N04 N05 ...
   ... -|---|---|---|---|---|---|---|- ...
   ... 64  65  66  67  68  69  70  71  ...
</pre>

<p>图22.交错：重新排序后的接收器缓冲区</p>
<p>请注意，IDR图片在传输过程中可能经历的最大延迟，包括可能的应用、传输或链路层重传，等于三个图片间隔。因此，与按解码顺序传输图像的情况相比，支持重传的系统提高了IDR图像的抗丢失能力。</p>
<h4 id="a13-4">13.4. 冗余编码片的鲁棒传输调度</h4>

<p>冗余编码图片是在相应的主编码图片正确解码的情况下，在解码过程中不使用的图片或图片的一部分的编码表示。对同一接入单元中的任何冗余图片应用H.264解码过程，解码后的主图片的任何区域与相应区域之间不应存在明显差异。冗余编码片是冗余编码图片的一部分。</p>
<p>冗余编码图像可以在容易出错的视频传输中提供不均匀的错误保护。如果图像的主要编码表示被错误地解码，则可以解码相应的冗余编码图像。使用冗余编解码器图片功能的应用程序和编码技术示例包括视频冗余编码[23]和多播流中的“关键图片”保护[24]。</p>
<p>许多容易出错的视频通信系统的一个特点是传输错误经常是突发性的。因此，它们可能以传输顺序影响多个连续的传输包。在低比特率视频通信中，将整个编码图像封装到一个传输包中是比较常见的。因此，主编码图像和相应的冗余编码图像可以按传输顺序连续分组传输。为了提高传输方案对突发传输错误的容忍度，有利于传输由多个数据包分隔的主编码图像和冗余编码图像。Don概念实现了这一点。</p>
<h4 id="a13-5">13.5. 其他设计可能性说明</h4>

<p>H.264编码标准的切片头语法结构包含一个frame_num语法元素，可以指示编码帧的解码顺序。但是，由于以下原因，使用frame_num语法元素不可行或不希望恢复解码顺序：</p>
<p>o接收器需要对每个编码图片至少分析一个切片头（在将编码数据传递给解码器之前）。</p>
<p>来自多个编码视频序列的O编码切片不能交错，因为帧编号语法元素在每个IDR图片中重置为0。</p>
<p>o互补字段对的编码字段共享frame_num语法元素的相同值。因此，不能基于H.264编码语法的frame_num syntax元素或任何其他语法元素恢复互补字段对编码字段的解码顺序。</p>
<p>用于传输MPEG-4基本流[25]的RTP有效负载格式允许在同一个RTP包中交错访问单元和传输多个访问单元。H.264编码标准中规定了一个访问单元，根据[1]的子条款7.4.1.2，它包括与主编码图片相关联的所有NAL单元。因此，不同图片的切片不能交错，并且不能使用多图片切片交错技术（见第12.6节）来提高错误恢复能力。</p>
<h3 id="a14">14. Acknowledgements</h3>

<p>作者感谢Roni Even、Dave Lindbergh、Philippe Gentric、Gonzalo Camarillo、Gary Sullivan、Joerg Ott和Colin Perkins对本文进行了仔细的回顾。</p>
<h3 id="a15">15. 参考文献</h3>
<h4 id="a15-1">15.1. 规范性引用文件</h4>
[1]  ITU-T Recommendation H.264, "Advanced video coding for generic audiovisual services", May 2003.
[3]  Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.
[4]  Schulzrinne, H.,  Casner, S., Frederick, R., and V. Jacobson, "RTP: A Transport Protocol for Real-Time Applications", STD 64, RFC 3550, July 2003.
[5]  Handley, M. and V. Jacobson, "SDP: Session Description Protocol", RFC 2327, April 1998.
[6]  Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", RFC 3548, July 2003.
[7]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model with Session Description Protocol (SDP)", RFC 3264, June 2002.
<h4 id="a15-2">15.2. 资料性引用</h4>

<p>…</p>
]]></content>
  </entry>
  <entry>
    <title>f4v文件格式</title>
    <url>/2020/11/19/doc/f4v/</url>
    <content><![CDATA[<h3 id="Adobe-Flash-Video-File-Format-Specification"><a href="#Adobe-Flash-Video-File-Format-Specification" class="headerlink" title="Adobe Flash Video File Format Specification"></a>Adobe Flash Video File Format Specification</h1></h3><p>  Version 10.1</p>
<p>Introduction</p>
<p>Flash®是Web上动态媒体的事实标准，支持多种媒体格式，包括两种用于提供同步音频和视频流的核心容器格式：</p>
<ul>
<li><p>   F4V, for H.264/AAC–based content, and</p>
</li>
<li><p>   FLV, for other supported codecs such as Sorensen Spark and On2 VP6.</p>
</li>
</ul>
<p>本文档提供Adobe®产品支持的F4V和FLV视频文件格式的技术格式信息。<br>Adobe认真考虑所有对视频文件格式规范的反馈。 通过<a href="mailto:&#x66;&#x6c;&#x61;&#x73;&#104;&#102;&#x6f;&#114;&#x6d;&#x61;&#x74;&#x40;&#x61;&#100;&#111;&#98;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x66;&#x6c;&#x61;&#x73;&#104;&#102;&#x6f;&#114;&#x6d;&#x61;&#x74;&#x40;&#x61;&#100;&#111;&#98;&#x65;&#x2e;&#99;&#111;&#x6d;</a>将规范中任何不清楚或可能错误的信息通过电子邮件发送给Adobe。 所有此类电子邮件提交均应遵守使用条款中的提交材料指南，网址为<a href="http://www.adobe.com/misc/copyright.html%E3%80%82">www.adobe.com/misc/copyright.html。</a></p>
<p>The F4V Video File Format</p>
<p>F4V视频文件格式的开放规范建立在标准IEC 14496-12（MPEG-4 Part 12）ISO基础媒体文件格式之上。 它具有灵活的结构，并定义了特定支持的编解码器和扩展。 因此，F4V视频文件格式简化了动态媒体软件的实现，促进了工具，服务和客户端之间的互操作性。</p>
<p>从Flash Player 9 Update 3（9,0,115,0）开始，Flash Player可以播放F4V文件。 有关F4V视频文件格式的详细信息，请参阅第1节.F4V文件格式<br>有关在F4V文件中使用元数据的信息，请参阅第3节.F4V元数据。</p>
<p>New in the F4V Video File Format</p>
<p>Flash Player 10,1,53,64的发布增加了Flash F4V视频文件格式中以下功能和框的支持。 斜体框由Adobe Systems定义。</p>
<p>新功能提示点，加密，提示，HTTP流媒体</p>
<p>New Boxes</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abst	adaf	adkm	aeib	afra	afrt	ahdr	akey	amhp	amto	aprm	aps</span><br><span class="line">asig	asrt	dinf	dref	edit	elst	enca	encr	encv	flxs	frma	hdlr</span><br><span class="line">hmdh  mehd   mfhd	mfra	mfro	moof	mvex	nmhd   rtmp	schi	schm	sdtp</span><br><span class="line">sinf	smhd   tfhd	tfra	traf	trex	trun	url	vmhd</span><br></pre></td></tr></table></figure>


<p>The FLV Video File Format</p>
<p>FLV文件对同步的音频和视频流进行编码。 FLV文件中的音频和视频数据的编码方式与SWF文件中的音频和视频相同。本文档描述了FLV版本1.参见附录E. FLV文件格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">    UA: userAgent</span><br><span class="line">    -- : 回车</span><br></pre></td></tr></table></figure>

<h3 id="a1">1. F4V文件格式</h3>
<h4 id="a1-1">1.1. Overview</h4>

<p>Flash Player 9 Update 3（9,0,115,0）及更高版本可以播放F4V文件。 F4V格式基于ISO / IEC 14496-12：2008 ISO基础媒体文件格式。</p>
<p>将F4V格式与ISO基础媒体文件格式区分开来的很大一部分涉及F4V可以存储的元数据格式。 本章讨论除元数据之外的F4V格式的所有方面，第3节F4V元数据对此进行了介绍。</p>
<h4 id="a1-2">1.2. 简单数据类型</h4>

<p>This following data types are used in F4V files.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Type     	Definition</span><br><span class="line"><span class="number">0</span>x…	      Hexadecimal value …</span><br><span class="line"><span class="number">4</span>CC	      Four-character ASCII code, such <span class="keyword">as</span> <span class="string">&#x27;moov&#x27;</span>, encoded <span class="keyword">as</span> UI32</span><br><span class="line">SI8	      Signed <span class="number">8</span>-bit integer</span><br><span class="line">SI8<span class="number">.8</span>	    Signed <span class="number">16</span>-bit fixed point number having <span class="number">8</span> fractional bits</span><br><span class="line">SI16	    Signed <span class="number">16</span>-bit integer</span><br><span class="line">SI16<span class="number">.16</span>	  Signed <span class="number">32</span>-bit fixed point number having <span class="number">16</span> fractional bits</span><br><span class="line">SI24	    Signed <span class="number">24</span>-bit integer</span><br><span class="line">SI32	    Signed <span class="number">32</span>-bit integer</span><br><span class="line">SI64	    Signed <span class="number">64</span>-bit integer</span><br><span class="line">STRING	  Sequence <span class="keyword">of</span> Unicode <span class="number">8</span>-bit characters (UTF-<span class="number">8</span>), terminated <span class="keyword">with</span> <span class="number">0x00</span> (unless otherwise specified)</span><br><span class="line">UI8	      Unsigned <span class="number">8</span>-bit integer</span><br><span class="line">UI16	    Unsigned <span class="number">16</span>-bit integer</span><br><span class="line">UI16<span class="number">.16</span>	  Unsigned <span class="number">32</span>-bit fixed point number having <span class="number">16</span> fractional bits</span><br><span class="line">UI24	    Unsigned <span class="number">24</span>-bit integer</span><br><span class="line">UI32	    Unsigned <span class="number">32</span>-bit integer</span><br><span class="line">UI64	    Unsigned <span class="number">64</span>-bit integer</span><br><span class="line">UIn	      Bit field <span class="keyword">with</span> unsigned n-bit integer, where n is <span class="keyword">in</span> the range <span class="number">1</span> to <span class="number">31</span>, excluding <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span></span><br><span class="line">xxx [ ]	  <span class="built_in">Array</span> <span class="keyword">of</span> type xxx. <span class="built_in">Number</span> <span class="keyword">of</span> elements to be inferred, <span class="keyword">for</span> example <span class="keyword">from</span> box size.</span><br><span class="line">xxx [n]	  <span class="built_in">Array</span> <span class="keyword">of</span> n elements <span class="keyword">of</span> type xxx</span><br></pre></td></tr></table></figure>


<p>与SWF相比，多字节整数应以big-endian字节顺序存储，SWF使用little-endian字节顺序。 例如，作为SWF文件格式的UI16，表示数字300（0x12C）的字节序列是0x2C 0x01; 作为F4V文件格式的UI16，表示数字300的字节序列是0x01 0x2C。</p>
<h4 id="a1-3">1.3. F4V box format</h4>

<p>F4V文件的基本构建块是具有以下BOX格式的框：F4V框</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	      Type	      Comment</span><br><span class="line">Header	  BOXHEADER	    所有框都具有一致的标题</span><br><span class="line">Payload	  UI8 [ ]	      字节数，其长度由boxheader定义。</span><br></pre></td></tr></table></figure>


<p>每个框结构以一个BoxHeader结构开头：BoxHeader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	          Type	           Comment</span><br><span class="line">TotalSize       UI32            框的总大小（以字节为单位），包括此标头。 <span class="number">0</span>表示该框延伸到文件末尾。</span><br><span class="line">BoxType	        UI32	          The type <span class="keyword">of</span> the box, usually <span class="keyword">as</span> <span class="number">4</span>CC</span><br><span class="line"></span><br><span class="line">ExtendedSize    IF TotalSize    框的总<span class="number">64</span>位长度（字节），包括此头</span><br><span class="line">                == <span class="number">1</span></span><br><span class="line">                UI64</span><br></pre></td></tr></table></figure>


<p>许多盒子的长度都小于4GB，可以将它们的大小存储在totalSize字段中。通过将32位totalSize字段设置为1并以extendedSize存储64位大小，该格式还支持非常大的框。每个框都用32位类型标识。对于大多数框，此32位类型可兼作人可读的四字符ASCII代码或4cc，例如“moov”（0x6d6f6f76）和“mdat”（0x6d646174）。</p>
<p>箱有效载荷紧跟箱头。有效负载的字节大小等于框的总大小减去8字节或16字节，具体取决于头的大小。</p>
<p>有关更多信息，请参见ISO/IEC 14496-12:2008第4.2节。</p>
<h4 id="a1-4">1.4. f4v框层次</h4>

<p>Table 1. The F4V Box Hierarchy</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Box Type	                  Required?	                    Short Description</span><br><span class="line">ftyp                        Y	                            文件类型和兼容性</span><br><span class="line">pdin                        N	                            渐进式下载信息</span><br><span class="line">afra                        See HTTP streaming            HTTP流的分段随机访问</span><br><span class="line">abst                        See HTTP streaming            HTTP流的引导信息</span><br><span class="line">    asrt                    Y	                            将片段映射到段</span><br><span class="line">    afrt                    Y	                            将时间映射到片段</span><br><span class="line">moov                        Y	                            结构元数据容器</span><br><span class="line">    mvhd                    Y	                            Movie标题，整体声明</span><br><span class="line">    trak                    Y	                            单个轨道的Container</span><br><span class="line">        tkhd                Y	                            标题,主要属性</span><br><span class="line">        edts                N	                            编辑列表容器</span><br><span class="line">            elst            N	                            时间线映射</span><br><span class="line">        mdia                Y	                            媒体轨属性容器</span><br><span class="line">            mdhd            Y	                            媒体track属性</span><br><span class="line">            hdlr            Y	                            处理程序，声明媒体类型</span><br><span class="line">            minf            Y	                            媒体信息容器</span><br><span class="line">                vmhd	                                    视频媒体标题</span><br><span class="line">                smhd                                      声音媒体标题</span><br><span class="line">                hmhd                                      提示媒体标题</span><br><span class="line">                nmhd        Y,其中一个根据媒体类型            空媒体头</span><br><span class="line">                dinf        Y	                            数据信息容器</span><br><span class="line">                  dref      Y	                            数据参考</span><br><span class="line">                      url   Y	                            网址参考</span><br><span class="line">                stbl        Y	                            样本属性容器</span><br><span class="line">                  stsd      Y	                            示例描述（编解码器类型等）</span><br><span class="line">                  stts      Y	                           地图解码采样时间</span><br><span class="line">                  ctts      N	                            将合成时间映射到样本</span><br><span class="line">                  stsc      Y	                            将示例映射到块</span><br><span class="line">                  stsz      N	                           样本大小</span><br><span class="line">                  stco</span><br><span class="line">                  co64      Y, stco or co64               块偏移</span><br><span class="line">                  stss      N	                            同步示例表</span><br><span class="line">                  sdtp      N	                            独立和一次性样品</span><br><span class="line">    mvex                    N	                            Movie <span class="keyword">extends</span></span><br><span class="line">        mehd                N	                            Movie <span class="keyword">extends</span> header</span><br><span class="line">        trex                Y	                            Track <span class="keyword">extends</span> defaults</span><br><span class="line">    auth                    N	                            Author metadata tag</span><br><span class="line">    titl                    N	                            Title metadata tag</span><br><span class="line">    dscp                    N	                            Description metadata tag</span><br><span class="line">    cprt                    N	                            Copyright metadata tag</span><br><span class="line">    udta                    N	                            User data</span><br><span class="line">uuid                        N	                            XMP Metadata</span><br><span class="line">moof                        N	                            Movie fragment</span><br><span class="line">    mfhd                    Y	                            Movie fragment header</span><br><span class="line">    traf                    N	                            Track fragment</span><br><span class="line">      tfhd                  Y	                            Track fragment header</span><br><span class="line">      trun                  N	                            Track fragment run</span><br><span class="line">mdat                        Y 对于HTTP流以外的其他流          Media data container</span><br><span class="line">meta                        N                           	Container <span class="keyword">for</span> metadata boxes</span><br><span class="line">    ilst                    N                           	Metadata tags</span><br><span class="line">free                        N	                            Free space</span><br><span class="line">skip                        N	                            Free space</span><br><span class="line">mfra                        N                           	Movie fragment random access</span><br><span class="line">    tfra                    N	                            Track fragment random access</span><br><span class="line">    mfro                    Y	                            Movie fragment random access offset</span><br></pre></td></tr></table></figure>

<h4 id="a1-5">1.5. 示例描述框层次结构</h4>

<p>Table 2 shows the hierarchy within the Sample Description box.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Box Name	                        Required?                       Short Description</span><br><span class="line">stsd                              Y	                              Sample descriptions</span><br><span class="line">    Mediatype-specific</span><br><span class="line">    sample entry boxes            Y 除加密外                        此track的示例说明</span><br><span class="line">    rtmp                          Y <span class="keyword">for</span> HTTP streaming            Adobe MUX提示示例条目</span><br><span class="line">        amhp                      Y	                              Adobe MUX提示过程</span><br><span class="line">        amto                      N	                              Adobe Mux时间偏移</span><br><span class="line">    encv</span><br><span class="line">    enca</span><br><span class="line">    encr                          Y <span class="keyword">for</span> encryption                加密track的示例说明条目</span><br><span class="line">        sinf                      Y	                              保护方案信息</span><br><span class="line">            frma                  Y	                              原始格式</span><br><span class="line">            schm                  Y	                              方案Type</span><br><span class="line">            schi                  Y	                              方案信息</span><br><span class="line">              adkm                Y                             	Adobe的DRM密钥管理系统</span><br><span class="line">                ahdr              Y	                              Adobe DRM标题</span><br><span class="line">                  aprm            Y	                              标准加密参数</span><br><span class="line">                    aeib          Y	                              加密信息</span><br><span class="line">                    akey          Y	                              关键信息</span><br><span class="line">                      aps         N	                              frms v1.x参数</span><br><span class="line">                      flxs        N	                              闪存访问v <span class="number">2.0</span>参数</span><br><span class="line">                  asig            N	                              Adobe 签名</span><br><span class="line">                adaf              Y	                              Adobe DRM 访问单元格式</span><br></pre></td></tr></table></figure>

<h4 id="a1-6">1.6. 处理不支持的boxes</h4>

<p>ISO规范ISO/IEC 14496-12:2008和Apple QuickTime规范定义了本规范中未包含的其他盒子类型。这些框类型不是f4v文件格式的一部分，f4v播放器不需要支持它们。F4V播放器应忽略不支持的盒子及其内容，并继续播放文件。</p>
<h4 id="a1-7">1.7. 排序</h4>

<p>为了获得最佳的播放器性能，F4V文件中所需的顶级框应按以下顺序排列：</p>
<ol>
<li><p>   File Type (ftyp),</p>
</li>
<li><p>   Movie (moov),</p>
</li>
</ol>
<p>.    Media Data (mdat).</p>
<p>FTYP箱应位于MOOV和MDAT箱以及任何其他“重要”可变尺寸箱之前。ftyp框应该是文件中的第一个框，或者尽可能早地位于文件中。</p>
<p>虽然Flash播放器可以同时播放MOOV和MDAT盒的订单，但MOOV盒应始终位于MDAT盒之前，因为这样可以更快地启动和进行流式处理。</p>
<p>许多f4v文件创建工具以次优的顺序放置方框以便播放，在这种情况下，应应用后处理步骤以推荐的顺序放置方框。</p>
<p>有关HTTP流支持所需的框和框顺序，请参阅附录C.HTTP流：文件结构。</p>
<h4 id="a1-8">1.8. Supported Media Types</h4>

<p>下表描述了可以封装在F4V文件中的媒体类型。</p>
<h5 id="a1-8-1">1.8.1. Supported audio types</h5>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Media type      	Comments</span><br><span class="line">MP3               媒体类型.mp3（<span class="number">0x2e6d7033</span>）表示曲目包含MP3音频数据。</span><br><span class="line">                  点号字符hex <span class="number">0x2e</span>用于生成完整的四字符代码。</span><br><span class="line">AAC               媒体类型MP4A（<span class="number">0x6D703461</span>）表示该曲目使用AAC音频编码。</span><br><span class="line">                  Flash播放器支持以下AAC配置文件，由它们的对象类型表示：</span><br><span class="line">-	<span class="number">1</span> = main profile</span><br><span class="line">-	<span class="number">2</span> = low complexity, a.k.a. LC</span><br><span class="line">-	<span class="number">5</span> = high efficiency/scale band replication, a.k.a. HE/SBR</span><br></pre></td></tr></table></figure>


<p>当音频编解码器为AAC时，示例表的STSD框中会出现一个ESDS框。此框包含AAC解码器解码流所需的初始化数据。有关此框结构的更多信息，请参见ISO/IEC 14496-3。</p>
<h5 id="a1-8-2">1.8.2. Supported video types</h5>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Media type	         Comments</span><br><span class="line">GIF                  媒体类型的gif（<span class="number">0x67696620</span>）表示使用CompuServe gif格式压缩的视频数据的静止帧。</span><br><span class="line">                    包括空格字符hex <span class="number">0x20</span>，以生成完整的四字符代码。</span><br><span class="line">  </span><br><span class="line">PNG                 PNG的媒体类型（<span class="number">0x706E6720</span>）表示使用标准PNG格式压缩的视频数据的静止帧。</span><br><span class="line">                    包括空格字符hex <span class="number">0x20</span>，以生成完整的四字符代码。</span><br><span class="line"></span><br><span class="line">JPEG                jpeg（<span class="number">0x6a706567</span>）的媒体类型表示使用标准jpeg格式压缩的视频数据的静止帧。</span><br><span class="line"></span><br><span class="line">H<span class="number">.264</span>               h264（<span class="number">0x48323634</span>）、h264（<span class="number">0x68323634</span>）或avc1（<span class="number">0x61766331</span>）</span><br><span class="line">                    的媒体类型表示该曲目使用H<span class="number">.264</span>视频编码。Flash播放器支持以下H<span class="number">.264</span>视频配置文件：</span><br><span class="line"></span><br><span class="line">-	<span class="number">0</span> = 支持忽略设置配置文件的旧媒体</span><br><span class="line">-	<span class="number">66</span> = baseline</span><br><span class="line">-	<span class="number">77</span> = extended</span><br><span class="line">-	<span class="number">88</span> = main</span><br><span class="line">-	<span class="number">100</span> = YUV <span class="number">4</span>:<span class="number">2</span>:<span class="number">0</span>, <span class="number">8</span> bits/sample, a.k.a. “High”</span><br><span class="line">-	<span class="number">110</span> = YUV <span class="number">4</span>:<span class="number">2</span>:<span class="number">0</span>, <span class="number">10</span> bits/sample, a.k.a. “High <span class="number">10</span>”</span><br><span class="line">-	<span class="number">122</span> = YUV <span class="number">4</span>:<span class="number">2</span>:<span class="number">2</span>, <span class="number">10</span> bits/sample, a.k.a. “High <span class="number">4</span>:<span class="number">2</span>:<span class="number">2</span>”</span><br><span class="line">-	<span class="number">144</span> = YUV <span class="number">4</span>:<span class="number">4</span>:<span class="number">4</span>, <span class="number">12</span> bits/sample, a.k.a. “High <span class="number">4</span>:<span class="number">4</span>:<span class="number">4</span>”</span><br><span class="line">当视频编解码器为H<span class="number">.264</span>时，在示例表的STSD框中会出现一个AVCC框。此框包含H<span class="number">.264</span>解码器解码流所需的初始化数据。</span><br><span class="line">BoxHeader后面的字节<span class="number">1</span>和<span class="number">3</span>分别包含AVC数据的概要文件和级别。有关AVCC箱其余部分的更多信息，</span><br><span class="line">请参见ISO/IEC <span class="number">14496</span>-<span class="number">15</span>第<span class="number">5.3</span><span class="number">.4</span><span class="number">.1</span>节。</span><br><span class="line"></span><br><span class="line">VP6                 以下媒体类型表示该曲目是用on2 vp6视频编码的。-VP6F（<span class="number">0x56503646</span>）</span><br><span class="line"></span><br><span class="line">-	VP6A (<span class="number">0x56503641</span>)</span><br><span class="line">-	VP60 (<span class="number">0x56503630</span>)</span><br><span class="line">-	VP61 (<span class="number">0x56503631</span>)</span><br><span class="line">-	VP62 (<span class="number">0x56503632</span>)</span><br></pre></td></tr></table></figure>

<h5 id="a1-8-3">1.8.3. Supported data types</>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Media type       	Comments</span><br><span class="line">Text              文本（<span class="number">0x74657874</span>）或tx3g（<span class="number">0x74783367</span>）</span><br><span class="line">                  的媒体类型表示曲目包含通过ActionScript提供的文本数据。</span><br><span class="line">AMF0              媒体类型amf0（<span class="number">0x616d6630</span>）表示该曲目包含与操作脚本消息格式</span><br><span class="line">                  （amf）的原始版本相对应的数据。</span><br><span class="line">AMF3              媒体类型amf3（<span class="number">0x616d6633</span>）表示该曲目包含与操作脚本消息格式（amf）版本<span class="number">3</span>对应的数据。</span><br></pre></td></tr></table></figure>

<h3 id="a2">2. F4V Box Definitions</h3>

<p>定义了f4v文件格式支持的框。</p>
<h4 id="a2-1">2.1. File Type box</h4>

<p>Box type: ‘ftyp’ </p>
<p>Container: File </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>f4v格式基于iso mpeg4格式，而iso mpeg4格式又基于Apple QuickTime容器格式。格式的子集支持不同的功能。文件类型（ftyp）框有助于识别程序播放特定文件所需支持的功能。</p>
<p>FTYP箱应尽早放置，并应位于任何可变长度箱之前。</p>
<p>flash player对ftyp框没有任何限制。如果文件包含Flash播放器可以解码的数据，Flash播放器会尝试播放。</p>
<p>ftyp box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                Type           Comments</span><br><span class="line">Header              	BOXHEADER	     BoxType = <span class="string">&#x27;ftyp&#x27;</span> (<span class="number">0x66747970</span>)</span><br><span class="line">MajorBrand            UI32          主要品牌标识符。对于f4v文件，majorbrand是<span class="string">&#x27;f4v&#x27;</span>（<span class="number">0x66347620</span>）。</span><br><span class="line"></span><br><span class="line">MinorVersion          UI32          Minorversion仅提供信息。不得用于确定文件是否符合标准。</span><br><span class="line">                                    它可能允许更精确地识别主要品牌，以便进行检查、调试或改进解码。</span><br><span class="line">                                    compatible brands ui32[]任意数量的兼容品牌，直到包装盒结束</span><br></pre></td></tr></table></figure>


<p>For more information, see section 4.3 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-2">2.2. 渐进式下载信息框</h4>

<p>Box type: ‘pdin’ </p>
<p>Container: File </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>渐进式下载信息（PDIN）框定义有关渐进式下载的信息。pdin框的有效负载提供了一些提示，提示玩家在安全开始播放之前要下载多少数据。</p>
<p>pdin框应尽可能早地放置在文件中，位于文件类型（ftyp）框之后，以获得最大的实用性。</p>
<p>pdin box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	          Type	        Comment</span><br><span class="line">Header          BOXHEADER	    BoxType = <span class="string">&#x27;pdin&#x27;</span> (<span class="number">0x7064696E</span>)</span><br><span class="line">Version         UI8	          Expected to be <span class="number">0</span></span><br><span class="line">Flags           UI24	        Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">RateDelay       RATEDELAY[]	  任意数量的RATEDLAY记录，直到方框结束</span><br><span class="line">Rate            UI32	        此记录要考虑的速率（字节/秒）</span><br><span class="line">InitialDelay    UI32	        以此速率开始播放之前要延迟的毫秒数</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.1.3 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-3">2.3.  Movie box</h4>

<p>Box type: ‘moov’ </p>
<p>Container: File </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>Movie（moov）框实际上是一个f4v文件的“头”。MOOV框本身包含一个或多个其他框，而其他框又包含定义F4V数据结构的其他框。</p>
<p>moov box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	      Type        	Comment</span><br><span class="line">Header	    BOXHEADER	    BoxType = <span class="string">&#x27;moov&#x27;</span> (<span class="number">0x6D6F6F76</span>)</span><br><span class="line">Boxes	      BOX [ ]	      定义文件结构的任意框数</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.2.1 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-4">2.4. Movie Header box</h4>

<p>Box type: ‘mvhd’ </p>
<p>Container: Movie box (‘moov’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>Movie标题（MVHD）框定义应用于整个F4V文件的播放信息。MVHD箱应首先放置在其容器中。</p>
<p>mvhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field     	    Type	              Comment</span><br><span class="line">Header	        BOXHEADER	          BoxType = <span class="string">&#x27;mvhd&#x27;</span> (<span class="number">0x6D766864</span>)</span><br><span class="line">Version	        UI8	                Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags           UI24	              Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">CreationTime    IF Version == <span class="number">0</span>     f4v文件的创建时间，</span><br><span class="line">                UI32                表示为自<span class="number">1904</span>年<span class="number">1</span>月<span class="number">1</span>日午夜（UTC）以来经过的秒数。</span><br><span class="line">                IF Version == <span class="number">1</span></span><br><span class="line">                UI64</span><br><span class="line"></span><br><span class="line">ModificationTime	IF Version == <span class="number">0</span>   f4v文件的最后一次修改时间，</span><br><span class="line">                UI32                表示为自<span class="number">1904</span>年<span class="number">1</span>月<span class="number">1</span>日午夜（UTC）以来经过的秒数。</span><br><span class="line">                IF Version == <span class="number">1</span></span><br><span class="line">                UI64</span><br><span class="line">TimeScale       UI32                整个f4v文件的时间坐标系，以每秒的时间单位数表示。</span><br><span class="line">                                    例如，<span class="number">100</span>表示时间单位为<span class="number">1</span>/<span class="number">100</span>秒。</span><br><span class="line">Duration        IF Version == <span class="number">0</span></span><br><span class="line">                UI32                以时间刻度单位表示的F4V文件的总长度</span><br><span class="line">                IF Version == <span class="number">1</span>     也是文件中最长曲目的持续时间。</span><br><span class="line">                UI64</span><br><span class="line">Rate            SI16<span class="number">.16</span>             首选播放速率，以固定点<span class="number">16.16</span>数字表示</span><br><span class="line">                                    （通常为<span class="number">0x00010000</span>=<span class="number">1.0</span>，或正常播放速率）</span><br><span class="line">Volume          SI8<span class="number">.8</span>               文件的主卷，表示为定点<span class="number">8.8</span>号</span><br><span class="line">                                    （通常为<span class="number">0x0100</span>=<span class="number">1.0</span>，或完整卷）。</span><br><span class="line">Reserved        UI16	              Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Reserved        UI32 [<span class="number">2</span>]	          Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Matrix          SI32 [<span class="number">9</span>]            f4v文件的转换矩阵应为:</span><br><span class="line">                                    &#123;<span class="number">0x00010000</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">0x00010000</span>, <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x40000000</span>&#125;</span><br><span class="line">Reserved        UI32 [<span class="number">6</span>]	          Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">NextTrackID     UI32                要添加到演示文稿的下一个track的ID。</span><br><span class="line">                                    该值不应为<span class="number">0</span>，但可以全部为<span class="number">1</span>，以表示未定义状态。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.2.2 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-5">2.5. Track box</h4>

<p>Box type: ‘trak’ </p>
<p>Container: Movie box (‘moov’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One or more</p>
<p>每个trak框对应于f4v文件中的单个媒体曲目，并包含进一步定义媒体曲目属性的框。</p>
<p>trak box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	          Type               Comment</span><br><span class="line">Header	        BOXHEADER	         BoxType = <span class="string">&#x27;trak&#x27;</span> (<span class="number">0x7472616B</span>)</span><br><span class="line">Boxes	          BOX [ ]	           定义媒体轨的任意框数</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.3.1 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-5-1">2.5.1. Track Header box</h5>

<p>Box type: ‘tkhd’ </p>
<p>Container: Movie box (‘trak’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>The Track Header （TKHD）框描述磁道的主要属性。TKHD箱应首先放在其容器中。</p>
<p>tkhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type	            Comment</span><br><span class="line">Header	          BOXHEADER	        BoxType = <span class="string">&#x27;tkhd&#x27;</span> (<span class="number">0x746B6864</span>)</span><br><span class="line"></span><br><span class="line">Version	          UI8	              Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags             UI24              Bit <span class="number">0</span> = 开启</span><br><span class="line">                                    Bit <span class="number">1</span> = the track is part <span class="keyword">of</span> the presentation</span><br><span class="line">                                    Bit <span class="number">2</span> = the track should be considered when previewing the F4V file</span><br><span class="line">CreationTime      IF Version == <span class="number">0</span></span><br><span class="line">                  UI32              轨道的创建时间</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line">ModificationTime	IF Version == <span class="number">0</span></span><br><span class="line">                  UI32              轨道的最后修改时间</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line">TrackID	          UI32	            track唯一标识符</span><br><span class="line">Reserved	        UI32	            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Duration          IF Version == <span class="number">0</span></span><br><span class="line">                  UI32              音轨的持续时间</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line"></span><br><span class="line">Reserved          UI32 [<span class="number">2</span>]	        Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Layer             SI16              track前后排序的位置，对于f4v文件，预计为<span class="number">0</span>。</span><br><span class="line">AlternateGroup	  SI16	            <span class="number">0</span></span><br><span class="line">Volume            SI8<span class="number">.8</span>             音频轨为<span class="number">0x0100</span>（定点<span class="number">8.8</span>，数字代表<span class="number">1.0</span>），否则为<span class="number">0</span></span><br><span class="line">Reserved          UI16	            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">TransformMatrix	  SI32[<span class="number">9</span>]           定义透视变换的固定点值矩阵，应</span><br><span class="line">                                    &#123;<span class="number">0x00010000</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                                    <span class="number">0</span>, <span class="number">0x00010000</span>, <span class="number">0</span></span><br><span class="line">                                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x40000000</span>&#125;</span><br><span class="line">Width             UI16<span class="number">.16</span>	          以固定点表示的宽度<span class="number">16.16</span>数字</span><br><span class="line">Height	          UI16<span class="number">.16</span>	          以固定点表示的高度<span class="number">16.16</span>数字</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-5-2">2.5.2. Edit box</h5>

<p>Box type: ‘edts’ </p>
<p>Container: Track box (‘trak’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>编辑（EDTS）框将演示时间线映射到媒体时间线，因为它存储在F4V文件中。EDTS框是编辑列表的容器。</p>
<p>如果文件不包含EDTS框，则会隐式地对这些时间线进行一对一映射。EDTS框应位于媒体（MDIA）框之前。</p>
<p>edit box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type	          Comment</span><br><span class="line">Header            BOXHEADER	      BoxType = <span class="string">&#x27;edts&#x27;</span> (<span class="number">0x65647473</span>)</span><br><span class="line">Edit list box	    BOX	            An explicit time-line map</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-5-2-1">2.5.2.1. Edit List box</h5>

<p>Box type: ‘elst’ </p>
<p>Container: Edit box (‘edts’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>tkhd box</p>
<p>编辑列表（ELST）框以编辑列表条目的形式包含显式时间线图。ELST框中的每个条目通过以下方式之一定义了演示时间线的一部分：</p>
<p>-通过映射媒体时间表的一部分</p>
<p>-通过指示空时间（即间隙）</p>
<p>-通过定义停留时间（即一个时间点停留一段时间的位置）</p>
<p>编辑列表框中的空编辑表示间隙。若要指定轨迹的起始偏移，请在轨迹的起始处插入空的编辑。</p>
<p>空编辑不应是曲目中的最后一个编辑。如果在“影片标题”框中指定的持续时间与曲目的实际持续时间不同，则会在曲目末尾放置一个隐式空编辑。</p>
<p>媒体应该在间隙后立即有一个关键帧。另外，flash播放器可以使用同步采样框中的数据在间隙后查找关键帧。</p>
<p>elst box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	              Type	            Comment</span><br><span class="line">Header              BOXHEADER         BoxType = <span class="string">&#x27;elst&#x27;</span> (<span class="number">0x656C7374</span>)</span><br><span class="line">Version	            UI8               Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags	              UI24	            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">EntryCount  	      UI32	            <span class="built_in">Number</span> <span class="keyword">of</span> entries <span class="keyword">in</span> the edit list entry table</span><br><span class="line">EditListEntryTable	ELSTRECORD </span><br><span class="line">                    [EntryCount]	    An array <span class="keyword">of</span> ELSTRECORD structures</span><br><span class="line">SegmentDuration	    IF Version == <span class="number">0</span></span><br><span class="line">                    UI32              此编辑段的持续时间</span><br><span class="line">                    IF Version == <span class="number">1</span></span><br><span class="line">                    UI64</span><br><span class="line">MediaTime           IF Version == <span class="number">0</span></span><br><span class="line">                    SI32              此编辑段媒体中的开始时间作为合成时间，</span><br><span class="line">                    IF Version == <span class="number">1</span>   以MDHD中定义的时间刻度单位表示？盒子。值-<span class="number">1</span>指定空编辑。</span><br><span class="line">                    SI64</span><br><span class="line">MediaRateInteger	  SI16              播放此编辑段媒体的相对速率。默认值为<span class="number">1</span>。值为<span class="number">0</span>表示停留编辑。</span><br><span class="line">MediaRateFraction	  SI16	            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.6 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-6">2.6. Media box</h4>

<p>Box type: ‘mdia’ </p>
<p>Container: Track box (‘trak’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>tkhd box</p>
<p>媒体（MDIA）框包含定义媒体曲目属性的框</p>
<p>mdia box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type	          Comment</span><br><span class="line">Header            BOXHEADER	      BoxType = <span class="string">&#x27;mdia&#x27;</span> (<span class="number">0x6D646961</span>)</span><br><span class="line">Edit list box	    BOX[]	          定义媒体跟踪属性的任意数量的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-6-1">2.6.1. Media Header box</h5>

<p>Box type: ‘mdhd’ </p>
<p>Container: Media box (‘mdia’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>媒体标题（MDHD）框描述媒体曲目的属性。MDHD箱应首先放在其容器中。</p>
<p>mdhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type	          Comment</span><br><span class="line">Header	          BOXHEADER	      BoxType = <span class="string">&#x27;mdhd&#x27;</span> (<span class="number">0x6D646864</span>)</span><br><span class="line">Version     	    UI8	            Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags	            UI24          	Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">CreationTime      IF Version == <span class="number">0</span></span><br><span class="line">                  UI32              The creation time <span class="keyword">of</span> the box</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line">ModificationTime	IF Version == <span class="number">0</span></span><br><span class="line">                  UI32              The last modification time <span class="keyword">of</span> the box</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line">TimeScale         UI32            此轨道的时间坐标系，以每秒的时间单位数表示</span><br><span class="line">Duration          IF Version == <span class="number">0</span></span><br><span class="line">                  UI32             The total duration <span class="keyword">of</span> <span class="built_in">this</span> track</span><br><span class="line">                  IF Version == <span class="number">1</span></span><br><span class="line">                  UI64</span><br><span class="line">Pad	              UI1	            Padding, set to <span class="number">0</span></span><br><span class="line">Language          UI5 [<span class="number">3</span>]         <span class="number">3</span>字符代码指定语言（见ISO <span class="number">639</span>-<span class="number">2</span>/T），</span><br><span class="line">                                  每个字符解释为<span class="number">0x60</span>+（<span class="number">5</span>位）代码，以生成一个ASCII字符</span><br><span class="line">Reserved	        UI16	          Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-6-2">2.6.2. Handler Reference box</h5>

<p>Box type: ‘hdlr’ </p>
<p>Container: Media box (‘mdia’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>处理程序引用（HDLR）框声明跟踪中媒体数据的性质。hdlr框应位于媒体信息（minf）框之前。</p>
<p>hdlr box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	          Type	          Comment</span><br><span class="line">Header          BOXHEADER	      BoxType = <span class="string">&#x27;hdlr&#x27;</span> (<span class="number">0x68646C72</span>)</span><br><span class="line">Version         UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags           UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">Predefined      UI32            <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">HandlerType     UI32            包含以下<span class="number">4</span>cc值的整数：“vide”=视频轨</span><br><span class="line">                                <span class="string">&#x27;soun&#x27;</span>=音频轨<span class="string">&#x27;data&#x27;</span>=数据轨<span class="string">&#x27;hint&#x27;</span>=提示轨</span><br><span class="line">                                其他轨道类型将被忽略。</span><br><span class="line">Reserved        UI32 [<span class="number">3</span>]        <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">Name            <span class="built_in">String</span>          以空结尾的命名跟踪类型的utf-<span class="number">8</span>字符串，用于调试。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.3 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-7">2.7. Media Information box</h4>

<p>Box type: ‘minf’ </p>
<p>Container: Media box (‘mdia’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>媒体信息（minf）框包含定义曲目媒体信息的框。</p>
<p>minf框包含一个媒体头框，其类型与曲目的handlerType相对应。</p>
<p>minf box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;minf&#x27;</span> (<span class="number">0x6D696E66</span>)</span><br><span class="line">Boxes         BOX [ ]         定义track媒体信息的任意框数</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.3 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-1">2.7.1. Video Media Header box</h5>

<p>Box type: ‘vmhd’ </p>
<p>Container: Media Information box (‘minf’)  </p>
<p>Mandatory: Yes for a video track, otherwise no.  </p>
<p>Quantity: One for a video track, otherwise zero.</p>
<p>视频媒体标题（vmhd）框包含视频媒体的一般信息，与所使用的编码无关。vmhd箱应首先放在其容器中。</p>
<p>vmhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;vmhd&#x27;</span> (<span class="number">0x766D6864</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            <span class="built_in">Set</span> to <span class="number">1.</span></span><br><span class="line">GraphicsMode  UI16            视频轨的合成模式。默认值为<span class="number">0</span>，这意味着复制现有图像。</span><br><span class="line">OpColor       UI16 [<span class="number">3</span>]        图形模式使用的一组<span class="number">3</span>个RGB颜色值。默认值：（<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>）</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.5.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-2">2.7.2. Sound Media Header box</h5>

<p>Box type: ‘smhd’ </p>
<p>Container:Media Information box (‘minf’) </p>
<p>Mandatory: Yes for an audio track, otherwise no.  </p>
<p>Quantity: One for an audio track, otherwise zero.</p>
<p>声音媒体标题框包含音频媒体的一般信息，与所使用的编码无关。SMHD盒应首先放在其容器中。</p>
<p>smhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;smhd&#x27;</span> (<span class="number">0x736D6864</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0.</span></span><br><span class="line">Flags         UI24            <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">Balance       SI8<span class="number">.8</span>           固定点<span class="number">8.8</span>号。将单声道音频曲目映射到立体声空间，如下所示：</span><br><span class="line">                              -<span class="number">1.0</span>=完全向左</span><br><span class="line">                              <span class="number">0</span> =中心</span><br><span class="line">                              <span class="number">1.0</span>=完全正确</span><br><span class="line">Reserved      UI16            <span class="built_in">Set</span> to <span class="number">0.</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.5.3 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-3">2.7.3. Hint Media Header box</h5>

<p>Box type: ‘hmhd’ </p>
<p>Container: Media Information box (‘minf’) </p>
<p>Mandatory: Yes for a hint track, otherwise no. </p>
<p>Quantity: One for a hint track, otherwise zero.</p>
<p>提示媒体头（hmhd）框包含提示跟踪的一般信息，与所使用的协议无关。HMHD箱应首先放在其容器中。</p>
<p>hmhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;hmhd&#x27;</span> (<span class="number">0x686D6864</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0.</span></span><br><span class="line">Flags         UI24            <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">MaxPDUSize    UI16            Size (<span class="keyword">in</span> bytes) <span class="keyword">of</span> the largest PDU <span class="keyword">in</span> hint stream.</span><br><span class="line">AvgPDUSize    UI16            Average size (<span class="keyword">in</span> bytes) <span class="keyword">of</span> a PDU <span class="keyword">in</span> entire presentation</span><br><span class="line">MaxBitRate    UI32            Maximum rate (<span class="keyword">in</span> bits per second) over an interval <span class="keyword">of</span> <span class="number">1</span> second.</span><br><span class="line">AvgBitRate    UI32            Average rate (<span class="keyword">in</span> bits per second) over entire presentation.</span><br><span class="line">Reserved      UI32            <span class="built_in">Set</span> to <span class="number">0.</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.5.4 of ISO/IEC 14496-12.</p>
<h5 id="a2-7-4">2.7.4. Null Media Header box</h5>

<p>Box type: ‘nmhd’ </p>
<p>Container:Media Information box (‘minf’) </p>
<p>Mandatory: Yes for metadata track, otherwise no. </p>
<p>Quantity: Zero for video, audio, and hint tracks, otherwise, one.</p>
<p>空媒体标题（NMHD）框包含视频和音频以外的曲目的常规信息。NMHD箱应首先放置在其容器中。</p>
<p>nmhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;nmhd&#x27;</span> (<span class="number">0x6E6D6864</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0.</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.4.5.5 of ISO/IEC 14496-12.</p>
<h5 id="a2-7-5">2.7.5. Data Information box</h5>

<p>Box type: ‘dinf’ </p>
<p>Container: Media Information box (‘minf’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>数据信息（DINF）框包含一个数据引用（DREF）框，用于声明媒体数据在某个磁道中的位置。DINF框应位于示例表（STBL）框之前。</p>
<p>dinf box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;dinf&#x27;</span> (<span class="number">0x64696E66</span>)</span><br><span class="line">Data          Reference box   BOX	Table <span class="keyword">of</span> data references, used to locate media data.</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.7.1 of ISO/IEC 14496-12.</p>
<h5 id="a2-7-6">2.7.6. Sample Table box</h5>

<p>Box type: ‘stbl’ </p>
<p>Container:Media Information box (‘minf’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>“示例表”（STBL）框包含一些框，用于定义组成轨迹的示例的属性。</p>
<p>STBL框中的框应按以下顺序排列：样本描述（STSD）、解码时间到样本（STTS）、样本到块（STSC）、样本大小（STSZ）、块偏移（STCO或CO64）。</p>
<p>样本描述（STSD）框及其包含的框在第2.8节样本描述框结构中进行了规定。</p>
<p>stbl box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stbl&#x27;</span> (<span class="number">0x7374626C</span>)</span><br><span class="line">Boxes         BOX [ ]        定义轨道组成样本属性的任意数量的框。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-1">2.7.6.1. Decoding Time to Sample box</h5>

<p>Box type: ‘stts’ </p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>解码采样时间（STTS）框定义采样表的采样映射时间</p>
<p>stts box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stts&#x27;</span> (<span class="number">0x73747473</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Count         UI32            The number <span class="keyword">of</span> STTSRECORD entries</span><br><span class="line">Entries       STTSRECORD </span><br><span class="line">              [Count]         An array <span class="keyword">of</span> STTSRECORD structures</span><br><span class="line"></span><br><span class="line">Each STTSRECORD has the following format: </span><br><span class="line">STTSRECORD</span><br><span class="line">SampleCount   UI32            此sttsrecord应用于的连续样本数</span><br><span class="line">SampleDelta   UI32            Sample duration <span class="keyword">in</span> TimeScale units defined <span class="keyword">in</span> the mdhd box</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.1.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-2">2.7.6.2. Composition Time to Sample box</h5>

<p>Box type: ‘ctts’ </p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>合成时间到样本（CTTS）框定义了样本表的合成时间到样本映射</p>
<p>ctts box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;ctts&#x27;</span> (<span class="number">0x63747473</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Count         UI32            The number <span class="keyword">of</span> CTTSRECORD entries</span><br><span class="line">Entries       CTTSRECORD </span><br><span class="line">              [Count]         An array <span class="keyword">of</span> CTTSRECORD structures</span><br><span class="line"></span><br><span class="line">Each STTSRECORD has the following format: </span><br><span class="line">STTSRECORD</span><br><span class="line">SampleCount     UI32          The number <span class="keyword">of</span> consecutive samples that <span class="built_in">this</span> CTTSRECORD applies to</span><br><span class="line">SampleOffset    UI32          对于sampleCount字段指定的每个样本，此</span><br><span class="line">                              字段包含一个正整数，它以MDHD框中定义的时间刻度单位指定解码时间的合成偏移量。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.1.3 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-3">2.7.6.3. Sample to Chunk box</h5>

<p>Box type: ‘stsc’ </p>
<p>Container: Sample Table box (‘stbl’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>“采样到块（STSC）”框定义媒体轨采样表中的采样到块映射。</p>
<p>stsc box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stsc&#x27;</span> (<span class="number">0x73747363</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Count         UI32            The number <span class="keyword">of</span> STSCRECORD entries</span><br><span class="line">Entries       STSCRECORD </span><br><span class="line">              [Count]         An array <span class="keyword">of</span> STSCRECORD structures</span><br><span class="line"></span><br><span class="line">Each STTSRECORD has the following format: </span><br><span class="line">STTSRECORD</span><br><span class="line">FirstChunk          UI32          The first chunk that <span class="built_in">this</span> record applies to</span><br><span class="line">SamplesPerChunk     UI32          The number <span class="keyword">of</span> consecutive samples that <span class="built_in">this</span> record applies to</span><br><span class="line">SampleDescIndex     UI32          The sample description that describes <span class="built_in">this</span> sequence <span class="keyword">of</span> chunks</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.7.4  of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-4">2.7.6.4. Sample Size box</h5>

<p>Box type: ‘stsz’ </p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>“样本大小”（STSZ）框指定样本表中每个样本的大小。</p>
<p>tkhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stsz&#x27;</span> (<span class="number">0x7374737A</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">ConstantSize  UI32            如果所有样本的大小相同，则此字段将使用该常量大小设置，否则为<span class="number">0</span>。</span><br><span class="line">SizeCount     UI32	          The number <span class="keyword">of</span> samples <span class="keyword">in</span> the track</span><br><span class="line">SizeTable     IF ConstantSize == <span class="number">0</span></span><br><span class="line">              UI32 [SizeCount]    样本量表。如果constantsize不是<span class="number">0</span>，则此表为空</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.7.3.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-5">2.7.6.5. Chunk Offset box</h5>

<p>Box type: ‘stco’ or ‘co64’</p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>每个样本表框应包含一个STCO或CO64类型的区块偏移框。STCO和CO64框为示例表中的每个块定义块偏移量。</p>
<p>stco and co64 boxes</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stco&#x27;</span> (<span class="number">0x7374636F</span>) or <span class="string">&#x27;co64&#x27;</span> (<span class="number">0x636F3634</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">OffsetCount   UI32            The number <span class="keyword">of</span> offsets <span class="keyword">in</span> the Offsets table</span><br><span class="line">Offsets       IF BoxType == <span class="string">&#x27;stco’</span></span><br><span class="line"><span class="string">              UI32 [OffsetCount]    文件中的绝对块偏移量表</span></span><br><span class="line"><span class="string">              ELSE IF BoxType == &#x27;</span>co64’</span><br><span class="line">              UI64 [OffsetCount]</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.7.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-6">2.7.6.6. Sync Sample box</h5>

<p>Box type: ‘stss’ </p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>同步样本（STSS）框指定样本表中的哪些样本是同步样本。同步样本是可以安全查找的样本。如果轨迹是视频轨迹，则同步采样是不依赖任何其他帧的任何数据的关键帧或帧内帧。</p>
<p>如果样本表（STBL）框不包含STSS框，则轨道中的所有样本均应视为同步样本。</p>
<p>stss box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;stss&#x27;</span> (<span class="number">0x73747373</span>)</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">SyncCount     UI32            The number <span class="keyword">of</span> entries <span class="keyword">in</span> SyncTable</span><br><span class="line">SyncTable     UI32            同时也是同步样本的样本数表，按样本数的升序</span><br><span class="line">              [SyncCount]</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.6.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-7-6-7">2.7.6.7. Independent and Disposable Samples box</h5>

<p>Box type: ‘sdtp’ </p>
<p>Container: Sample Table box (‘stbl’) or Track Fragment ‘traf </p>
<p>Mandatory: No </p>
<p>Quantity: One in each of the stbl and traf boxes</p>
<p>一个STBL或TRAF盒可分别包含一个独立的一次性样品盒（SDTP）。SDTP盒有助于实现诸如快进和随机访问等功能。sdtp框说明样本是否为i-picture，并提供有关样本中存在的帧依赖性和冗余编码的信息。表中的条目数与“样本大小”框中的sampleCount值相同。</p>
<p>stss box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	              Type	                  Comment</span><br><span class="line">Header              BOXHEADER               BoxType = <span class="string">&#x27;sdtp&#x27;</span> (<span class="number">0x73647470</span>)</span><br><span class="line">Version             UI8                     Expected to be <span class="number">0</span></span><br><span class="line">Flags               UI24                    Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">SampleDependency    SAMPLEDEPENDENCY []     每个示例的依赖关系信息，到框的末尾</span><br><span class="line"></span><br><span class="line">Each SAMPLEDEPENDENCY record has the following structure: </span><br><span class="line">SAMPLEDEPENDENCY</span><br><span class="line">Reserved            UI2                     Reserved. <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">SampleDependsOn     UI2</span><br><span class="line">                                            <span class="number">0</span> = the sample dependency is unknown</span><br><span class="line">                                            <span class="number">1</span> = <span class="built_in">this</span> sample does depend on others (not an I picture)</span><br><span class="line">                                            <span class="number">2</span> = <span class="built_in">this</span> sample does not depend on others (I picture)</span><br><span class="line">                                            <span class="number">3</span> = reserved</span><br><span class="line">SampleIsDependedOn	UI2</span><br><span class="line">                                            <span class="number">0</span> = the dependency <span class="keyword">of</span> other samples on <span class="built_in">this</span> sample is unknown</span><br><span class="line">                                            <span class="number">1</span> = other samples may depend on <span class="built_in">this</span> one (not disposable)</span><br><span class="line">                                            <span class="number">2</span> = no other sample depends on <span class="built_in">this</span> one (disposable)</span><br><span class="line">                                            <span class="number">3</span> = reserved</span><br><span class="line">SampleHasRedundancy  UI2</span><br><span class="line">                                            <span class="number">0</span> = it is unknown whether there is redundant coding <span class="keyword">in</span> <span class="built_in">this</span> sample</span><br><span class="line">                                            <span class="number">1</span> = there is redundant coding <span class="keyword">in</span> <span class="built_in">this</span> sample</span><br><span class="line">                                            <span class="number">2</span> = there is no redundant coding <span class="keyword">in</span> <span class="built_in">this</span> sample</span><br><span class="line">                                            <span class="number">3</span> = reserved</span><br></pre></td></tr></table></figure>


<p>当存在冗余编码时，“sampleDependson”的值仅对应于主编码。参数“sampleisdependedon”独立于冗余编码的存在。</p>
<p>For more information, see section 8.6.4 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-8">2.8. Sample Description Box Structure</h4>
<h5 id="a2-8-1">2.8.1. Sample Description box</h5>

<p>Box type: ‘stsd’ </p>
<p>Container:Sample Table box (‘stbl’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>“示例说明”（STSD）框定义示例表的示例说明。STSD框可以包含一个曲目的多个描述，每个媒体类型包含一个描述。示例描述表提供了有关所用编码类型的详细信息，以及该编码所需的任何初始化信息。</p>
<p>表2显示了示例描述框中的层次结构。有关更多信息，请参见ISO/IEC 14496-12第8.5.2节。</p>
<p>stsd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	               Type	                   Comment</span><br><span class="line">Header              BOXHEADER               BoxType = <span class="string">&#x27;stsd&#x27;</span> (<span class="number">0x73747364</span>)</span><br><span class="line">Version             UI8                     Expected to be <span class="number">0</span></span><br><span class="line">Flags               UI24                    Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Count               UI32</span><br><span class="line"><span class="built_in">Number</span> <span class="keyword">of</span> entries, one <span class="keyword">for</span> each media type contained <span class="keyword">in</span> the track</span><br><span class="line">Descriptions        DESCRIPTIONRECORD</span><br><span class="line">                    [Count]                 一组框，每个框对应包含在曲目中的媒体类型。</span><br></pre></td></tr></table></figure>


<p>Each DESCRIPTIONRECORD shall be one of the following boxes:</p>
<ul>
<li><p>   VisualSampleEntry, for HandlerType == ‘vide’ [video track],</p>
</li>
<li><p>   AudioSampleEntry, for HandlerType == ‘soun’ [audio track],</p>
</li>
<li><p>   MetaDataSampleEntry, for HandlerType == ‘meta’ [timed metadata track],</p>
</li>
<li><p>   SampleEntry, for HandlerType == ‘data’ [data track],</p>
</li>
<li><p>   HintSampleEntry, for HandlerType == ‘hint’ [hint track], or</p>
</li>
<li><p>   AdobeMuxHintSampleEntry, for HandlerType == ‘hint’ [Adobe Multiplexed Hint Track]</p>
<h5 id="a2-8-2">2.8.2. VisualSampleEntry box</h5>

</li>
</ul>
<p>Box type: one of the video media types specified in Section 1.8.2 Supported video types </p>
<p>Container:Sample Table box (‘stsd’) </p>
<p>Mandatory: Yes for video tracks </p>
<p>Quantity: One for each video track</p>
<p>VisualSampleEntry框包含有关所用视频编码类型的详细信息，以及该编码所需的任何初始化信息。有关更多信息，请参见ISO/IEC 14496-12:2008第8.5.2节。</p>
<p>VisualSampleEntry box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                 Type	          Comment</span><br><span class="line">Header                 BOXHEADER      BoxType is one <span class="keyword">of</span> the video media types specified <span class="keyword">in</span> <span class="number">1.8</span><span class="number">.2</span></span><br><span class="line">Reserved               UI8 [<span class="number">6</span>]        <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">DataReferenceIndex     UI16	          用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">Predefined             UI16           <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Reserved               UI16            <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Predefined             UI32 [<span class="number">3</span>]       <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Width                 UI16            Max visual width (<span class="keyword">in</span> pixels) <span class="keyword">from</span> codec</span><br><span class="line">Height                UI16            Max visual height (<span class="keyword">in</span> pixels) <span class="keyword">from</span> codec</span><br><span class="line">HorizResolution       UI16<span class="number">.16</span>         图像像素/英寸的分辨率，默认值为<span class="number">0x0048000</span>（<span class="number">72</span> dpi）</span><br><span class="line">VertResolution        UI16<span class="number">.16</span>         图像像素/英寸的分辨率，默认值为<span class="number">0x0048000</span>（<span class="number">72</span> dpi）</span><br><span class="line">Reserved              UI32            <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">FrameCount            UI16            每个样本中存储多少帧，默认值<span class="number">1</span>（每个样本一帧）</span><br><span class="line">CompressorName        UI8 [<span class="number">32</span>]        压缩机名称（仅供参考）。第一个字节设置为第一个字节后可显示数据的字节数。</span><br><span class="line">Depth                 UI16            比特深度。默认值<span class="number">0x0018</span>（不带字母的颜色）</span><br><span class="line">Predefined            SI16            <span class="built_in">Set</span> to -<span class="number">1</span></span><br><span class="line">Boxes                 BOX [ ]         为媒体类型或加密指定的附加框</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-3">2.8.3. AudioSampleEntry box</h5>

<p>Box type: one of the audio media types specified in Section 1.8.1 Supported audio types </p>
<p>Container:Sample Table box (‘stsd’)  </p>
<p>Mandatory: Yes for audio tracks </p>
<p>Quantity: One</p>
<p>audioSampleEntry框包含有关所用音频编码类型的详细信息，以及该编码所需的任何初始化信息。有关更多信息，请参见ISO/IEC 14496-12:2008第8.5.2节。</p>
<p>AudioSampleEntry box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                Type	          Comment</span><br><span class="line">Header                BOXHEADER       BoxType is one <span class="keyword">of</span> the audio media types specified <span class="keyword">in</span> <span class="number">1.8</span><span class="number">.1</span></span><br><span class="line">Reserved              UI8 [<span class="number">6</span>]         <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">DataReferenceIndex    UI16            用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">Reserved              UI32 [<span class="number">2</span>]        <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">ChannelCount          UI16            频道数。默认值为<span class="number">2</span>。</span><br><span class="line">                                      <span class="number">1</span> = Mono</span><br><span class="line">                                      <span class="number">2</span> = Stereo</span><br><span class="line">SampleSize            UI16            Size <span class="keyword">of</span> sample. Default value is <span class="number">16</span></span><br><span class="line">Predefined            UI16            <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">Reserved              UI16            <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">SampleRate            UI16<span class="number">.16</span>         Sampling rate, fixed point <span class="number">16.16</span> number</span><br><span class="line">Boxes                 BOX [ ]         Additional boxes <span class="keyword">as</span> specified <span class="keyword">for</span> the media type, or encryption</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-4">2.8.4. MetaDataSampleEntry box</h5>

<p>Box type: depends on protocol used </p>
<p>Container:Sample Table box (‘stsd’)  </p>
<p>Mandatory: Yes for metadata tracks </p>
<p>Quantity: One for each metadata track</p>
<p>MetadataSampleEntry框包含有关所用元数据编码类型的详细信息，以及该编码所需的任何初始化信息。有关更多信息，请参见ISO/IEC 14496-12:2008第8.5.2节。</p>
<p>MetaDataSampleEntry box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                  Type	          Comment</span><br><span class="line">Header                  BOXHEADER       BoxType depends on protocol used</span><br><span class="line">Reserved                UI8 [<span class="number">6</span>          <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">DataReferenceIndex      UI16            用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">Data                    UI8 [ ]         Additional contents <span class="keyword">as</span> specified <span class="keyword">in</span> ISO/IEC <span class="number">14496</span>-<span class="number">12</span>:<span class="number">2008</span></span><br></pre></td></tr></table></figure>

<h5 id="a2-8-5">2.8.5. SampleEntry box</h5>

<p>Box type: one of the data media types specified in Section1.8.3 Supported data types </p>
<p>Container:Sample Table box (‘stsd’) </p>
<p>Mandatory: Yes for data tracks </p>
<p>Quantity: One for each data track</p>
<p>sampleEntry框包含有关所用编码类型的详细信息，以及该编码所需的任何初始化信息。有关更多信息，请参见ISO/IEC 14496-12:2008第8.5.2节。</p>
<p>SampleEntry box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                Type	          Comment</span><br><span class="line">Header                BOXHEADER       BoxType is one <span class="keyword">of</span> the data media types specified <span class="keyword">in</span> Supported data types.</span><br><span class="line">Reserved              UI8 [<span class="number">6</span>]         <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">DataReferenceIndex	  UI16            用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">Boxes	                BOX [ ]         Additional boxes <span class="keyword">as</span> specified <span class="keyword">for</span> the media type, or encryption</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.aaaaaaaaaaaaaaaaaaaaaaaaaaa of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-8-6">2.8.6. HintSampleEntry box</h5>

<p>Box type: ‘hint’ </p>
<p>Container:Sample Table box (‘stsd’ </p>
<p>Mandatory: Yes for hint tracks </p>
<p>Quantity: One for each hint track</p>
<p>hintsampleEntry（提示）框包含正在使用的流协议的适当声明性数据以及提示轨的格式。有关更多信息，请参见ISO/IEC 14496-12:2008第8.5.2节。</p>
<p>HintSampleEntry box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	               Type	            Comment</span><br><span class="line">Header               BOXHEADER         一般来说，boxType取决于使用的协议。在F4V文件中，只允许使用“提示”框类型。</span><br><span class="line">                                       保留的ui8[<span class="number">6</span>]设置为<span class="number">0</span></span><br><span class="line">DataReferenceIndex	  UI16            用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">Data                  UI8 [ ]         Arbitrary number <span class="keyword">of</span> bytes until end <span class="keyword">of</span> box</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-7">2.8.7. Sample Descriptions for HTTP Streaming with Fragments</h5>
<h5 id="a2-8-7-1">2.8.7.1.  Adobe Mux Hint Sample Entry box</h5>

<p>Box type: ‘rtmp’ </p>
<p>Container:Sample Table box (‘stsd’) </p>
<p>Mandatory: Yes for HTTP streaming support with F4V fragments </p>
<p>Quantity: One for the hint track for HTTP streaming support with F4V fragments</p>
<p>Adobemux提示示例条目（rtmp）框描述了使用f4v片段的HTTP流中使用的提示轨。见附录C.HTTP流：文件结构。提示轨包含ADobemuxhintsamples。</p>
<p>rtmp box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                  Type	                Comment</span><br><span class="line">Header                  BOXHEADER             BoxType = <span class="string">&#x27;rtmp&#x27;</span> (<span class="number">0x72746D70</span>)</span><br><span class="line">Reserved                UI8 [<span class="number">6</span>]               <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">DataReferenceIndex      UI16                  用于检索与使用此示例说明的示例关联的数据引用的索引。数据引用存储在数据引用（DREF）框中。</span><br><span class="line">HintTrackVersion        UI16                  正在使用的提示跟踪定义的版本。设置为<span class="number">1</span>。</span><br><span class="line">HighestCompatibleVersion	UI16                指定与旧版本的兼容性。</span><br><span class="line">MaxPacketSize           UI16                  最大的Adobe多路复用提示跟踪示例包大小（字节）。</span><br><span class="line">AdditionalData          BOX [ ]               一个Adobe MUX提示处理框和零个或一个Adobe MUX时间偏移框</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-7-2">2.8.7.2. Adobe Mux Hint Process box</h5>

<p>Box type: ‘amhp’ </p>
<p>Container:Adobe Mux Hint Sample Entry (‘rtmp’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>Adobe mux提示进程（amhp）框包含此曲目中使用的提示模式的描述</p>
<p>amhp box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;amhp&#x27;</span> (<span class="number">0x616D6870</span>))</span><br><span class="line">Version       UI8             Expected to be <span class="number">0</span></span><br><span class="line">Flags         UI24            Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">ModeCount     UI8             此框中支持的模式配置数。此值也是相应提示轨中支持的模式数。</span><br><span class="line">ENTRIES       MuxHintProcessEntry</span><br><span class="line">              [ModeCount]         An array <span class="keyword">of</span> MuxHintProcessEntry</span><br><span class="line"></span><br><span class="line">Each MuxHintProcessEntry has the following format:</span><br><span class="line">MuxHintProcessEntry</span><br><span class="line">HintTrackMode           UI8         条目对应的模式（示例或立即模式）。有关模式的更多信息，请参阅附录C<span class="number">.5</span> Adobe多路提示跟踪格式。</span><br><span class="line">TrailerLengthField      UI1         <span class="number">1</span>表示此模式的adobemuxhintsample中存在trailerLength字段。如果为<span class="number">0</span>，则使用trailerDefaultSize。</span><br><span class="line">LengthField             UI1         <span class="number">1</span>表示此模式的ADobemuxhintsample中存在提示样本长度字段。模式==<span class="number">2</span>时，长度字段应为<span class="number">1</span>。</span><br><span class="line">ModeField               UI1         <span class="number">1</span>表示此模式的ADobemuxhintsample中存在模式字段。当使用多种模式时，ModeField应为<span class="number">1</span>。</span><br><span class="line">ConstructorCountField   UI1         <span class="number">1</span>表示此模式的adobEmuxHintSample中存在<span class="title">constructorCount</span>字段。如果为0，则有一个构造函数</span><br><span class="line"><span class="title">PacketCountField</span>        <span class="title">UI1</span>         1表示此模式的<span class="title">ADobemuxhintsample</span>中存在<span class="title">packetcount</span>字段。</span><br><span class="line"><span class="title">Reserved</span>                <span class="title">UI3</span>         <span class="title">Set</span> <span class="title">to</span> 0</span><br><span class="line"><span class="title">TrailerDefaultSize</span>      <span class="title">UI8</span>         提示示例有效负载之后拖车数据的默认大小（以字节为单位）。在没有<span class="title">TrailerLengthField</span>时使用。</span><br></pre></td></tr></table></figure>


<p>对于FLV兼容模式，trailerLengthField、lengthField、modeField、constructorCountField和packetCountField应为0。在这种情况下，使用即时节点提升提示模式。</p>
<h5 id="a2-8-7-3">2.8.7.3. Adobe Mux Time Offset box</h5>

<p>Box type: ‘amto’ </p>
<p>Container:Adobe Mux Hint Sample Entry (‘rtmp’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>Adobe mux time offset（amto）框存储此文件中第一个提示示例的时间戳</p>
<p>amto box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header        BOXHEADER       BoxType = <span class="string">&#x27;amto&#x27;</span> (<span class="number">0x616D746F</span>)</span><br><span class="line">TimeOffset    UI32            文件中第一个提示示例的时间戳。</span><br><span class="line">                              这个时间戳是从累计的样本持续时间中导出的每个样本的表示时间中添加的偏移量。</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8">2.8.8. Sample Descriptions for Protected Contents</h5>
<h5 id="a2-8-8-1">2.8.8.1. Encrypted Video box</h5>

<p>Box type: ‘encv’ </p>
<p>Container:Sample Table box (‘stsd’) </p>
<p>Mandatory: Yes for encrypted video tracks </p>
<p>Quantity: One for each encrypted video track</p>
<p>如附件D.2所述，加密视频（Encv）盒应为原始视觉样本，并附上“sinf”盒。有关更多信息，请参见ISO/IEC 14496-12:2008第8.12节。</p>
<h5 id="a2-8-8-2">2.8.8.2. Encrypted Audio box</h5>

<p>Box type: ‘enca’ </p>
<p>Container: Sample Table box (‘stsd’)  </p>
<p>Mandatory:  Yes for encrypted audio tracks </p>
<p>Quantity: One for each encrypted audio track</p>
<p>如附录D.2所述，加密音频（ENCA）盒应为原始音频采样中心，并附上“sinf”盒。有关更多信息，请参见ISO/IEC 14496-12:2008第8.12节。</p>
<h5 id="a2-8-8-3">2.8.8.3. Encrypted Data box</h5>

<p>Box type: ‘encr’<br>&lt;<br>Container:Sample Table box (‘stsd’) </p>
<p>Mandatory: Yes for encrypted video tracks </p>
<p>Quantity: One for each encrypted video track</p>
<p>如附录D.2所述，加密数据（encr）箱应为原始样品中心，并附上“sinf”箱。有关更多信息，请参见ISO/IEC 14496-12:2008第8.12节。</p>
<h5 id="a2-8-8-4">2.8.8.4. Protection Scheme Information box</h5>

<p>Box type: ‘sinf’ </p>
<p>Container:’encv’ or ‘enca’ Sample Description Entry for the protected track in ‘stsd’ box </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>保护方案信息（sinf）框是一个容器框，其中包含了解所应用的加密转换及其参数以及查找密钥管理系统类型和位置等其他信息所需的所有信息。它还记录了媒体的原始（未加密）格式。它应附加到具有四个字符代码（“encv”、“enca”或“encr”）的任何示例条目中，以指示受保护的流。</p>
<p>sinf box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                  Type	                 Comment</span><br><span class="line">Header                  BOXHEADER             BoxType = <span class="string">&#x27;sinf&#x27;</span></span><br><span class="line">OriginalFormatBox       OriginalFormatBox     The format <span class="keyword">of</span> the original sample</span><br><span class="line">SchemeTypeBox           SchemeTypeBox         The DRM type. Required. (This is optional <span class="keyword">in</span> ISO <span class="number">14496</span>-<span class="number">12</span>)</span><br><span class="line">SchemeInformationBox    SchemeInformationBox  DRM details. Required. (This is optional <span class="keyword">in</span> ISO <span class="number">14496</span>-<span class="number">12</span>)</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.12 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-8-8-5">2.8.8.5. Original Format box</h5>

<p>Box type: ‘frma’ </p>
<p>Container:Protection Scheme Information box (‘sinf’)  </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>“原始格式”（FRMA）框指定原始样本的格式，例如，如果流包含受保护的MPEG-4视觉材料，“MP4V”。</p>
<p>frma box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                        Type	                  Comment</span><br><span class="line">Header                        BOXHEADER               BoxType = <span class="string">&#x27;frma&#x27;</span></span><br><span class="line">UnencryptedDataFormat         UI32                    原始未转换样本条目的四字符代码</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.12.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-8-8-6">2.8.8.6.  Scheme Type box</h5>

<p>Box type: ‘schm’ </p>
<p>Container: Protection Scheme Information box (‘sinf’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>方案类型（schm）框指定用于管理密钥和内容解密的DRM系统。由于媒体文件格式可能支持除Adobe的DRM以外的其他密钥管理系统，因此使用中的密钥管理系统应在schemetype字段中以四字符代码（4cc）表示。</p>
<p>schm box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header        BOXHEADER         BoxType = <span class="string">&#x27;schm&#x27;</span></span><br><span class="line">Version       UI8               Shall be <span class="number">1</span></span><br><span class="line">Flags         UI24              Shall be <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">SchemeType    UI32              方案类型。应为“adkm”，表示内容使用Adobe的DRM系统进行保护。</span><br><span class="line">SchemeVersion	UI32              Shall be <span class="number">1</span></span><br><span class="line">SchemeUri     IF Flags == <span class="number">1</span></span><br><span class="line">              STRING</span><br><span class="line">              Browser URI</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.12.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-8-8-7">2.8.8.7.  Scheme Information box</h5>

<p>Box type: ‘schi’ </p>
<p>Container:Protection Scheme Information box (‘sinf’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>方案信息（Schi）框是一个包含DRM密钥/权限管理系统特定信息的容器框。对于Adobe的DRM，此框应包括一个Adobe DRM密钥管理系统框。可能还有其他盒子。为了与其他DRM的互操作性，Adobe DRM密钥管理系统框可以位于方案信息框中的任何位置。</p>
<p>schi box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                      Type	          Comment</span><br><span class="line">Header                      BOXHEADER       BoxType = <span class="string">&#x27;schi&#x27;</span></span><br><span class="line">OtherDRMSpecificData        BOX [ ]         （可选）包含其他DRM特定密钥管理信息的框</span><br><span class="line">SchemeSpecificData          AdobeDRMKMSBox    Adobe DRM密钥管理系统框，指定密钥管理信息</span><br><span class="line">OtherDRMSpecificData        BOX [ ]         （可选）包含其他DRM特定密钥管理信息的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.12.6 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-8-8-8">2.8.8.8. Boxes for Adobe's Protection Scheme</h5>

<p>以下框由Adobe定义，未在ISO 14496-12:2008中记录。</p>
<h5 id="a2-8-8-8-1">2.8.8.8.1.  Adobe DRM Key Management System box</h5>

<p>Box type: ‘adkm’ </p>
<p>Container:Scheme Information box (‘schi’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>AdobeDRM密钥管理系统（ADKM）框指定加密和示例格式。</p>
<p>tkhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	         Type	             Comment</span><br><span class="line">Header         BOXHEADER         BoxType = <span class="string">&#x27;adkm&#x27;</span></span><br><span class="line"></span><br><span class="line">Version        UI8               Shall be <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Flags          UI24              Shall be <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Header       AdobeDRMHeaderBox   AdobeDRM头框，指定如何检索密钥以及如何使用它来解密内容。</span><br><span class="line">AUFormat	   AdobeDRMAUFormatBox	  Adobe DRM Access Unit格式框，指定每个示例预先准备的格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-2">2.8.8.8.2. Adobe DRM Header box</h5>

<p>Box type: ‘ahdr’ </p>
<p>Container:Adobe DRM Key Management System box (‘adkm’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>AdobeDRM头（ahdr）框指定加密格式和方法的版本。</p>
<p>ahdr box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	             Type	                      Comment</span><br><span class="line">Header             BOXHEADER                   BoxType = <span class="string">&#x27;ahdr&#x27;</span></span><br><span class="line">Version            UI8                         Shall be <span class="number">1</span> or <span class="number">2</span>, indicating the version <span class="keyword">of</span> the encryption format.</span><br><span class="line">                                              <span class="number">1</span> = FMRMS v1.x products.</span><br><span class="line">                                              <span class="number">2</span> = Flash Access <span class="number">2.0</span> products.</span><br><span class="line">                                              使用任一版本保护的内容均已存在，因此应用程序应能够同时使用两个版本的内容。</span><br><span class="line">Flags              UI24                        Shall be <span class="number">0</span>      </span><br><span class="line">StdEncryptionBox	StandardEncryptionParamsBox	标准加密参数框，包含用于加密样本的加密方法属于“标准加密”类型。</span><br><span class="line">Signature          IF Version == <span class="number">1</span></span><br><span class="line">                  AdobeSignatureBox           此文档中未描述AdobeSignatureBox</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-3">2.8.8.8.3. Standard Encryption Params box</h5>

<p>Box type: ‘aprm’ </p>
<p>Container: Adobe DRM Header box (‘ahdr’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>标准加密参数（APRM）框包含加密方法“标准”的参数。</p>
<p>tkhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                          Type	                  Comment</span><br><span class="line">Header                          BOXHEADER               BoxType = <span class="string">&#x27;aprm&#x27;</span></span><br><span class="line">Version                         UI8                     Shall be <span class="number">1</span></span><br><span class="line">Flags                           UI24                    Shall be <span class="number">0</span></span><br><span class="line">EncInfoBox                      EncryptionInfoBox       加密信息框，指定用于加密样本的加密算法</span><br><span class="line">KeyInfoBox                      KeyInfoBox              密钥信息框，指定如何检索用于解密示例的密钥</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-4">2.8.8.8.4. Encryption Information box</h5>

<p>Box type: ‘aeib’ </p>
<p>Container:标准加密参数框(‘aprm’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>加密信息（AEIB）框指定用于加密样本的加密算法。</p>
<p>aeib box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                        Type	                  Comment</span><br><span class="line">Header                          BOXHEADER               BoxType = <span class="string">&#x27;aeib&#x27;</span></span><br><span class="line">Version                         UI8                     Shall be <span class="number">1</span></span><br><span class="line">Flags                           UI24                    Shall be <span class="number">0</span></span><br><span class="line">EncryptionAlgorithm             STRING                  加密算法。应为“aes-cbc”，说明所使用的加密为“aes-cbc”，并根据RFC <span class="number">2630</span>进行填充。</span><br><span class="line">KeyLength                       UI8                     加密/解密算法的密钥长度（字节）。应为<span class="number">16</span>（即<span class="number">128</span>位）</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-5">2.8.8.8.5. Key Information box</h5>

<p>Box type: ‘akey’ </p>
<p>Container:Standard Encryption Params box (‘aprm’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>密钥信息（akey）框包含用于检索用于解密样本的密钥的信息。</p>
<p>这些框中包含的条目的详细信息以及DRM客户机用于检索密钥的机制超出了本规范的范围。</p>
<p>akey box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	              Type	                         Comment</span><br><span class="line">Header                BOXHEADER                      BoxType = <span class="string">&#x27;akey&#x27;</span></span><br><span class="line">Version               UI8                            Shall be <span class="number">1</span></span><br><span class="line">Flags                 UI24                           Shall be <span class="number">0</span></span><br><span class="line">Params      IF AdobeDRMHeaderBox.Version == <span class="number">1</span>  </span><br><span class="line">                APSParamsBox                        本文件中未对apsparamsbox进行描述，因为它将不再由符合要求的应用程序生成。</span><br><span class="line">            ELSE</span><br><span class="line">                FMRMSv2ParamsBox</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-6">2.8.8.8.6. Flash Access Params box</h5>

<p>Box type: ‘flxs’ </p>
<p>Container:Key Info box (‘akey’) </p>
<p>Mandatory: Yes, if AdobeDRMHeaderBox.Version == 2, else No </p>
<p>Quantity: One, if AdobeDRMHeaderBox.Version == 2, else Zero</p>
<p>flash access params（flxs）框包含用于检索用于解密样本的密钥的信息。</p>
<p>flxs box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	              Type	         Comment</span><br><span class="line">Header                BOXHEADER      BoxType = <span class="string">&#x27;flxs&#x27;</span></span><br><span class="line">FmrmsV2Metadata       STRING        DRM客户端用于检索解密密钥的base64编码元数据</span><br></pre></td></tr></table></figure>

<h5 id="a2-8-8-8-7">2.8.8.8.7. Adobe DRM Access Unit Format box</h5>

<p>Box type: ‘adaf’ </p>
<p>Container:Key Info box (‘adkm’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>访问单元格式（ADAF）框指定放置在样本上的头的格式。</p>
<p>tkhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	              Type	        Comment</span><br><span class="line">Header                BOXHEADER     BoxType = <span class="string">&#x27;tkhd&#x27;</span></span><br><span class="line">Version               UI8           Shall be <span class="number">1</span></span><br><span class="line">Flags                 UI24          Shall be <span class="number">0</span></span><br><span class="line">SelectiveEncryption   UI1           指示使用选择性加密。应为<span class="number">1</span>。</span><br><span class="line">                                    <span class="number">1</span>=启用选择性加密，即只加密部分样本，而不是全部样本。</span><br><span class="line">                                    <span class="number">0</span>=关闭选择性加密，并且对所有样本进行加密</span><br><span class="line">Reserved              UI7           Shall be <span class="number">0</span></span><br><span class="line">Reserved              UI8           Shall be <span class="number">0</span></span><br><span class="line">IVLength              UI8           初始化向量的大小（字节）。该长度应与所用算法一致。应为<span class="number">16</span>（<span class="number">128</span>位）</span><br></pre></td></tr></table></figure>

<h3 id="a2-9">2.9.  Movie Extends box</h3>

<p>Box type: ‘mvex’ </p>
<p>Container:Movie box (‘moov’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>如果f4v文件包含片段，则电影（moov）框包含一个电影扩展（mvex）框，否则没有mvex框。对于碎片，一个F4V文件应包含一个且仅一个MVEX盒。mvex框告诉读者此文件可能包含电影片段（moof）框。</p>
<p>mvex box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	          Comment</span><br><span class="line">Header          BOXHEADER         BoxType = <span class="string">&#x27;mvex&#x27;</span> (<span class="number">0x6D766578</span>)</span><br><span class="line">Boxes           BOX [ ]           定义片段的轨迹默认值的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.1 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-9-1">2.9.1. Movie Extends Header box</h4>

<p>Box type: ‘mehd’ </p>
<p>Container:Movie Extends box (‘mvex’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>Movie扩展头（mehd）框提供碎片Movie的持续时间。如果Movie扩展（mvex）框不包含mehd框，则通过检查所有片段来计算总持续时间。</p>
<p>mehd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                 Type	          Comment</span><br><span class="line">Header                   BOXHEADER         BoxType = <span class="string">&#x27;mehd&#x27;</span> (<span class="number">0x6D766578</span>)</span><br><span class="line">Version                  UI8               Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                    UI24              Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">FragmentDuration        If Version==<span class="number">0</span></span><br><span class="line">                            UI32            在mvhd框中定义的时间刻度单位中最长轨迹的持续时间</span><br><span class="line">                        If Version ==<span class="number">1</span></span><br><span class="line">                            UI64</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.2 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-9-2">2.9.2. Track Extends box</h4>

<p>Box type: ‘trex’ </p>
<p>Container:Movie Extends box (‘mvex’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One for each track in the Movie box</p>
<p>轨迹延伸”（Trex）框定义电影片段的默认值。</p>
<p>trex box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                            Type	            Comment</span><br><span class="line">Header                              BOXHEADER           BoxType = <span class="string">&#x27;trex&#x27;</span> (<span class="number">0x74726578</span>)</span><br><span class="line">Version                             UI8                 Expected to be <span class="number">0</span></span><br><span class="line">Flags                               UI24                Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">TrackID                             UI32                Identity <span class="keyword">of</span> the associated track</span><br><span class="line">DefaultSampleDescriptionIndex       UI32                要在跟踪片段中使用的默认sampleDescriptionIndex</span><br><span class="line">DefaultSampleDuration               UI32                在跟踪片段中使用的默认sampleduration</span><br><span class="line">DefaultSampleSize                   UI32                在track片段中使用的默认sampleSize</span><br><span class="line">DefaultSampleFlags                  SAMPLEFLAGS         在跟踪片段中使用的默认sampleFlags</span><br><span class="line"></span><br><span class="line">Each SAMPLEFLAGS record has the following layout: </span><br><span class="line">SAMPLEFLAGS</span><br><span class="line"></span><br><span class="line">Reserved                            UI6                 Reserved. <span class="built_in">Set</span> to <span class="number">0.</span></span><br><span class="line">SampleDependsOn                     UI2                 <span class="number">0</span> = 示例依赖项未知</span><br><span class="line">                                                        <span class="number">1</span> = 此示例依赖于其他示例（不是i图片）</span><br><span class="line">                                                        <span class="number">2</span> = 此示例不依赖于其他示例（图片）</span><br><span class="line">                                                        <span class="number">3</span> = reserved</span><br><span class="line">SampleIsDependedOn                  UI2                 <span class="number">0</span> = 其他示例对该示例的依赖性未知</span><br><span class="line">                                                        <span class="number">1</span> = 其他样品可能依赖于此样品（非一次性样品）</span><br><span class="line">                                                        <span class="number">2</span> = 其他样品不依赖于此样品（一次性）</span><br><span class="line">                                                        <span class="number">3</span> = reserved</span><br><span class="line">SampleHasRedundancy                 UI2                 <span class="number">0</span> = 尚不清楚此示例中是否存在冗余编码</span><br><span class="line">                                                        <span class="number">1</span> = 此示例中存在冗余编码</span><br><span class="line">                                                        <span class="number">2</span> = 此示例中没有冗余编码</span><br><span class="line">                                                        <span class="number">3</span> = reserved</span><br><span class="line">SamplePaddingValue                  UI3                 Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">SampleIsDifferenceSample            UI1                 <span class="number">0</span> = 密钥或同步示例</span><br><span class="line">                                                        <span class="number">1</span> = 非键或非同步示例</span><br><span class="line">SampleDegradationPriority           UI16                Reserved. <span class="built_in">Set</span> to <span class="number">1.</span></span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.3 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-10">2.10. User Data box</h4>

<p>Box type: ‘udta’ </p>
<p>Container:Movie box (‘moov’) or Track box (‘trak’) </p>
<p>Mandatory: No </p>
<p>Quantity: One at each movie level or track level</p>
<p>用户数据（udta）框包含在电影（moov）框或曲目（trak）框中。最多，每个电影级别或曲目级别可能会出现一个UDTA框。UDTA框应最后放置在其包含框中。</p>
<p>UDTA框声明有关包含框及其数据（表示或跟踪）的自由格式用户信息。Flash播放器忽略UDTA框的内容。</p>
<p>udta box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;udta&#x27;</span> (<span class="number">0x75647461</span>)</span><br><span class="line">UserData        BOX [ ]             具有自由格式用户数据的任意数量的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.10.1 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-11">2.11. F4V Boxes for HTTP Streaming</h4>
<h5 id="a2-11-1">2.11.2. Fragment Random Access box</h5>

<p>Box type: ‘afra’ </p>
<p>Container:File </p>
<p>Mandatory: Yes for HTTP streaming support with F4V fragments, otherwise no. </p>
<p>Quantity: One per fragment for HTTP streaming support with F4V fragments, otherwise zero.</p>
<p>片段随机访问（AFRA）框为一个或多个片段提供随机访问信息。</p>
<p>对于带有F4V片段的HTTP流支持，F4V文件可以为每个片段包含一个AFRA框。AFRA盒应位于片段的媒体数据（MDAT）和电影片段（MOOF）盒之前。AFRA框可用于查找包含给定时间内最近随机访问样本的F4V文件中的确切点。</p>
<p>AFRA框与给定片段关联（这里称为“关联片段”）。AFRA框还提供对同一段或不同段中其他片段中信息的随机访问。</p>
<p>AFRA框包含条目数组。每个条目包含随机访问样本的位置和表示时间。如果随机访问样本不在相关片段中，则条目还提供以下信息：</p>
<p>-段识别信息</p>
<p>-片段识别信息</p>
<p>-从包含段的开始到与此随机数关联的“afra”框的字节偏移量</p>
<p>接入点</p>
<p>-从关联的“afra”框到示例的字节偏移量</p>
<blockquote>
<p>片段中的每个随机访问样本不一定都有数组条目。AFRA盒的缺失并不意味着所有样本都是同步样本。“trun”、“traf”和“trex”中的随机访问信息设置适当，而不考虑此框的存在。</p>
</blockquote>
<p>afra box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                 Type	            Comment</span><br><span class="line">Header                   BOXHEADER           BoxType = <span class="string">&#x27;afra&#x27;</span> (<span class="number">0x61667261</span>)</span><br><span class="line">Version                  UI8                 Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                    UI24                Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">LongIDs                  UI1                 控制全局框架项的段和片段字段的大小。</span><br><span class="line">LongOffsets              UI1                 控制AfraEntry的偏移字段的大小。还控制全局框架项的afraOffset和offsetFromAfra字段的大小。</span><br><span class="line">GlobalEntries            UI1                 值<span class="number">1</span>表示存在GlobalRycount</span><br><span class="line">Reserved                 UI5                 <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">TimeScale                UI32                每秒在AfraEntry和GlobalAfraEntry的时间字段中使用的时间单位数。</span><br><span class="line">EntryCount               UI32                LocalAccessEntries中的条目数</span><br><span class="line">LocalAccessEntries      AFRAENTRY</span><br><span class="line">                        [EntryCount]         随机访问此片段中的点。此数组不一定包含此片段中每个随机访问样本的条目。</span><br><span class="line">GlobalEntryCount        IF GlobalEntries == <span class="number">1</span> </span><br><span class="line">                            UI32            GlobalAccessEntries中的条目数。如果globalentries==<span class="number">0</span>，则此字段不存在，globalentrycount为<span class="number">0</span>。</span><br><span class="line">GlobalAccessEntries     GLOBALAFRAENTRY</span><br><span class="line">                        [GlobalEntryCount]  随机访问此片段之外的点。</span><br><span class="line"></span><br><span class="line">Each AFRAENTRY points to a sample within <span class="built_in">this</span> fragment, and has the following format: </span><br><span class="line">AFRAENTRY</span><br><span class="line"></span><br><span class="line">Time                    UI64                随机访问样本的表示时间，以时间刻度单位表示。</span><br><span class="line">Offset              IF LongOffsets == <span class="number">0</span></span><br><span class="line">                        UI32                从片段随机访问框开始到样本的字节偏移量</span><br><span class="line">                    ELSE</span><br><span class="line">                        UI64</span><br><span class="line">Each GLOBALAFRAENTRY points to a sample outside <span class="built_in">this</span> fragment, and has the following format: </span><br><span class="line">GLOBALAFRAENTRY</span><br><span class="line"></span><br><span class="line">Time                    UI64                 随机访问样本的表示时间，以时间刻度单位表示。</span><br><span class="line">Segment             IF LongIDs == <span class="number">0</span></span><br><span class="line">                        UI16                包含此随机接入点的段的数目</span><br><span class="line">                    ELSE</span><br><span class="line">                        UI32</span><br><span class="line">Fragment            IF LongIDs == <span class="number">0</span></span><br><span class="line">                        UI16                包含此随机访问点的片段的数目</span><br><span class="line">                    ELSE</span><br><span class="line">                        UI32</span><br><span class="line">AfraOffset          IF LongOffsets == <span class="number">0</span></span><br><span class="line">                        UI32                从包含段开始到与此随机接入点关联的AFRA框的字节偏移量。</span><br><span class="line">                    ELSE</span><br><span class="line">                        UI64</span><br><span class="line">OffsetFromAfra	IF LongOffsets == <span class="number">0</span></span><br><span class="line">                        UI32                从关联的AFRA框到样本的字节偏移量</span><br><span class="line">                    ELSE</span><br><span class="line">                        UI64</span><br></pre></td></tr></table></figure>

<h5 id="a2-11-2">2.11.2. Bootstrap Info box</h5>

<p>Box type: ‘abst’ </p>
<p>Container:File </p>
<p>Mandatory: Yes for HTTP streaming support with F4V fragments, otherwise no. </p>
<p>Quantity: One or more for HTTP streaming support with F4V fragments, otherwise zero.</p>
<p>引导信息（abst）框包含引导媒体演示URL从媒体客户端向HTTP服务器请求RFC1630所需的信息。媒体演示可以是现场演示，也可以是视频点播。此框包含有关服务器、电影和段信息的基本信息。它还包含一个或多个段运行表和段运行表。</p>
<p>在HTTP流段中，abt框是可选的，位于电影（moov）框之前。在HTTP流片段中，ABT框是必需的。有关HTTP流所需的框和结构的描述，请参阅附录C.HTTP流：文件结构。</p>
<p>abst box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                Type	            Comment</span><br><span class="line">Header                  BOXHEADER           BoxType = <span class="string">&#x27;abst&#x27;</span> (<span class="number">0x61627374</span>)</span><br><span class="line">Version                 UI8                 Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                   UI24                Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">BootstrapinfoVersion    UI32                引导信息的版本号。设置更新字段后，bootstrapinfoversion指示正在更新的版本号。</span><br><span class="line">Profile                 UI2                 指示它是命名访问（<span class="number">0</span>）还是范围访问（<span class="number">1</span>）配置文件。为将来的配置文件保留一个位。</span><br><span class="line">Live                    UI1                 指示媒体演示文稿是否为实时（<span class="number">1</span>）。</span><br><span class="line">Update                  UI1                 指示此表是引导程序框或文件的完整版本（<span class="number">0</span>）还是以前定义（发送）的完整版本的更新（<span class="number">1</span>）。</span><br><span class="line">                                            更新不是完整的替换。它们只能包含更改的元素。服务器仅在引导信息更改时发送更新。</span><br><span class="line">                                            更新应用于具有相同bootstrapinfoversion编号的完整版本。</span><br><span class="line">                                            同一个bootstrapinfoversion号可能有多个更新。</span><br><span class="line">                                            如果服务器发送多个更新，这些更新将应用于具有相同bootstrapinfoversion号的完整版本。</span><br><span class="line">                                            每个更新都包括以前对同一个bootstrapinfoversion的所有更新。对于单个完整版本的多个更新，</span><br><span class="line">                                            最新更新是基于当前的MediaTime确定的。</span><br><span class="line"></span><br><span class="line">Reserved                UI4                 Reserved, set to <span class="number">0</span></span><br><span class="line">TimeScale               UI32                每秒的时间单位数。字段CurrentMediaTime使用此值表示准确的时间。通常，该值为<span class="number">1000</span>，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">CurrentMediaTime        UI64                媒体演示文稿中最新可用片段的时间刻度单位时间戳。这个时间戳用于请求正确的片段号。</span><br><span class="line">                                            CurrentMediaTime可以是总持续时间。对于非活动的媒体演示文稿，当前MediaTime可以为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">SmpteTimeCodeOffset     UI64                当前媒体时间与smpte时间代码之间的偏移量，已转换为毫秒。</span><br><span class="line">                                            此偏移量不是以时间刻度单位表示的。未使用时，此字段为零。</span><br><span class="line">                                            服务器使用smpte时间代码模块<span class="number">24</span>小时使偏移量为正。</span><br><span class="line"></span><br><span class="line">MovieIdentifier         STRING              此演示文稿的标识符。标识符是以空结尾的UTF-<span class="number">8</span>字符串。例如，它可以是URL中的文件名或路径名。见</span><br><span class="line">                                            附录C<span class="number">.4</span> URL结构供使用</span><br><span class="line"></span><br><span class="line">ServerEntryCount        UI8                 ServerEntryTable条目数。最小值为<span class="number">0</span>。</span><br><span class="line">ServerEntryTable        SERVERENTRY</span><br><span class="line">                        [ServerEntryCount]  按优先顺序降序排列的服务器URL</span><br><span class="line">QualityEntryCount       UI8                 QualityEntryTable条目数，也就是可用的质量级别数。最小值为<span class="number">0</span>。</span><br><span class="line">                                            可用的质量级别包括，例如，多比特率文件或技巧文件。</span><br><span class="line"></span><br><span class="line">QualityEntryTable       QUALITYENTRY</span><br><span class="line">                        [QualityEntryCount] 从高质量到低质量的质量文件参考</span><br><span class="line">DrmData                 STRING              以NULL或NULL结尾的UTF-<span class="number">8</span>字符串。此字符串包含数字版权管理元数据。</span><br><span class="line">                                            加密文件使用此元数据获取解密和播放所需的密钥和许可证。</span><br><span class="line">MetaData                STRING              包含元数据的以NULL或NULL结尾的UTF-<span class="number">8</span>字符串</span><br><span class="line">SegmentRunTableCount    UI8                 SegmentRunTableEntries中的条目数。最小值为<span class="number">1</span>。通常，一个表包含所有段运行。</span><br><span class="line">                                            但是，此计数提供了为每个质量级别（或技巧文件）单独定义段运行的灵活性。</span><br><span class="line">SegmentRunTableEntries  SegmentRunTable</span><br><span class="line">                    [SegmentRunTableCount]  <span class="built_in">Array</span> <span class="keyword">of</span> SegmentRunTable elements</span><br><span class="line">FragmentRunTableCount       UI8             fragmentruntable中的条目数-条目数。最小值为<span class="number">1</span>。</span><br><span class="line">FragmentRunTableEntries   FragmentRunTable</span><br><span class="line">                    [FragmentRunTableCount]     碎片可运行元素数组</span><br><span class="line"></span><br><span class="line">Each SERVERENTRY has the following format: SERVERENTRY</span><br><span class="line"></span><br><span class="line">ServerBaseURL           STRING               该服务器上此演示文稿的服务器基URL。该值是以空结尾的utf-<span class="number">8</span>字符串，没有尾随的“/”。</span><br><span class="line"></span><br><span class="line">Each QUALITYENTRY has the following format: QUALITYENTRY</span><br><span class="line"></span><br><span class="line">QualitySegmentUrlModifier   STRING	         用于构造该质量媒体的正确URL的质量（段）文件的名称。</span><br><span class="line">                                            该值是以空结尾的utf-<span class="number">8</span>字符串，可以选择带有尾随的“/”。</span><br></pre></td></tr></table></figure>

<h5 id="a2-11-2-1">2.11.2.1. Segment Run Table box</h5>

<p>Box type: ‘asrt’ </p>
<p>Container:Bootstrap Info box (‘abst’)  </p>
<p>Mandatory: Yes </p>
<p>Quantity: One or more</p>
<p>段运行表（ASRT）框可用于定位包含特定片段的段。可能有几个ASRT箱，每个箱的质量等级不同。</p>
<p>ASRT框使用压缩编码：</p>
<p>-段运行表可以表示几个质量级别的段运行。</p>
<p>-段运行表是紧凑编码的。每个条目给出一段运行的第一个段号</p>
<p>同样数量的碎片。具有相同片段计数的片段的计数可以通过从下一个条目中的第一个片段号减去此条目中的第一个片段号来计算。</p>
<p>asrt box</p>
<p>ASRT框使用压缩编码：</p>
<p>-段运行表可以表示几个质量级别的段运行。</p>
<p>-段运行表是紧凑编码的。每个条目给出一段运行的第一个段号</p>
<p>同样数量的碎片。具有相同片段计数的片段的计数可以通过从下一个条目中的第一个片段号减去此条目中的第一个片段号来计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field                                Type	                    Comment</span><br><span class="line">Header                               BOXHEADER                  BoxType = <span class="string">&#x27;asrt&#x27;</span> (<span class="number">0x61737274</span>)</span><br><span class="line">Version                              UI8                        Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                                UI24                       定义了以下值：</span><br><span class="line">                                                                <span class="number">0</span>=整张桌子。</span><br><span class="line">                                                                <span class="number">1</span>=此表中的记录是对先前定义的段运行表的更新（或要附加的新条目）。</span><br><span class="line">                                                                当此标志为<span class="number">1</span>时，包含引导信息框中的更新标志应为<span class="number">1</span>。</span><br><span class="line">QualityEntryCount                    UI8                                 后面的QualitySegmentUrlModifier（质量级别引用）的数量。如果为<span class="number">0</span>，</span><br><span class="line">                                                                则此段运行表适用于所有质量级别，引导信息框中只能有一个段运行表框。</span><br><span class="line"></span><br><span class="line">QualitySegmentUrlModifiers           STRING</span><br><span class="line">                                [QualityEntryCount]             此表应用于的质量级别的名称数组。名称是以空结尾的UTF-<span class="number">8</span>字符串。</span><br><span class="line">                                                                数组应是引导信息（abt）框中可输入的质量的子集。</span><br><span class="line">                                                                这些名称不应出现在引导程序信息框中的任何其他段运行表中。</span><br><span class="line">SegmentRunEntryCount                 UI32                       此SegmentRunEntryTable中的项数。最小值为<span class="number">1</span>。</span><br><span class="line">SegmentRunEntryTable                 SEGMENTRUNENTRY            段运行项数组</span><br><span class="line">                        [           SegmentRunEntryCount ]</span><br><span class="line"></span><br><span class="line">Each SEGMENTRUNENTRY has the following format: SEGMENTRUNENTRY</span><br><span class="line"></span><br><span class="line">FirstSegment                         UI32                        包含相同数量片段的段运行中第一段的标识号。</span><br><span class="line">                                                                 对应于下一个segmentrunentry中第一个segment的段将终止此运行。</span><br><span class="line">FragmentsPerSegment                  UI32                        此运行中每个段中的片段数</span><br></pre></td></tr></table></figure>

<h5 id="a2-11-2-2">2.11.2.2. Fragment Run Table box</h5>

<p>Box type: ‘afrt’ </p>
<p>Container:Bootstrap Info box (‘abst’)  </p>
<p>Mandatory: Yes </p>
<p>Quantity: One or more</p>
<p>片段运行表（AFRT）框可用于查找包含与给定时间对应的样本的片段。</p>
<p>片段由URL方案单独标识。碎片的持续时间和样本数量都可能不同。碎片的持续时间储存在AFRT箱中。</p>
<p>AFRT盒使用压缩编码：</p>
<p>-片段运行表可以表示多个质量级别的片段。</p>
<p>-片段运行表是紧凑编码的，因为每个条目都给出了运行的第一个片段号。</p>
<p>具有相同持续时间的片段。可以通过从下一个条目中的第一个片段号减去此条目中的第一个片段号来计算具有相同持续时间的片段数。</p>
<p>一个引导信息框中可能有几个片段运行表框，每个框用于不同的质量级别。</p>
<p>asrt box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                            Type	                    Comment</span><br><span class="line">Header                              BOXHEADER                   BoxType =<span class="string">&#x27;afrt&#x27;</span> (<span class="number">0x61667274</span>)</span><br><span class="line">Version                             UI8                         Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                               UI24                        定义了以下值：</span><br><span class="line">                                                                <span class="number">0</span>=A full table</span><br><span class="line">                                                                <span class="number">1</span>=此表中的记录是以前定义的片段运行表的更新（或要追加的新条目</span><br><span class="line">                                                                当此标志为<span class="number">1</span>时，包含引导信息框中的更新标志应为<span class="number">1</span>。</span><br><span class="line">TimeScale                           UI32                        每秒在FirstFragmentTimestamp和FragmentDuration字段中使用的时间单位数。通常，值为<span class="number">1</span>。</span><br><span class="line">QualityEntryCount                   UI8                         后面的QualitySegmentUrlModifier（质量级别引用）的数量。</span><br><span class="line">                                                                如果为<span class="number">0</span>，则此片段运行表适用于所有质量级别，并且引导信息框中只能有一个片段运行表框。</span><br><span class="line">QualitySegmentUrlModifiers          STRING</span><br><span class="line">                                [QualityEntryCount]             此表应用于的质量级别的名称数组。名称是以空结尾的UTF-<span class="number">8</span>字符串。</span><br><span class="line">                                                                数组应是引导信息（abt）框中可输入的质量的子集。</span><br><span class="line">                                                                这些名称不应出现在引导程序信息框中的任何其他片段运行表中。</span><br><span class="line"></span><br><span class="line">FragmentRunEntryCount               UI32                        此FragmentRunEntryTable中的项数。最小值为<span class="number">1</span>。</span><br><span class="line">FragmentRunEntryTable               FRAGMENTRUNENTRY</span><br><span class="line">                                [FragmentRunEntryCount]         片段运行项数组</span><br><span class="line">每个fragmentrunentry的格式如下：fragmentrunentry</span><br><span class="line"></span><br><span class="line">FirstFragment                       UI32                        具有相同持续时间的此片段运行中第一个片段的标识号。</span><br><span class="line">                                                                与下一个fragmentrunentry中的第一个fragment对应的片段将终止此运行。</span><br><span class="line">FirstFragmentTimestamp              UI64                        第一个片段的时间戳，以时间刻度单位表示。</span><br><span class="line">                                                                此字段确保片段时间戳可以在开始时准确表示。</span><br><span class="line">                                                                它还可以确保在由于持续时间准确性或时间戳不连续而发生偏移时同步时间戳。</span><br><span class="line">FragmentDuration                    U32                         此运行中每个片段的持续时间（以时间刻度单位表示）</span><br><span class="line">DiscontinuityIndicator          IF FragmentDuration == <span class="number">0</span></span><br><span class="line">                                    UI8                         表示时间戳和/或片段号中的不连续。此字段还用于标识（实时）演示文稿的结尾。</span><br><span class="line">                                                                定义了以下值：</span><br><span class="line">                                                                <span class="number">0</span>=演示结束。</span><br><span class="line">                                                                <span class="number">1</span>=片段编号的不连续性。</span><br><span class="line">                                                                <span class="number">2</span>=时间戳的不连续性。</span><br><span class="line">                                                                <span class="number">3</span>=时间戳和片段编号的不连续性。</span><br><span class="line">                                                                保留所有其他值。</span><br><span class="line">                                                                在现场场景中，在带内发出演示结束的信号非常有用。</span><br><span class="line">                                                                表示中的间隔被表示为零持续时间片段的运行，同时具有片段数和时间戳不连续性。</span><br><span class="line">                                                                片段数不连续性对于片段编号方案中没有不连续性的跳变信号很有用</span><br></pre></td></tr></table></figure>

<h4 id="a2-12">2.12. Movie Fragment box</h4>

<p>Box type: ‘moof’ </p>
<p>Container: File </p>
<p>Mandatory: Yes for HTTP streaming support with F4V fragments, otherwise no </p>
<p>Quantity: One per fragment for HTTP streaming support with F4V fragments, otherwise zero.</p>
<p>Movie片段（MOOF）框提供特定于片段的信息，否则这些信息将出现在媒体（MOOV）框中。MOOF箱应按顺序排列。</p>
<p>moof box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;moof&#x27;</span> (<span class="number">0x6D6F6F66</span>)</span><br><span class="line">Boxes           BOX [ ]             定义示例结构的多个框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.4 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-12-1">2.12.1. Movie Fragment Header box</h5>

<p>Box type: ‘mfhd’ </p>
<p>Container: Movie Fragment box (‘moof’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>Movie片段头（mfhd）框包含序列号，用于验证文件的完整性。</p>
<p>mfhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;mfhd&#x27;</span> (<span class="number">0x6D666864</span>)</span><br><span class="line">Version         UI8                 Expected to be <span class="number">0</span></span><br><span class="line">Flags           UI24                Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">SequenceNumber  UI32                从<span class="number">1</span>开始，并按文件中每个电影片段的出现顺序递增。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.5 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-12-2">2.12.2. Track Fragment box</h5>

<p>Box type: ‘traf’ </p>
<p>Container: Movie Fragment box  </p>
<p>Mandatory: No </p>
<p>Quantity: Zero or more</p>
<p>轨迹片段（traf）框对应于f4v文件中的轨迹。每个交通箱包含零个或多个轨道运行，其中包括该轨道的连续运行。</p>
<p>traf box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;traf&#x27;</span> (<span class="number">0x74726166</span>)</span><br><span class="line">Boxes           BOX [ ]             定义片段中轨道运行的任意数量的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.6 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-12-2-1">2.12.2.1. Track Fragment Header box</h5>

<p>Box type: ‘tfhd’ </p>
<p>Container: Track Fragment box  </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>“轨迹片段头”（tfhd）框设置用于影片片段中样本运行的信息和默认值。每个电影片段可以向每个曲目添加零个或多个片段，而一个曲目片段可以添加零个或多个连续运行的示例。</p>
<p>tfhd box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                     Type	            Comment</span><br><span class="line">Header                       BOXHEADER           BoxType = <span class="string">&#x27;tfhd&#x27;</span> (<span class="number">0x74666864</span>)</span><br><span class="line">Version                      UI8                 Expected to be <span class="number">0</span></span><br><span class="line">Flags                        UI24                以下标志可用于任何组合：</span><br><span class="line">                                                 <span class="number">0x000001</span>=基础数据偏移量存在</span><br><span class="line">                                                 <span class="number">0x000002</span>=样本描述存在</span><br><span class="line">                                                 <span class="number">0x000008</span>=默认样本持续时间存在</span><br><span class="line">                                                 <span class="number">0x0000010</span>=默认样本大小存在</span><br><span class="line">                                                 <span class="number">0x0000020</span>=默认样本标志存在</span><br><span class="line">                                                 <span class="number">0x10000</span>=持续时间为空：没有样本用于提供的持续时间</span><br><span class="line">                                                 TFHD框或Trex框中的默认采样持续时间。见下表注释</span><br><span class="line">TrackID                      UI32                在“Track标题”框中指定的关联Track的标识</span><br><span class="line">BaseDataOffset               IF Flags </span><br><span class="line">                             &amp; <span class="number">0x000001</span> == <span class="literal">true</span></span><br><span class="line">                                UI64            可选的。计算每个轨道运行中的数据偏移量时要使用的基准偏移量。默认值在表下面定义。</span><br><span class="line">SampleDescriptionIndex      IF Flags</span><br><span class="line">                            &amp; <span class="number">0x000002</span> == <span class="literal">true</span></span><br><span class="line">                                UI32            可选的。要在此片段中使用的sampleDescriptionIndex。</span><br><span class="line">                                                这将覆盖该片段的trex框中的默认sampleDescriptionIndex。</span><br><span class="line">DefaultSampleDuration       IF Flags </span><br><span class="line">                            &amp; <span class="number">0x000008</span> == <span class="literal">true</span></span><br><span class="line">                                UI32            可选的。此片段中要使用的默认sampleduration。</span><br><span class="line">                                                这将覆盖该片段的Trex框中的默认采样持续时间。</span><br><span class="line">DefaultSampleSize           IF Flags</span><br><span class="line">                            &amp; <span class="number">0x000010</span> == <span class="literal">true</span></span><br><span class="line">                                UI32            可选的。此片段中使用的默认sampleSize。这将覆盖该片段的trex框中的默认sampleSize。</span><br><span class="line">DefaultSampleFlags          IF Flags </span><br><span class="line">                            &amp; <span class="number">0x000020</span> == <span class="literal">true</span></span><br><span class="line">                                SAMPLEFLAGS     可选的。此片段中要使用的默认sampleFlags。这将覆盖该片段的trex框中的默认sampleFlags。</span><br></pre></td></tr></table></figure>


<p>basedataoffset：如果此处未提供值，则电影片段中第一个曲目的默认值是封闭电影片段框的第一个字节的位置。对于后续的跟踪片段，默认值是由前面的片段定义的数据的结尾。以这种方式“继承”其偏移量的片段都应使用相同的数据引用，即，这些轨迹的数据应在同一个文件中。</p>
<blockquote>
<p>0x010000持续时间为空：如果一个F4V文档在MOOV框中有编辑列表，并且具有空的持续时间片段，则认为该文档格式不正确。</p>
</blockquote>
<p>For more information, see section 8.8.7 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-12-2-2">2.12.2.2. Track Fragment Run box</h5>

<p>Box type: ‘trun’ </p>
<p>Container: Track Fragment box (‘traf’) </p>
<p>Mandatory: No </p>
<p>Quantity: Zero or more</p>
<p>跟踪片段运行（trun）框定义跟踪的连续样本集。如果在“轨迹碎片框”（traf）框中设置了“持续时间为空”标志，则没有“躯干框”。</p>
<p>trun box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                    Type	            Comment</span><br><span class="line">Header                      BOXHEADER           BoxType = <span class="string">&#x27;trun&#x27;</span> (<span class="number">0x7472756E</span>)</span><br><span class="line">Version                     UI8                 Expected to be <span class="number">0</span></span><br><span class="line">Flags                       UI24                下列标志可用于任何组合，但<span class="number">0x000004</span>和<span class="number">0x000400</span>除外：</span><br><span class="line">                                                <span class="number">0x000001</span>=存在数据偏移量</span><br><span class="line">                                                <span class="number">0x000004</span>=存在第一个样本标志</span><br><span class="line">                                                <span class="number">0x000100</span>=存在样本持续时间</span><br><span class="line">                                                <span class="number">0x000200</span>=存在样本大小</span><br><span class="line">                                                <span class="number">0x000400</span>=存在样本标志</span><br><span class="line">                                                <span class="number">0x00800</span>=存在样品组成时间偏移</span><br><span class="line">SampleCount                 UI32                sampleInformation中的条目数</span><br><span class="line">DataOffset                  IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000001</span> == <span class="literal">true</span></span><br><span class="line">                            SI32                可选的。要添加到在tfhd框中定义的数据偏移量的值。默认值在表下面定义。</span><br><span class="line">FirstSampleFlags            IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000004</span> == <span class="literal">true</span></span><br><span class="line">                            SAMPLEFLAGS         可选的。仅用于此Trun Box中描述的集合的第一个样本的标志。见下表文本。</span><br><span class="line">SampleInformation           SampleInformationStructure</span><br><span class="line">                            [SampleCount]       结构中的所有字段都是可选的</span><br><span class="line"></span><br><span class="line">每个sampleInformationstructure记录都有以下布局：sampleInformationstructure</span><br><span class="line">SampleDuration              IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000100</span> == <span class="literal">true</span></span><br><span class="line">                            UI32                可选的。每个采样的持续时间，以媒体头中为此曲目定义的时间刻度单位为单位</span><br><span class="line">                                                如果不存在，则使用默认值。</span><br><span class="line">SampleSize                  IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000200</span> == <span class="literal">true</span></span><br><span class="line">                            UI32                可选的。每个样本的大小。如果不存在，则使用默认值。</span><br><span class="line">SampleFlags                 IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000400</span> == <span class="literal">true</span></span><br><span class="line">                            SAMPLEFLAGS         可选的。每个样本的sampleFlags。如果不存在，则使用默认值。</span><br><span class="line">SampleCompositionTimeOffset	IF Flags </span><br><span class="line">                        &amp; <span class="number">0x000800</span> == <span class="literal">true</span></span><br><span class="line">                            UI32                可选的。每个样本的合成时间偏移。如果不存在，则使用默认值。</span><br></pre></td></tr></table></figure>


<p>data offset：如果不存在数据偏移量，则此运行的数据从两个位置之一开始。如果此运行是跟踪片段中的第一个，则它从由跟踪片段头定义的基础数据偏移量开始。否则，它会在上一次运行的数据之后立即启动。</p>
<p>FirstSampleFlags：仅覆盖第一个示例的默认标志。这使得记录一组帧成为可能，其中第一个帧是键，其余的帧是不同的帧，而不为每个样本提供显式标志。设置此标志时，不应出现示例标志。</p>
<p>For more information, see section 8.8.8 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-13">2.13.  Media Data box</h4>

<p>Box type: ‘mdat’ </p>
<p>Container: File </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>媒体数据（mdat）框包含f4v文件的媒体数据负载。所有视频示例、音频示例、数据示例以及提示轨和示例都包含在mdat框中。请参见1.8支持的媒体类型。</p>
<p>mdat框与media（moov）框一起出现在f4v文件的顶层。</p>
<p>无法单独理解mdat框，这也是文件中必须存在moov框的原因。</p>
<p>mdat box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;mdat&#x27;</span> (<span class="number">0x6D646174</span>)</span><br><span class="line">Payload         UI8 [ ]             媒体数据字节，其结构在文件的MOOV框中定义。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.2.2 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-13-1">2.13.1.  Hint Track Samples for HTTP Streaming</h5>

<p>mdat框包含用于包含f4v片段的HTTP流的提示轨。提示轨包含ADobemuxhintsamples。Adobemux提示示例输入框（rtmp）描述了提示轨迹。</p>
<h5 id="a2-13-1-1">2.13.1.1. AdobeMuxHintSample</h5>

<p>一组adobemuxhintsamples组成了一个提示跟踪，它采用Adobe多路提示跟踪格式。Adobemuxhintsample具有以下布局：</p>
<p>AdobeMuxHintSample</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	                    Comment</span><br><span class="line">PacketCount     IF PacketCountField == <span class="number">1</span></span><br><span class="line">                UI8                         此adobemuxhintsample中的adobemuxPacket条目数。</span><br><span class="line">                                            当packetCountField==<span class="number">0</span>时，adobmuxPackets是自描述的，可以隐式确定数字。</span><br><span class="line">Packets         AdobeMuxPacket</span><br><span class="line">                [PacketCount]               AdobEmuxPacket元素数组</span><br></pre></td></tr></table></figure>

<h5 id="a2-13-1-2">2.13.1.2. AdobeMuxPacket</h5>

<p>AdobEmuxPacket具有以下布局。EncryptionHeader及其之前的部分与E.4.1节中定义的flvtag中的相应部分相同。</p>
<p>AdobeMuxPacket</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                    Type	                    Comment</span><br><span class="line">Reserved                    UI2                         Reserved <span class="keyword">for</span> FMS, should be <span class="number">0</span></span><br><span class="line">Filter                      UI1                         指示是否筛选数据包。</span><br><span class="line">                                                        <span class="number">0</span>=不需要预处理。</span><br><span class="line">                                                        <span class="number">1</span>=在呈现数据包之前，需要对其进行预处理（如解密）。</span><br><span class="line">                                                        未加密文件中应为<span class="number">0</span>，加密标签应为<span class="number">1</span>。过滤器的使用见附录F.FLV加密。</span><br><span class="line">TagType                     UI5                         此标记的类型。定义了以下类型：</span><br><span class="line">                                                        <span class="number">8</span>＝音频</span><br><span class="line">                                                        <span class="number">9</span>＝视频</span><br><span class="line">                                                        保留所有其他值</span><br><span class="line">                                                        （<span class="number">18</span>=不得使用脚本数据）</span><br><span class="line">DataSize                    UI24                        消息的长度。streamid到数据包结尾后的字节数（等于数据包长度–<span class="number">11</span>）</span><br><span class="line">Timestamp                   UI24                        应用此标记中数据的时间（毫秒）。该值与flv文件中的第一个标记相关，该标记的时间戳始终为<span class="number">0</span>。</span><br><span class="line">TimestampExtended           UI8                         timestamp字段的扩展，以形成si32值。此字段表示高<span class="number">8</span>位，而前一个时间戳字段表示低<span class="number">24</span>位时间（毫秒）。</span><br><span class="line">StreamID                    UI24                        Always <span class="number">0.</span></span><br><span class="line">AudioTagHeader              IF TagType == <span class="number">8</span></span><br><span class="line">                            AudioTagHeader              第E<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span>节中定义的audioTagHeader元素。</span><br><span class="line">VideoTagHeader              IF TagType == <span class="number">9</span></span><br><span class="line">                            VideoTagHeader              第E<span class="number">.4</span><span class="number">.3</span><span class="number">.1</span>节中定义的VideoTagHeader元素。</span><br><span class="line">EncryptionHeader            IF Filter == <span class="number">1</span></span><br><span class="line">                            EncryptionTagHeader         如第F<span class="number">.3</span><span class="number">.1</span>节所述，每个受保护样品应包括加密头。</span><br><span class="line">ConstructorCount            IF ConstructorCountField == <span class="number">1</span></span><br><span class="line">                                UI8                     ADobemuxhintconstructors的数目。</span><br><span class="line">                                                        当使用使用不同模式或原始样本的不同部分的多个数据块构造单个FLV标记或RTMP消息时，</span><br><span class="line">                                                        特别使用此字段。如果<span class="title">constructorCountField</span>==0，则<span class="title">constructorCount</span>=1</span><br><span class="line"><span class="title">DataEntry</span>                   <span class="title">AdobeMuxHintConstructor</span></span><br><span class="line">                            [<span class="title">ConstructorCount</span>]          <span class="title">ADobEmuxHintConstructors</span>元素数组</span><br><span class="line"><span class="title">TrailerLength</span>               <span class="title">If</span> <span class="title">TrailerLengthField</span> == 1</span><br><span class="line">                                <span class="title">UI8</span>                     拖车的长度，以字节为单位。</span><br><span class="line">                                                        如果<span class="title">trailerLengthField</span>=0，则<span class="title">trailerLength</span>=<span class="title">trailerDefaultSize</span></span><br><span class="line"><span class="title">Trailer</span>                     <span class="title">UI8</span> </span><br><span class="line">                            [<span class="title">TrailerLength</span>]             其他数据，例如，为了兼容性。当处于<span class="title">FLV</span>兼容模式时，此字段携带上一个标记大小。</span><br></pre></td></tr></table></figure>

<h5 id="a2-13-1-3">2.13.1.3. AdobeMuxHintConstructor</h5>

<p>AdobEmuxHintConstructor具有以下布局：</p>
<p>AdobeMuxHintConstructor</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Mode            If ModeField == <span class="number">1</span></span><br><span class="line">                UI8                 提示正在使用跟踪模式。</span><br><span class="line">                                    当modefield==<span class="number">0</span>时，可以从Adobe MUX提示进程（AMHP）框中确定模式。</span><br><span class="line">HintInfo        If Mode == <span class="number">2</span>        如模式所示。尽管定义了三种提示模式，</span><br><span class="line">                AdobeMuxHintSampleConstructor</span><br><span class="line">                ELSE                但由于立即节点和立即节点提升模式都使用了ADobmUxHintimmediateConstructor，因此只指定了两个构造函数。</span><br><span class="line">                AdobeMuxHintImmediateConstructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="a2-13-1-4">2.13.1.4. AdobeMuxHintImmediateConstructor</h5>

<p>Adobmuxhintimmediteconstructor应在即时和即时节点提升模式中使用。这些模式以Adobe多路提示跟踪格式描述。</p>
<p>AdobEmuxHintimmediateConstructor具有以下布局：</p>
<p>AdobeMuxHintImmediateConstructor</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Length          If LengthField == <span class="number">1</span></span><br><span class="line">                UI24                要从后面的数据中获取的字节数。</span><br><span class="line">                                    如果lengthField==<span class="number">0</span>，则不存在此字段，并且长度是根据adobmuxPacket.dataSize计算得出的。</span><br><span class="line">Data            UI8 [Length]        要放入有效负载部分的数据字节</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.aaaaaaaaaaaaaaaaaaaaaaaaaaa of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-13-1-5">2.13.1.5. AdobeMuxHintSampleConstructor</h5>

<p>示例模式中应使用Adobemuxhintsampleconstructor。示例模式以Adobe多路提示跟踪格式描述。</p>
<p>AdobEmuxHintSampleConstructor具有以下布局：</p>
<p>AdobeMuxHintSampleConstructor</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	        Comment</span><br><span class="line">TrackRefIndex   SI8             指示示例数据将来自哪个跟踪的值。</span><br><span class="line">                                值为<span class="number">0</span>表示只引用了一个媒体曲目。</span><br><span class="line">                                <span class="number">1</span>到<span class="number">127</span>之间的值是指向提示跟踪引用原子项的索引。</span><br><span class="line">                                这些值指示要从哪个原始媒体跟踪样本。一个值</span><br><span class="line">                                -<span class="number">1</span>表示提示跟踪本身。也就是说，从与当前解析的提示示例相同的轨道获取示例。</span><br><span class="line">Length          UI24            要复制的示例中的字节数。模式==<span class="number">2</span>时，长度场应为<span class="number">1</span>。</span><br><span class="line">SampleNumber    UI32            轨道样本号。</span><br><span class="line">SampleOffset    UI32            从样本开始到开始复制点的偏移量</span><br></pre></td></tr></table></figure>

<h4 id="a2-14">2.14. Meta box</h4>

<p>Box type: ‘meta’ </p>
<p>Container:  File, Movie box (‘moov’), or Track box (‘trak’) </p>
<p>Mandatory: No </p>
<p>Quantity: Zero or one at each file level, movie level, or track level</p>
<p>元（meta）框的容器是一个f4v文件、一个电影（moov）框或一个轨道（trak）框。meta-box可以包含其他各种包含元数据的框。</p>
<p>meta box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;meta&#x27;</span> (<span class="number">0x6D657461</span>)</span><br><span class="line">Version         UI8                 Reserved, set to <span class="number">0</span></span><br><span class="line">Flags           UI24                Reserved, set to <span class="number">0</span></span><br><span class="line">Boxes           BOX [ ]             定义文件元数据的任意框数</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.11.1 of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-15">2.15. Free Space boxes</h4>

<p>Box type:  ‘free’ or ‘skip’  </p>
<p>Container: File or any box  </p>
<p>Mandatory: No </p>
<p>Quantity: Any</p>
<p>自由（free）和跳过（skip）框的内容是自由文件空间，播放机应忽略它们的内容。在允许使用盒子的地方可以使用盒子。这些框可以为将来扩展容器框中的数据保留空间。</p>
<p>mfra框应该是文件中的最后一个。mfra框中的最后一个框提供了mfra框中长度字段的副本。</p>
<p>free space box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;free&#x27;</span> (<span class="number">0x66726565</span>) or <span class="string">&#x27;skip&#x27;</span> (<span class="number">0x736b6970</span>)</span><br><span class="line">Void            UI8 [ ]             Arbitrary number <span class="keyword">of</span> bytes to end <span class="keyword">of</span> box</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.aaaaaaaaaaaaaaaaaaaaaaaaaaa of ISO/IEC 14496-12:2008.</p>
<h4 id="a2-16">2.16. Movie Fragment Random Access box</h4>

<p>Box type: ‘mfra’ </p>
<p>Container: File </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>电影片段随机访问（mfra）框通过为轨迹（不一定是所有轨迹）提供轨迹片段随机访问（tfra）框，帮助在碎片化的f4v文件中查找随机访问点。此框中的信息不确定，只提供随机接入点的提示。</p>
<p>mfra box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;mfra&#x27;</span> (<span class="number">0x6D667261</span>)</span><br><span class="line">Boxes           BOX [ ]             定义随机接入点的任意数量的框</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.9 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-16-1">2.16.1. Track Fragment Random Access box</h5>

<p>Box type: ‘tfra’ </p>
<p>Container: Movie Fragment Random Access box (‘mfra’) </p>
<p>Mandatory: No </p>
<p>Quantity:  Zero or more</p>
<p>每个跟踪片段随机访问（TFRA）框条目提供随机可访问样本的位置和表示时间。tfra框不需要包含跟踪中每个随机可访问样本的条目。此框的缺失并不意味着所有样本都是同步样本。</p>
<p>tfra box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                    Type	            Comment</span><br><span class="line">Header                      BOXHEADER           BoxType = <span class="string">&#x27;tfra&#x27;</span> (<span class="number">0x74667261</span>)</span><br><span class="line">Version                     UI8                 Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags                       UI24                Reserved, set to <span class="number">0</span></span><br><span class="line">TrackID                     UI32                Identifies the track</span><br><span class="line">Reserved                    UI26                Reserved. <span class="built_in">Set</span> to <span class="number">0</span></span><br><span class="line">LengthSizeTrafNumMinus1     UI2                 RandomAccessStructure记录中TrafNumber字段的长度（以字节为单位），减去<span class="number">1</span></span><br><span class="line">LengthSizeTrunNumMinus1     UI2                 RandoAccessStructure记录中的TrunNumber字段的长度（以字节为单位），减去<span class="number">1</span></span><br><span class="line">LengthSizeSampleNumMinus1   UI2                 randomAccessStructure记录中sampleNumber字段的长度（以字节为单位），减去<span class="number">1</span></span><br><span class="line">NumberEntry                 UI32                此曲目的条目数。如果为<span class="number">0</span>，则每个样本都是随机接入点</span><br><span class="line">RandomAccessSample          RandomAccessStructure</span><br><span class="line">                            [NumberEntry]       随机访问样本的位置和呈现时间</span><br><span class="line">每个randomaccessstructure记录都有以下布局：randomaccessstructure</span><br><span class="line">Time                        IF Version == <span class="number">0</span></span><br><span class="line">                                UI32</span><br><span class="line">                            IF Version == <span class="number">1</span></span><br><span class="line">                                UI64             随机访问样本的表示时间，以媒体标题中为此曲目定义的时间刻度单位表示。</span><br><span class="line">MoofOffset                  IF Version == <span class="number">0</span></span><br><span class="line">                                UI32</span><br><span class="line">                            IF Version == <span class="number">1</span></span><br><span class="line">                                UI64            对应电影片段框的字节偏移量，从文件开始</span><br><span class="line">TrafNumber                  &#123; UI8, UI16, UI24, UI32 &#125; </span><br><span class="line">                            [LengthSizeTrafNumMinus1]   包含随机可访问样本的traf编号。每个MOOF中的第一个traf编号为<span class="number">1</span>。</span><br><span class="line">                                                        类型是按长度大小索引的ui8、ui16、ui24、ui32中的一个<span class="number">1</span></span><br><span class="line">TrunNumber                  &#123; UI8, UI16, UI24, UI32 &#125; </span><br><span class="line">                            [LengthSizeTrunNumMinus1]   包含随机可访问样本的Trun编号。每个交通中的第一个通道编号为<span class="number">1</span>。</span><br><span class="line">SampleNumber                &#123; UI8, UI16, UI24, UI32 &#125;</span><br><span class="line">                            [LengthSizeSampleNumMinus1]     包含随机可访问样本的样本号。每个耳轴的第一个样本编号为<span class="number">1</span>。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.10 of ISO/IEC 14496-12:2008.</p>
<h5 id="a2-16-2">2.16.2. Movie Fragment Random Access Offset box</h5>

<p>Box type: ‘mfro’ </p>
<p>Container: Movie Fragment Random Access box (‘mfra’) </p>
<p>Mandatory: Yes </p>
<p>Quantity: One</p>
<p>Movie片段随机访问偏移量（mfro）框提供Movie片段随机访问（mfra）框的长度字段的副本，并帮助查找mfra框。mfro箱应最后放置在mfra箱中。</p>
<p>mfro box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;mfro&#x27;</span> (<span class="number">0x6d66726f</span>)</span><br><span class="line">Version         UI8                 Either <span class="number">0</span> or <span class="number">1</span></span><br><span class="line">Flags           UI24                Reserved, set to <span class="number">0</span></span><br><span class="line">Size            UI32                封闭movie片段随机访问框的大小（字节）</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.8.11 of ISO/IEC 14496-12:2008.</p>
<h3 id="a3">3. F4V Metadata</h3>

<p>本节介绍f4v文件格式支持的元数据。</p>
<h4 id="a3-1">3.1. Tag box</h4>

<p>Box type:  ‘auth’, ‘titl’, ‘dscp’ and ‘cprt’  </p>
<p>Container: Movie box (‘moov’) </p>
<p>Mandatory: No </p>
<p>Quantity: Zero or one of each type.</p>
<p>f4v文件格式支持包含在电影（moov）框中的四个可选标记框。一个f4v文件最多可以包含256个标记（包括这些框中的标记和在ILST框中定义的标记）。</p>
<p>Tag box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType应为以下类型之一：</span><br><span class="line">                                    作者的“auth”（<span class="number">0x61757468</span>）</span><br><span class="line">                                    “titl”（<span class="number">0x7469746C</span>）表示标题</span><br><span class="line">                                    “dscp”（<span class="number">0x64736370</span>）用于说明“cprt”（<span class="number">0x63707274</span>）用于版权</span><br><span class="line">Version         UI8                 Shall be <span class="number">0</span></span><br><span class="line">Flags           UI24                Reserved, set to <span class="number">0</span></span><br><span class="line">Pad             UI1                 Padding, set to <span class="number">0</span></span><br><span class="line">Language        UI5 [<span class="number">3</span>]             指定语言的三字符代码（见ISO <span class="number">639</span>-<span class="number">2</span>/T）。每个字符被解释为<span class="number">0x60</span>+（<span class="number">5</span>位）代码，以生成一个ASCII字符。</span><br><span class="line">TagString       UI8 [ ]             标记字符串数据，占用框的其余部分。标记字符串长度不得超过<span class="number">65535</span>字节。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="a3-2">3.2. XMP Metadata box</h4>

<p>Box type: ‘uuid’ </p>
<p>Container: File </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>从第10版开始，Flash播放器可以加载嵌入到F4V文件中的XMP数据。XMP是Adobe的可扩展元数据平台。有关详细信息，请参阅<a href="http://www.adobe.com/go/xmp%E3%80%82">www.adobe.com/go/xmp。</a></p>
<p>XMP元数据框应立即跟随电影（MOOV）框，无中间框。xmp元数据框的大小不得超过64兆字节。</p>
<p>通过XMP元数据框，该文件可以通过actionscript将XMP元数据与SWF电影通信。xmpmetadata通过名为dat a的字符串属性向actionscript公开。</p>
<p>XMP Metadata box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = ‘uuid’ (<span class="number">0x75756964</span>)</span><br><span class="line">UUID            UI8 [<span class="number">16</span>]            <span class="number">16</span>字节（<span class="number">128</span>位）通用唯一标识符（UUID）。</span><br><span class="line">                                    uuid应为十六进制字节，即<span class="number">7</span>a cf cb <span class="number">97</span> a9 <span class="number">42</span> e8 <span class="number">9</span>c <span class="number">71</span> <span class="number">99</span> <span class="number">94</span> <span class="number">91</span> e3 af ac。</span><br><span class="line">XMPMetadata     UI8 [ ]             XMP元数据，按照XMP元数据标准格式化</span><br></pre></td></tr></table></figure>

<h4 id="a3-3">3.3.  ilst box</h4>

<p>Box type: ‘ilst’ </p>
<p>Container: Meta box (‘meta’) </p>
<p>Mandatory: No </p>
<p>Quantity: One</p>
<p>ILST框出现在元（meta）框中，包含任意数量的元数据标记。f4v文件最多可包含256个标记（包括此框和“auth”、“titl”、“dscp”和“cprt”框中的标记）</p>
<p>ilst box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;ilst&#x27;</span> (<span class="number">0x696C7374</span>)</span><br><span class="line">TagCount        UI32                在ILST框中枚举的标记数</span><br><span class="line">Tags            TAGRECORD </span><br><span class="line">                [TagCount]          多个标记记录条目 </span><br><span class="line">每个标记记录都有以下布局：TAGRECORD</span><br><span class="line">TagLength       UI32                标记记录的总长度，包括此长度字段</span><br><span class="line">TagName         UI8 [<span class="number">4</span>]             <span class="number">4</span>个字节，指示标记的名称。这些字节通常来自人类可读的ASCII集，但不总是</span><br><span class="line">DataLength      UI32                标记记录的数据部分的总长度</span><br><span class="line">DataTag         UI8 [<span class="number">4</span>]             <span class="number">4</span>个字节<span class="string">&#x27;d&#x27;</span>、<span class="string">&#x27;a&#x27;</span>、<span class="string">&#x27;t&#x27;</span>和<span class="string">&#x27;a&#x27;</span>表示标记记录的数据部分</span><br><span class="line">DataType        UI32                指定标记记录的数据负载中的数据类型</span><br><span class="line">Reserved        UI32                Reserved, set to <span class="number">0</span></span><br><span class="line">Payload         UI8 [ ]             占用标记记录其余部分的任意字节数。精确的有效负载格式取决于数据类型</span><br><span class="line">                                    数据类型支持的值为：</span><br><span class="line">                                    -<span class="number">0</span>:自定义数据。在<span class="string">&#x27;trkn&#x27;</span>和<span class="string">&#x27;disk&#x27;</span>标记类型的情况下，数据有效负载被解释为单个ui32</span><br><span class="line">                                    - <span class="number">1</span>：文本数据</span><br><span class="line">                                    -<span class="number">13</span>，<span class="number">14</span>：二进制数据</span><br><span class="line">                                    -<span class="number">21</span>：通用数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="a3-4">3.4. Text Track Metadata</h4>

<p>Box type:  See below </p>
<p>Container: Text samples (‘text’ or ‘tx3g’) in Media Data box (‘mdat’) </p>
<p>Mandatory: No </p>
<p>Quantity: Any</p>
<p>文本示例（“text”或“tx3g”）可以包含以下元数据框。它们的内容通过ontextdata属性暴露给正在运行的actionscript程序。</p>
<h5 id="a3-4-1">3.4.1. Style box</h5>

<p>样式（Styl）框包含文本样式规范。此信息通过st yl e属性公开给actionscript。</p>
<p>styl box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;styl&#x27;</span> (<span class="number">0x7374796C</span>)</span><br><span class="line">Count           UI16                样式数组中的条目数</span><br><span class="line">Styles          STYLERECORD</span><br><span class="line">                [Count]             一组样式记录结构，每个结构都作为ActionScript对象</span><br><span class="line">单个样式记录具有以下布局：STYLERECORD</span><br><span class="line">StartChar       UI16                此样式记录应用到的第一个字符，通过名为startchar的双属性向actionscript公开</span><br><span class="line">EndChar         UI16                此样式记录应用到的最后一个字符，通过名为endchar的双属性向actionscript公开</span><br><span class="line">FontID          UI16                用于此样式的字体ID，通过名为fontid的双属性公开给actionscript</span><br><span class="line">                                    FaceStyleFlags UI8通过名为facestyleflags的双属性用于ActionScript</span><br><span class="line">FontSize        UI8                 用于字体的大小，通过属性fontsize用于actionscript</span><br><span class="line">TextColor       UI32                文本的rgba颜色，通过属性textcolor公开给actionscript</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-2">3.4.2. Highlight box</h5>

<p>突出显示（HLIT）框指定要突出显示的文本范围。此信息通过highlight属性公开给actionscript。</p>
<p>hlit box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	             Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;hlit&#x27;</span> (<span class="number">0x686C6974</span>)</span><br><span class="line">StartChar       UI16                要突出显示的第一个字符，通过名为startchar的双属性向actionscript公开</span><br><span class="line">EndChar         UI16                要突出显示的最后一个字符，通过名为endchar的双属性向actionscript公开。</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-3">3.4.3. Highlight Color box</h5>

<p>突出显示颜色（HCLR）框指定文本的突出显示颜色。此信息通过hi ghl i ght col或属性公开给actionscript。</p>
<p>hclr box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;hclr&#x27;</span> (<span class="number">0x68636C72</span>)</span><br><span class="line">HighlightColor  UI16 [<span class="number">3</span>]            通过名为hi-ghlightcolor的双属性向actionscript公开的三元素数组，它按顺序保存红色、绿色和蓝色组件的值。</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-4">3.4.4. Karaoke box</h5>

<p>Karaoke（krok）框指定Karaoke元数据。此信息通过karaoke属性公开给actionscript。时间以轨道定义的时间刻度单位表示。</p>
<p>krok box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;krok&#x27;</span> (<span class="number">0x6B726F6B</span>)</span><br><span class="line">StartTime       UI32                通过名为StartTime的双属性向ActionScript公开</span><br><span class="line">Count           UI16                KaraokeRecords数组中的条目数</span><br><span class="line">KaraokeRecords  KARAOKEREC [Count]  karaokerec结构的数组，每个结构都作为对象暴露在actionscript中</span><br><span class="line"></span><br><span class="line">An individual KARAOKEREC has the following structure: KARAOKEREC</span><br><span class="line">EndTime         UI32                通过名为endtime的双属性向ActionScript公开</span><br><span class="line">StartChar       UI16                通过名为startchar的双属性向ActionScript公开</span><br><span class="line">EndChar         UI16                通过名为endchar的双属性向ActionScript公开</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-5">3.4.5. Scroll Delay box</h5>

<p>滚动延迟（dlay）框指定滚动延迟。此信息通过scr ol l del ay属性向actionscript公开，该属性以与跟踪相关的时间刻度单位表示。</p>
<p>dlay box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	             Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;dlay&#x27;</span> (<span class="number">0x646C6179</span>)</span><br><span class="line">ScrollDelay     UI32                通过名为ScrollDelay的双属性向ActionScript公开</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-6">3.4.6. Drop Shadow Offset box</h5>

<p>放置阴影（DRPO）框指定文本的放置阴影偏移坐标。</p>
<p>drpo box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	                Type	            Comment</span><br><span class="line">Header                  BOXHEADER           BoxType = <span class="string">&#x27;drpo&#x27;</span> (<span class="number">0x6472706F</span>)</span><br><span class="line">DropShadowOffsetX       UI16                通过名为DropshadowOffsetx的双属性向ActionScript公开</span><br><span class="line">DropShadowOffsetY       UI16                通过名为DropshadowOffsty的双属性向ActionScript公开</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-7">3.4.7. Drop Shadow Alpha box</h5>

<p>放置阴影alpha（drpt）框指定放置阴影alpha值。</p>
<p>drpt box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;drpt&#x27;</span> (<span class="number">0x64727074</span>)</span><br><span class="line">DropShadowAlpha UI16                一个<span class="number">16</span>位alpha值，通过名为dr opshadowal pha的双属性公开给actionscript。</span><br></pre></td></tr></table></figure>


<p>For more information, see section 8.aaaaaaaaaaaaaaaaaaaaaaaaaaa of ISO/IEC 14496-12:2008.</p>
<h5 id="a3-4-8">3.4.8. Hypertext box</h5>

<p>超文本框（href）指定在文本范围内具有alt文本的超文本链接。此信息通过hyper t ext属性公开给actionscript。</p>
<p>href box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;href&#x27;</span> (<span class="number">0x68726566</span>)</span><br><span class="line">StartChar       UI16                文本范围的开始字符，通过名为startchar的双属性向actionscript公开。</span><br><span class="line">EndChar         UI16                文本范围的最后一个字符，通过名为endchar的双属性向actionscript公开</span><br><span class="line">URLSize         UI8                 The length <span class="keyword">of</span> the URL string</span><br><span class="line">URL             UI8 [URLSize]       通过名为url的字符串属性向actionscript公开的url字符串</span><br><span class="line">ALTSize         UI8                 The length <span class="keyword">of</span> the ALT string</span><br><span class="line">ALT             UI8 [ALTSize]       当用户鼠标悬停在链接上时显示的alt字符串，通过名为alt的字符串属性向actionscript公开。</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-9">3.4.9. Text Box box</h5>

<p>文本框（tbox）框定义文本框的坐标。此信息通过t ex t box属性公开给actionscript。</p>
<p>tbox box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;tbox&#x27;</span> (<span class="number">0x74626F78</span>)</span><br><span class="line">Top             UI16                顶部像素坐标，通过名为top的双属性向actionscript公开</span><br><span class="line">Left            UI16                左像素坐标，通过名为Left的双属性向ActionScript公开</span><br><span class="line">Bottom          UI16    </span><br><span class="line">Right           UI16</span><br></pre></td></tr></table></figure>

<h5 id="a3-4-10">3.4.10. Blinking box</h5>

<p>Blinking（BLNK）框指定要设置闪烁的文本范围。此信息通过blink属性公开给actionscript。</p>
<p>blnk box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;blnk&#x27;</span> (<span class="number">0x626C6E6B</span>)</span><br><span class="line">StartChar       UI16                闪烁范围中的第一个字符，通过名为startchar的双属性向actionscript公开</span><br><span class="line">EndChar         UI16                闪烁范围中的结束字符，通过名为endchar的双属性向actionscript公开</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="a3-4-11">3.4.11. Text Wrap box</h5>

<p>文本换行（twrp）框为文本设置换行标志。</p>
<p>twrp box</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	            Comment</span><br><span class="line">Header          BOXHEADER           BoxType = <span class="string">&#x27;twrp&#x27;</span> (<span class="number">0x74777270</span>)</span><br><span class="line">WrapFlag        UI8                 如果文本应该换行，则为非零的布尔值，通过名为wrapflag的双属性向actionscript公开。</span><br></pre></td></tr></table></figure>

<h3 id="a4">附件A.嵌入提示点</h3>
<h4 id="a4-1">A.1.Overview</h4>

<p>使用Flash构建媒体应用程序的一个关键好处是能够混合媒体播放和丰富的交互式数据。f4v应用程序可以支持以amf样本的形式嵌入时间数据（提示点）。这些示例与音频和视频示例一起传输到Flash运行时，在那里它们被发送到应用程序脚本。</p>
<h4 id="a4-2">A.2.AMF样本格式</h4>

<p>AMF示例是包含类型化AMF值列表的AMF对象。</p>
<p>根据为数据轨指定的类型，AMF对象应为AMF0对象或AMF3对象。amf0和amf3的规范可以在以下网址找到：<a href="http://opensource.adobe.com/wiki/display/blazeds/developer+documentation">http://opensource.adobe.com/wiki/display/blazeds/developer+documentation</a></p>
<p>第一个值应为表示AMF样本名称的字符串。AMF值将被调度到具有此名称的方法。例如，如果第一个字段是名为“onfoo”的字符串，则在播放AMF示例时调用方法“onfoo”。</p>
<p>表3列出了为运行时保留且未调度到脚本的名称：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Table <span class="number">3.</span> Reserved names</span><br><span class="line"></span><br><span class="line">attachAudio	    attachVideo	    call	close	getBufferInfo</span><br><span class="line">onStatus	    pause	        play	play2	publish</span><br><span class="line">receiveAudio	receiveVideo	seek	send	setBufferTime</span><br></pre></td></tr></table></figure>

<h4 id="a4-3">A.3.AMF数据跟踪结构</h4>

<p>AMF样本可以存储在数据跟踪中。数据轨配置如下：</p>
<p>处理程序参考（HDLR）框中的处理程序类型应为“数据”，媒体头框类型应为“NMHD”。</p>
<p>样品描述（STSD）框应包含一份描述AMF样品的描述记录。</p>
<p>说明条目格式应为sampleEntry类型。</p>
<p>说明条目的框类型应为“amf0”或“amf3”，与样本的“amf”格式相对应。以下数据轨框应包含每个AMF样本的条目：</p>
<p>-解码时间采样（STTS）框，用于AMF样本的解码时间。</p>
<p>-样本大小（STSZ）框，用于AMF样本的大小。</p>
<p>-chunk offset（STCO或CO64）框，用于AMF样本的偏移。</p>
<p>-合成时间采样（CTTS）框，用于将AMF样本传递到ActionScript的时间</p>
<p>程序。</p>
<p>在媒体数据（mdat）框中，数据轨中的样本应与音频和视频样本交错。</p>
<h5 id="a4-3-1">A.3.1.解码数据轨</h5>

<p>播放一个f4v文件时，mdat框中的amf示例将传递给amf解码器。在STTS框中指定的时间，AMF解码器对样本进行解码。</p>
<p>在CTTS框中指定的时间，AMF解码器将解码后的AMF样本传递给actionscript程序。</p>
<h4 id="a4-4">A.4.渐进式下载</h4>

<p>通过适当的交织，该方法适用于渐进式下载。</p>
<p>AMF内容应与音频和视频内容在正确的时间交错，以确保在下载文件时数据在正确的时间可用。</p>
<p>AMF数据不应存储在文件的末尾，因为在这种情况下，在发送第一个AMF样本之前，必须下载整个文件，即使该样本在内容的时间非常早。</p>
<h4 id="a4-5">A.5.多个数据轨</h4>

<p>只有一个数据轨。</p>
<h3 id="a5">附件B.Flash播放器元数据</h3>
<h4 id="a5-1">B.1.流属性</h4>

<p>当flash player加载一个f4v文件时，可以通过net st r eam为正在运行的actionscript程序提供各种流属性。Onmet Adat a Property公司。可用属性因用于创建文件的软件而异。典型特性为：</p>
<p>-audi ocodeci d：一个包含四个字符的字符串，定义使用的音频编解码器（如果存在音频并且</p>
<p>使用Flash播放器可以解码的编解码器编码</p>
<p>-avcl-level：表示视频符合的avc级别的双精度符号，如果存在视频并对其进行编码。</p>
<p>采用AVC／H.264</p>
<p>-ile的avcpr：一个双精度符号，表示视频符合的avc配置文件（如果存在视频且</p>
<p>用AVC/H.264编码</p>
<p>-打开时的持续时间：以秒为单位表示电影总长度的两倍</p>
<p>-高度：表示视频高度的双精度符号，如果视频存在并使用编解码器编码</p>
<p>Flash播放器可以解码</p>
<p>-moovposition：一个双精度符号，表示f4v文件中moov框的绝对偏移量。此属性</p>
<p>用于确定文件是否将逐步加载</p>
<p>-videocodecid：一个包含四个字符的字符串，定义所使用的视频编解码器（如果存在视频且</p>
<p>使用Flash播放器可以解码的编解码器编码</p>
<p>-如果存在视频，则显示视频的平均视频帧速率。</p>
<p>使用Flash播放器可以解码的编解码器编码</p>
<p>-width：一个双精度符号，表示视频的宽度，如果视频存在，并用闪烁的编解码器编码。</p>
<p>玩家可以解码</p>
<h4 id="a5-2">B.2.影像元数据</h4>

<p>如果f4v示例是图像类型（gif、png或jpeg），则通过oni magedat a属性将数据提供给正在运行的actionscript程序。存在以下属性：</p>
<p>-数据：包含压缩图像数据（即原始jpeg、png或gif文件数据）的字节数组。</p>
<p>-trackID：指示此示例所属的轨道的双精度符号。</p>
<h3 id="a6">附件C.HTTP流：文件结构</h3>
<h4 id="a6-1">C.1.概述</h4>

<p>Flash播放器支持带有F4V片段的HTTP流。HTTP流表示由HTTP流清单文件（F4M）和HTTP流段（分段的F4V文件或F4F）组成。</p>
<p>表示沿时间线划分为HTTP流段，进一步划分为HTTP流段。演示文稿可以在多个质量级别上并行提供。可以通过片段（完全或部分）和质量级别缓存和交付演示文稿。</p>
<p>演示文稿的引导信息框指定演示文稿的数据结构和对其的访问。清单文件（fdm）在<a href="http://opensource.adobe.com/wiki/display/osmf/flash+media+manifest+file+format+specification%E4%B8%AD%E6%9C%89%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%8F%8F%E8%BF%B0%E3%80%82">http://opensource.adobe.com/wiki/display/osmf/flash+media+manifest+file+format+specification中有进一步的描述。</a></p>
<h4 id="a6-2">C.2.HTTP流段</h4>

<p>HTTP流段是包含片段的完整F4V文件。该段只能属于一个质量级别。该段应包括一组方框，后跟一组HTTP流片段。</p>
<p>成套盒子应包括以下盒子，最好按此顺序排列（可选盒子用括号[]表示）：</p>
<ul>
<li><p>   ftyp</p>
</li>
<li><p>   [afra]</p>
</li>
<li><p>   [abst]</p>
</li>
<li><p>   moov</p>
</li>
<li><p>   rtmp</p>
</li>
<li><p>   [mdat]</p>
</li>
</ul>
<p>一套盒子可能包括AFRA和MDAT盒子。如果包含，AFRA盒应位于MDAT盒和ABT盒之前。</p>
<p>HTTP流段中HTTP流段外部的MOOF盒不得用于HTTP流。</p>
<h4 id="a6-3">C.2.HTTP流片段</h4>

<p>HTTP流片段应包括以下每个框中的一个，最好按此顺序：</p>
<ul>
<li><p>   afra</p>
</li>
<li><p>   abst</p>
</li>
<li><p>   moof</p>
</li>
<li><p>   mdat</p>
</li>
</ul>
<p>AFRA箱应位于所有其他箱之前。</p>
<p>片段不是完整的f4v文件。HTTP流片段中不允许使用框ftyp、pdin和moov。</p>
<h4 id="a6-4">C.4.URL构造</h4>

<p>每个HTTP流段都是一个单独的URL资源（文件）。URL方案可以唯一地寻址每个HTTP流片段。HTTP流片段的URL构造如下：</p>
<p><a href="http://serverbaseurl&gt;/">http://serverbaseurl&gt;/</a>&lt;*movieidentifier&gt;&lt;*qualityssegmenturlmodifier&gt;seg&lt;*segment number&gt;-frag&lt;*fragmentnumber&gt;</p>
<p>其中，f4v规范定义了括号中的字段，数字没有前导零。如果serverEntryCount==0，&lt;*serverBaseURL&gt;和尾随斜杠应省略。</p>
<p>如果QualityEntryCount==0，&lt;*QualitySegmenturModifier&gt;应省略。</p>
<p>示例：<a href="http://adobe.com/mymovie/highseg1-frag210">http://adobe。com/mymovie/highseg1-frag210</a></p>
<h4 id="a6-5">C.5.Adobe多路提示跟踪格式</h4>

<p>用于HTTP流的F4V文件需要包含提示跟踪。提示跟踪提供了使流服务器能够创建传输数据包的信息。有关流的信息，请参阅ISO规范第7节。</p>
<p>Adobe支持Adobe多路提示跟踪格式。Adobe多路复用提示跟踪格式足够灵活，可以支持RTMP数据包以及类似FLV的格式，其中样本作为一个整体按时间顺序交错。FLV兼容模式是为提示样本和FLV格式之间的有效映射而定义的。可以对格式进行配置，以确保由一系列提示样本组成的mdat与对应于这些样本的flv的一部分相同。</p>
<p>Adobemux提示示例输入框（rtmp）描述了提示轨迹。提示轨包含一个AdobEmuxhintsamples集合，并位于媒体数据框中。</p>
<p>定义了三种提示模式：</p>
<p>-立即模式（模式=0）</p>
<p>在这种模式下，为了提高效率，多路复用轨道的有效载荷直接在提示样本本身中可用。但是，必须小心使用此模式，因为它可能会导致某些数据重复。</p>
<p>-立即节点提升模式（模式=1）</p>
<p>立即节点提升模式的定义是为了避免立即模式下的数据复制。在此配置中，原始（音频/视频）曲目的采样表中的偏移量被调整为物理指向包含媒体数据的（立即模式）提示样本（本地位于mdat位置）。因为块偏移量被更改为指向每个样本的提示样本（在头之后和样本开始的位置），所以所有块只包含一个样本。</p>
<p>因此，媒体框“mdat”只包含提示示例（没有音频或视频示例）。提示示例将在其即时数据字段中嵌入媒体数据。只有在Adobe多路复用数据包中使用完整样本（而不是在分块RTMP模式下）时，这才是可能的。此外，这也会增加区块偏移表的副作用，但与获得的效率相比，这是最小的。</p>
<p>-采样模式（模式=2）</p>
<p>在这种模式下，包头和尾部被定义为提示样本的一部分。多路复用磁道的有效负载通过引用具有长度和偏移量的媒体磁道中的特定样本从提示样本“指向”媒体磁道。</p>
<h3 id="a7">附录D.F4V加密D.1概述</h3>
<h4 id="a7-1">D.1.加密过程</h4>

<p>本节概述了如何使用Adobe的DRM密钥/权限管理系统来保护F4V内的媒体。保护仅适用于F4V的音频/视频曲目。其他曲目类型（如AMF曲目）的加密格式不在本规范的范围内。</p>
<p>本节应与ISO 14496-12:2008第8.12节（对受保护流的支持）一起阅读。在阅读下一节之前，读者必须理解上述文件格式。</p>
<h4 id="a7-2">D.2.加密过程</h4>

<p>加密过程将样本格式从纯文本更改为密码文本。在每个示例数据之前插入一个Adobe DRM访问单元头。由于将纯文本转换为密码文本，因此如果不使用适当的密钥，则无法使用应用程序访问基础媒体。</p>
<p>将转换描述加密样本的样本描述表中的样本描述条目。转换结构遵循ISO 14496-12:2008第8.12节。转换示例描述条目的目的是双重的：示例描述条目防止意外处理加密数据，就像它是未加密的一样，并记录应用的转换。</p>
<p>执行以下示例描述转换：</p>
<p>-样本描述条目的4cc替换为4cc，表示加密：</p>
<p>o“encv”表示加密视频流（而不是“mp4v”、“avc1”），o“enca”表示加密音频流（而不是“mp4a”、“samr”），o“encr”表示加密数据流。</p>
<p>-保护方案信息（sinf）框附加到示例描述条目后，保留所有其他框。</p>
<p>未修改的sinf框包含理解应用的加密转换及其参数以及查找其他信息（如密钥管理系统的类型和位置）所需的所有信息。它还记录了媒体的原始（未加密）格式。</p>
<p>-样本描述条目的原始格式4cc存储在原始格式（frma）框中，即</p>
<p>sinf框的子框。</p>
<p>-方案类型（schm）框也是sinf框的子框，并将加密方案指定为4cc和</p>
<p>它的版本。在f4v文件中，该方案4cc应为“adkm”，即Adobe的DRM密钥管理。</p>
<p>-在sinf框中，有一个“黑框”（方案信息（schi）框）空间，用于描述</p>
<p>控制对加密媒体内容的访问的密钥管理。schi框是一个容器框，仅由正在使用的方案解释。在F4V文件中，此框应为Adobe DRM密钥管理系统框。</p>
<p>图1–在f4v中存储保护信息的示例</p>
<p>图1说明了保护信息如何存储在F4V中。在示例中，将保护方案信息（sinf）框放入每个曲目的示例描述条目中，并将Adobe的DRM标识符指定为密钥/权限管理系统，以保护音频和视频曲目。</p>
<p>sinf框是每个示例描述框中的示例条目。虽然在一个样本描述框中可以有多个样本条目（每个曲目只能有一个样本描述框），但这并不常见。因此，上面的图表只显示每个轨道一个sinf框。但是，由于每个磁道可能有多个磁道，因此DRM Packager和DRM解码器都应该能够处理这种情况。</p>
<h4 id="a7-3">D.3.样本加密</h4>

<p>本节介绍在将DRM应用于F4V中的音频或视频轨时如何转换每个样本。</p>
<h5 id="a7-3-1">D.3.1.接入单元头</h5>

<p>表4中定义的访问单元头指定了由Adobe的DRM保护的每个样本单元的格式。媒体文件格式将媒体数据的布局指定为示例，但加密/解密过程需要在每个示例中包含其他信息。附加信息取决于所使用的DRM密钥管理。Adobe的DRM指定了自己的访问单元报头，该报头应位于每个编解码器特定的示例数据之前。f4v访问单元头与flv选择性加密过滤器参数相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Table <span class="number">4.</span> Access Unit Header</span><br><span class="line">Access Unit Header</span><br><span class="line">Field                 Type              Comment</span><br><span class="line">EncryptedAU	          UI1               选择性加密指示器显示数据包是否加密。</span><br><span class="line">                                            <span class="number">0</span>=样本未加密</span><br><span class="line">                                            <span class="number">1</span>=样本已加密。     </span><br><span class="line">Reserved              UI7               Shall be <span class="number">0</span></span><br><span class="line">IV              IF EncryptedAU == <span class="number">1</span></span><br><span class="line">                    UI8 [IVLength]      仅在样本加密时存在。包含<span class="number">16</span>字节的AES-CBC IV数据</span><br></pre></td></tr></table></figure>


<p>上述指定的访问单元头应添加到样本描述条目打开DRM（即存在保护方案信息（sinf）框）的每个样本中，即使特定样本未加密。报头是解码器知道特定样本是否加密的唯一方法（在selectiveencryption为1的情况下）。当只加密关键帧时，样本的选择性加密可以提高性能。</p>
<h5 id="a7-3-2">D.3.2.加密样本的填充</h5>

<p>所有加密样本应填充到块密码块长度的倍数。填料方案应如RFC 2630中所述，复制如下：</p>
<p>块密码期望输入数据是k个八位字节的倍数（对于aes 128，要求输入数据是16个八位字节的倍数），其中k大于1。对于此类算法，输入应在尾端填充k-（length mod k）八位字节，所有八位字节的值均为k-（length mod k），其中length是输入的长度。</p>
<p>因此，输入用下面的一个k字节序列填充在尾端，如表5所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Table <span class="number">5.</span> Padding the cipher block</span><br><span class="line"></span><br><span class="line">Condition                   Bytes added to the end <span class="keyword">of</span> the block</span><br><span class="line">IF length mod k=k-<span class="number">1</span>	                                    <span class="number">0</span>1</span><br><span class="line">IF length mod k=k-<span class="number">2</span>	                                <span class="number">0</span>2	<span class="number">0</span>2</span><br><span class="line">...</span><br><span class="line">IF length mod k=n                           ...  k-n   k-n</span><br><span class="line">...</span><br><span class="line">IF length mod k=<span class="number">0</span>           k	k	…	k	k    k       k</span><br></pre></td></tr></table></figure>


<p>由于所有输入都被填充，包括已经是块大小的倍数的输入值，并且没有填充序列是另一个的后缀，因此可以从填充块明确地确定填充的大小。最后一个八位字节表示要修剪多少个八位字节。</p>
<h3 id="a8">附录E.FLV文件格式</h3>
<h4 id="a8-1">E.1.概述</h4>

<p>flv文件中的每个标记类型构成一个单独的流。在一个FLV文件中，同步在一起的音频和视频流不得超过一个。FLV文件不应定义单个类型的多个独立流。FLV中使用的简单数据类型在SWF格式规范中定义。flv文件使用一个没有为swf文件定义的附加类型：ui24表示无符号的24位整数。</p>
<p>与SWF文件不同，FLV文件应以大端字节顺序存储多字节数。例如，作为SWF文件格式中的ui16，表示数字300（0x12c）的字节序列为0x2c 0x01；作为FLV文件格式中的ui16，表示数字300的字节序列为0x01 0x2c。</p>
<p>另请参见SWF文件格式规范，网址为<a href="http://www.adobe.com/go/swf_file_format%E3%80%82">http://www.adobe.com/go/swf_file_format。</a></p>
<h4 id="a8-2">E.2.FLV报头</h4>

<p>FLV文件应以FLV头开始：</p>
<p>FLV header</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Signature           UI8	Signature byte always <span class="string">&#x27;F&#x27;</span> (<span class="number">0x46</span>)</span><br><span class="line">Signature           UI8	Signature byte always <span class="string">&#x27;L&#x27;</span> (<span class="number">0x4C</span>)</span><br><span class="line">Signature           UI8	Signature byte always <span class="string">&#x27;V&#x27;</span> (<span class="number">0x56</span>)</span><br><span class="line">Version             UI8	File version (<span class="keyword">for</span> example, <span class="number">0x01</span> <span class="keyword">for</span> FLV version <span class="number">1</span>)</span><br><span class="line">TypeFlagsReserved   UB [<span class="number">5</span>]	Shall be <span class="number">0</span></span><br><span class="line">TypeFlagsAudio      UB [<span class="number">1</span>]	<span class="number">1</span> = Audio tags are present</span><br><span class="line">TypeFlagsReserved   UB [<span class="number">1</span>]	Shall be <span class="number">0</span></span><br><span class="line">TypeFlagsVideo      UB [<span class="number">1</span>]	<span class="number">1</span> = Video tags are present</span><br><span class="line">DataOffset          UI32	The length <span class="keyword">of</span> <span class="built_in">this</span> header <span class="keyword">in</span> bytes</span><br></pre></td></tr></table></figure>


<p>对于FLV版本1，dataoffset字段的值通常为9。此字段用于在将来的版本中容纳较大的标题。</p>
<h4 id="a8-3">E.3.FLV文件体</h4>

<p>在flv头段之后，flv文件的其余部分应包含交替的反向指针和标签。它们交错排列，如下表所示：</p>
<p>FLV File Body</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type            Comment</span><br><span class="line">PreviousTagSize0    UI32            Always <span class="number">0</span></span><br><span class="line">Tag1                FLVTAG          First tag</span><br><span class="line">PreviousTagSize1    UI32            上一个标记（包括其标题）的大小（字节）。</span><br><span class="line">                                    对于FLV版本<span class="number">1</span>，该值为<span class="number">11</span>加上上上一个标记的数据大小。</span><br><span class="line">Tag2                FLVTAG          Second tag</span><br><span class="line">...</span><br><span class="line">PreviousTagSizeN-<span class="number">1</span>  UI32            第二个到最后一个标记（包括其标题）的大小（字节）。</span><br><span class="line">TagN                FLVTAG          Last tag</span><br><span class="line">PreviousTagSizeN    UI32            最后一个标记（包括其标题）的大小（字节）。</span><br></pre></td></tr></table></figure>

<h4 id="a8-4">E.4.FLV标签定义</h4>
<H5 id="a8-4-1">E.4.1FLV标签</H5>

<p>flv标记包含音频、视频或脚本的元数据、可选加密元数据和有效负载。FLVTAG</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field                       Type	        Comment</span><br><span class="line">Reserved                    UB [<span class="number">2</span>]          Reserved <span class="keyword">for</span> FMS, should be <span class="number">0</span></span><br><span class="line">Filter                      UB [<span class="number">1</span>]          指示是否筛选数据包。</span><br><span class="line">                                            <span class="number">0</span>=不需要预处理。</span><br><span class="line">                                            <span class="number">1</span>=在呈现数据包之前，需要对其进行预处理（如解密）。</span><br><span class="line">                                            未加密文件中应为<span class="number">0</span>，加密标签应为<span class="number">1</span>。过滤器的使用见附录F.FLV加密。</span><br><span class="line"></span><br><span class="line">TagType                     UB [<span class="number">5</span>]          此标记中的内容类型。定义了以下类型：</span><br><span class="line">                                            <span class="number">8</span>＝音频</span><br><span class="line">                                            <span class="number">9</span>＝视频</span><br><span class="line">                                            <span class="number">18</span>=脚本数据</span><br><span class="line"></span><br><span class="line">DataSize                    UI24            消息的长度。streamid到标记末尾后的字节数（等于标记的长度–<span class="number">11</span>）</span><br><span class="line">Timestamp                   UI24            应用此标记中数据的时间（毫秒）。该值与flv文件中的第一个标记相关，该标记的时间戳始终为<span class="number">0</span>。</span><br><span class="line">TimestampExtended           UI8             timestamp字段的扩展，以形成si32值。此字段表示高<span class="number">8</span>位，而前一个时间戳字段表示低<span class="number">24</span>位时间（毫秒）。</span><br><span class="line">StreamID                    UI24            Always <span class="number">0.</span></span><br><span class="line">AudioTagHeader          IF TagType == <span class="number">8</span>     第E<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span>节中定义的audioTagHeader元素。</span><br><span class="line">                            AudioTagHeader</span><br><span class="line">VideoTagHeader          IF TagType == <span class="number">9</span>      第E<span class="number">.4</span><span class="number">.3</span><span class="number">.1</span>节中定义的VideoTagHeader元素。</span><br><span class="line">                            VideoTagHeader</span><br><span class="line">EncryptionHeader        IF Filter == <span class="number">1</span>      如第F<span class="number">.3</span><span class="number">.1</span>节所述，每个受保护样品应包括加密头。</span><br><span class="line">                        EncryptionTagHeader</span><br><span class="line">FilterParams            IF Filter == <span class="number">1</span>      根据第F<span class="number">.3</span><span class="number">.2</span>节的规定，每个受保护样品应包括过滤器参数。</span><br><span class="line">                            FilterParams</span><br><span class="line"></span><br><span class="line">Data                    IF TagType == <span class="number">8</span>     每种媒体类型的特定数据。</span><br><span class="line">                            AUDIODATA</span><br><span class="line">                        IF TagType == <span class="number">9</span></span><br><span class="line">                            VIDEODATA</span><br><span class="line">                        IF TagType == <span class="number">18</span></span><br><span class="line">                            SCRIPTDATA</span><br></pre></td></tr></table></figure>


<p>在回放中，flv标记的时间顺序仅取决于flv时间戳。应忽略有效载荷数据格式中内置的任何定时机制。<br><H5 id="a8-4-2">E.4.2音频标签</H5></p>
<p>音频标签类似于SWF文件格式中的definesound标签。对于SWF中也支持的格式，FLV和SWF中的有效载荷数据是相同的。<br><H5 id="a8-4-2-1">E.4.2.1音频数据</H5></p>
<p>audioTagHeader包含音频特定的元数据</p>
<p>AudioTagHeader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type            Comment</span><br><span class="line">SoundFormat         UB [<span class="number">4</span>]          声音数据的格式。定义了以下值：</span><br><span class="line">(见注释下表：为了特殊编码)              <span class="number">0</span>=线性PCM，平台端</span><br><span class="line">                                    <span class="number">1</span>＝ADPCM</span><br><span class="line">                                    <span class="number">2</span>＝MP3</span><br><span class="line">                                    <span class="number">3</span>=线性PCM，小端</span><br><span class="line">                                    <span class="number">4</span>=<span class="number">16</span> kHz单声道Nellymoser</span><br><span class="line">                                    <span class="number">5</span>=<span class="number">8</span> kHz单声道Nellymoser</span><br><span class="line">                                    <span class="number">6</span> = NelyMysor</span><br><span class="line">                                    <span class="number">7</span>=G<span class="number">.711</span> a-律对数pcm</span><br><span class="line">                                    <span class="number">8</span>=G<span class="number">.711</span>μm对数pcm</span><br><span class="line">                                    <span class="number">9</span> =保留</span><br><span class="line">                                    <span class="number">10</span>＝AAC</span><br><span class="line">                                    <span class="number">11</span> = SeEX</span><br><span class="line">                                    <span class="number">14</span>＝MP3 <span class="number">8</span> kHz</span><br><span class="line">                                    <span class="number">15</span>=设备特定声音</span><br><span class="line">                                    保留格式<span class="number">7</span>、<span class="number">8</span>、<span class="number">14</span>和<span class="number">15</span>。</span><br><span class="line">                                    Flash Player <span class="number">9</span>、<span class="number">0</span>115、<span class="number">0</span>及更高版本支持AAC。</span><br><span class="line">                                    Flash Player <span class="number">10</span>及更高版本支持speex。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SoundRate           UB [<span class="number">2</span>]          采样率。定义了以下值：</span><br><span class="line">                                    <span class="number">0</span>＝<span class="number">5.5</span>千赫</span><br><span class="line">                                    <span class="number">1</span>＝<span class="number">11</span>千赫</span><br><span class="line">                                    <span class="number">2</span>＝<span class="number">22</span>千赫</span><br><span class="line">                                    <span class="number">3</span>＝<span class="number">44</span>千赫</span><br><span class="line">SoundSize           UB [<span class="number">1</span>]          每个音频样本的大小。此参数仅适用于未压缩格式。压缩格式总是在内部解码为<span class="number">16</span>位。</span><br><span class="line">                                    <span class="number">0</span>=<span class="number">8</span>位样本</span><br><span class="line">                                    <span class="number">1</span>=<span class="number">16</span>位样本</span><br><span class="line">SoundType           UB [<span class="number">1</span>]          单声道或立体声</span><br><span class="line">                                    <span class="number">0</span> =单声道</span><br><span class="line">                                    <span class="number">1</span>=立体声</span><br><span class="line">AACPacketType       IF SoundFormat == <span class="number">10</span></span><br><span class="line">                    UI8             定义了以下值：</span><br><span class="line">                                    <span class="number">0</span>=AAC序列头</span><br><span class="line">                                    <span class="number">1</span> = AAC原材料</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>格式3，线性PCM，存储原始PCM样本。如果数据为8位，则样本为无符号字节。如果数据是16位的，那么样本将存储为有符号的小尾数。如果数据是立体声的，则左右样本是交错存储的：左-右-左-右-等等。</p>
<p>格式0 pcm与格式3 pcm相同，只是格式0按照文件创建平台的尾数顺序存储16位pcm样本。因此，不应使用格式0。</p>
<p>8 kHz和16 kHz是特殊情况，因为声速场不能代表8或16 kHz的采样率。当在SoundFormat中指定Nellymser 8 kHz或Nellymser 16 kHz时，Flash播放器将忽略SoundRate和SoundType字段。对于其他Nellymser采样率，请指定正常的Nellymser SoundFormat，并像往常一样使用SoundRate和SoundType字段。</p>
<p>如果SoundFormat指示AAC，则SoundType应为1（立体声），SoundRate应为3（44 kHz）。但是，这并不意味着FLV中的AAC音频总是立体声的，44 kHz的数据。相反，flash播放器忽略这些值并提取通道，采样率数据编码在AAC比特流中。</p>
<p>如果SoundFormat指示为speex，则音频以16kHz的频率进行单采样压缩，声音速率应为0，声音大小应为1，声音类型应为0。有关存储在swf文件中的speex功能和限制的信息，请参阅<a href="http://www.adobe.com/go/swf_file_format%E4%B8%8A%E7%9A%84swf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E3%80%82">http://www.adobe.com/go/swf_file_format上的swf文件格式规范。</a></p>
<p>音频数据段包含音频有效载荷。</p>
<p>AUDIODATA</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	         Comment</span><br><span class="line">IF Encrypted	                 详见附件F.FLV加密。</span><br><span class="line">    Body	    EncryptedBody	按照第F<span class="number">.3</span><span class="number">.3</span>节的规定加密的音频标签体。</span><br><span class="line">ELSE</span><br><span class="line">    Body        AudioTagBody</span><br></pre></td></tr></table></figure>


<p>AudioTagBody保存音频有效负载。</p>
<p>AudioTagBody</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	        Type	         Comment</span><br><span class="line">SoundData</span><br><span class="line">IF SoundFormat == <span class="number">10</span></span><br><span class="line">AACAUDIODATA</span><br><span class="line">ELSE</span><br><span class="line">Varies by format</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-2-2">E.4.2.2 AACAUDIODATA</H5>

<p>Flash Player 9、0115、0及更高版本支持AAC格式。</p>
<p>AACAUDIODATA</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	    Type	                        Comment</span><br><span class="line">Data        IF AACPacketType == <span class="number">0</span>	        </span><br><span class="line">            udioSpecificConfig              AudioSpecificConfig在ISO中定义。</span><br><span class="line">            ELSE IF AACPacketType == <span class="number">1</span></span><br><span class="line">            Raw AAC frame data <span class="keyword">in</span> UI8 [ ]   <span class="number">14496</span>～<span class="number">3</span>。请注意，这与MP4/F4V文件中ESDS框的内容不同。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<H5 id="a8-4-3">E.4.3视频标签</H5>
视频标签类似于SWF文件格式的视频帧标签，其有效载荷数据相同。另请参见SWF文件格式规范，网址为http://www.adobe.com/go/swf_file_format。
<H5 id="a8-4-3-1">E.4.3.1视频数据</H5>

<p>VideoTagHeader包含特定于视频的元数据</p>
<p>VideoTagHeader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	            Type	            Comment</span><br><span class="line">Frame Type          UB [<span class="number">4</span>]              视频帧的类型。定义了以下值：</span><br><span class="line">                                        <span class="number">1</span>=关键帧（对于AVC，可查找的帧）</span><br><span class="line">                                        <span class="number">2</span>=帧间（对于AVC，是不可查找的帧）</span><br><span class="line">                                        <span class="number">3</span>=一次性内框（仅H<span class="number">.263</span>）</span><br><span class="line">                                        <span class="number">4</span>=生成的密钥帧（仅供服务器使用）</span><br><span class="line">                                        <span class="number">5</span>=视频信息/命令帧</span><br><span class="line"></span><br><span class="line">CodecID             UB [<span class="number">4</span>]              编解码器标识符。定义了以下值：</span><br><span class="line">                                        <span class="number">2</span>=Sorenson H<span class="number">.263</span></span><br><span class="line">                                        <span class="number">3</span>=屏幕视频</span><br><span class="line">                                        <span class="number">4</span>＝ON2 VP6</span><br><span class="line">                                        <span class="number">5</span>=ON2 VP6，带阿尔法通道</span><br><span class="line">                                        <span class="number">6</span>=屏幕视频版本<span class="number">2</span></span><br><span class="line">                                        <span class="number">7</span> = AVC</span><br><span class="line"></span><br><span class="line">AVCPacketType       IF CodecID == <span class="number">7</span></span><br><span class="line">                        UI8             定义了以下值：</span><br><span class="line">                                        <span class="number">0</span>=AVC序列头段</span><br><span class="line">                                        <span class="number">1</span> = AVC NALU</span><br><span class="line">                                        <span class="number">2</span>=AVC序列结束（不需要或不支持低级NALU序列结束符</span><br><span class="line">CompositionTime     IF CodecID == <span class="number">7</span>         </span><br><span class="line">                        SI24            如果avcpacketype==<span class="number">1</span></span><br><span class="line">                                        合成时间偏移</span><br><span class="line">                                        否则</span><br><span class="line">                                        零有关组成时间的说明，</span><br><span class="line">                                        请参见ISO <span class="number">14496</span>-<span class="number">12</span>，<span class="number">8.15</span><span class="number">.3</span>。</span><br><span class="line">                                        flv文件中的偏移量始终以毫秒为单位。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>视频数据段包含视频元数据、可选加密元数据和视频有效负载。</p>
<p>VIDEODATA</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field	         Type	            Comment</span><br><span class="line">IF Encrypted	                    详见附件F.FLV加密。</span><br><span class="line">Body	        EncryptedBody	    视频标记体按照第F<span class="number">.3</span><span class="number">.3</span>节的规定加密。</span><br><span class="line">ELSE</span><br><span class="line">Body</span><br></pre></td></tr></table></figure>


<p>VideoTagBody</p>
<p>VideoTagBody包含视频帧有效负载。</p>
<p>VideoTagBody</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type                                Comment</span><br><span class="line">VideoTagBody        IF FrameType == <span class="number">5</span>                  视频帧有效载荷或帧信息 </span><br><span class="line">                        UI8</span><br><span class="line">                    ELSE (</span><br><span class="line">                        IF CodecID == <span class="number">2</span></span><br><span class="line">                            H263VIDEOPACKET</span><br><span class="line">                        IF CodecID == <span class="number">3</span></span><br><span class="line">                            SCREENVIDEOPACKET</span><br><span class="line">                        IF CodecID == <span class="number">4</span></span><br><span class="line">                            VP6FLVVIDEOPACKET</span><br><span class="line">                        IF CodecID == <span class="number">5</span></span><br><span class="line">                            VP6FLVALPHAVIDEOPACKET</span><br><span class="line">                        IF CodecID == <span class="number">6</span></span><br><span class="line">                            SCREENV2VIDEOPACKET</span><br><span class="line">                        IF CodecID == <span class="number">7</span></span><br><span class="line">                            AVCVIDEOPACKET</span><br><span class="line">                    )                                  如果frametype==<span class="number">5</span>，而不是视频有效负载，则视频数据主体包含一个具有以下含义的ui8：</span><br><span class="line">                                                        <span class="number">0</span>=客户端查找视频帧序列的开始</span><br><span class="line">                                                        <span class="number">1</span>=客户端查找视频帧序列结束 </span><br><span class="line">除avcvideopacket以外的所有文件，请参阅SWF文件格式规范了解详细信息。</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-3-2">E.4.3.2 AVCVIDEOPACKET</H5>

<p>AVC视频包携带AVC视频数据的有效载荷。</p>
<p>AVCVIDEOPACKET</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field       Type	                        Comment</span><br><span class="line">Data        IF AVCPacketType == <span class="number">0</span></span><br><span class="line">                AVCDecoderConfigurationRecord</span><br><span class="line">            IF AVCPacketType == <span class="number">1</span></span><br><span class="line">                One or more NALUs (Full frames are required)</span><br></pre></td></tr></table></figure>


<p>AVCDecoderConfigurationRecord的说明见ISO 14496-15，5.2.4.1。它包含的信息与存储在MP4/FLV文件中的AVCC框中的信息相同。<br><H5 id="a8-4-4">E.4.4数据标签</H5></p>
<p>数据标记封装了单个方法调用，通常在Flash播放器的Netstream对象上调用。数据标记由一个方法名和一组参数组成。<br><H5 id="a8-4-4-1">E.4.4.1脚本数据</H5></p>
<p>脚本数据段包含可选的加密元数据和脚本有效负载。</p>
<p>SCRIPTDATA</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type	            Comment</span><br><span class="line">IF Encrypted	                        See Annex F. FLV Encryption <span class="keyword">for</span> details.</span><br><span class="line">Body	        EncryptedBody	        ScriptTagBody encrypted <span class="keyword">as</span> specified <span class="keyword">in</span> Section F<span class="number">.3</span><span class="number">.3</span>.</span><br><span class="line">ELSE</span><br><span class="line">Body            ScriptTagBody</span><br></pre></td></tr></table></figure>


<p>ScriptTagBody包含以操作消息格式（AMF）编码的脚本数据，该格式是用于序列化ActionScript对象图的压缩二进制格式。AMF0的规范可从以下网址获得：<a href="http://opensource.adobe.com/wiki/display/blazeds/developer+documentation">http://opensource.adobe.com/wiki/display/blazeds/developer+documentation</a></p>
<p>ScriptTagBody</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type                    Comment</span><br><span class="line">Name                SCRIPTDATAVALUE	        方法或对象名称。scriptDataValue.Type=<span class="number">2</span>（字符串）</span><br><span class="line">Value               SCRIPTDATAVALUE         AMF参数或对象属性。scriptDataValue.Type=<span class="number">8</span>（ECMA数组）</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-2">E.4.4.2    SCRIPTDATAVALUE</H5>

<p>ScriptDataValue记录包含类型化的ActionScript值。</p>
<p>SCRIPTDATAVALUE</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type        Comment</span><br><span class="line">Type                UI8         ScriptDataValue的类型。</span><br><span class="line">                                定义了以下类型：</span><br><span class="line">                                <span class="number">0</span>＝数</span><br><span class="line">                                <span class="number">1</span> =布尔</span><br><span class="line">                                <span class="number">2</span> =字符串</span><br><span class="line">                                <span class="number">3</span> =对象</span><br><span class="line">                                <span class="number">4</span>=movieclip（保留，不支持）</span><br><span class="line">                                <span class="number">5</span> =空</span><br><span class="line">                                <span class="number">6</span> =未定义</span><br><span class="line">                                <span class="number">7</span> =参考文献</span><br><span class="line">                                <span class="number">8</span>＝ECMA阵列</span><br><span class="line">                                <span class="number">9</span>=对象结束标记</span><br><span class="line">                                <span class="number">10</span>=严格数组</span><br><span class="line">                                <span class="number">11</span> =日期</span><br><span class="line">                                <span class="number">12</span>=长串</span><br><span class="line">ScriptDataValue</span><br><span class="line">                IF Type == <span class="number">0</span>     编写数据值脚本。</span><br><span class="line">                DOUBLE</span><br><span class="line">                IF Type == <span class="number">1</span>    布尔值为（scriptDataValue≠<span class="number">0</span>）。</span><br><span class="line">                UI8</span><br><span class="line">                IF Type == <span class="number">2</span></span><br><span class="line">                SCRIPTDATASTRING</span><br><span class="line">                IF Type == <span class="number">3</span></span><br><span class="line">                SCRIPTDATAOBJECT</span><br><span class="line">                IF Type == <span class="number">7</span></span><br><span class="line">                UI16</span><br><span class="line">                IF Type == <span class="number">8</span></span><br><span class="line">                SCRIPTDATAECMAARRAY</span><br><span class="line">                IF Type == <span class="number">10</span></span><br><span class="line">                SCRIPTDATASTRICTARRAY</span><br><span class="line">                IF Type == <span class="number">11</span></span><br><span class="line">                SCRIPTDATADATE</span><br><span class="line">                IF Type == <span class="number">12</span></span><br><span class="line">                SCRIPTDATALONGSTRING</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-3">E.4.4.3    SCRIPTDATADATE</H5>

<p>脚本数据日期记录存储日期和时间。</p>
<p>SCRIPTDATADATE</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field                   Type        Comment</span><br><span class="line">DateTime                DOUBLE      <span class="built_in">Number</span> <span class="keyword">of</span> milliseconds since Jan <span class="number">1</span>, <span class="number">1970</span> UTC.</span><br><span class="line">LocalDateTimeOffset     SI16        本地时间与UTC的时差（分钟）。对于位于英国格林威治以西的时区，该值为负数。英国格林威治以东的时区是正的。</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-4">E.4.4.4    SCRIPTDATAECMAARRAY</H5>

<p>A SCRIPTDATAECMAARRAY记录存储一个ecma数组。ECMA数组是一个关联数组，当actionscript数组包含非顺序索引时应使用该数组。所有的索引，无论是序数还是其他，都是字符串而不是整数。为了进行序列化，此类型与匿名ActionScript对象非常相似。该列表包含大约ecmaarrayllength个项目。ScriptDataObjectEnd记录在项目列表之后。</p>
<p>SCRIPTDATAECMAARRAY</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field                   Type                            Comment</span><br><span class="line">ECMAArrayLength         UI32                            ECMA数组中的近似项数</span><br><span class="line">Variables               SCRIPTDATAOBJECTPROPERTY [ ]    变量名和值列表</span><br><span class="line">List Terminator         SCRIPTDATAOBJECTEND             列表终止符    </span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-5">E.4.4.5    SCRIPTDATALONGSTRING</H5>

<p>scriptDataString和scriptDataLongstring记录存储字符串</p>
<p>SCRIPTDATALONGSTRING</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field           Type	Comment</span><br><span class="line">StringLength    UI32	StringData length <span class="keyword">in</span> bytes</span><br><span class="line">StringData      STRING	<span class="built_in">String</span> data, <span class="keyword">with</span> no terminating NUL</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-6">E.4.4.6    SCRIPTDATAOBJECT</H5>

<p>ScriptDataObject记录对匿名ActionScript对象的属性进行编码。ScriptDataObjectEnd记录跟随属性列表。</p>
<p>SCRIPTDATAOBJECT</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type                            Comment</span><br><span class="line">ObjectProperties    SCRIPTDATAOBJECTPROPERTY [ ]	List <span class="keyword">of</span> object properties</span><br><span class="line">List Terminator     SCRIPTDATAOBJECTEND             List terminator</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-7">E.4.4.7    SCRIPTDATAOBJECTEND</H5>

<p>scriptDataObjectEnd记录终止scriptDataObjectProperty记录的列表。ScriptDataObjectEnd记录是一个带零长度字符串和对象结束标记的ScriptDataObjectProperty记录。</p>
<p>SCRIPTDATAOBJECTEND</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field           Type        Comment</span><br><span class="line">ObjectEndMarker UI8 [<span class="number">3</span>]     Shall be <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-8">E.4.4.8    SCRIPTDATAOBJECTPROPERTY</H5>

<p>ScriptDataObjectProperty记录定义ActionScript对象的对象属性或关联数组的变量。</p>
<p>SCRIPTDATAOBJECTPROPERTY</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field           Type                    Comment</span><br><span class="line">PropertyName    SCRIPTDATASTRING        Name <span class="keyword">of</span> the object property or variable</span><br><span class="line">PropertyData    SCRIPTDATAVALUE         对象属性或变量的值和类型</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-9">E.4.4.9    SCRIPTDATASTRICTARRAY</H5>

<p>脚本数据严格数组记录存储严格数组。严格数组只包含顺序索引，而不存储在记录中。指数可以是密集的或稀疏的。索引之间稀疏区域中未定义的条目应序列化为未定义。该列表应包含严格的数组长度值。列表后面没有终止记录。</p>
<p>SCRIPTDATASTRICTARRAY</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type	            Comment</span><br><span class="line">StrictArrayLength   UI32                <span class="built_in">Number</span> <span class="keyword">of</span> items <span class="keyword">in</span> the array</span><br><span class="line">StrictArrayValue    SCRIPTDATAVALUE </span><br><span class="line">                [ StrictArrayLength ]   List <span class="keyword">of</span> typed values</span><br></pre></td></tr></table></figure>

<H5 id="a8-4-4-10">E.4.4.10    SCRIPTDATASTRING</H5>

<p>scriptDataString和scriptDataLongstring记录存储字符串。</p>
<p>脚本数据字符串记录可用于长度不超过65535个字符的字符串。</p>
<p>SCRIPTDATASTRING</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field           Type        Comment</span><br><span class="line">StringLength    UI16        StringData length <span class="keyword">in</span> bytes.</span><br><span class="line">StringData      STRING      <span class="built_in">String</span> data, up to <span class="number">65535</span> bytes, <span class="keyword">with</span> no terminating NUL</span><br></pre></td></tr></table></figure>

<h4 id="a8-5">E.5 onMetaData</h4>

<p>flv元数据对象应包含在名为onmet adat a的scriptdata标记中。运行中的actionscript程序可通过net st r eam使用各种属性。Onmet Adat a Property公司。可用属性因创建FLV文件的软件而异。典型特性包括：</p>
<p>onMetadata properties</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name   Type        Comment</span><br><span class="line">audiocodecid    <span class="built_in">Number</span>	    文件中使用的音频编解码器ID（有关可用的SoundFormat值，请参阅E<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span>）</span><br><span class="line">audiodatarate   <span class="built_in">Number</span>      音频比特率（千比特/秒）</span><br><span class="line">audiodelay      <span class="built_in">Number</span>      音频编解码器引入的延迟（秒）</span><br><span class="line">audiosamplerate <span class="built_in">Number</span>      重播音频流的频率</span><br><span class="line">audiosamplesize <span class="built_in">Number</span>      单个音频样本的分辨率</span><br><span class="line">canSeekToEnd    <span class="built_in">Boolean</span>     表示最后一个视频帧是关键帧</span><br><span class="line">creationdate    <span class="built_in">String</span>      创建日期和时间</span><br><span class="line">duration        <span class="built_in">Number</span>      文件的总持续时间（秒）</span><br><span class="line">filesize        <span class="built_in">Number</span>      文件的总大小（字节）</span><br><span class="line">framerate       <span class="built_in">Number</span>      每秒帧数</span><br><span class="line">height          <span class="built_in">Number</span>      视频的高度（像素）</span><br><span class="line">stereo          <span class="built_in">Boolean</span>     指示立体声音频</span><br><span class="line">videocodecid    <span class="built_in">Number</span>      文件中使用的视频编解码器ID（有关可用的编解码器ID值，请参阅E<span class="number">.4</span><span class="number">.3</span><span class="number">.1</span>）</span><br><span class="line">videodatarate   <span class="built_in">Number</span>      视频比特率（千比特/秒）</span><br><span class="line">width           <span class="built_in">Number</span>      视频的宽度（像素）</span><br></pre></td></tr></table></figure>

<h4 id="a8-6">E.6 flv中的xmp元数据</h4>

<p>xmp元数据对象应包含在名为onxmpdat a的scriptData标记中。标记应及时放置。</p>
<p>0。标签应该在所有时间0之后，在所有时间0之前，在所有时间0之前，音频或视频标签，但读者不应该要求这样的排序。</p>
<p>XMPMetadata object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name	Type	                Comment</span><br><span class="line">liveXML         <span class="built_in">String</span> or Long string	XMP元数据，根据XMP元数据规范格式化</span><br></pre></td></tr></table></figure>


<p>For further details, see <a href="http://www.adobe.com/devnet/xmp/pdfs/XMPSpecificationPart3.pdf">www.adobe.com/devnet/xmp/pdfs/XMPSpecificationPart3.pdf</a></p>
<h3 id="a9">附件F.FLV加密</h3>
<h4 id="a9-1">F.1概述</h4>

<p>1.加密头，包含解密flv所需的加密元数据，如加密</p>
<p>算法、密钥长度和内容加密密钥检索协议标识符在任何加密内容之前，在FLV头之后立即存储为脚本数据。</p>
<p>2.内容携带标签加密。</p>
<p>a.为了提高效率，可以选择只加密标签的子集，例如I帧。</p>
<p>b.如果标签被加密，那么包中的过滤器标志被打开。筛选标志指示</p>
<p>解码前需要对数据包进行预处理。加密筛选器在数据包中指定。不合规的玩家将忽略设置了筛选标志的标签，因为他们实际上有一个新的标签类型。</p>
<p>c.大多数元数据（例如，无论是音频或视频帧、关键帧还是I帧、编解码器类型）都是</p>
<p>保持清晰，以便服务器和客户端播放器可以处理元数据而无需解密内容。</p>
<p>d.根据加密算法和加密要求对内容进行加密。</p>
<p>关键。加密数据存储在包中。</p>
<p>此规范定义了头元数据和加密数据包的格式。</p>
<h4 id="a9-2">F.2标题信息</h4>
<H5 id="a9-2-1">F.2.1 AdditionalHeader对象</H5>

<p>在加密的FLV文件中，应存在额外的头对象，并且应包括加密头对象。</p>
<p>AdditionalHeader对象应包含在名为Additional Header的scriptData标记中。（注意名称中的竖线（“”））对象应该出现在flv的开头，时间戳为0，紧跟在onmet adat的scriptdata标记之后。这使FLV解码器能够在遇到任何加密标签之前访问加密元数据。</p>
<p>AdditionalHeader object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name       Type                        Comment</span><br><span class="line">Encryption          Encryption Header object	Encryption Header</span><br></pre></td></tr></table></figure>

<H5 id="a9-2-2">F.2.2加密头对象</H5>

<p>encryption header对象包含解密flv所需的加密元数据。加密头对象</p>
<p>Encryption Header object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name       Type        Comment</span><br><span class="line">Version             <span class="built_in">Number</span>      加密头的版本。</span><br><span class="line">                                应为<span class="number">1</span>或<span class="number">2</span>，表示</span><br><span class="line">                                加密格式。</span><br><span class="line">                                <span class="number">1</span>=FMRMS v1.x产品。</span><br><span class="line">                                <span class="number">2</span>=闪存访问<span class="number">2.0</span>产品。</span><br><span class="line">                                使用任一版本保护的内容都存在，</span><br><span class="line">                                因此应用程序应能够同时使用两个版本的内容。</span><br><span class="line">Method              string      Encryption method. Shall be ‘Standard’</span><br><span class="line">Flags               <span class="built_in">Number</span>      Encryption flags. Shall be <span class="number">0.</span></span><br><span class="line">Params          Standard Encoding </span><br><span class="line">                Parameters object       加密方法“标准”的参数</span><br><span class="line">IF Version == <span class="number">1</span></span><br><span class="line">    SigFormat       <span class="built_in">String</span>      在本文档中，没有提供有关sigformat的信息。</span><br><span class="line">    Signature       Long string 本文件签名上未提供任何信息。</span><br></pre></td></tr></table></figure>

<H5 id="a9-2-3">F.2.3标准编码参数对象</H5>

<p>此结构包含特定于“标准”加密方法的参数。</p>
<p>Standard Encoding Parameters object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name           Type                Comment</span><br><span class="line">Version                 <span class="built_in">Number</span>              Version. Shall be <span class="number">1.</span></span><br><span class="line">EncryptionAlgorithm     <span class="built_in">String</span>              加密算法。应为“aes-cbc”，</span><br><span class="line">                                            其中规定所使用的加密为“aes-cbc”，</span><br><span class="line">                                            并根据RFC <span class="number">2630</span>填充。</span><br><span class="line"></span><br><span class="line">EncryptionParams        AES-CBC             加密算法“aes-cbc”的参数。</span><br><span class="line">                        Encryption </span><br><span class="line">                        Parameters object</span><br><span class="line"></span><br><span class="line">KeyInfo                 Key Information     获取解密密钥的信息</span><br><span class="line">                        object	</span><br></pre></td></tr></table></figure>

<H5 id="a9-2-4">F.2.4 AES-CBC加密参数对象</H5>

<p>这个结构包含特定于加密算法的参数，在本例中是aes-cbc_128。</p>
<p>AES-CBC Encryption Parameters object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name           Type                Comment</span><br><span class="line">KeyLength               <span class="built_in">Number</span>              加密算法的密钥长度（字节）。应为<span class="number">16</span>（即<span class="number">128</span>位）</span><br></pre></td></tr></table></figure>

<H5 id="a9-2-5">F.2.5关键信息对象</H5>

<p>密钥信息框包含用于检索用于解密示例的密钥的信息。这些框中包含的条目的详细信息以及DRM客户机用于检索密钥的机制不在本规范的范围内。</p>
<p>Key Information object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name            Type        Comment</span><br><span class="line">SubType                 <span class="built_in">String</span>          如果encryptionheader.version==<span class="number">1</span></span><br><span class="line">                                        aps<span class="string">&#x27;=（Adobe Policy Server）联机密钥协议协商协议</span></span><br><span class="line"><span class="string">                                        否则</span></span><br><span class="line"><span class="string">                                        FlashAccessv2&#x27;</span>=联机密钥检索协议</span><br><span class="line">Data                IF SubType == ‘APS’</span><br><span class="line">                    Adobe Policy Server object</span><br><span class="line">                    IF SubType == ’FlashAccessv2’</span><br><span class="line">                    FlashAccessv2 object    子类型“aps”不再由符合要求的应用程序生成，因此没有提供进一步的信息</span><br></pre></td></tr></table></figure>

<H5 id="a9-2-6">F.2.6 FlashAccessv2对象</H5>

<p>闪存访问服务器使用联机密钥检索协议提供解密密钥。</p>
<p>FlashAccessv2对象包含FlashAccessv2模块执行联机密钥检索所需的以下高级元素（这些元素的详细信息不在文档范围内）。</p>
<p>FlashAccessv2 object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Property Name       Type            Comment</span><br><span class="line">Metadata            Long string     DRM客户机用于检索解密密钥的Base <span class="number">64</span>编码元数据。</span><br></pre></td></tr></table></figure>

<h4 id="a9-3">F.3内容加密</h4>

<p>本节介绍如何加密FLV标记。</p>
<p>在加密的FLV文件中，每个FLV标记都可以指示其加密状态：</p>
<p>-筛选器标志可能指示在呈现数据包之前需要对其进行预处理。</p>
<p>-在版本2中，当设置过滤器标志时，选择性加密指示器可能进一步指示</p>
<p>数据包已加密。</p>
<p>无论文件是完全加密还是部分加密，在版本2中（encryptionheader.version==2），每个音频和视频包都应该设置flvtag.filter位。对于未加密的脚本数据，不应设置过滤位，使播放器能够定位onmetadata信息。</p>
<p>一小部分指定的字节保持清晰，以便在不解密其余内容的情况下启用智能客户端处理。</p>
<h5 id="a9-3-1">F.3.1加密标记头</h5>

<p>如果在flv标签中设置了filter标志，则在呈现前应对包内容进行预处理。加密标记头指定要应用的筛选器。过滤器指定加密类型并指示是否应用加密。</p>
<p>EncryptionTagHeader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type            Comments</span><br><span class="line">NumFilters          UI8             <span class="built_in">Number</span> <span class="keyword">of</span> filters applied to the packet. Shall be <span class="number">1.</span></span><br><span class="line">FilterName          <span class="built_in">String</span>          筛选器的名称。</span><br><span class="line">                                    如果encryptionheader.version==<span class="number">1</span></span><br><span class="line">                                    <span class="string">&#x27;加密&#x27;</span></span><br><span class="line">                                    否则</span><br><span class="line">                                    “SE”</span><br><span class="line">                                    SE代表选择性加密。</span><br><span class="line">Length              UI24            Length <span class="keyword">of</span> FilterParams <span class="keyword">in</span> bytes</span><br></pre></td></tr></table></figure>

<h5 id="a9-3-2">F.3.2滤波器参数</h5>

<p>filterparams包含特定于解密方法的参数。</p>
<p>FilterParams</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type                                Comments</span><br><span class="line">FilterParams        IF FilterName = ‘Encryption’        特定于筛选器的参数。</span><br><span class="line">                        EncryptionFilterParams</span><br><span class="line">                    IF FilterName = ‘SE’</span><br><span class="line">                        SelectiveEncryptionFilterParams</span><br></pre></td></tr></table></figure>


<p>非选择性）加密的筛选器参数在encryptionfilterparams中定义。带有此字段的所有数据包都应加密。</p>
<p>EncryptionFilterParams</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field       Type        Comment</span><br><span class="line">IV          UI8 [<span class="number">16</span>]	包含<span class="number">16</span>字节的AES-CBC IV数据。</span><br></pre></td></tr></table></figure>


<p>选择加密的筛选参数在SelectiveEncryptionFilterParams中定义。</p>
<p>SelectiveEncryptionFilterParams</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field               Type            Comment</span><br><span class="line">EncryptedAU         UB [<span class="number">1</span>]          选择性加密指示器显示数据包是否加密。</span><br><span class="line">                                    <span class="number">0</span>=数据包未加密</span><br><span class="line">                                    <span class="number">1</span>=数据包已加密。</span><br><span class="line">Reserved            UB [<span class="number">7</span>]          Shall be <span class="number">0</span></span><br><span class="line">IV                  IF EncryptedAU == <span class="number">1</span></span><br><span class="line">                    UI8 [<span class="number">16</span>]        仅当数据包加密时才存在。包含<span class="number">16</span>字节的AES-CBC IV数据</span><br></pre></td></tr></table></figure>

<h5 id="a9-3-3">F.3.3加密正文</h5>

<p>如果包是加密的，那么主体应包含本节所述的加密主体，否则主体应包含纯文本数据。</p>
<p>EncryptedBody</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Field       Type                    Comment</span><br><span class="line">Content     UI8 [Plaintext Length]	密码文本</span><br><span class="line">Padding     UI8 [Padding Length]	加密填充。</span><br></pre></td></tr></table></figure>

<h5 id="a9-3-3-1">3.3.1填充</h5>

<p>所有加密样本应填充到块密码块长度的倍数。填料方案应如RFC 2630中所述，复制如下：</p>
<p>块密码期望输入数据是k八位字节的倍数（对于aes 128，是16个八位字节的倍数），其中k大于1。对于此类算法，输入应在尾端填充k-（length mod k）八位字节，所有八位字节的值均为k-（length mod k），其中length是输入的长度。</p>
<p>填充使块大小达到块密码块长度的下一整数倍。即使纯文本可以被块长度平均整除，也会出现填充。</p>
<p>示例：如果k为16字节，长度为32字节，填充长度为16字节，包含0x10，块大小为48字节。</p>
<h4 id="a9-4">F.4加密和元数据</h4>

<p>当FLV加密时，OnMetadata脚本数据应始终保持清晰。</p>
<p>不同的flv解析器需要这一点来成功地传输flv，媒体播放器也需要这一点来为使用提供一些上下文信息。</p>
]]></content>
  </entry>
</search>
